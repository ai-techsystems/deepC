!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
10	blas/testing/cblat2.f	/^   10                         CONTINUE$/;"	l	subroutine:CCHK1	file:
10	blas/testing/cblat2.f	/^   10                      CONTINUE$/;"	l	subroutine:CCHK2	file:
10	blas/testing/cblat2.f	/^   10                CONTINUE$/;"	l	subroutine:CCHK4	file:
10	blas/testing/cblat2.f	/^   10                CONTINUE$/;"	l	subroutine:CCHK6	file:
10	blas/testing/cblat2.f	/^   10             CONTINUE$/;"	l	subroutine:CCHK5	file:
10	blas/testing/cblat2.f	/^   10       CONTINUE$/;"	l	function:LCERES	file:
10	blas/testing/cblat2.f	/^   10       CONTINUE$/;"	l	subroutine:CMVCH	file:
10	blas/testing/cblat2.f	/^   10    CONTINUE$/;"	l	subroutine:CMAKE	file:
10	blas/testing/cblat2.f	/^   10 CONTINUE$/;"	l	function:LCE	file:
10	blas/testing/cblat2.f	/^   10 CONTINUE$/;"	l	program:CBLAT2	file:
10	blas/testing/cblat2.f	/^   10 CONTINUE$/;"	l	subroutine:CCHK3	file:
10	blas/testing/cblat2.f	/^   10 I = I*MI$/;"	l	function:CBEG	file:
10	blas/testing/cblat2.f	/^   10 INFOT = 1$/;"	l	subroutine:CCHKE	file:
10	blas/testing/cblat3.f	/^   10                      CONTINUE$/;"	l	subroutine:CCHK1	file:
10	blas/testing/cblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:CCHK2	file:
10	blas/testing/cblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:CCHK4	file:
10	blas/testing/cblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:CCHK5	file:
10	blas/testing/cblat3.f	/^   10       CONTINUE$/;"	l	function:LCERES	file:
10	blas/testing/cblat3.f	/^   10    CONTINUE$/;"	l	subroutine:CCHK3	file:
10	blas/testing/cblat3.f	/^   10    CONTINUE$/;"	l	subroutine:CMAKE	file:
10	blas/testing/cblat3.f	/^   10    CONTINUE$/;"	l	subroutine:CMMCH	file:
10	blas/testing/cblat3.f	/^   10 CONTINUE$/;"	l	function:LCE	file:
10	blas/testing/cblat3.f	/^   10 CONTINUE$/;"	l	program:CBLAT3	file:
10	blas/testing/cblat3.f	/^   10 I = I*MI$/;"	l	function:CBEG	file:
10	blas/testing/cblat3.f	/^   10 INFOT = 1$/;"	l	subroutine:CCHKE	file:
10	blas/testing/dblat2.f	/^   10                         CONTINUE$/;"	l	subroutine:DCHK1	file:
10	blas/testing/dblat2.f	/^   10                      CONTINUE$/;"	l	subroutine:DCHK2	file:
10	blas/testing/dblat2.f	/^   10                CONTINUE$/;"	l	subroutine:DCHK4	file:
10	blas/testing/dblat2.f	/^   10                CONTINUE$/;"	l	subroutine:DCHK6	file:
10	blas/testing/dblat2.f	/^   10             CONTINUE$/;"	l	subroutine:DCHK5	file:
10	blas/testing/dblat2.f	/^   10       CONTINUE$/;"	l	function:LDERES	file:
10	blas/testing/dblat2.f	/^   10       CONTINUE$/;"	l	subroutine:DMVCH	file:
10	blas/testing/dblat2.f	/^   10    CONTINUE$/;"	l	subroutine:DMAKE	file:
10	blas/testing/dblat2.f	/^   10 CONTINUE$/;"	l	function:LDE	file:
10	blas/testing/dblat2.f	/^   10 CONTINUE$/;"	l	program:DBLAT2	file:
10	blas/testing/dblat2.f	/^   10 CONTINUE$/;"	l	subroutine:DCHK3	file:
10	blas/testing/dblat2.f	/^   10 I = I*MI$/;"	l	function:DBEG	file:
10	blas/testing/dblat2.f	/^   10 INFOT = 1$/;"	l	subroutine:DCHKE	file:
10	blas/testing/dblat3.f	/^   10                      CONTINUE$/;"	l	subroutine:DCHK1	file:
10	blas/testing/dblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:DCHK2	file:
10	blas/testing/dblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:DCHK4	file:
10	blas/testing/dblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:DCHK5	file:
10	blas/testing/dblat3.f	/^   10       CONTINUE$/;"	l	function:LDERES	file:
10	blas/testing/dblat3.f	/^   10    CONTINUE$/;"	l	subroutine:DCHK3	file:
10	blas/testing/dblat3.f	/^   10    CONTINUE$/;"	l	subroutine:DMAKE	file:
10	blas/testing/dblat3.f	/^   10    CONTINUE$/;"	l	subroutine:DMMCH	file:
10	blas/testing/dblat3.f	/^   10 CONTINUE$/;"	l	function:LDE	file:
10	blas/testing/dblat3.f	/^   10 CONTINUE$/;"	l	program:DBLAT3	file:
10	blas/testing/dblat3.f	/^   10 I = I*MI$/;"	l	function:DBEG	file:
10	blas/testing/dblat3.f	/^   10 INFOT = 1$/;"	l	subroutine:DCHKE	file:
10	blas/testing/sblat2.f	/^   10                         CONTINUE$/;"	l	subroutine:SCHK1	file:
10	blas/testing/sblat2.f	/^   10                      CONTINUE$/;"	l	subroutine:SCHK2	file:
10	blas/testing/sblat2.f	/^   10                CONTINUE$/;"	l	subroutine:SCHK4	file:
10	blas/testing/sblat2.f	/^   10                CONTINUE$/;"	l	subroutine:SCHK6	file:
10	blas/testing/sblat2.f	/^   10             CONTINUE$/;"	l	subroutine:SCHK5	file:
10	blas/testing/sblat2.f	/^   10       CONTINUE$/;"	l	function:LSERES	file:
10	blas/testing/sblat2.f	/^   10       CONTINUE$/;"	l	subroutine:SMVCH	file:
10	blas/testing/sblat2.f	/^   10    CONTINUE$/;"	l	subroutine:SMAKE	file:
10	blas/testing/sblat2.f	/^   10 CONTINUE$/;"	l	function:LSE	file:
10	blas/testing/sblat2.f	/^   10 CONTINUE$/;"	l	program:SBLAT2	file:
10	blas/testing/sblat2.f	/^   10 CONTINUE$/;"	l	subroutine:SCHK3	file:
10	blas/testing/sblat2.f	/^   10 I = I*MI$/;"	l	function:SBEG	file:
10	blas/testing/sblat2.f	/^   10 INFOT = 1$/;"	l	subroutine:SCHKE	file:
10	blas/testing/sblat3.f	/^   10                      CONTINUE$/;"	l	subroutine:SCHK1	file:
10	blas/testing/sblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:SCHK2	file:
10	blas/testing/sblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:SCHK4	file:
10	blas/testing/sblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:SCHK5	file:
10	blas/testing/sblat3.f	/^   10       CONTINUE$/;"	l	function:LSERES	file:
10	blas/testing/sblat3.f	/^   10    CONTINUE$/;"	l	subroutine:SCHK3	file:
10	blas/testing/sblat3.f	/^   10    CONTINUE$/;"	l	subroutine:SMAKE	file:
10	blas/testing/sblat3.f	/^   10    CONTINUE$/;"	l	subroutine:SMMCH	file:
10	blas/testing/sblat3.f	/^   10 CONTINUE$/;"	l	function:LSE	file:
10	blas/testing/sblat3.f	/^   10 CONTINUE$/;"	l	program:SBLAT3	file:
10	blas/testing/sblat3.f	/^   10 I = I*MI$/;"	l	function:SBEG	file:
10	blas/testing/sblat3.f	/^   10 INFOT = 1$/;"	l	subroutine:SCHKE	file:
10	blas/testing/zblat2.f	/^   10                         CONTINUE$/;"	l	subroutine:ZCHK1	file:
10	blas/testing/zblat2.f	/^   10                      CONTINUE$/;"	l	subroutine:ZCHK2	file:
10	blas/testing/zblat2.f	/^   10                CONTINUE$/;"	l	subroutine:ZCHK4	file:
10	blas/testing/zblat2.f	/^   10                CONTINUE$/;"	l	subroutine:ZCHK6	file:
10	blas/testing/zblat2.f	/^   10             CONTINUE$/;"	l	subroutine:ZCHK5	file:
10	blas/testing/zblat2.f	/^   10       CONTINUE$/;"	l	function:LZERES	file:
10	blas/testing/zblat2.f	/^   10       CONTINUE$/;"	l	subroutine:ZMVCH	file:
10	blas/testing/zblat2.f	/^   10    CONTINUE$/;"	l	subroutine:ZMAKE	file:
10	blas/testing/zblat2.f	/^   10 CONTINUE$/;"	l	function:LZE	file:
10	blas/testing/zblat2.f	/^   10 CONTINUE$/;"	l	program:ZBLAT2	file:
10	blas/testing/zblat2.f	/^   10 CONTINUE$/;"	l	subroutine:ZCHK3	file:
10	blas/testing/zblat2.f	/^   10 I = I*MI$/;"	l	function:ZBEG	file:
10	blas/testing/zblat2.f	/^   10 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
10	blas/testing/zblat3.f	/^   10                      CONTINUE$/;"	l	subroutine:ZCHK1	file:
10	blas/testing/zblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:ZCHK2	file:
10	blas/testing/zblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:ZCHK4	file:
10	blas/testing/zblat3.f	/^   10                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
10	blas/testing/zblat3.f	/^   10       CONTINUE$/;"	l	function:LZERES	file:
10	blas/testing/zblat3.f	/^   10    CONTINUE$/;"	l	subroutine:ZCHK3	file:
10	blas/testing/zblat3.f	/^   10    CONTINUE$/;"	l	subroutine:ZMAKE	file:
10	blas/testing/zblat3.f	/^   10    CONTINUE$/;"	l	subroutine:ZMMCH	file:
10	blas/testing/zblat3.f	/^   10 CONTINUE$/;"	l	function:LZE	file:
10	blas/testing/zblat3.f	/^   10 CONTINUE$/;"	l	program:ZBLAT3	file:
10	blas/testing/zblat3.f	/^   10 I = I*MI$/;"	l	function:ZBEG	file:
10	blas/testing/zblat3.f	/^   10 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
10	lapack/clacgv.f	/^   10    CONTINUE$/;"	l	subroutine:CLACGV	file:
10	lapack/clarfb.f	/^   10          CONTINUE$/;"	l	subroutine:CLARFB	file:
10	lapack/clarfg.f	/^   10       CONTINUE$/;"	l	subroutine:CLARFG	file:
10	lapack/dlarfb.f	/^   10          CONTINUE$/;"	l	subroutine:DLARFB	file:
10	lapack/dlarfg.f	/^   10       CONTINUE$/;"	l	subroutine:DLARFG	file:
10	lapack/slarfb.f	/^   10          CONTINUE$/;"	l	subroutine:SLARFB	file:
10	lapack/slarfg.f	/^   10       CONTINUE$/;"	l	subroutine:SLARFG	file:
10	lapack/zlacgv.f	/^   10    CONTINUE$/;"	l	subroutine:ZLACGV	file:
10	lapack/zlarfb.f	/^   10          CONTINUE$/;"	l	subroutine:ZLARFB	file:
10	lapack/zlarfg.f	/^   10       CONTINUE$/;"	l	subroutine:ZLARFG	file:
100	blas/testing/cblat1.f	/^  100    CONTINUE$/;"	l	subroutine:CHECK1	file:
100	blas/testing/cblat2.f	/^  100             CONTINUE$/;"	l	subroutine:CCHK6	file:
100	blas/testing/cblat2.f	/^  100       CONTINUE$/;"	l	subroutine:CCHK1	file:
100	blas/testing/cblat2.f	/^  100       CONTINUE$/;"	l	subroutine:CCHK4	file:
100	blas/testing/cblat2.f	/^  100       CONTINUE$/;"	l	subroutine:CMAKE	file:
100	blas/testing/cblat2.f	/^  100    CONTINUE$/;"	l	subroutine:CCHK2	file:
100	blas/testing/cblat2.f	/^  100    CONTINUE$/;"	l	subroutine:CCHK3	file:
100	blas/testing/cblat2.f	/^  100 CONTINUE$/;"	l	subroutine:CCHK5	file:
100	blas/testing/cblat2.f	/^  100 INFOT = 1$/;"	l	subroutine:CCHKE	file:
100	blas/testing/cblat3.f	/^  100             CONTINUE$/;"	l	subroutine:CCHK3	file:
100	blas/testing/cblat3.f	/^  100             CONTINUE$/;"	l	subroutine:CMMCH	file:
100	blas/testing/cblat3.f	/^  100          CONTINUE$/;"	l	subroutine:CCHK5	file:
100	blas/testing/cblat3.f	/^  100    CONTINUE$/;"	l	subroutine:CCHK1	file:
100	blas/testing/cblat3.f	/^  100 CONTINUE$/;"	l	program:CBLAT3	file:
100	blas/testing/cblat3.f	/^  100 CONTINUE$/;"	l	subroutine:CCHK2	file:
100	blas/testing/cblat3.f	/^  100 CONTINUE$/;"	l	subroutine:CCHK4	file:
100	blas/testing/cblat3.f	/^  100 IF( OK )THEN$/;"	l	subroutine:CCHKE	file:
100	blas/testing/dblat1.f	/^  100    CONTINUE$/;"	l	subroutine:CHECK2	file:
100	blas/testing/dblat1.f	/^  100 CONTINUE$/;"	l	subroutine:CHECK3	file:
100	blas/testing/dblat2.f	/^  100             CONTINUE$/;"	l	subroutine:DCHK6	file:
100	blas/testing/dblat2.f	/^  100       CONTINUE$/;"	l	subroutine:DCHK1	file:
100	blas/testing/dblat2.f	/^  100       CONTINUE$/;"	l	subroutine:DCHK4	file:
100	blas/testing/dblat2.f	/^  100       CONTINUE$/;"	l	subroutine:DMAKE	file:
100	blas/testing/dblat2.f	/^  100    CONTINUE$/;"	l	subroutine:DCHK2	file:
100	blas/testing/dblat2.f	/^  100    CONTINUE$/;"	l	subroutine:DCHK3	file:
100	blas/testing/dblat2.f	/^  100 CONTINUE$/;"	l	subroutine:DCHK5	file:
100	blas/testing/dblat2.f	/^  100 INFOT = 1$/;"	l	subroutine:DCHKE	file:
100	blas/testing/dblat3.f	/^  100             CONTINUE$/;"	l	subroutine:DCHK3	file:
100	blas/testing/dblat3.f	/^  100          CONTINUE$/;"	l	subroutine:DCHK5	file:
100	blas/testing/dblat3.f	/^  100    CONTINUE$/;"	l	subroutine:DCHK1	file:
100	blas/testing/dblat3.f	/^  100    CONTINUE$/;"	l	subroutine:DMMCH	file:
100	blas/testing/dblat3.f	/^  100 CONTINUE$/;"	l	program:DBLAT3	file:
100	blas/testing/dblat3.f	/^  100 CONTINUE$/;"	l	subroutine:DCHK2	file:
100	blas/testing/dblat3.f	/^  100 CONTINUE$/;"	l	subroutine:DCHK4	file:
100	blas/testing/sblat1.f	/^  100    CONTINUE$/;"	l	subroutine:CHECK2	file:
100	blas/testing/sblat1.f	/^  100 CONTINUE$/;"	l	subroutine:CHECK3	file:
100	blas/testing/sblat2.f	/^  100             CONTINUE$/;"	l	subroutine:SCHK6	file:
100	blas/testing/sblat2.f	/^  100       CONTINUE$/;"	l	subroutine:SCHK1	file:
100	blas/testing/sblat2.f	/^  100       CONTINUE$/;"	l	subroutine:SCHK4	file:
100	blas/testing/sblat2.f	/^  100       CONTINUE$/;"	l	subroutine:SMAKE	file:
100	blas/testing/sblat2.f	/^  100    CONTINUE$/;"	l	subroutine:SCHK2	file:
100	blas/testing/sblat2.f	/^  100    CONTINUE$/;"	l	subroutine:SCHK3	file:
100	blas/testing/sblat2.f	/^  100 CONTINUE$/;"	l	subroutine:SCHK5	file:
100	blas/testing/sblat2.f	/^  100 INFOT = 1$/;"	l	subroutine:SCHKE	file:
100	blas/testing/sblat3.f	/^  100             CONTINUE$/;"	l	subroutine:SCHK3	file:
100	blas/testing/sblat3.f	/^  100          CONTINUE$/;"	l	subroutine:SCHK5	file:
100	blas/testing/sblat3.f	/^  100    CONTINUE$/;"	l	subroutine:SCHK1	file:
100	blas/testing/sblat3.f	/^  100    CONTINUE$/;"	l	subroutine:SMMCH	file:
100	blas/testing/sblat3.f	/^  100 CONTINUE$/;"	l	program:SBLAT3	file:
100	blas/testing/sblat3.f	/^  100 CONTINUE$/;"	l	subroutine:SCHK2	file:
100	blas/testing/sblat3.f	/^  100 CONTINUE$/;"	l	subroutine:SCHK4	file:
100	blas/testing/zblat1.f	/^  100    CONTINUE$/;"	l	subroutine:CHECK1	file:
100	blas/testing/zblat2.f	/^  100             CONTINUE$/;"	l	subroutine:ZCHK6	file:
100	blas/testing/zblat2.f	/^  100       CONTINUE$/;"	l	subroutine:ZCHK1	file:
100	blas/testing/zblat2.f	/^  100       CONTINUE$/;"	l	subroutine:ZCHK4	file:
100	blas/testing/zblat2.f	/^  100       CONTINUE$/;"	l	subroutine:ZMAKE	file:
100	blas/testing/zblat2.f	/^  100    CONTINUE$/;"	l	subroutine:ZCHK2	file:
100	blas/testing/zblat2.f	/^  100    CONTINUE$/;"	l	subroutine:ZCHK3	file:
100	blas/testing/zblat2.f	/^  100 CONTINUE$/;"	l	subroutine:ZCHK5	file:
100	blas/testing/zblat2.f	/^  100 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
100	blas/testing/zblat3.f	/^  100             CONTINUE$/;"	l	subroutine:ZCHK3	file:
100	blas/testing/zblat3.f	/^  100             CONTINUE$/;"	l	subroutine:ZMMCH	file:
100	blas/testing/zblat3.f	/^  100          CONTINUE$/;"	l	subroutine:ZCHK5	file:
100	blas/testing/zblat3.f	/^  100    CONTINUE$/;"	l	subroutine:ZCHK1	file:
100	blas/testing/zblat3.f	/^  100 CONTINUE$/;"	l	program:ZBLAT3	file:
100	blas/testing/zblat3.f	/^  100 CONTINUE$/;"	l	subroutine:ZCHK2	file:
100	blas/testing/zblat3.f	/^  100 CONTINUE$/;"	l	subroutine:ZCHK4	file:
100	blas/testing/zblat3.f	/^  100 IF( OK )THEN$/;"	l	subroutine:ZCHKE	file:
100	lapack/clarfb.f	/^  100          CONTINUE$/;"	l	subroutine:CLARFB	file:
100	lapack/dlarfb.f	/^  100          CONTINUE$/;"	l	subroutine:DLARFB	file:
100	lapack/slarfb.f	/^  100          CONTINUE$/;"	l	subroutine:SLARFB	file:
100	lapack/zlarfb.f	/^  100          CONTINUE$/;"	l	subroutine:ZLARFB	file:
110	blas/testing/cblat2.f	/^  110          CONTINUE$/;"	l	subroutine:CCHK6	file:
110	blas/testing/cblat2.f	/^  110       CONTINUE$/;"	l	subroutine:CMAKE	file:
110	blas/testing/cblat2.f	/^  110    CONTINUE$/;"	l	program:CBLAT2	file:
110	blas/testing/cblat2.f	/^  110    CONTINUE$/;"	l	subroutine:CCHK1	file:
110	blas/testing/cblat2.f	/^  110    CONTINUE$/;"	l	subroutine:CCHK4	file:
110	blas/testing/cblat2.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK2	file:
110	blas/testing/cblat2.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK3	file:
110	blas/testing/cblat2.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK5	file:
110	blas/testing/cblat2.f	/^  110 INFOT = 1$/;"	l	subroutine:CCHKE	file:
110	blas/testing/cblat3.f	/^  110          CONTINUE$/;"	l	subroutine:CCHK3	file:
110	blas/testing/cblat3.f	/^  110          CONTINUE$/;"	l	subroutine:CMMCH	file:
110	blas/testing/cblat3.f	/^  110       CONTINUE$/;"	l	subroutine:CCHK5	file:
110	blas/testing/cblat3.f	/^  110 CONTINUE$/;"	l	program:CBLAT3	file:
110	blas/testing/cblat3.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK1	file:
110	blas/testing/cblat3.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK2	file:
110	blas/testing/cblat3.f	/^  110 CONTINUE$/;"	l	subroutine:CCHK4	file:
110	blas/testing/dblat2.f	/^  110          CONTINUE$/;"	l	subroutine:DCHK6	file:
110	blas/testing/dblat2.f	/^  110       CONTINUE$/;"	l	subroutine:DMAKE	file:
110	blas/testing/dblat2.f	/^  110    CONTINUE$/;"	l	program:DBLAT2	file:
110	blas/testing/dblat2.f	/^  110    CONTINUE$/;"	l	subroutine:DCHK1	file:
110	blas/testing/dblat2.f	/^  110    CONTINUE$/;"	l	subroutine:DCHK4	file:
110	blas/testing/dblat2.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK2	file:
110	blas/testing/dblat2.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK3	file:
110	blas/testing/dblat2.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK5	file:
110	blas/testing/dblat2.f	/^  110 INFOT = 1$/;"	l	subroutine:DCHKE	file:
110	blas/testing/dblat3.f	/^  110          CONTINUE$/;"	l	subroutine:DCHK3	file:
110	blas/testing/dblat3.f	/^  110       CONTINUE$/;"	l	subroutine:DCHK5	file:
110	blas/testing/dblat3.f	/^  110    CONTINUE$/;"	l	subroutine:DMMCH	file:
110	blas/testing/dblat3.f	/^  110 CONTINUE$/;"	l	program:DBLAT3	file:
110	blas/testing/dblat3.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK1	file:
110	blas/testing/dblat3.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK2	file:
110	blas/testing/dblat3.f	/^  110 CONTINUE$/;"	l	subroutine:DCHK4	file:
110	blas/testing/sblat2.f	/^  110          CONTINUE$/;"	l	subroutine:SCHK6	file:
110	blas/testing/sblat2.f	/^  110       CONTINUE$/;"	l	subroutine:SMAKE	file:
110	blas/testing/sblat2.f	/^  110    CONTINUE$/;"	l	program:SBLAT2	file:
110	blas/testing/sblat2.f	/^  110    CONTINUE$/;"	l	subroutine:SCHK1	file:
110	blas/testing/sblat2.f	/^  110    CONTINUE$/;"	l	subroutine:SCHK4	file:
110	blas/testing/sblat2.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK2	file:
110	blas/testing/sblat2.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK3	file:
110	blas/testing/sblat2.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK5	file:
110	blas/testing/sblat2.f	/^  110 INFOT = 1$/;"	l	subroutine:SCHKE	file:
110	blas/testing/sblat3.f	/^  110          CONTINUE$/;"	l	subroutine:SCHK3	file:
110	blas/testing/sblat3.f	/^  110       CONTINUE$/;"	l	subroutine:SCHK5	file:
110	blas/testing/sblat3.f	/^  110    CONTINUE$/;"	l	subroutine:SMMCH	file:
110	blas/testing/sblat3.f	/^  110 CONTINUE$/;"	l	program:SBLAT3	file:
110	blas/testing/sblat3.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK1	file:
110	blas/testing/sblat3.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK2	file:
110	blas/testing/sblat3.f	/^  110 CONTINUE$/;"	l	subroutine:SCHK4	file:
110	blas/testing/zblat2.f	/^  110          CONTINUE$/;"	l	subroutine:ZCHK6	file:
110	blas/testing/zblat2.f	/^  110       CONTINUE$/;"	l	subroutine:ZMAKE	file:
110	blas/testing/zblat2.f	/^  110    CONTINUE$/;"	l	program:ZBLAT2	file:
110	blas/testing/zblat2.f	/^  110    CONTINUE$/;"	l	subroutine:ZCHK1	file:
110	blas/testing/zblat2.f	/^  110    CONTINUE$/;"	l	subroutine:ZCHK4	file:
110	blas/testing/zblat2.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK2	file:
110	blas/testing/zblat2.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK3	file:
110	blas/testing/zblat2.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK5	file:
110	blas/testing/zblat2.f	/^  110 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
110	blas/testing/zblat3.f	/^  110          CONTINUE$/;"	l	subroutine:ZCHK3	file:
110	blas/testing/zblat3.f	/^  110          CONTINUE$/;"	l	subroutine:ZMMCH	file:
110	blas/testing/zblat3.f	/^  110       CONTINUE$/;"	l	subroutine:ZCHK5	file:
110	blas/testing/zblat3.f	/^  110 CONTINUE$/;"	l	program:ZBLAT3	file:
110	blas/testing/zblat3.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK1	file:
110	blas/testing/zblat3.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK2	file:
110	blas/testing/zblat3.f	/^  110 CONTINUE$/;"	l	subroutine:ZCHK4	file:
110	lapack/clarfb.f	/^  110             CONTINUE$/;"	l	subroutine:CLARFB	file:
110	lapack/dlarfb.f	/^  110             CONTINUE$/;"	l	subroutine:DLARFB	file:
110	lapack/slarfb.f	/^  110             CONTINUE$/;"	l	subroutine:SLARFB	file:
110	lapack/zlarfb.f	/^  110             CONTINUE$/;"	l	subroutine:ZLARFB	file:
120	blas/testing/cblat1.f	/^  120    CONTINUE$/;"	l	subroutine:CHECK1	file:
120	blas/testing/cblat2.f	/^  120       CONTINUE$/;"	l	subroutine:CCHK6	file:
120	blas/testing/cblat2.f	/^  120       CONTINUE$/;"	l	subroutine:CMAKE	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	program:CBLAT2	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK1	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK2	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK3	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK4	file:
120	blas/testing/cblat2.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK5	file:
120	blas/testing/cblat2.f	/^  120 INFOT = 1$/;"	l	subroutine:CCHKE	file:
120	blas/testing/cblat3.f	/^  120                CONTINUE$/;"	l	subroutine:CMMCH	file:
120	blas/testing/cblat3.f	/^  120       CONTINUE$/;"	l	subroutine:CCHK3	file:
120	blas/testing/cblat3.f	/^  120    CONTINUE$/;"	l	subroutine:CCHK5	file:
120	blas/testing/cblat3.f	/^  120 CONTINUE$/;"	l	program:CBLAT3	file:
120	blas/testing/cblat3.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK1	file:
120	blas/testing/cblat3.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK2	file:
120	blas/testing/cblat3.f	/^  120 CONTINUE$/;"	l	subroutine:CCHK4	file:
120	blas/testing/dblat1.f	/^  120 CONTINUE$/;"	l	subroutine:CHECK2	file:
120	blas/testing/dblat1.f	/^  120 CONTINUE$/;"	l	subroutine:CHECK3	file:
120	blas/testing/dblat2.f	/^  120       CONTINUE$/;"	l	subroutine:DCHK6	file:
120	blas/testing/dblat2.f	/^  120       CONTINUE$/;"	l	subroutine:DMAKE	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	program:DBLAT2	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK1	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK2	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK3	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK4	file:
120	blas/testing/dblat2.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK5	file:
120	blas/testing/dblat2.f	/^  120 INFOT = 1$/;"	l	subroutine:DCHKE	file:
120	blas/testing/dblat3.f	/^  120       CONTINUE$/;"	l	subroutine:DCHK3	file:
120	blas/testing/dblat3.f	/^  120    CONTINUE$/;"	l	subroutine:DCHK5	file:
120	blas/testing/dblat3.f	/^  120 CONTINUE$/;"	l	program:DBLAT3	file:
120	blas/testing/dblat3.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK1	file:
120	blas/testing/dblat3.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK2	file:
120	blas/testing/dblat3.f	/^  120 CONTINUE$/;"	l	subroutine:DCHK4	file:
120	blas/testing/dblat3.f	/^  120 CONTINUE$/;"	l	subroutine:DMMCH	file:
120	blas/testing/sblat1.f	/^  120 CONTINUE$/;"	l	subroutine:CHECK2	file:
120	blas/testing/sblat1.f	/^  120 CONTINUE$/;"	l	subroutine:CHECK3	file:
120	blas/testing/sblat2.f	/^  120       CONTINUE$/;"	l	subroutine:SCHK6	file:
120	blas/testing/sblat2.f	/^  120       CONTINUE$/;"	l	subroutine:SMAKE	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	program:SBLAT2	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK1	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK2	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK3	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK4	file:
120	blas/testing/sblat2.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK5	file:
120	blas/testing/sblat2.f	/^  120 INFOT = 1$/;"	l	subroutine:SCHKE	file:
120	blas/testing/sblat3.f	/^  120       CONTINUE$/;"	l	subroutine:SCHK3	file:
120	blas/testing/sblat3.f	/^  120    CONTINUE$/;"	l	subroutine:SCHK5	file:
120	blas/testing/sblat3.f	/^  120 CONTINUE$/;"	l	program:SBLAT3	file:
120	blas/testing/sblat3.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK1	file:
120	blas/testing/sblat3.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK2	file:
120	blas/testing/sblat3.f	/^  120 CONTINUE$/;"	l	subroutine:SCHK4	file:
120	blas/testing/sblat3.f	/^  120 CONTINUE$/;"	l	subroutine:SMMCH	file:
120	blas/testing/zblat1.f	/^  120    CONTINUE$/;"	l	subroutine:CHECK1	file:
120	blas/testing/zblat2.f	/^  120       CONTINUE$/;"	l	subroutine:ZCHK6	file:
120	blas/testing/zblat2.f	/^  120       CONTINUE$/;"	l	subroutine:ZMAKE	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	program:ZBLAT2	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK1	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK2	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK3	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK4	file:
120	blas/testing/zblat2.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK5	file:
120	blas/testing/zblat2.f	/^  120 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
120	blas/testing/zblat3.f	/^  120                CONTINUE$/;"	l	subroutine:ZMMCH	file:
120	blas/testing/zblat3.f	/^  120       CONTINUE$/;"	l	subroutine:ZCHK3	file:
120	blas/testing/zblat3.f	/^  120    CONTINUE$/;"	l	subroutine:ZCHK5	file:
120	blas/testing/zblat3.f	/^  120 CONTINUE$/;"	l	program:ZBLAT3	file:
120	blas/testing/zblat3.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK1	file:
120	blas/testing/zblat3.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK2	file:
120	blas/testing/zblat3.f	/^  120 CONTINUE$/;"	l	subroutine:ZCHK4	file:
120	lapack/clarfb.f	/^  120          CONTINUE$/;"	l	subroutine:CLARFB	file:
120	lapack/dlarfb.f	/^  120          CONTINUE$/;"	l	subroutine:DLARFB	file:
120	lapack/slarfb.f	/^  120          CONTINUE$/;"	l	subroutine:SLARFB	file:
120	lapack/zlarfb.f	/^  120          CONTINUE$/;"	l	subroutine:ZLARFB	file:
130	blas/testing/cblat2.f	/^  130    CONTINUE$/;"	l	subroutine:CCHK6	file:
130	blas/testing/cblat2.f	/^  130    CONTINUE$/;"	l	subroutine:CMAKE	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	program:CBLAT2	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK1	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK2	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK3	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK4	file:
130	blas/testing/cblat2.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK5	file:
130	blas/testing/cblat2.f	/^  130 INFOT = 1$/;"	l	subroutine:CCHKE	file:
130	blas/testing/cblat3.f	/^  130             CONTINUE$/;"	l	subroutine:CMMCH	file:
130	blas/testing/cblat3.f	/^  130    CONTINUE$/;"	l	subroutine:CCHK3	file:
130	blas/testing/cblat3.f	/^  130 CONTINUE$/;"	l	program:CBLAT3	file:
130	blas/testing/cblat3.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK1	file:
130	blas/testing/cblat3.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK4	file:
130	blas/testing/cblat3.f	/^  130 CONTINUE$/;"	l	subroutine:CCHK5	file:
130	blas/testing/dblat2.f	/^  130    CONTINUE$/;"	l	subroutine:DCHK6	file:
130	blas/testing/dblat2.f	/^  130    CONTINUE$/;"	l	subroutine:DMAKE	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	program:DBLAT2	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK1	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK2	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK3	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK4	file:
130	blas/testing/dblat2.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK5	file:
130	blas/testing/dblat2.f	/^  130 INFOT = 1$/;"	l	subroutine:DCHKE	file:
130	blas/testing/dblat3.f	/^  130    CONTINUE$/;"	l	subroutine:DCHK3	file:
130	blas/testing/dblat3.f	/^  130 CONTINUE$/;"	l	program:DBLAT3	file:
130	blas/testing/dblat3.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK1	file:
130	blas/testing/dblat3.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK4	file:
130	blas/testing/dblat3.f	/^  130 CONTINUE$/;"	l	subroutine:DCHK5	file:
130	blas/testing/dblat3.f	/^  130 FATAL = .TRUE.$/;"	l	subroutine:DMMCH	file:
130	blas/testing/sblat2.f	/^  130    CONTINUE$/;"	l	subroutine:SCHK6	file:
130	blas/testing/sblat2.f	/^  130    CONTINUE$/;"	l	subroutine:SMAKE	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	program:SBLAT2	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK1	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK2	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK3	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK4	file:
130	blas/testing/sblat2.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK5	file:
130	blas/testing/sblat2.f	/^  130 INFOT = 1$/;"	l	subroutine:SCHKE	file:
130	blas/testing/sblat3.f	/^  130    CONTINUE$/;"	l	subroutine:SCHK3	file:
130	blas/testing/sblat3.f	/^  130 CONTINUE$/;"	l	program:SBLAT3	file:
130	blas/testing/sblat3.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK1	file:
130	blas/testing/sblat3.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK4	file:
130	blas/testing/sblat3.f	/^  130 CONTINUE$/;"	l	subroutine:SCHK5	file:
130	blas/testing/sblat3.f	/^  130 FATAL = .TRUE.$/;"	l	subroutine:SMMCH	file:
130	blas/testing/zblat2.f	/^  130    CONTINUE$/;"	l	subroutine:ZCHK6	file:
130	blas/testing/zblat2.f	/^  130    CONTINUE$/;"	l	subroutine:ZMAKE	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	program:ZBLAT2	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK1	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK2	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK3	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK4	file:
130	blas/testing/zblat2.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK5	file:
130	blas/testing/zblat2.f	/^  130 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
130	blas/testing/zblat3.f	/^  130             CONTINUE$/;"	l	subroutine:ZMMCH	file:
130	blas/testing/zblat3.f	/^  130    CONTINUE$/;"	l	subroutine:ZCHK3	file:
130	blas/testing/zblat3.f	/^  130 CONTINUE$/;"	l	program:ZBLAT3	file:
130	blas/testing/zblat3.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK1	file:
130	blas/testing/zblat3.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK4	file:
130	blas/testing/zblat3.f	/^  130 CONTINUE$/;"	l	subroutine:ZCHK5	file:
130	lapack/clarfb.f	/^  130          CONTINUE$/;"	l	subroutine:CLARFB	file:
130	lapack/dlarfb.f	/^  130          CONTINUE$/;"	l	subroutine:DLARFB	file:
130	lapack/slarfb.f	/^  130          CONTINUE$/;"	l	subroutine:SLARFB	file:
130	lapack/zlarfb.f	/^  130          CONTINUE$/;"	l	subroutine:ZLARFB	file:
140	blas/testing/cblat1.f	/^  140    CONTINUE$/;"	l	subroutine:CHECK1	file:
140	blas/testing/cblat2.f	/^  140       CALL CCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
140	blas/testing/cblat2.f	/^  140       CONTINUE$/;"	l	subroutine:CMAKE	file:
140	blas/testing/cblat2.f	/^  140 CONTINUE$/;"	l	subroutine:CCHK1	file:
140	blas/testing/cblat2.f	/^  140 CONTINUE$/;"	l	subroutine:CCHK4	file:
140	blas/testing/cblat2.f	/^  140 CONTINUE$/;"	l	subroutine:CCHK6	file:
140	blas/testing/cblat2.f	/^  140 INFOT = 1$/;"	l	subroutine:CCHKE	file:
140	blas/testing/cblat3.f	/^  140                CONTINUE$/;"	l	subroutine:CMMCH	file:
140	blas/testing/cblat3.f	/^  140       CALL CCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT3	file:
140	blas/testing/cblat3.f	/^  140 CONTINUE$/;"	l	subroutine:CCHK3	file:
140	blas/testing/cblat3.f	/^  140 CONTINUE$/;"	l	subroutine:CCHK5	file:
140	blas/testing/dblat1.f	/^  140 CONTINUE$/;"	l	subroutine:CHECK3	file:
140	blas/testing/dblat2.f	/^  140       CALL DCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
140	blas/testing/dblat2.f	/^  140       CONTINUE$/;"	l	subroutine:DMAKE	file:
140	blas/testing/dblat2.f	/^  140 CONTINUE$/;"	l	subroutine:DCHK1	file:
140	blas/testing/dblat2.f	/^  140 CONTINUE$/;"	l	subroutine:DCHK4	file:
140	blas/testing/dblat2.f	/^  140 CONTINUE$/;"	l	subroutine:DCHK6	file:
140	blas/testing/dblat2.f	/^  140 INFOT = 1$/;"	l	subroutine:DCHKE	file:
140	blas/testing/dblat3.f	/^  140       CALL DCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT3	file:
140	blas/testing/dblat3.f	/^  140 CONTINUE$/;"	l	subroutine:DCHK3	file:
140	blas/testing/dblat3.f	/^  140 CONTINUE$/;"	l	subroutine:DCHK5	file:
140	blas/testing/dblat3.f	/^  140 CONTINUE$/;"	l	subroutine:DMMCH	file:
140	blas/testing/sblat1.f	/^  140 CONTINUE$/;"	l	subroutine:CHECK3	file:
140	blas/testing/sblat2.f	/^  140       CALL SCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
140	blas/testing/sblat2.f	/^  140       CONTINUE$/;"	l	subroutine:SMAKE	file:
140	blas/testing/sblat2.f	/^  140 CONTINUE$/;"	l	subroutine:SCHK1	file:
140	blas/testing/sblat2.f	/^  140 CONTINUE$/;"	l	subroutine:SCHK4	file:
140	blas/testing/sblat2.f	/^  140 CONTINUE$/;"	l	subroutine:SCHK6	file:
140	blas/testing/sblat2.f	/^  140 INFOT = 1$/;"	l	subroutine:SCHKE	file:
140	blas/testing/sblat3.f	/^  140       CALL SCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT3	file:
140	blas/testing/sblat3.f	/^  140 CONTINUE$/;"	l	subroutine:SCHK3	file:
140	blas/testing/sblat3.f	/^  140 CONTINUE$/;"	l	subroutine:SCHK5	file:
140	blas/testing/sblat3.f	/^  140 CONTINUE$/;"	l	subroutine:SMMCH	file:
140	blas/testing/zblat1.f	/^  140    CONTINUE$/;"	l	subroutine:CHECK1	file:
140	blas/testing/zblat2.f	/^  140       CALL ZCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
140	blas/testing/zblat2.f	/^  140       CONTINUE$/;"	l	subroutine:ZMAKE	file:
140	blas/testing/zblat2.f	/^  140 CONTINUE$/;"	l	subroutine:ZCHK1	file:
140	blas/testing/zblat2.f	/^  140 CONTINUE$/;"	l	subroutine:ZCHK4	file:
140	blas/testing/zblat2.f	/^  140 CONTINUE$/;"	l	subroutine:ZCHK6	file:
140	blas/testing/zblat2.f	/^  140 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
140	blas/testing/zblat3.f	/^  140                CONTINUE$/;"	l	subroutine:ZMMCH	file:
140	blas/testing/zblat3.f	/^  140       CALL ZCHK1( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT3	file:
140	blas/testing/zblat3.f	/^  140 CONTINUE$/;"	l	subroutine:ZCHK3	file:
140	blas/testing/zblat3.f	/^  140 CONTINUE$/;"	l	subroutine:ZCHK5	file:
140	lapack/clarfb.f	/^  140             CONTINUE$/;"	l	subroutine:CLARFB	file:
140	lapack/dlarfb.f	/^  140             CONTINUE$/;"	l	subroutine:DLARFB	file:
140	lapack/slarfb.f	/^  140             CONTINUE$/;"	l	subroutine:SLARFB	file:
140	lapack/zlarfb.f	/^  140             CONTINUE$/;"	l	subroutine:ZLARFB	file:
150	blas/testing/cblat2.f	/^  150       CALL CCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
150	blas/testing/cblat2.f	/^  150       CONTINUE$/;"	l	subroutine:CMAKE	file:
150	blas/testing/cblat2.f	/^  150 CONTINUE$/;"	l	subroutine:CCHK4	file:
150	blas/testing/cblat2.f	/^  150 CONTINUE$/;"	l	subroutine:CCHK6	file:
150	blas/testing/cblat2.f	/^  150 INFOT = 1$/;"	l	subroutine:CCHKE	file:
150	blas/testing/cblat3.f	/^  150             CONTINUE$/;"	l	subroutine:CMMCH	file:
150	blas/testing/cblat3.f	/^  150       CALL CCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT3	file:
150	blas/testing/cblat3.f	/^  150 CONTINUE$/;"	l	subroutine:CCHK3	file:
150	blas/testing/cblat3.f	/^  150 CONTINUE$/;"	l	subroutine:CCHK5	file:
150	blas/testing/dblat2.f	/^  150       CALL DCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
150	blas/testing/dblat2.f	/^  150       CONTINUE$/;"	l	subroutine:DMAKE	file:
150	blas/testing/dblat2.f	/^  150 CONTINUE$/;"	l	subroutine:DCHK4	file:
150	blas/testing/dblat2.f	/^  150 CONTINUE$/;"	l	subroutine:DCHK6	file:
150	blas/testing/dblat2.f	/^  150 INFOT = 1$/;"	l	subroutine:DCHKE	file:
150	blas/testing/dblat3.f	/^  150       CALL DCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT3	file:
150	blas/testing/dblat3.f	/^  150 CONTINUE$/;"	l	subroutine:DCHK3	file:
150	blas/testing/dblat3.f	/^  150 CONTINUE$/;"	l	subroutine:DCHK5	file:
150	blas/testing/dblat3.f	/^  150 CONTINUE$/;"	l	subroutine:DMMCH	file:
150	blas/testing/sblat2.f	/^  150       CALL SCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
150	blas/testing/sblat2.f	/^  150       CONTINUE$/;"	l	subroutine:SMAKE	file:
150	blas/testing/sblat2.f	/^  150 CONTINUE$/;"	l	subroutine:SCHK4	file:
150	blas/testing/sblat2.f	/^  150 CONTINUE$/;"	l	subroutine:SCHK6	file:
150	blas/testing/sblat2.f	/^  150 INFOT = 1$/;"	l	subroutine:SCHKE	file:
150	blas/testing/sblat3.f	/^  150       CALL SCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT3	file:
150	blas/testing/sblat3.f	/^  150 CONTINUE$/;"	l	subroutine:SCHK3	file:
150	blas/testing/sblat3.f	/^  150 CONTINUE$/;"	l	subroutine:SCHK5	file:
150	blas/testing/sblat3.f	/^  150 CONTINUE$/;"	l	subroutine:SMMCH	file:
150	blas/testing/zblat2.f	/^  150       CALL ZCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
150	blas/testing/zblat2.f	/^  150       CONTINUE$/;"	l	subroutine:ZMAKE	file:
150	blas/testing/zblat2.f	/^  150 CONTINUE$/;"	l	subroutine:ZCHK4	file:
150	blas/testing/zblat2.f	/^  150 CONTINUE$/;"	l	subroutine:ZCHK6	file:
150	blas/testing/zblat2.f	/^  150 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
150	blas/testing/zblat3.f	/^  150             CONTINUE$/;"	l	subroutine:ZMMCH	file:
150	blas/testing/zblat3.f	/^  150       CALL ZCHK2( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT3	file:
150	blas/testing/zblat3.f	/^  150 CONTINUE$/;"	l	subroutine:ZCHK3	file:
150	blas/testing/zblat3.f	/^  150 CONTINUE$/;"	l	subroutine:ZCHK5	file:
150	lapack/clarfb.f	/^  150          CONTINUE$/;"	l	subroutine:CLARFB	file:
150	lapack/dlarfb.f	/^  150          CONTINUE$/;"	l	subroutine:DLARFB	file:
150	lapack/slarfb.f	/^  150          CONTINUE$/;"	l	subroutine:SLARFB	file:
150	lapack/zlarfb.f	/^  150          CONTINUE$/;"	l	subroutine:ZLARFB	file:
160	blas/testing/cblat2.f	/^  160       CALL CCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
160	blas/testing/cblat2.f	/^  160       CONTINUE$/;"	l	subroutine:CMAKE	file:
160	blas/testing/cblat2.f	/^  160 CONTINUE$/;"	l	subroutine:CCHK6	file:
160	blas/testing/cblat2.f	/^  160 INFOT = 1$/;"	l	subroutine:CCHKE	file:
160	blas/testing/cblat3.f	/^  160                CONTINUE$/;"	l	subroutine:CMMCH	file:
160	blas/testing/cblat3.f	/^  160       CALL CCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT3	file:
160	blas/testing/cblat3.f	/^  160 CONTINUE$/;"	l	subroutine:CCHK3	file:
160	blas/testing/cblat3.f	/^  160 CONTINUE$/;"	l	subroutine:CCHK5	file:
160	blas/testing/dblat1.f	/^  160 CONTINUE$/;"	l	subroutine:CHECK3	file:
160	blas/testing/dblat2.f	/^  160       CALL DCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
160	blas/testing/dblat2.f	/^  160       CONTINUE$/;"	l	subroutine:DMAKE	file:
160	blas/testing/dblat2.f	/^  160 CONTINUE$/;"	l	subroutine:DCHK6	file:
160	blas/testing/dblat2.f	/^  160 INFOT = 1$/;"	l	subroutine:DCHKE	file:
160	blas/testing/dblat3.f	/^  160       CALL DCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT3	file:
160	blas/testing/dblat3.f	/^  160 CONTINUE$/;"	l	subroutine:DCHK3	file:
160	blas/testing/dblat3.f	/^  160 CONTINUE$/;"	l	subroutine:DCHK5	file:
160	blas/testing/sblat1.f	/^  160 CONTINUE$/;"	l	subroutine:CHECK3	file:
160	blas/testing/sblat2.f	/^  160       CALL SCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
160	blas/testing/sblat2.f	/^  160       CONTINUE$/;"	l	subroutine:SMAKE	file:
160	blas/testing/sblat2.f	/^  160 CONTINUE$/;"	l	subroutine:SCHK6	file:
160	blas/testing/sblat2.f	/^  160 INFOT = 1$/;"	l	subroutine:SCHKE	file:
160	blas/testing/sblat3.f	/^  160       CALL SCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT3	file:
160	blas/testing/sblat3.f	/^  160 CONTINUE$/;"	l	subroutine:SCHK3	file:
160	blas/testing/sblat3.f	/^  160 CONTINUE$/;"	l	subroutine:SCHK5	file:
160	blas/testing/zblat2.f	/^  160       CALL ZCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
160	blas/testing/zblat2.f	/^  160       CONTINUE$/;"	l	subroutine:ZMAKE	file:
160	blas/testing/zblat2.f	/^  160 CONTINUE$/;"	l	subroutine:ZCHK6	file:
160	blas/testing/zblat2.f	/^  160 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
160	blas/testing/zblat3.f	/^  160                CONTINUE$/;"	l	subroutine:ZMMCH	file:
160	blas/testing/zblat3.f	/^  160       CALL ZCHK3( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT3	file:
160	blas/testing/zblat3.f	/^  160 CONTINUE$/;"	l	subroutine:ZCHK3	file:
160	blas/testing/zblat3.f	/^  160 CONTINUE$/;"	l	subroutine:ZCHK5	file:
160	lapack/clarfb.f	/^  160          CONTINUE$/;"	l	subroutine:CLARFB	file:
160	lapack/dlarfb.f	/^  160          CONTINUE$/;"	l	subroutine:DLARFB	file:
160	lapack/slarfb.f	/^  160          CONTINUE$/;"	l	subroutine:SLARFB	file:
160	lapack/zlarfb.f	/^  160          CONTINUE$/;"	l	subroutine:ZLARFB	file:
170	blas/testing/cblat2.f	/^  170       CALL CCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
170	blas/testing/cblat2.f	/^  170    CONTINUE$/;"	l	subroutine:CMAKE	file:
170	blas/testing/cblat2.f	/^  170 CONTINUE$/;"	l	subroutine:CCHK6	file:
170	blas/testing/cblat2.f	/^  170 INFOT = 1$/;"	l	subroutine:CCHKE	file:
170	blas/testing/cblat3.f	/^  170             CONTINUE$/;"	l	subroutine:CMMCH	file:
170	blas/testing/cblat3.f	/^  170       CALL CCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT3	file:
170	blas/testing/dblat2.f	/^  170       CALL DCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
170	blas/testing/dblat2.f	/^  170    CONTINUE$/;"	l	subroutine:DMAKE	file:
170	blas/testing/dblat2.f	/^  170 CONTINUE$/;"	l	subroutine:DCHK6	file:
170	blas/testing/dblat2.f	/^  170 IF( OK )THEN$/;"	l	subroutine:DCHKE	file:
170	blas/testing/dblat3.f	/^  170       CALL DCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT3	file:
170	blas/testing/sblat2.f	/^  170       CALL SCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
170	blas/testing/sblat2.f	/^  170    CONTINUE$/;"	l	subroutine:SMAKE	file:
170	blas/testing/sblat2.f	/^  170 CONTINUE$/;"	l	subroutine:SCHK6	file:
170	blas/testing/sblat2.f	/^  170 IF( OK )THEN$/;"	l	subroutine:SCHKE	file:
170	blas/testing/sblat3.f	/^  170       CALL SCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT3	file:
170	blas/testing/zblat2.f	/^  170       CALL ZCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
170	blas/testing/zblat2.f	/^  170    CONTINUE$/;"	l	subroutine:ZMAKE	file:
170	blas/testing/zblat2.f	/^  170 CONTINUE$/;"	l	subroutine:ZCHK6	file:
170	blas/testing/zblat2.f	/^  170 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
170	blas/testing/zblat3.f	/^  170             CONTINUE$/;"	l	subroutine:ZMMCH	file:
170	blas/testing/zblat3.f	/^  170       CALL ZCHK4( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT3	file:
170	lapack/clarfb.f	/^  170             CONTINUE$/;"	l	subroutine:CLARFB	file:
170	lapack/dlarfb.f	/^  170             CONTINUE$/;"	l	subroutine:DLARFB	file:
170	lapack/slarfb.f	/^  170             CONTINUE$/;"	l	subroutine:SLARFB	file:
170	lapack/zlarfb.f	/^  170             CONTINUE$/;"	l	subroutine:ZLARFB	file:
180	blas/testing/cblat2.f	/^  180       CALL CCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
180	blas/testing/cblat2.f	/^  180       CONTINUE$/;"	l	subroutine:CMAKE	file:
180	blas/testing/cblat2.f	/^  180 IF( OK )THEN$/;"	l	subroutine:CCHKE	file:
180	blas/testing/cblat3.f	/^  180                CONTINUE$/;"	l	subroutine:CMMCH	file:
180	blas/testing/cblat3.f	/^  180       CALL CCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT3	file:
180	blas/testing/dblat1.f	/^  180    CONTINUE$/;"	l	subroutine:CHECK3	file:
180	blas/testing/dblat2.f	/^  180       CALL DCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
180	blas/testing/dblat2.f	/^  180       CONTINUE$/;"	l	subroutine:DMAKE	file:
180	blas/testing/dblat3.f	/^  180       CALL DCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT3	file:
180	blas/testing/sblat1.f	/^  180    CONTINUE$/;"	l	subroutine:CHECK3	file:
180	blas/testing/sblat2.f	/^  180       CALL SCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
180	blas/testing/sblat2.f	/^  180       CONTINUE$/;"	l	subroutine:SMAKE	file:
180	blas/testing/sblat3.f	/^  180       CALL SCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT3	file:
180	blas/testing/zblat2.f	/^  180       CALL ZCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
180	blas/testing/zblat2.f	/^  180       CONTINUE$/;"	l	subroutine:ZMAKE	file:
180	blas/testing/zblat2.f	/^  180 IF( OK )THEN$/;"	l	subroutine:ZCHKE	file:
180	blas/testing/zblat3.f	/^  180                CONTINUE$/;"	l	subroutine:ZMMCH	file:
180	blas/testing/zblat3.f	/^  180       CALL ZCHK5( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT3	file:
180	lapack/clarfb.f	/^  180          CONTINUE$/;"	l	subroutine:CLARFB	file:
180	lapack/dlarfb.f	/^  180          CONTINUE$/;"	l	subroutine:DLARFB	file:
180	lapack/slarfb.f	/^  180          CONTINUE$/;"	l	subroutine:SLARFB	file:
180	lapack/zlarfb.f	/^  180          CONTINUE$/;"	l	subroutine:ZLARFB	file:
190	blas/testing/cblat2.f	/^  190       CALL CCHK6( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:CBLAT2	file:
190	blas/testing/cblat2.f	/^  190    CONTINUE$/;"	l	subroutine:CMAKE	file:
190	blas/testing/cblat3.f	/^  190             CONTINUE$/;"	l	subroutine:CMMCH	file:
190	blas/testing/cblat3.f	/^  190       IF( FATAL.AND.SFATAL )$/;"	l	program:CBLAT3	file:
190	blas/testing/dblat2.f	/^  190       CALL DCHK6( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:DBLAT2	file:
190	blas/testing/dblat2.f	/^  190    CONTINUE$/;"	l	subroutine:DMAKE	file:
190	blas/testing/dblat3.f	/^  190       IF( FATAL.AND.SFATAL )$/;"	l	program:DBLAT3	file:
190	blas/testing/sblat2.f	/^  190       CALL SCHK6( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:SBLAT2	file:
190	blas/testing/sblat2.f	/^  190    CONTINUE$/;"	l	subroutine:SMAKE	file:
190	blas/testing/sblat3.f	/^  190       IF( FATAL.AND.SFATAL )$/;"	l	program:SBLAT3	file:
190	blas/testing/zblat2.f	/^  190       CALL ZCHK6( SNAMES( ISNUM ), EPS, THRESH, NOUT, NTRA, TRACE,$/;"	l	program:ZBLAT2	file:
190	blas/testing/zblat2.f	/^  190    CONTINUE$/;"	l	subroutine:ZMAKE	file:
190	blas/testing/zblat3.f	/^  190             CONTINUE$/;"	l	subroutine:ZMMCH	file:
190	blas/testing/zblat3.f	/^  190       IF( FATAL.AND.SFATAL )$/;"	l	program:ZBLAT3	file:
190	lapack/clarfb.f	/^  190          CONTINUE$/;"	l	subroutine:CLARFB	file:
190	lapack/dlarfb.f	/^  190          CONTINUE$/;"	l	subroutine:DLARFB	file:
190	lapack/slarfb.f	/^  190          CONTINUE$/;"	l	subroutine:SLARFB	file:
190	lapack/zlarfb.f	/^  190          CONTINUE$/;"	l	subroutine:ZLARFB	file:
20	blas/testing/cblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK1	file:
20	blas/testing/cblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK2	file:
20	blas/testing/cblat1.f	/^   20    WRITE (NOUT,99997) ICASE, N, INCX, INCY, MODE, I, SCOMP(I),$/;"	l	subroutine:STEST	file:
20	blas/testing/cblat1.f	/^   20 CONTINUE$/;"	l	program:CBLAT1	file:
20	blas/testing/cblat1.f	/^   20 CONTINUE$/;"	l	subroutine:CTEST	file:
20	blas/testing/cblat1.f	/^   20 ID = ICOMP - ITRUE$/;"	l	subroutine:ITEST1	file:
20	blas/testing/cblat2.f	/^   20                         CONTINUE$/;"	l	subroutine:CCHK1	file:
20	blas/testing/cblat2.f	/^   20                      CONTINUE$/;"	l	subroutine:CCHK2	file:
20	blas/testing/cblat2.f	/^   20                   CONTINUE$/;"	l	subroutine:CCHK3	file:
20	blas/testing/cblat2.f	/^   20                CONTINUE$/;"	l	subroutine:CCHK4	file:
20	blas/testing/cblat2.f	/^   20                CONTINUE$/;"	l	subroutine:CCHK6	file:
20	blas/testing/cblat2.f	/^   20             CONTINUE$/;"	l	subroutine:CCHK5	file:
20	blas/testing/cblat2.f	/^   20       CONTINUE$/;"	l	subroutine:CMVCH	file:
20	blas/testing/cblat2.f	/^   20    CONTINUE$/;"	l	function:LCERES	file:
20	blas/testing/cblat2.f	/^   20 CONTINUE$/;"	l	function:LCE	file:
20	blas/testing/cblat2.f	/^   20 CONTINUE$/;"	l	program:CBLAT2	file:
20	blas/testing/cblat2.f	/^   20 CONTINUE$/;"	l	subroutine:CMAKE	file:
20	blas/testing/cblat2.f	/^   20 INFOT = 1$/;"	l	subroutine:CCHKE	file:
20	blas/testing/cblat3.f	/^   20                      CONTINUE$/;"	l	subroutine:CCHK1	file:
20	blas/testing/cblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:CCHK2	file:
20	blas/testing/cblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:CCHK4	file:
20	blas/testing/cblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:CCHK5	file:
20	blas/testing/cblat3.f	/^   20          CONTINUE$/;"	l	subroutine:CMMCH	file:
20	blas/testing/cblat3.f	/^   20    CONTINUE$/;"	l	function:LCERES	file:
20	blas/testing/cblat3.f	/^   20 CONTINUE$/;"	l	function:LCE	file:
20	blas/testing/cblat3.f	/^   20 CONTINUE$/;"	l	program:CBLAT3	file:
20	blas/testing/cblat3.f	/^   20 CONTINUE$/;"	l	subroutine:CCHK3	file:
20	blas/testing/cblat3.f	/^   20 CONTINUE$/;"	l	subroutine:CMAKE	file:
20	blas/testing/cblat3.f	/^   20 INFOT = 1$/;"	l	subroutine:CCHKE	file:
20	blas/testing/dblat1.f	/^   20          CONTINUE$/;"	l	subroutine:CHECK3	file:
20	blas/testing/dblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK1	file:
20	blas/testing/dblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK2	file:
20	blas/testing/dblat1.f	/^   20    WRITE (NOUT,99997) ICASE, N, INCX, INCY, I, SCOMP(I),$/;"	l	subroutine:STEST	file:
20	blas/testing/dblat1.f	/^   20    WRITE (NOUT,99997) ICASE, N, INCX, INCY, SCOMP,$/;"	l	subroutine:TESTDSDOT	file:
20	blas/testing/dblat1.f	/^   20 CONTINUE$/;"	l	program:DBLAT1	file:
20	blas/testing/dblat1.f	/^   20 CONTINUE$/;"	l	subroutine:CHECK0	file:
20	blas/testing/dblat1.f	/^   20 ID = ICOMP - ITRUE$/;"	l	subroutine:ITEST1	file:
20	blas/testing/dblat2.f	/^   20                         CONTINUE$/;"	l	subroutine:DCHK1	file:
20	blas/testing/dblat2.f	/^   20                      CONTINUE$/;"	l	subroutine:DCHK2	file:
20	blas/testing/dblat2.f	/^   20                   CONTINUE$/;"	l	subroutine:DCHK3	file:
20	blas/testing/dblat2.f	/^   20                CONTINUE$/;"	l	subroutine:DCHK4	file:
20	blas/testing/dblat2.f	/^   20                CONTINUE$/;"	l	subroutine:DCHK6	file:
20	blas/testing/dblat2.f	/^   20             CONTINUE$/;"	l	subroutine:DCHK5	file:
20	blas/testing/dblat2.f	/^   20       CONTINUE$/;"	l	subroutine:DMVCH	file:
20	blas/testing/dblat2.f	/^   20    CONTINUE$/;"	l	function:LDERES	file:
20	blas/testing/dblat2.f	/^   20 CONTINUE$/;"	l	function:LDE	file:
20	blas/testing/dblat2.f	/^   20 CONTINUE$/;"	l	program:DBLAT2	file:
20	blas/testing/dblat2.f	/^   20 CONTINUE$/;"	l	subroutine:DMAKE	file:
20	blas/testing/dblat2.f	/^   20 INFOT = 1$/;"	l	subroutine:DCHKE	file:
20	blas/testing/dblat3.f	/^   20                      CONTINUE$/;"	l	subroutine:DCHK1	file:
20	blas/testing/dblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:DCHK2	file:
20	blas/testing/dblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:DCHK4	file:
20	blas/testing/dblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:DCHK5	file:
20	blas/testing/dblat3.f	/^   20          CONTINUE$/;"	l	subroutine:DMMCH	file:
20	blas/testing/dblat3.f	/^   20    CONTINUE$/;"	l	function:LDERES	file:
20	blas/testing/dblat3.f	/^   20 CONTINUE$/;"	l	function:LDE	file:
20	blas/testing/dblat3.f	/^   20 CONTINUE$/;"	l	program:DBLAT3	file:
20	blas/testing/dblat3.f	/^   20 CONTINUE$/;"	l	subroutine:DCHK3	file:
20	blas/testing/dblat3.f	/^   20 CONTINUE$/;"	l	subroutine:DMAKE	file:
20	blas/testing/dblat3.f	/^   20 INFOT = 1$/;"	l	subroutine:DCHKE	file:
20	blas/testing/sblat1.f	/^   20          CONTINUE$/;"	l	subroutine:CHECK3	file:
20	blas/testing/sblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK1	file:
20	blas/testing/sblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK2	file:
20	blas/testing/sblat1.f	/^   20    WRITE (NOUT,99997) ICASE, N, INCX, INCY, I, SCOMP(I),$/;"	l	subroutine:STEST	file:
20	blas/testing/sblat1.f	/^   20 CONTINUE$/;"	l	program:SBLAT1	file:
20	blas/testing/sblat1.f	/^   20 CONTINUE$/;"	l	subroutine:CHECK0	file:
20	blas/testing/sblat1.f	/^   20 ID = ICOMP - ITRUE$/;"	l	subroutine:ITEST1	file:
20	blas/testing/sblat2.f	/^   20                         CONTINUE$/;"	l	subroutine:SCHK1	file:
20	blas/testing/sblat2.f	/^   20                      CONTINUE$/;"	l	subroutine:SCHK2	file:
20	blas/testing/sblat2.f	/^   20                   CONTINUE$/;"	l	subroutine:SCHK3	file:
20	blas/testing/sblat2.f	/^   20                CONTINUE$/;"	l	subroutine:SCHK4	file:
20	blas/testing/sblat2.f	/^   20                CONTINUE$/;"	l	subroutine:SCHK6	file:
20	blas/testing/sblat2.f	/^   20             CONTINUE$/;"	l	subroutine:SCHK5	file:
20	blas/testing/sblat2.f	/^   20       CONTINUE$/;"	l	subroutine:SMVCH	file:
20	blas/testing/sblat2.f	/^   20    CONTINUE$/;"	l	function:LSERES	file:
20	blas/testing/sblat2.f	/^   20 CONTINUE$/;"	l	function:LSE	file:
20	blas/testing/sblat2.f	/^   20 CONTINUE$/;"	l	program:SBLAT2	file:
20	blas/testing/sblat2.f	/^   20 CONTINUE$/;"	l	subroutine:SMAKE	file:
20	blas/testing/sblat2.f	/^   20 INFOT = 1$/;"	l	subroutine:SCHKE	file:
20	blas/testing/sblat3.f	/^   20                      CONTINUE$/;"	l	subroutine:SCHK1	file:
20	blas/testing/sblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:SCHK2	file:
20	blas/testing/sblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:SCHK4	file:
20	blas/testing/sblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:SCHK5	file:
20	blas/testing/sblat3.f	/^   20          CONTINUE$/;"	l	subroutine:SMMCH	file:
20	blas/testing/sblat3.f	/^   20    CONTINUE$/;"	l	function:LSERES	file:
20	blas/testing/sblat3.f	/^   20 CONTINUE$/;"	l	function:LSE	file:
20	blas/testing/sblat3.f	/^   20 CONTINUE$/;"	l	program:SBLAT3	file:
20	blas/testing/sblat3.f	/^   20 CONTINUE$/;"	l	subroutine:SCHK3	file:
20	blas/testing/sblat3.f	/^   20 CONTINUE$/;"	l	subroutine:SMAKE	file:
20	blas/testing/sblat3.f	/^   20 INFOT = 1$/;"	l	subroutine:SCHKE	file:
20	blas/testing/zblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK1	file:
20	blas/testing/zblat1.f	/^   20       CONTINUE$/;"	l	subroutine:CHECK2	file:
20	blas/testing/zblat1.f	/^   20    WRITE (NOUT,99997) ICASE, N, INCX, INCY, MODE, I, SCOMP(I),$/;"	l	subroutine:STEST	file:
20	blas/testing/zblat1.f	/^   20 CONTINUE$/;"	l	program:ZBLAT1	file:
20	blas/testing/zblat1.f	/^   20 CONTINUE$/;"	l	subroutine:CTEST	file:
20	blas/testing/zblat1.f	/^   20 ID = ICOMP - ITRUE$/;"	l	subroutine:ITEST1	file:
20	blas/testing/zblat2.f	/^   20                         CONTINUE$/;"	l	subroutine:ZCHK1	file:
20	blas/testing/zblat2.f	/^   20                      CONTINUE$/;"	l	subroutine:ZCHK2	file:
20	blas/testing/zblat2.f	/^   20                   CONTINUE$/;"	l	subroutine:ZCHK3	file:
20	blas/testing/zblat2.f	/^   20                CONTINUE$/;"	l	subroutine:ZCHK4	file:
20	blas/testing/zblat2.f	/^   20                CONTINUE$/;"	l	subroutine:ZCHK6	file:
20	blas/testing/zblat2.f	/^   20             CONTINUE$/;"	l	subroutine:ZCHK5	file:
20	blas/testing/zblat2.f	/^   20       CONTINUE$/;"	l	subroutine:ZMVCH	file:
20	blas/testing/zblat2.f	/^   20    CONTINUE$/;"	l	function:LZERES	file:
20	blas/testing/zblat2.f	/^   20 CONTINUE$/;"	l	function:LZE	file:
20	blas/testing/zblat2.f	/^   20 CONTINUE$/;"	l	program:ZBLAT2	file:
20	blas/testing/zblat2.f	/^   20 CONTINUE$/;"	l	subroutine:ZMAKE	file:
20	blas/testing/zblat2.f	/^   20 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
20	blas/testing/zblat3.f	/^   20                      CONTINUE$/;"	l	subroutine:ZCHK1	file:
20	blas/testing/zblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:ZCHK2	file:
20	blas/testing/zblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:ZCHK4	file:
20	blas/testing/zblat3.f	/^   20                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
20	blas/testing/zblat3.f	/^   20          CONTINUE$/;"	l	subroutine:ZMMCH	file:
20	blas/testing/zblat3.f	/^   20    CONTINUE$/;"	l	function:LZERES	file:
20	blas/testing/zblat3.f	/^   20 CONTINUE$/;"	l	function:LZE	file:
20	blas/testing/zblat3.f	/^   20 CONTINUE$/;"	l	program:ZBLAT3	file:
20	blas/testing/zblat3.f	/^   20 CONTINUE$/;"	l	subroutine:ZCHK3	file:
20	blas/testing/zblat3.f	/^   20 CONTINUE$/;"	l	subroutine:ZMAKE	file:
20	blas/testing/zblat3.f	/^   20 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
20	lapack/clacgv.f	/^   20    CONTINUE$/;"	l	subroutine:CLACGV	file:
20	lapack/clarfb.f	/^   20             CONTINUE$/;"	l	subroutine:CLARFB	file:
20	lapack/clarfg.f	/^ 20      CONTINUE$/;"	l	subroutine:CLARFG	file:
20	lapack/dlarfb.f	/^   20             CONTINUE$/;"	l	subroutine:DLARFB	file:
20	lapack/dlarfg.f	/^ 20      CONTINUE$/;"	l	subroutine:DLARFG	file:
20	lapack/slarfb.f	/^   20             CONTINUE$/;"	l	subroutine:SLARFB	file:
20	lapack/slarfg.f	/^ 20      CONTINUE$/;"	l	subroutine:SLARFG	file:
20	lapack/zlacgv.f	/^   20    CONTINUE$/;"	l	subroutine:ZLACGV	file:
20	lapack/zlarfb.f	/^   20             CONTINUE$/;"	l	subroutine:ZLARFB	file:
20	lapack/zlarfg.f	/^ 20      CONTINUE$/;"	l	subroutine:ZLARFG	file:
200	blas/testing/cblat2.f	/^  200       IF( FATAL.AND.SFATAL )$/;"	l	program:CBLAT2	file:
200	blas/testing/cblat3.f	/^  200    CONTINUE$/;"	l	subroutine:CMMCH	file:
200	blas/testing/cblat3.f	/^  200 CONTINUE$/;"	l	program:CBLAT3	file:
200	blas/testing/dblat1.f	/^  200 CONTINUE$/;"	l	subroutine:CHECK3	file:
200	blas/testing/dblat2.f	/^  200       IF( FATAL.AND.SFATAL )$/;"	l	program:DBLAT2	file:
200	blas/testing/dblat3.f	/^  200 CONTINUE$/;"	l	program:DBLAT3	file:
200	blas/testing/sblat1.f	/^  200 CONTINUE$/;"	l	subroutine:CHECK3	file:
200	blas/testing/sblat2.f	/^  200       IF( FATAL.AND.SFATAL )$/;"	l	program:SBLAT2	file:
200	blas/testing/sblat3.f	/^  200 CONTINUE$/;"	l	program:SBLAT3	file:
200	blas/testing/zblat2.f	/^  200       IF( FATAL.AND.SFATAL )$/;"	l	program:ZBLAT2	file:
200	blas/testing/zblat3.f	/^  200    CONTINUE$/;"	l	subroutine:ZMMCH	file:
200	blas/testing/zblat3.f	/^  200 CONTINUE$/;"	l	program:ZBLAT3	file:
200	lapack/clarfb.f	/^  200             CONTINUE$/;"	l	subroutine:CLARFB	file:
200	lapack/dlarfb.f	/^  200             CONTINUE$/;"	l	subroutine:DLARFB	file:
200	lapack/slarfb.f	/^  200             CONTINUE$/;"	l	subroutine:SLARFB	file:
200	lapack/zlarfb.f	/^  200             CONTINUE$/;"	l	subroutine:ZLARFB	file:
210	blas/testing/cblat2.f	/^  210 CONTINUE$/;"	l	program:CBLAT2	file:
210	blas/testing/cblat3.f	/^  210    CONTINUE$/;"	l	subroutine:CMMCH	file:
210	blas/testing/cblat3.f	/^  210 CONTINUE$/;"	l	program:CBLAT3	file:
210	blas/testing/dblat2.f	/^  210 CONTINUE$/;"	l	program:DBLAT2	file:
210	blas/testing/dblat3.f	/^  210 CONTINUE$/;"	l	program:DBLAT3	file:
210	blas/testing/sblat2.f	/^  210 CONTINUE$/;"	l	program:SBLAT2	file:
210	blas/testing/sblat3.f	/^  210 CONTINUE$/;"	l	program:SBLAT3	file:
210	blas/testing/zblat2.f	/^  210 CONTINUE$/;"	l	program:ZBLAT2	file:
210	blas/testing/zblat3.f	/^  210    CONTINUE$/;"	l	subroutine:ZMMCH	file:
210	blas/testing/zblat3.f	/^  210 CONTINUE$/;"	l	program:ZBLAT3	file:
210	lapack/clarfb.f	/^  210          CONTINUE$/;"	l	subroutine:CLARFB	file:
210	lapack/dlarfb.f	/^  210          CONTINUE$/;"	l	subroutine:DLARFB	file:
210	lapack/slarfb.f	/^  210          CONTINUE$/;"	l	subroutine:SLARFB	file:
210	lapack/zlarfb.f	/^  210          CONTINUE$/;"	l	subroutine:ZLARFB	file:
220	blas/testing/cblat2.f	/^  220 CONTINUE$/;"	l	program:CBLAT2	file:
220	blas/testing/cblat3.f	/^  220 CONTINUE$/;"	l	program:CBLAT3	file:
220	blas/testing/cblat3.f	/^  220 CONTINUE$/;"	l	subroutine:CMMCH	file:
220	blas/testing/dblat2.f	/^  220 CONTINUE$/;"	l	program:DBLAT2	file:
220	blas/testing/dblat3.f	/^  220 CONTINUE$/;"	l	program:DBLAT3	file:
220	blas/testing/sblat2.f	/^  220 CONTINUE$/;"	l	program:SBLAT2	file:
220	blas/testing/sblat3.f	/^  220 CONTINUE$/;"	l	program:SBLAT3	file:
220	blas/testing/zblat2.f	/^  220 CONTINUE$/;"	l	program:ZBLAT2	file:
220	blas/testing/zblat3.f	/^  220 CONTINUE$/;"	l	program:ZBLAT3	file:
220	blas/testing/zblat3.f	/^  220 CONTINUE$/;"	l	subroutine:ZMMCH	file:
220	lapack/clarfb.f	/^  220          CONTINUE$/;"	l	subroutine:CLARFB	file:
220	lapack/dlarfb.f	/^  220          CONTINUE$/;"	l	subroutine:DLARFB	file:
220	lapack/slarfb.f	/^  220          CONTINUE$/;"	l	subroutine:SLARFB	file:
220	lapack/zlarfb.f	/^  220          CONTINUE$/;"	l	subroutine:ZLARFB	file:
230	blas/testing/cblat2.f	/^  230 CONTINUE$/;"	l	program:CBLAT2	file:
230	blas/testing/cblat3.f	/^  230 CONTINUE$/;"	l	program:CBLAT3	file:
230	blas/testing/cblat3.f	/^  230 FATAL = .TRUE.$/;"	l	subroutine:CMMCH	file:
230	blas/testing/dblat2.f	/^  230 CONTINUE$/;"	l	program:DBLAT2	file:
230	blas/testing/dblat3.f	/^  230 CONTINUE$/;"	l	program:DBLAT3	file:
230	blas/testing/sblat2.f	/^  230 CONTINUE$/;"	l	program:SBLAT2	file:
230	blas/testing/sblat3.f	/^  230 CONTINUE$/;"	l	program:SBLAT3	file:
230	blas/testing/zblat2.f	/^  230 CONTINUE$/;"	l	program:ZBLAT2	file:
230	blas/testing/zblat3.f	/^  230 CONTINUE$/;"	l	program:ZBLAT3	file:
230	blas/testing/zblat3.f	/^  230 FATAL = .TRUE.$/;"	l	subroutine:ZMMCH	file:
230	lapack/clarfb.f	/^  230             CONTINUE$/;"	l	subroutine:CLARFB	file:
230	lapack/dlarfb.f	/^  230             CONTINUE$/;"	l	subroutine:DLARFB	file:
230	lapack/slarfb.f	/^  230             CONTINUE$/;"	l	subroutine:SLARFB	file:
230	lapack/zlarfb.f	/^  230             CONTINUE$/;"	l	subroutine:ZLARFB	file:
240	blas/testing/cblat2.f	/^  240 CONTINUE$/;"	l	program:CBLAT2	file:
240	blas/testing/cblat3.f	/^  240 CONTINUE$/;"	l	subroutine:CMMCH	file:
240	blas/testing/dblat2.f	/^  240 CONTINUE$/;"	l	program:DBLAT2	file:
240	blas/testing/sblat2.f	/^  240 CONTINUE$/;"	l	program:SBLAT2	file:
240	blas/testing/zblat2.f	/^  240 CONTINUE$/;"	l	program:ZBLAT2	file:
240	blas/testing/zblat3.f	/^  240 CONTINUE$/;"	l	subroutine:ZMMCH	file:
240	lapack/clarfb.f	/^  240          CONTINUE$/;"	l	subroutine:CLARFB	file:
240	lapack/dlarfb.f	/^  240          CONTINUE$/;"	l	subroutine:DLARFB	file:
240	lapack/slarfb.f	/^  240          CONTINUE$/;"	l	subroutine:SLARFB	file:
240	lapack/zlarfb.f	/^  240          CONTINUE$/;"	l	subroutine:ZLARFB	file:
250	blas/testing/cblat3.f	/^  250 CONTINUE$/;"	l	subroutine:CMMCH	file:
250	blas/testing/zblat3.f	/^  250 CONTINUE$/;"	l	subroutine:ZMMCH	file:
30	blas/testing/cblat2.f	/^   30                         CONTINUE$/;"	l	subroutine:CCHK1	file:
30	blas/testing/cblat2.f	/^   30                      CONTINUE$/;"	l	subroutine:CCHK2	file:
30	blas/testing/cblat2.f	/^   30                   CONTINUE$/;"	l	subroutine:CCHK3	file:
30	blas/testing/cblat2.f	/^   30                CONTINUE$/;"	l	subroutine:CCHK4	file:
30	blas/testing/cblat2.f	/^   30                CONTINUE$/;"	l	subroutine:CCHK6	file:
30	blas/testing/cblat2.f	/^   30             CONTINUE$/;"	l	subroutine:CCHK5	file:
30	blas/testing/cblat2.f	/^   30       CONTINUE$/;"	l	function:LCERES	file:
30	blas/testing/cblat2.f	/^   30       CONTINUE$/;"	l	subroutine:CMAKE	file:
30	blas/testing/cblat2.f	/^   30       CONTINUE$/;"	l	subroutine:CMVCH	file:
30	blas/testing/cblat2.f	/^   30 CONTINUE$/;"	l	program:CBLAT2	file:
30	blas/testing/cblat2.f	/^   30 INFOT = 1$/;"	l	subroutine:CCHKE	file:
30	blas/testing/cblat2.f	/^   30 RETURN$/;"	l	function:LCE	file:
30	blas/testing/cblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:CCHK1	file:
30	blas/testing/cblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:CCHK3	file:
30	blas/testing/cblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:CCHK2	file:
30	blas/testing/cblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:CCHK4	file:
30	blas/testing/cblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:CCHK5	file:
30	blas/testing/cblat3.f	/^   30       CONTINUE$/;"	l	function:LCERES	file:
30	blas/testing/cblat3.f	/^   30       CONTINUE$/;"	l	subroutine:CMAKE	file:
30	blas/testing/cblat3.f	/^   30       CONTINUE$/;"	l	subroutine:CMMCH	file:
30	blas/testing/cblat3.f	/^   30 INFOT = 1$/;"	l	subroutine:CCHKE	file:
30	blas/testing/cblat3.f	/^   30 READ( NIN, FMT = 9988, END = 60 )SNAMET, LTESTT$/;"	l	program:CBLAT3	file:
30	blas/testing/cblat3.f	/^   30 RETURN$/;"	l	function:LCE	file:
30	blas/testing/dblat2.f	/^   30                         CONTINUE$/;"	l	subroutine:DCHK1	file:
30	blas/testing/dblat2.f	/^   30                      CONTINUE$/;"	l	subroutine:DCHK2	file:
30	blas/testing/dblat2.f	/^   30                   CONTINUE$/;"	l	subroutine:DCHK3	file:
30	blas/testing/dblat2.f	/^   30                CONTINUE$/;"	l	subroutine:DCHK4	file:
30	blas/testing/dblat2.f	/^   30                CONTINUE$/;"	l	subroutine:DCHK6	file:
30	blas/testing/dblat2.f	/^   30             CONTINUE$/;"	l	subroutine:DCHK5	file:
30	blas/testing/dblat2.f	/^   30       CONTINUE$/;"	l	function:LDERES	file:
30	blas/testing/dblat2.f	/^   30       CONTINUE$/;"	l	subroutine:DMAKE	file:
30	blas/testing/dblat2.f	/^   30 CONTINUE$/;"	l	program:DBLAT2	file:
30	blas/testing/dblat2.f	/^   30 CONTINUE$/;"	l	subroutine:DMVCH	file:
30	blas/testing/dblat2.f	/^   30 INFOT = 1$/;"	l	subroutine:DCHKE	file:
30	blas/testing/dblat2.f	/^   30 RETURN$/;"	l	function:LDE	file:
30	blas/testing/dblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:DCHK1	file:
30	blas/testing/dblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:DCHK3	file:
30	blas/testing/dblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:DCHK2	file:
30	blas/testing/dblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:DCHK4	file:
30	blas/testing/dblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:DCHK5	file:
30	blas/testing/dblat3.f	/^   30       CONTINUE$/;"	l	function:LDERES	file:
30	blas/testing/dblat3.f	/^   30       CONTINUE$/;"	l	subroutine:DMAKE	file:
30	blas/testing/dblat3.f	/^   30       CONTINUE$/;"	l	subroutine:DMMCH	file:
30	blas/testing/dblat3.f	/^   30 INFOT = 1$/;"	l	subroutine:DCHKE	file:
30	blas/testing/dblat3.f	/^   30 READ( NIN, FMT = 9988, END = 60 )SNAMET, LTESTT$/;"	l	program:DBLAT3	file:
30	blas/testing/dblat3.f	/^   30 RETURN$/;"	l	function:LDE	file:
30	blas/testing/sblat2.f	/^   30                         CONTINUE$/;"	l	subroutine:SCHK1	file:
30	blas/testing/sblat2.f	/^   30                      CONTINUE$/;"	l	subroutine:SCHK2	file:
30	blas/testing/sblat2.f	/^   30                   CONTINUE$/;"	l	subroutine:SCHK3	file:
30	blas/testing/sblat2.f	/^   30                CONTINUE$/;"	l	subroutine:SCHK4	file:
30	blas/testing/sblat2.f	/^   30                CONTINUE$/;"	l	subroutine:SCHK6	file:
30	blas/testing/sblat2.f	/^   30             CONTINUE$/;"	l	subroutine:SCHK5	file:
30	blas/testing/sblat2.f	/^   30       CONTINUE$/;"	l	function:LSERES	file:
30	blas/testing/sblat2.f	/^   30       CONTINUE$/;"	l	subroutine:SMAKE	file:
30	blas/testing/sblat2.f	/^   30 CONTINUE$/;"	l	program:SBLAT2	file:
30	blas/testing/sblat2.f	/^   30 CONTINUE$/;"	l	subroutine:SMVCH	file:
30	blas/testing/sblat2.f	/^   30 INFOT = 1$/;"	l	subroutine:SCHKE	file:
30	blas/testing/sblat2.f	/^   30 RETURN$/;"	l	function:LSE	file:
30	blas/testing/sblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:SCHK1	file:
30	blas/testing/sblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:SCHK3	file:
30	blas/testing/sblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:SCHK2	file:
30	blas/testing/sblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:SCHK4	file:
30	blas/testing/sblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:SCHK5	file:
30	blas/testing/sblat3.f	/^   30       CONTINUE$/;"	l	function:LSERES	file:
30	blas/testing/sblat3.f	/^   30       CONTINUE$/;"	l	subroutine:SMAKE	file:
30	blas/testing/sblat3.f	/^   30       CONTINUE$/;"	l	subroutine:SMMCH	file:
30	blas/testing/sblat3.f	/^   30 INFOT = 1$/;"	l	subroutine:SCHKE	file:
30	blas/testing/sblat3.f	/^   30 READ( NIN, FMT = 9988, END = 60 )SNAMET, LTESTT$/;"	l	program:SBLAT3	file:
30	blas/testing/sblat3.f	/^   30 RETURN$/;"	l	function:LSE	file:
30	blas/testing/zblat2.f	/^   30                         CONTINUE$/;"	l	subroutine:ZCHK1	file:
30	blas/testing/zblat2.f	/^   30                      CONTINUE$/;"	l	subroutine:ZCHK2	file:
30	blas/testing/zblat2.f	/^   30                   CONTINUE$/;"	l	subroutine:ZCHK3	file:
30	blas/testing/zblat2.f	/^   30                CONTINUE$/;"	l	subroutine:ZCHK4	file:
30	blas/testing/zblat2.f	/^   30                CONTINUE$/;"	l	subroutine:ZCHK6	file:
30	blas/testing/zblat2.f	/^   30             CONTINUE$/;"	l	subroutine:ZCHK5	file:
30	blas/testing/zblat2.f	/^   30       CONTINUE$/;"	l	function:LZERES	file:
30	blas/testing/zblat2.f	/^   30       CONTINUE$/;"	l	subroutine:ZMAKE	file:
30	blas/testing/zblat2.f	/^   30       CONTINUE$/;"	l	subroutine:ZMVCH	file:
30	blas/testing/zblat2.f	/^   30 CONTINUE$/;"	l	program:ZBLAT2	file:
30	blas/testing/zblat2.f	/^   30 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
30	blas/testing/zblat2.f	/^   30 RETURN$/;"	l	function:LZE	file:
30	blas/testing/zblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:ZCHK1	file:
30	blas/testing/zblat3.f	/^   30                      CONTINUE$/;"	l	subroutine:ZCHK3	file:
30	blas/testing/zblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:ZCHK2	file:
30	blas/testing/zblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:ZCHK4	file:
30	blas/testing/zblat3.f	/^   30                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
30	blas/testing/zblat3.f	/^   30       CONTINUE$/;"	l	function:LZERES	file:
30	blas/testing/zblat3.f	/^   30       CONTINUE$/;"	l	subroutine:ZMAKE	file:
30	blas/testing/zblat3.f	/^   30       CONTINUE$/;"	l	subroutine:ZMMCH	file:
30	blas/testing/zblat3.f	/^   30 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
30	blas/testing/zblat3.f	/^   30 READ( NIN, FMT = 9988, END = 60 )SNAMET, LTESTT$/;"	l	program:ZBLAT3	file:
30	blas/testing/zblat3.f	/^   30 RETURN$/;"	l	function:LZE	file:
30	lapack/clarfb.f	/^   30          CONTINUE$/;"	l	subroutine:CLARFB	file:
30	lapack/dlarfb.f	/^   30          CONTINUE$/;"	l	subroutine:DLARFB	file:
30	lapack/slarfb.f	/^   30          CONTINUE$/;"	l	subroutine:SLARFB	file:
30	lapack/zlarfb.f	/^   30          CONTINUE$/;"	l	subroutine:ZLARFB	file:
40	blas/testing/cblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK1	file:
40	blas/testing/cblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK2	file:
40	blas/testing/cblat1.f	/^   40 CONTINUE$/;"	l	subroutine:ITEST1	file:
40	blas/testing/cblat1.f	/^   40 CONTINUE$/;"	l	subroutine:STEST	file:
40	blas/testing/cblat2.f	/^   40                         CONTINUE$/;"	l	subroutine:CCHK1	file:
40	blas/testing/cblat2.f	/^   40                      CONTINUE$/;"	l	subroutine:CCHK2	file:
40	blas/testing/cblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:CCHK3	file:
40	blas/testing/cblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:CCHK5	file:
40	blas/testing/cblat2.f	/^   40                CONTINUE$/;"	l	subroutine:CCHK4	file:
40	blas/testing/cblat2.f	/^   40                CONTINUE$/;"	l	subroutine:CCHK6	file:
40	blas/testing/cblat2.f	/^   40       CONTINUE$/;"	l	function:LCERES	file:
40	blas/testing/cblat2.f	/^   40       CONTINUE$/;"	l	subroutine:CMAKE	file:
40	blas/testing/cblat2.f	/^   40 CONTINUE$/;"	l	program:CBLAT2	file:
40	blas/testing/cblat2.f	/^   40 CONTINUE$/;"	l	subroutine:CMVCH	file:
40	blas/testing/cblat2.f	/^   40 INFOT = 1$/;"	l	subroutine:CCHKE	file:
40	blas/testing/cblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:CCHK1	file:
40	blas/testing/cblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:CCHK3	file:
40	blas/testing/cblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:CCHK4	file:
40	blas/testing/cblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:CCHK2	file:
40	blas/testing/cblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:CCHK5	file:
40	blas/testing/cblat3.f	/^   40             CONTINUE$/;"	l	subroutine:CMMCH	file:
40	blas/testing/cblat3.f	/^   40       CONTINUE$/;"	l	function:LCERES	file:
40	blas/testing/cblat3.f	/^   40       CONTINUE$/;"	l	subroutine:CMAKE	file:
40	blas/testing/cblat3.f	/^   40 CONTINUE$/;"	l	program:CBLAT3	file:
40	blas/testing/cblat3.f	/^   40 INFOT = 1$/;"	l	subroutine:CCHKE	file:
40	blas/testing/dblat1.f	/^   40          CONTINUE$/;"	l	subroutine:CHECK1	file:
40	blas/testing/dblat1.f	/^   40          CONTINUE$/;"	l	subroutine:CHECK2	file:
40	blas/testing/dblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK3	file:
40	blas/testing/dblat1.f	/^   40 CONTINUE$/;"	l	subroutine:ITEST1	file:
40	blas/testing/dblat1.f	/^   40 CONTINUE$/;"	l	subroutine:STEST	file:
40	blas/testing/dblat1.f	/^   40 CONTINUE$/;"	l	subroutine:TESTDSDOT	file:
40	blas/testing/dblat1.f	/^   40 RETURN$/;"	l	subroutine:CHECK0	file:
40	blas/testing/dblat2.f	/^   40                         CONTINUE$/;"	l	subroutine:DCHK1	file:
40	blas/testing/dblat2.f	/^   40                      CONTINUE$/;"	l	subroutine:DCHK2	file:
40	blas/testing/dblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:DCHK3	file:
40	blas/testing/dblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:DCHK5	file:
40	blas/testing/dblat2.f	/^   40                CONTINUE$/;"	l	subroutine:DCHK4	file:
40	blas/testing/dblat2.f	/^   40                CONTINUE$/;"	l	subroutine:DCHK6	file:
40	blas/testing/dblat2.f	/^   40       CONTINUE$/;"	l	function:LDERES	file:
40	blas/testing/dblat2.f	/^   40       CONTINUE$/;"	l	subroutine:DMAKE	file:
40	blas/testing/dblat2.f	/^   40 CONTINUE$/;"	l	program:DBLAT2	file:
40	blas/testing/dblat2.f	/^   40 CONTINUE$/;"	l	subroutine:DMVCH	file:
40	blas/testing/dblat2.f	/^   40 INFOT = 1$/;"	l	subroutine:DCHKE	file:
40	blas/testing/dblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:DCHK1	file:
40	blas/testing/dblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:DCHK3	file:
40	blas/testing/dblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:DCHK4	file:
40	blas/testing/dblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:DCHK2	file:
40	blas/testing/dblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:DCHK5	file:
40	blas/testing/dblat3.f	/^   40          CONTINUE$/;"	l	subroutine:DMMCH	file:
40	blas/testing/dblat3.f	/^   40       CONTINUE$/;"	l	function:LDERES	file:
40	blas/testing/dblat3.f	/^   40       CONTINUE$/;"	l	subroutine:DMAKE	file:
40	blas/testing/dblat3.f	/^   40 CONTINUE$/;"	l	program:DBLAT3	file:
40	blas/testing/dblat3.f	/^   40 INFOT = 1$/;"	l	subroutine:DCHKE	file:
40	blas/testing/sblat1.f	/^   40          CONTINUE$/;"	l	subroutine:CHECK1	file:
40	blas/testing/sblat1.f	/^   40          CONTINUE$/;"	l	subroutine:CHECK2	file:
40	blas/testing/sblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK3	file:
40	blas/testing/sblat1.f	/^   40 CONTINUE$/;"	l	subroutine:ITEST1	file:
40	blas/testing/sblat1.f	/^   40 CONTINUE$/;"	l	subroutine:STEST	file:
40	blas/testing/sblat1.f	/^   40 RETURN$/;"	l	subroutine:CHECK0	file:
40	blas/testing/sblat2.f	/^   40                         CONTINUE$/;"	l	subroutine:SCHK1	file:
40	blas/testing/sblat2.f	/^   40                      CONTINUE$/;"	l	subroutine:SCHK2	file:
40	blas/testing/sblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:SCHK3	file:
40	blas/testing/sblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:SCHK5	file:
40	blas/testing/sblat2.f	/^   40                CONTINUE$/;"	l	subroutine:SCHK4	file:
40	blas/testing/sblat2.f	/^   40                CONTINUE$/;"	l	subroutine:SCHK6	file:
40	blas/testing/sblat2.f	/^   40       CONTINUE$/;"	l	function:LSERES	file:
40	blas/testing/sblat2.f	/^   40       CONTINUE$/;"	l	subroutine:SMAKE	file:
40	blas/testing/sblat2.f	/^   40 CONTINUE$/;"	l	program:SBLAT2	file:
40	blas/testing/sblat2.f	/^   40 CONTINUE$/;"	l	subroutine:SMVCH	file:
40	blas/testing/sblat2.f	/^   40 INFOT = 1$/;"	l	subroutine:SCHKE	file:
40	blas/testing/sblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:SCHK1	file:
40	blas/testing/sblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:SCHK3	file:
40	blas/testing/sblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:SCHK4	file:
40	blas/testing/sblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:SCHK2	file:
40	blas/testing/sblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:SCHK5	file:
40	blas/testing/sblat3.f	/^   40          CONTINUE$/;"	l	subroutine:SMMCH	file:
40	blas/testing/sblat3.f	/^   40       CONTINUE$/;"	l	function:LSERES	file:
40	blas/testing/sblat3.f	/^   40       CONTINUE$/;"	l	subroutine:SMAKE	file:
40	blas/testing/sblat3.f	/^   40 CONTINUE$/;"	l	program:SBLAT3	file:
40	blas/testing/sblat3.f	/^   40 INFOT = 1$/;"	l	subroutine:SCHKE	file:
40	blas/testing/zblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK1	file:
40	blas/testing/zblat1.f	/^   40    CONTINUE$/;"	l	subroutine:CHECK2	file:
40	blas/testing/zblat1.f	/^   40 CONTINUE$/;"	l	subroutine:ITEST1	file:
40	blas/testing/zblat1.f	/^   40 CONTINUE$/;"	l	subroutine:STEST	file:
40	blas/testing/zblat2.f	/^   40                         CONTINUE$/;"	l	subroutine:ZCHK1	file:
40	blas/testing/zblat2.f	/^   40                      CONTINUE$/;"	l	subroutine:ZCHK2	file:
40	blas/testing/zblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:ZCHK3	file:
40	blas/testing/zblat2.f	/^   40                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
40	blas/testing/zblat2.f	/^   40                CONTINUE$/;"	l	subroutine:ZCHK4	file:
40	blas/testing/zblat2.f	/^   40                CONTINUE$/;"	l	subroutine:ZCHK6	file:
40	blas/testing/zblat2.f	/^   40       CONTINUE$/;"	l	function:LZERES	file:
40	blas/testing/zblat2.f	/^   40       CONTINUE$/;"	l	subroutine:ZMAKE	file:
40	blas/testing/zblat2.f	/^   40 CONTINUE$/;"	l	program:ZBLAT2	file:
40	blas/testing/zblat2.f	/^   40 CONTINUE$/;"	l	subroutine:ZMVCH	file:
40	blas/testing/zblat2.f	/^   40 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
40	blas/testing/zblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:ZCHK1	file:
40	blas/testing/zblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:ZCHK3	file:
40	blas/testing/zblat3.f	/^   40                      CONTINUE$/;"	l	subroutine:ZCHK4	file:
40	blas/testing/zblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:ZCHK2	file:
40	blas/testing/zblat3.f	/^   40                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
40	blas/testing/zblat3.f	/^   40             CONTINUE$/;"	l	subroutine:ZMMCH	file:
40	blas/testing/zblat3.f	/^   40       CONTINUE$/;"	l	function:LZERES	file:
40	blas/testing/zblat3.f	/^   40       CONTINUE$/;"	l	subroutine:ZMAKE	file:
40	blas/testing/zblat3.f	/^   40 CONTINUE$/;"	l	program:ZBLAT3	file:
40	blas/testing/zblat3.f	/^   40 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
40	lapack/clarfb.f	/^   40          CONTINUE$/;"	l	subroutine:CLARFB	file:
40	lapack/dlarfb.f	/^   40          CONTINUE$/;"	l	subroutine:DLARFB	file:
40	lapack/slarfb.f	/^   40          CONTINUE$/;"	l	subroutine:SLARFB	file:
40	lapack/zlarfb.f	/^   40          CONTINUE$/;"	l	subroutine:ZLARFB	file:
50	blas/testing/cblat2.f	/^   50                         CONTINUE$/;"	l	subroutine:CCHK3	file:
50	blas/testing/cblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:CCHK1	file:
50	blas/testing/cblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:CCHK4	file:
50	blas/testing/cblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:CCHK6	file:
50	blas/testing/cblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:CCHK2	file:
50	blas/testing/cblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:CCHK5	file:
50	blas/testing/cblat2.f	/^   50    CONTINUE$/;"	l	function:LCERES	file:
50	blas/testing/cblat2.f	/^   50    CONTINUE$/;"	l	subroutine:CMAKE	file:
50	blas/testing/cblat2.f	/^   50 CONTINUE$/;"	l	subroutine:CMVCH	file:
50	blas/testing/cblat2.f	/^   50 INFOT = 1$/;"	l	subroutine:CCHKE	file:
50	blas/testing/cblat2.f	/^   50 READ( NIN, FMT = 9984, END = 80 )SNAMET, LTESTT$/;"	l	program:CBLAT2	file:
50	blas/testing/cblat3.f	/^   50                            CONTINUE$/;"	l	subroutine:CCHK5	file:
50	blas/testing/cblat3.f	/^   50                      CONTINUE$/;"	l	subroutine:CCHK3	file:
50	blas/testing/cblat3.f	/^   50                   CONTINUE$/;"	l	subroutine:CCHK1	file:
50	blas/testing/cblat3.f	/^   50                CONTINUE$/;"	l	subroutine:CCHK2	file:
50	blas/testing/cblat3.f	/^   50                CONTINUE$/;"	l	subroutine:CCHK4	file:
50	blas/testing/cblat3.f	/^   50          CONTINUE$/;"	l	subroutine:CMMCH	file:
50	blas/testing/cblat3.f	/^   50    CONTINUE$/;"	l	function:LCERES	file:
50	blas/testing/cblat3.f	/^   50    CONTINUE$/;"	l	subroutine:CMAKE	file:
50	blas/testing/cblat3.f	/^   50 INFOT = 1$/;"	l	subroutine:CCHKE	file:
50	blas/testing/cblat3.f	/^   50 LTEST( I ) = LTESTT$/;"	l	program:CBLAT3	file:
50	blas/testing/dblat2.f	/^   50                         CONTINUE$/;"	l	subroutine:DCHK3	file:
50	blas/testing/dblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:DCHK1	file:
50	blas/testing/dblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:DCHK4	file:
50	blas/testing/dblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:DCHK6	file:
50	blas/testing/dblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:DCHK2	file:
50	blas/testing/dblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:DCHK5	file:
50	blas/testing/dblat2.f	/^   50    CONTINUE$/;"	l	function:LDERES	file:
50	blas/testing/dblat2.f	/^   50    CONTINUE$/;"	l	subroutine:DMAKE	file:
50	blas/testing/dblat2.f	/^   50 FATAL = .TRUE.$/;"	l	subroutine:DMVCH	file:
50	blas/testing/dblat2.f	/^   50 INFOT = 1$/;"	l	subroutine:DCHKE	file:
50	blas/testing/dblat2.f	/^   50 READ( NIN, FMT = 9984, END = 80 )SNAMET, LTESTT$/;"	l	program:DBLAT2	file:
50	blas/testing/dblat3.f	/^   50                            CONTINUE$/;"	l	subroutine:DCHK5	file:
50	blas/testing/dblat3.f	/^   50                      CONTINUE$/;"	l	subroutine:DCHK3	file:
50	blas/testing/dblat3.f	/^   50                   CONTINUE$/;"	l	subroutine:DCHK1	file:
50	blas/testing/dblat3.f	/^   50                CONTINUE$/;"	l	subroutine:DCHK2	file:
50	blas/testing/dblat3.f	/^   50                CONTINUE$/;"	l	subroutine:DCHK4	file:
50	blas/testing/dblat3.f	/^   50       CONTINUE$/;"	l	subroutine:DMMCH	file:
50	blas/testing/dblat3.f	/^   50    CONTINUE$/;"	l	function:LDERES	file:
50	blas/testing/dblat3.f	/^   50    CONTINUE$/;"	l	subroutine:DMAKE	file:
50	blas/testing/dblat3.f	/^   50 INFOT = 1$/;"	l	subroutine:DCHKE	file:
50	blas/testing/dblat3.f	/^   50 LTEST( I ) = LTESTT$/;"	l	program:DBLAT3	file:
50	blas/testing/sblat2.f	/^   50                         CONTINUE$/;"	l	subroutine:SCHK3	file:
50	blas/testing/sblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:SCHK1	file:
50	blas/testing/sblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:SCHK4	file:
50	blas/testing/sblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:SCHK6	file:
50	blas/testing/sblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:SCHK2	file:
50	blas/testing/sblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:SCHK5	file:
50	blas/testing/sblat2.f	/^   50    CONTINUE$/;"	l	function:LSERES	file:
50	blas/testing/sblat2.f	/^   50    CONTINUE$/;"	l	subroutine:SMAKE	file:
50	blas/testing/sblat2.f	/^   50 FATAL = .TRUE.$/;"	l	subroutine:SMVCH	file:
50	blas/testing/sblat2.f	/^   50 INFOT = 1$/;"	l	subroutine:SCHKE	file:
50	blas/testing/sblat2.f	/^   50 READ( NIN, FMT = 9984, END = 80 )SNAMET, LTESTT$/;"	l	program:SBLAT2	file:
50	blas/testing/sblat3.f	/^   50                            CONTINUE$/;"	l	subroutine:SCHK5	file:
50	blas/testing/sblat3.f	/^   50                      CONTINUE$/;"	l	subroutine:SCHK3	file:
50	blas/testing/sblat3.f	/^   50                   CONTINUE$/;"	l	subroutine:SCHK1	file:
50	blas/testing/sblat3.f	/^   50                CONTINUE$/;"	l	subroutine:SCHK2	file:
50	blas/testing/sblat3.f	/^   50                CONTINUE$/;"	l	subroutine:SCHK4	file:
50	blas/testing/sblat3.f	/^   50       CONTINUE$/;"	l	subroutine:SMMCH	file:
50	blas/testing/sblat3.f	/^   50    CONTINUE$/;"	l	function:LSERES	file:
50	blas/testing/sblat3.f	/^   50    CONTINUE$/;"	l	subroutine:SMAKE	file:
50	blas/testing/sblat3.f	/^   50 INFOT = 1$/;"	l	subroutine:SCHKE	file:
50	blas/testing/sblat3.f	/^   50 LTEST( I ) = LTESTT$/;"	l	program:SBLAT3	file:
50	blas/testing/zblat2.f	/^   50                         CONTINUE$/;"	l	subroutine:ZCHK3	file:
50	blas/testing/zblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:ZCHK1	file:
50	blas/testing/zblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:ZCHK4	file:
50	blas/testing/zblat2.f	/^   50                      CONTINUE$/;"	l	subroutine:ZCHK6	file:
50	blas/testing/zblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:ZCHK2	file:
50	blas/testing/zblat2.f	/^   50                   CONTINUE$/;"	l	subroutine:ZCHK5	file:
50	blas/testing/zblat2.f	/^   50    CONTINUE$/;"	l	function:LZERES	file:
50	blas/testing/zblat2.f	/^   50    CONTINUE$/;"	l	subroutine:ZMAKE	file:
50	blas/testing/zblat2.f	/^   50 CONTINUE$/;"	l	subroutine:ZMVCH	file:
50	blas/testing/zblat2.f	/^   50 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
50	blas/testing/zblat2.f	/^   50 READ( NIN, FMT = 9984, END = 80 )SNAMET, LTESTT$/;"	l	program:ZBLAT2	file:
50	blas/testing/zblat3.f	/^   50                            CONTINUE$/;"	l	subroutine:ZCHK5	file:
50	blas/testing/zblat3.f	/^   50                      CONTINUE$/;"	l	subroutine:ZCHK3	file:
50	blas/testing/zblat3.f	/^   50                   CONTINUE$/;"	l	subroutine:ZCHK1	file:
50	blas/testing/zblat3.f	/^   50                CONTINUE$/;"	l	subroutine:ZCHK2	file:
50	blas/testing/zblat3.f	/^   50                CONTINUE$/;"	l	subroutine:ZCHK4	file:
50	blas/testing/zblat3.f	/^   50          CONTINUE$/;"	l	subroutine:ZMMCH	file:
50	blas/testing/zblat3.f	/^   50    CONTINUE$/;"	l	function:LZERES	file:
50	blas/testing/zblat3.f	/^   50    CONTINUE$/;"	l	subroutine:ZMAKE	file:
50	blas/testing/zblat3.f	/^   50 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
50	blas/testing/zblat3.f	/^   50 LTEST( I ) = LTESTT$/;"	l	program:ZBLAT3	file:
50	lapack/clarfb.f	/^   50             CONTINUE$/;"	l	subroutine:CLARFB	file:
50	lapack/dlarfb.f	/^   50             CONTINUE$/;"	l	subroutine:DLARFB	file:
50	lapack/slarfb.f	/^   50             CONTINUE$/;"	l	subroutine:SLARFB	file:
50	lapack/zlarfb.f	/^   50             CONTINUE$/;"	l	subroutine:ZLARFB	file:
60	blas/testing/cblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK1	file:
60	blas/testing/cblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK2	file:
60	blas/testing/cblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:CCHK4	file:
60	blas/testing/cblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:CCHK6	file:
60	blas/testing/cblat2.f	/^   60                   CONTINUE$/;"	l	subroutine:CCHK1	file:
60	blas/testing/cblat2.f	/^   60                CONTINUE$/;"	l	subroutine:CCHK2	file:
60	blas/testing/cblat2.f	/^   60                CONTINUE$/;"	l	subroutine:CCHK3	file:
60	blas/testing/cblat2.f	/^   60                CONTINUE$/;"	l	subroutine:CCHK5	file:
60	blas/testing/cblat2.f	/^   60       CONTINUE$/;"	l	subroutine:CMAKE	file:
60	blas/testing/cblat2.f	/^   60 CONTINUE$/;"	l	program:CBLAT2	file:
60	blas/testing/cblat2.f	/^   60 FATAL = .TRUE.$/;"	l	subroutine:CMVCH	file:
60	blas/testing/cblat2.f	/^   60 INFOT = 1$/;"	l	subroutine:CCHKE	file:
60	blas/testing/cblat3.f	/^   60                               CONTINUE$/;"	l	subroutine:CCHK3	file:
60	blas/testing/cblat3.f	/^   60                            CONTINUE$/;"	l	subroutine:CCHK5	file:
60	blas/testing/cblat3.f	/^   60                CONTINUE$/;"	l	subroutine:CCHK1	file:
60	blas/testing/cblat3.f	/^   60             CONTINUE$/;"	l	subroutine:CCHK2	file:
60	blas/testing/cblat3.f	/^   60             CONTINUE$/;"	l	subroutine:CCHK4	file:
60	blas/testing/cblat3.f	/^   60             CONTINUE$/;"	l	subroutine:CMMCH	file:
60	blas/testing/cblat3.f	/^   60       CONTINUE$/;"	l	subroutine:CMAKE	file:
60	blas/testing/cblat3.f	/^   60 CONTINUE$/;"	l	program:CBLAT3	file:
60	blas/testing/cblat3.f	/^   60 INFOT = 1$/;"	l	subroutine:CCHKE	file:
60	blas/testing/dblat1.f	/^   60          CONTINUE$/;"	l	subroutine:CHECK2	file:
60	blas/testing/dblat1.f	/^   60    CONTINUE$/;"	l	subroutine:CHECK1	file:
60	blas/testing/dblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK3	file:
60	blas/testing/dblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:DCHK4	file:
60	blas/testing/dblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:DCHK6	file:
60	blas/testing/dblat2.f	/^   60                   CONTINUE$/;"	l	subroutine:DCHK1	file:
60	blas/testing/dblat2.f	/^   60                CONTINUE$/;"	l	subroutine:DCHK2	file:
60	blas/testing/dblat2.f	/^   60                CONTINUE$/;"	l	subroutine:DCHK3	file:
60	blas/testing/dblat2.f	/^   60                CONTINUE$/;"	l	subroutine:DCHK5	file:
60	blas/testing/dblat2.f	/^   60       CONTINUE$/;"	l	subroutine:DMAKE	file:
60	blas/testing/dblat2.f	/^   60 CONTINUE$/;"	l	program:DBLAT2	file:
60	blas/testing/dblat2.f	/^   60 CONTINUE$/;"	l	subroutine:DMVCH	file:
60	blas/testing/dblat2.f	/^   60 INFOT = 1$/;"	l	subroutine:DCHKE	file:
60	blas/testing/dblat3.f	/^   60                               CONTINUE$/;"	l	subroutine:DCHK3	file:
60	blas/testing/dblat3.f	/^   60                            CONTINUE$/;"	l	subroutine:DCHK5	file:
60	blas/testing/dblat3.f	/^   60                CONTINUE$/;"	l	subroutine:DCHK1	file:
60	blas/testing/dblat3.f	/^   60             CONTINUE$/;"	l	subroutine:DCHK2	file:
60	blas/testing/dblat3.f	/^   60             CONTINUE$/;"	l	subroutine:DCHK4	file:
60	blas/testing/dblat3.f	/^   60          CONTINUE$/;"	l	subroutine:DMMCH	file:
60	blas/testing/dblat3.f	/^   60       CONTINUE$/;"	l	subroutine:DMAKE	file:
60	blas/testing/dblat3.f	/^   60 CONTINUE$/;"	l	program:DBLAT3	file:
60	blas/testing/dblat3.f	/^   60 INFOT = 1$/;"	l	subroutine:DCHKE	file:
60	blas/testing/sblat1.f	/^   60          CONTINUE$/;"	l	subroutine:CHECK2	file:
60	blas/testing/sblat1.f	/^   60    CONTINUE$/;"	l	subroutine:CHECK1	file:
60	blas/testing/sblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK3	file:
60	blas/testing/sblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:SCHK4	file:
60	blas/testing/sblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:SCHK6	file:
60	blas/testing/sblat2.f	/^   60                   CONTINUE$/;"	l	subroutine:SCHK1	file:
60	blas/testing/sblat2.f	/^   60                CONTINUE$/;"	l	subroutine:SCHK2	file:
60	blas/testing/sblat2.f	/^   60                CONTINUE$/;"	l	subroutine:SCHK3	file:
60	blas/testing/sblat2.f	/^   60                CONTINUE$/;"	l	subroutine:SCHK5	file:
60	blas/testing/sblat2.f	/^   60       CONTINUE$/;"	l	subroutine:SMAKE	file:
60	blas/testing/sblat2.f	/^   60 CONTINUE$/;"	l	program:SBLAT2	file:
60	blas/testing/sblat2.f	/^   60 CONTINUE$/;"	l	subroutine:SMVCH	file:
60	blas/testing/sblat2.f	/^   60 INFOT = 1$/;"	l	subroutine:SCHKE	file:
60	blas/testing/sblat3.f	/^   60                               CONTINUE$/;"	l	subroutine:SCHK3	file:
60	blas/testing/sblat3.f	/^   60                            CONTINUE$/;"	l	subroutine:SCHK5	file:
60	blas/testing/sblat3.f	/^   60                CONTINUE$/;"	l	subroutine:SCHK1	file:
60	blas/testing/sblat3.f	/^   60             CONTINUE$/;"	l	subroutine:SCHK2	file:
60	blas/testing/sblat3.f	/^   60             CONTINUE$/;"	l	subroutine:SCHK4	file:
60	blas/testing/sblat3.f	/^   60          CONTINUE$/;"	l	subroutine:SMMCH	file:
60	blas/testing/sblat3.f	/^   60       CONTINUE$/;"	l	subroutine:SMAKE	file:
60	blas/testing/sblat3.f	/^   60 CONTINUE$/;"	l	program:SBLAT3	file:
60	blas/testing/sblat3.f	/^   60 INFOT = 1$/;"	l	subroutine:SCHKE	file:
60	blas/testing/zblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK1	file:
60	blas/testing/zblat1.f	/^   60 CONTINUE$/;"	l	subroutine:CHECK2	file:
60	blas/testing/zblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:ZCHK4	file:
60	blas/testing/zblat2.f	/^   60                      CONTINUE$/;"	l	subroutine:ZCHK6	file:
60	blas/testing/zblat2.f	/^   60                   CONTINUE$/;"	l	subroutine:ZCHK1	file:
60	blas/testing/zblat2.f	/^   60                CONTINUE$/;"	l	subroutine:ZCHK2	file:
60	blas/testing/zblat2.f	/^   60                CONTINUE$/;"	l	subroutine:ZCHK3	file:
60	blas/testing/zblat2.f	/^   60                CONTINUE$/;"	l	subroutine:ZCHK5	file:
60	blas/testing/zblat2.f	/^   60       CONTINUE$/;"	l	subroutine:ZMAKE	file:
60	blas/testing/zblat2.f	/^   60 CONTINUE$/;"	l	program:ZBLAT2	file:
60	blas/testing/zblat2.f	/^   60 FATAL = .TRUE.$/;"	l	subroutine:ZMVCH	file:
60	blas/testing/zblat2.f	/^   60 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
60	blas/testing/zblat3.f	/^   60                               CONTINUE$/;"	l	subroutine:ZCHK3	file:
60	blas/testing/zblat3.f	/^   60                            CONTINUE$/;"	l	subroutine:ZCHK5	file:
60	blas/testing/zblat3.f	/^   60                CONTINUE$/;"	l	subroutine:ZCHK1	file:
60	blas/testing/zblat3.f	/^   60             CONTINUE$/;"	l	subroutine:ZCHK2	file:
60	blas/testing/zblat3.f	/^   60             CONTINUE$/;"	l	subroutine:ZCHK4	file:
60	blas/testing/zblat3.f	/^   60             CONTINUE$/;"	l	subroutine:ZMMCH	file:
60	blas/testing/zblat3.f	/^   60       CONTINUE$/;"	l	subroutine:ZMAKE	file:
60	blas/testing/zblat3.f	/^   60 CONTINUE$/;"	l	program:ZBLAT3	file:
60	blas/testing/zblat3.f	/^   60 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
60	lapack/clarfb.f	/^   60          CONTINUE$/;"	l	subroutine:CLARFB	file:
60	lapack/dlarfb.f	/^   60          CONTINUE$/;"	l	subroutine:DLARFB	file:
60	lapack/slarfb.f	/^   60          CONTINUE$/;"	l	subroutine:SLARFB	file:
60	lapack/zlarfb.f	/^   60          CONTINUE$/;"	l	subroutine:ZLARFB	file:
70	blas/testing/cblat2.f	/^   70                      CONTINUE$/;"	l	subroutine:CCHK6	file:
70	blas/testing/cblat2.f	/^   70                   CONTINUE$/;"	l	subroutine:CCHK4	file:
70	blas/testing/cblat2.f	/^   70                CONTINUE$/;"	l	subroutine:CCHK1	file:
70	blas/testing/cblat2.f	/^   70             CONTINUE$/;"	l	subroutine:CCHK2	file:
70	blas/testing/cblat2.f	/^   70             CONTINUE$/;"	l	subroutine:CCHK3	file:
70	blas/testing/cblat2.f	/^   70          CONTINUE$/;"	l	subroutine:CCHK5	file:
70	blas/testing/cblat2.f	/^   70       CONTINUE$/;"	l	subroutine:CMAKE	file:
70	blas/testing/cblat2.f	/^   70 CONTINUE$/;"	l	function:LCERES	file:
70	blas/testing/cblat2.f	/^   70 CONTINUE$/;"	l	subroutine:CMVCH	file:
70	blas/testing/cblat2.f	/^   70 INFOT = 1$/;"	l	subroutine:CCHKE	file:
70	blas/testing/cblat2.f	/^   70 LTEST( I ) = LTESTT$/;"	l	program:CBLAT2	file:
70	blas/testing/cblat3.f	/^   70                            CONTINUE$/;"	l	subroutine:CCHK3	file:
70	blas/testing/cblat3.f	/^   70                      CONTINUE$/;"	l	subroutine:CCHK5	file:
70	blas/testing/cblat3.f	/^   70             CONTINUE$/;"	l	subroutine:CCHK1	file:
70	blas/testing/cblat3.f	/^   70          CONTINUE$/;"	l	subroutine:CCHK2	file:
70	blas/testing/cblat3.f	/^   70          CONTINUE$/;"	l	subroutine:CCHK4	file:
70	blas/testing/cblat3.f	/^   70          CONTINUE$/;"	l	subroutine:CMMCH	file:
70	blas/testing/cblat3.f	/^   70       CONTINUE$/;"	l	subroutine:CMAKE	file:
70	blas/testing/cblat3.f	/^   70 CONTINUE$/;"	l	function:LCERES	file:
70	blas/testing/cblat3.f	/^   70 INFOT = 1$/;"	l	subroutine:CCHKE	file:
70	blas/testing/dblat2.f	/^   70                      CONTINUE$/;"	l	subroutine:DCHK6	file:
70	blas/testing/dblat2.f	/^   70                   CONTINUE$/;"	l	subroutine:DCHK4	file:
70	blas/testing/dblat2.f	/^   70                CONTINUE$/;"	l	subroutine:DCHK1	file:
70	blas/testing/dblat2.f	/^   70             CONTINUE$/;"	l	subroutine:DCHK2	file:
70	blas/testing/dblat2.f	/^   70             CONTINUE$/;"	l	subroutine:DCHK3	file:
70	blas/testing/dblat2.f	/^   70          CONTINUE$/;"	l	subroutine:DCHK5	file:
70	blas/testing/dblat2.f	/^   70       CONTINUE$/;"	l	subroutine:DMAKE	file:
70	blas/testing/dblat2.f	/^   70 CONTINUE$/;"	l	function:LDERES	file:
70	blas/testing/dblat2.f	/^   70 CONTINUE$/;"	l	subroutine:DMVCH	file:
70	blas/testing/dblat2.f	/^   70 INFOT = 1$/;"	l	subroutine:DCHKE	file:
70	blas/testing/dblat2.f	/^   70 LTEST( I ) = LTESTT$/;"	l	program:DBLAT2	file:
70	blas/testing/dblat3.f	/^   70                            CONTINUE$/;"	l	subroutine:DCHK3	file:
70	blas/testing/dblat3.f	/^   70                      CONTINUE$/;"	l	subroutine:DCHK5	file:
70	blas/testing/dblat3.f	/^   70             CONTINUE$/;"	l	subroutine:DCHK1	file:
70	blas/testing/dblat3.f	/^   70          CONTINUE$/;"	l	subroutine:DCHK2	file:
70	blas/testing/dblat3.f	/^   70          CONTINUE$/;"	l	subroutine:DCHK4	file:
70	blas/testing/dblat3.f	/^   70       CONTINUE$/;"	l	subroutine:DMAKE	file:
70	blas/testing/dblat3.f	/^   70       CONTINUE$/;"	l	subroutine:DMMCH	file:
70	blas/testing/dblat3.f	/^   70 CONTINUE$/;"	l	function:LDERES	file:
70	blas/testing/dblat3.f	/^   70 IF( OK )THEN$/;"	l	subroutine:DCHKE	file:
70	blas/testing/sblat2.f	/^   70                      CONTINUE$/;"	l	subroutine:SCHK6	file:
70	blas/testing/sblat2.f	/^   70                   CONTINUE$/;"	l	subroutine:SCHK4	file:
70	blas/testing/sblat2.f	/^   70                CONTINUE$/;"	l	subroutine:SCHK1	file:
70	blas/testing/sblat2.f	/^   70             CONTINUE$/;"	l	subroutine:SCHK2	file:
70	blas/testing/sblat2.f	/^   70             CONTINUE$/;"	l	subroutine:SCHK3	file:
70	blas/testing/sblat2.f	/^   70          CONTINUE$/;"	l	subroutine:SCHK5	file:
70	blas/testing/sblat2.f	/^   70       CONTINUE$/;"	l	subroutine:SMAKE	file:
70	blas/testing/sblat2.f	/^   70 CONTINUE$/;"	l	function:LSERES	file:
70	blas/testing/sblat2.f	/^   70 CONTINUE$/;"	l	subroutine:SMVCH	file:
70	blas/testing/sblat2.f	/^   70 INFOT = 1$/;"	l	subroutine:SCHKE	file:
70	blas/testing/sblat2.f	/^   70 LTEST( I ) = LTESTT$/;"	l	program:SBLAT2	file:
70	blas/testing/sblat3.f	/^   70                            CONTINUE$/;"	l	subroutine:SCHK3	file:
70	blas/testing/sblat3.f	/^   70                      CONTINUE$/;"	l	subroutine:SCHK5	file:
70	blas/testing/sblat3.f	/^   70             CONTINUE$/;"	l	subroutine:SCHK1	file:
70	blas/testing/sblat3.f	/^   70          CONTINUE$/;"	l	subroutine:SCHK2	file:
70	blas/testing/sblat3.f	/^   70          CONTINUE$/;"	l	subroutine:SCHK4	file:
70	blas/testing/sblat3.f	/^   70       CONTINUE$/;"	l	subroutine:SMAKE	file:
70	blas/testing/sblat3.f	/^   70       CONTINUE$/;"	l	subroutine:SMMCH	file:
70	blas/testing/sblat3.f	/^   70 CONTINUE$/;"	l	function:LSERES	file:
70	blas/testing/sblat3.f	/^   70 IF( OK )THEN$/;"	l	subroutine:SCHKE	file:
70	blas/testing/zblat2.f	/^   70                      CONTINUE$/;"	l	subroutine:ZCHK6	file:
70	blas/testing/zblat2.f	/^   70                   CONTINUE$/;"	l	subroutine:ZCHK4	file:
70	blas/testing/zblat2.f	/^   70                CONTINUE$/;"	l	subroutine:ZCHK1	file:
70	blas/testing/zblat2.f	/^   70             CONTINUE$/;"	l	subroutine:ZCHK2	file:
70	blas/testing/zblat2.f	/^   70             CONTINUE$/;"	l	subroutine:ZCHK3	file:
70	blas/testing/zblat2.f	/^   70          CONTINUE$/;"	l	subroutine:ZCHK5	file:
70	blas/testing/zblat2.f	/^   70       CONTINUE$/;"	l	subroutine:ZMAKE	file:
70	blas/testing/zblat2.f	/^   70 CONTINUE$/;"	l	function:LZERES	file:
70	blas/testing/zblat2.f	/^   70 CONTINUE$/;"	l	subroutine:ZMVCH	file:
70	blas/testing/zblat2.f	/^   70 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
70	blas/testing/zblat2.f	/^   70 LTEST( I ) = LTESTT$/;"	l	program:ZBLAT2	file:
70	blas/testing/zblat3.f	/^   70                            CONTINUE$/;"	l	subroutine:ZCHK3	file:
70	blas/testing/zblat3.f	/^   70                      CONTINUE$/;"	l	subroutine:ZCHK5	file:
70	blas/testing/zblat3.f	/^   70             CONTINUE$/;"	l	subroutine:ZCHK1	file:
70	blas/testing/zblat3.f	/^   70          CONTINUE$/;"	l	subroutine:ZCHK2	file:
70	blas/testing/zblat3.f	/^   70          CONTINUE$/;"	l	subroutine:ZCHK4	file:
70	blas/testing/zblat3.f	/^   70          CONTINUE$/;"	l	subroutine:ZMMCH	file:
70	blas/testing/zblat3.f	/^   70       CONTINUE$/;"	l	subroutine:ZMAKE	file:
70	blas/testing/zblat3.f	/^   70 CONTINUE$/;"	l	function:LZERES	file:
70	blas/testing/zblat3.f	/^   70 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
70	lapack/clarfb.f	/^   70          CONTINUE$/;"	l	subroutine:CLARFB	file:
70	lapack/dlarfb.f	/^   70          CONTINUE$/;"	l	subroutine:DLARFB	file:
70	lapack/slarfb.f	/^   70          CONTINUE$/;"	l	subroutine:SLARFB	file:
70	lapack/zlarfb.f	/^   70          CONTINUE$/;"	l	subroutine:ZLARFB	file:
80	blas/testing/cblat1.f	/^   80    CONTINUE$/;"	l	subroutine:CHECK1	file:
80	blas/testing/cblat2.f	/^   80                      CONTINUE$/;"	l	subroutine:CCHK6	file:
80	blas/testing/cblat2.f	/^   80             CONTINUE$/;"	l	subroutine:CCHK1	file:
80	blas/testing/cblat2.f	/^   80             CONTINUE$/;"	l	subroutine:CCHK4	file:
80	blas/testing/cblat2.f	/^   80          CONTINUE$/;"	l	subroutine:CCHK2	file:
80	blas/testing/cblat2.f	/^   80          CONTINUE$/;"	l	subroutine:CCHK3	file:
80	blas/testing/cblat2.f	/^   80       CONTINUE$/;"	l	subroutine:CCHK5	file:
80	blas/testing/cblat2.f	/^   80       CONTINUE$/;"	l	subroutine:CMAKE	file:
80	blas/testing/cblat2.f	/^   80 CONTINUE$/;"	l	program:CBLAT2	file:
80	blas/testing/cblat2.f	/^   80 CONTINUE$/;"	l	subroutine:CMVCH	file:
80	blas/testing/cblat2.f	/^   80 INFOT = 1$/;"	l	subroutine:CCHKE	file:
80	blas/testing/cblat2.f	/^   80 RETURN$/;"	l	function:LCERES	file:
80	blas/testing/cblat3.f	/^   80                   CONTINUE$/;"	l	subroutine:CCHK3	file:
80	blas/testing/cblat3.f	/^   80                CONTINUE$/;"	l	subroutine:CCHK5	file:
80	blas/testing/cblat3.f	/^   80             CONTINUE$/;"	l	subroutine:CMMCH	file:
80	blas/testing/cblat3.f	/^   80          CONTINUE$/;"	l	subroutine:CCHK1	file:
80	blas/testing/cblat3.f	/^   80       CONTINUE$/;"	l	subroutine:CCHK2	file:
80	blas/testing/cblat3.f	/^   80       CONTINUE$/;"	l	subroutine:CCHK4	file:
80	blas/testing/cblat3.f	/^   80       CONTINUE$/;"	l	subroutine:CMAKE	file:
80	blas/testing/cblat3.f	/^   80 INFOT = 1$/;"	l	subroutine:CCHKE	file:
80	blas/testing/cblat3.f	/^   80 RETURN$/;"	l	function:LCERES	file:
80	blas/testing/dblat1.f	/^   80          CONTINUE$/;"	l	subroutine:CHECK2	file:
80	blas/testing/dblat1.f	/^   80 CONTINUE$/;"	l	subroutine:CHECK1	file:
80	blas/testing/dblat1.f	/^   80 CONTINUE$/;"	l	subroutine:CHECK3	file:
80	blas/testing/dblat2.f	/^   80                      CONTINUE$/;"	l	subroutine:DCHK6	file:
80	blas/testing/dblat2.f	/^   80             CONTINUE$/;"	l	subroutine:DCHK1	file:
80	blas/testing/dblat2.f	/^   80             CONTINUE$/;"	l	subroutine:DCHK4	file:
80	blas/testing/dblat2.f	/^   80          CONTINUE$/;"	l	subroutine:DCHK2	file:
80	blas/testing/dblat2.f	/^   80          CONTINUE$/;"	l	subroutine:DCHK3	file:
80	blas/testing/dblat2.f	/^   80       CONTINUE$/;"	l	subroutine:DCHK5	file:
80	blas/testing/dblat2.f	/^   80       CONTINUE$/;"	l	subroutine:DMAKE	file:
80	blas/testing/dblat2.f	/^   80 CONTINUE$/;"	l	program:DBLAT2	file:
80	blas/testing/dblat2.f	/^   80 INFOT = 1$/;"	l	subroutine:DCHKE	file:
80	blas/testing/dblat2.f	/^   80 RETURN$/;"	l	function:LDERES	file:
80	blas/testing/dblat3.f	/^   80                   CONTINUE$/;"	l	subroutine:DCHK3	file:
80	blas/testing/dblat3.f	/^   80                CONTINUE$/;"	l	subroutine:DCHK5	file:
80	blas/testing/dblat3.f	/^   80          CONTINUE$/;"	l	subroutine:DCHK1	file:
80	blas/testing/dblat3.f	/^   80          CONTINUE$/;"	l	subroutine:DMMCH	file:
80	blas/testing/dblat3.f	/^   80       CONTINUE$/;"	l	subroutine:DCHK2	file:
80	blas/testing/dblat3.f	/^   80       CONTINUE$/;"	l	subroutine:DCHK4	file:
80	blas/testing/dblat3.f	/^   80       CONTINUE$/;"	l	subroutine:DMAKE	file:
80	blas/testing/dblat3.f	/^   80 RETURN$/;"	l	function:LDERES	file:
80	blas/testing/sblat1.f	/^   80          CONTINUE$/;"	l	subroutine:CHECK2	file:
80	blas/testing/sblat1.f	/^   80 CONTINUE$/;"	l	subroutine:CHECK1	file:
80	blas/testing/sblat1.f	/^   80 CONTINUE$/;"	l	subroutine:CHECK3	file:
80	blas/testing/sblat2.f	/^   80                      CONTINUE$/;"	l	subroutine:SCHK6	file:
80	blas/testing/sblat2.f	/^   80             CONTINUE$/;"	l	subroutine:SCHK1	file:
80	blas/testing/sblat2.f	/^   80             CONTINUE$/;"	l	subroutine:SCHK4	file:
80	blas/testing/sblat2.f	/^   80          CONTINUE$/;"	l	subroutine:SCHK2	file:
80	blas/testing/sblat2.f	/^   80          CONTINUE$/;"	l	subroutine:SCHK3	file:
80	blas/testing/sblat2.f	/^   80       CONTINUE$/;"	l	subroutine:SCHK5	file:
80	blas/testing/sblat2.f	/^   80       CONTINUE$/;"	l	subroutine:SMAKE	file:
80	blas/testing/sblat2.f	/^   80 CONTINUE$/;"	l	program:SBLAT2	file:
80	blas/testing/sblat2.f	/^   80 INFOT = 1$/;"	l	subroutine:SCHKE	file:
80	blas/testing/sblat2.f	/^   80 RETURN$/;"	l	function:LSERES	file:
80	blas/testing/sblat3.f	/^   80                   CONTINUE$/;"	l	subroutine:SCHK3	file:
80	blas/testing/sblat3.f	/^   80                CONTINUE$/;"	l	subroutine:SCHK5	file:
80	blas/testing/sblat3.f	/^   80          CONTINUE$/;"	l	subroutine:SCHK1	file:
80	blas/testing/sblat3.f	/^   80          CONTINUE$/;"	l	subroutine:SMMCH	file:
80	blas/testing/sblat3.f	/^   80       CONTINUE$/;"	l	subroutine:SCHK2	file:
80	blas/testing/sblat3.f	/^   80       CONTINUE$/;"	l	subroutine:SCHK4	file:
80	blas/testing/sblat3.f	/^   80       CONTINUE$/;"	l	subroutine:SMAKE	file:
80	blas/testing/sblat3.f	/^   80 RETURN$/;"	l	function:LSERES	file:
80	blas/testing/zblat1.f	/^   80    CONTINUE$/;"	l	subroutine:CHECK1	file:
80	blas/testing/zblat2.f	/^   80                      CONTINUE$/;"	l	subroutine:ZCHK6	file:
80	blas/testing/zblat2.f	/^   80             CONTINUE$/;"	l	subroutine:ZCHK1	file:
80	blas/testing/zblat2.f	/^   80             CONTINUE$/;"	l	subroutine:ZCHK4	file:
80	blas/testing/zblat2.f	/^   80          CONTINUE$/;"	l	subroutine:ZCHK2	file:
80	blas/testing/zblat2.f	/^   80          CONTINUE$/;"	l	subroutine:ZCHK3	file:
80	blas/testing/zblat2.f	/^   80       CONTINUE$/;"	l	subroutine:ZCHK5	file:
80	blas/testing/zblat2.f	/^   80       CONTINUE$/;"	l	subroutine:ZMAKE	file:
80	blas/testing/zblat2.f	/^   80 CONTINUE$/;"	l	program:ZBLAT2	file:
80	blas/testing/zblat2.f	/^   80 CONTINUE$/;"	l	subroutine:ZMVCH	file:
80	blas/testing/zblat2.f	/^   80 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
80	blas/testing/zblat2.f	/^   80 RETURN$/;"	l	function:LZERES	file:
80	blas/testing/zblat3.f	/^   80                   CONTINUE$/;"	l	subroutine:ZCHK3	file:
80	blas/testing/zblat3.f	/^   80                CONTINUE$/;"	l	subroutine:ZCHK5	file:
80	blas/testing/zblat3.f	/^   80             CONTINUE$/;"	l	subroutine:ZMMCH	file:
80	blas/testing/zblat3.f	/^   80          CONTINUE$/;"	l	subroutine:ZCHK1	file:
80	blas/testing/zblat3.f	/^   80       CONTINUE$/;"	l	subroutine:ZCHK2	file:
80	blas/testing/zblat3.f	/^   80       CONTINUE$/;"	l	subroutine:ZCHK4	file:
80	blas/testing/zblat3.f	/^   80       CONTINUE$/;"	l	subroutine:ZMAKE	file:
80	blas/testing/zblat3.f	/^   80 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
80	blas/testing/zblat3.f	/^   80 RETURN$/;"	l	function:LZERES	file:
80	lapack/clarfb.f	/^   80             CONTINUE$/;"	l	subroutine:CLARFB	file:
80	lapack/dlarfb.f	/^   80             CONTINUE$/;"	l	subroutine:DLARFB	file:
80	lapack/slarfb.f	/^   80             CONTINUE$/;"	l	subroutine:SLARFB	file:
80	lapack/zlarfb.f	/^   80             CONTINUE$/;"	l	subroutine:ZLARFB	file:
90	blas/testing/cblat2.f	/^   90                   CONTINUE$/;"	l	subroutine:CCHK6	file:
90	blas/testing/cblat2.f	/^   90          CONTINUE$/;"	l	subroutine:CCHK1	file:
90	blas/testing/cblat2.f	/^   90          CONTINUE$/;"	l	subroutine:CCHK4	file:
90	blas/testing/cblat2.f	/^   90       CONTINUE$/;"	l	subroutine:CCHK2	file:
90	blas/testing/cblat2.f	/^   90       CONTINUE$/;"	l	subroutine:CCHK3	file:
90	blas/testing/cblat2.f	/^   90    CONTINUE$/;"	l	subroutine:CCHK5	file:
90	blas/testing/cblat2.f	/^   90    CONTINUE$/;"	l	subroutine:CMAKE	file:
90	blas/testing/cblat2.f	/^   90 INFOT = 1$/;"	l	subroutine:CCHKE	file:
90	blas/testing/cblat3.f	/^   90                CONTINUE$/;"	l	subroutine:CCHK3	file:
90	blas/testing/cblat3.f	/^   90             CONTINUE$/;"	l	subroutine:CCHK5	file:
90	blas/testing/cblat3.f	/^   90          CONTINUE$/;"	l	subroutine:CMMCH	file:
90	blas/testing/cblat3.f	/^   90       CONTINUE$/;"	l	subroutine:CCHK1	file:
90	blas/testing/cblat3.f	/^   90    CONTINUE$/;"	l	program:CBLAT3	file:
90	blas/testing/cblat3.f	/^   90    CONTINUE$/;"	l	subroutine:CCHK2	file:
90	blas/testing/cblat3.f	/^   90    CONTINUE$/;"	l	subroutine:CCHK4	file:
90	blas/testing/cblat3.f	/^   90    CONTINUE$/;"	l	subroutine:CMAKE	file:
90	blas/testing/cblat3.f	/^   90 INFOT = 1$/;"	l	subroutine:CCHKE	file:
90	blas/testing/dblat2.f	/^   90                   CONTINUE$/;"	l	subroutine:DCHK6	file:
90	blas/testing/dblat2.f	/^   90          CONTINUE$/;"	l	subroutine:DCHK1	file:
90	blas/testing/dblat2.f	/^   90          CONTINUE$/;"	l	subroutine:DCHK4	file:
90	blas/testing/dblat2.f	/^   90       CONTINUE$/;"	l	subroutine:DCHK2	file:
90	blas/testing/dblat2.f	/^   90       CONTINUE$/;"	l	subroutine:DCHK3	file:
90	blas/testing/dblat2.f	/^   90    CONTINUE$/;"	l	subroutine:DCHK5	file:
90	blas/testing/dblat2.f	/^   90    CONTINUE$/;"	l	subroutine:DMAKE	file:
90	blas/testing/dblat2.f	/^   90 INFOT = 1$/;"	l	subroutine:DCHKE	file:
90	blas/testing/dblat3.f	/^   90                CONTINUE$/;"	l	subroutine:DCHK3	file:
90	blas/testing/dblat3.f	/^   90             CONTINUE$/;"	l	subroutine:DCHK5	file:
90	blas/testing/dblat3.f	/^   90       CONTINUE$/;"	l	subroutine:DCHK1	file:
90	blas/testing/dblat3.f	/^   90       CONTINUE$/;"	l	subroutine:DMMCH	file:
90	blas/testing/dblat3.f	/^   90    CONTINUE$/;"	l	program:DBLAT3	file:
90	blas/testing/dblat3.f	/^   90    CONTINUE$/;"	l	subroutine:DCHK2	file:
90	blas/testing/dblat3.f	/^   90    CONTINUE$/;"	l	subroutine:DCHK4	file:
90	blas/testing/dblat3.f	/^   90    CONTINUE$/;"	l	subroutine:DMAKE	file:
90	blas/testing/sblat2.f	/^   90                   CONTINUE$/;"	l	subroutine:SCHK6	file:
90	blas/testing/sblat2.f	/^   90          CONTINUE$/;"	l	subroutine:SCHK1	file:
90	blas/testing/sblat2.f	/^   90          CONTINUE$/;"	l	subroutine:SCHK4	file:
90	blas/testing/sblat2.f	/^   90       CONTINUE$/;"	l	subroutine:SCHK2	file:
90	blas/testing/sblat2.f	/^   90       CONTINUE$/;"	l	subroutine:SCHK3	file:
90	blas/testing/sblat2.f	/^   90    CONTINUE$/;"	l	subroutine:SCHK5	file:
90	blas/testing/sblat2.f	/^   90    CONTINUE$/;"	l	subroutine:SMAKE	file:
90	blas/testing/sblat2.f	/^   90 INFOT = 1$/;"	l	subroutine:SCHKE	file:
90	blas/testing/sblat3.f	/^   90                CONTINUE$/;"	l	subroutine:SCHK3	file:
90	blas/testing/sblat3.f	/^   90             CONTINUE$/;"	l	subroutine:SCHK5	file:
90	blas/testing/sblat3.f	/^   90       CONTINUE$/;"	l	subroutine:SCHK1	file:
90	blas/testing/sblat3.f	/^   90       CONTINUE$/;"	l	subroutine:SMMCH	file:
90	blas/testing/sblat3.f	/^   90    CONTINUE$/;"	l	program:SBLAT3	file:
90	blas/testing/sblat3.f	/^   90    CONTINUE$/;"	l	subroutine:SCHK2	file:
90	blas/testing/sblat3.f	/^   90    CONTINUE$/;"	l	subroutine:SCHK4	file:
90	blas/testing/sblat3.f	/^   90    CONTINUE$/;"	l	subroutine:SMAKE	file:
90	blas/testing/zblat2.f	/^   90                   CONTINUE$/;"	l	subroutine:ZCHK6	file:
90	blas/testing/zblat2.f	/^   90          CONTINUE$/;"	l	subroutine:ZCHK1	file:
90	blas/testing/zblat2.f	/^   90          CONTINUE$/;"	l	subroutine:ZCHK4	file:
90	blas/testing/zblat2.f	/^   90       CONTINUE$/;"	l	subroutine:ZCHK2	file:
90	blas/testing/zblat2.f	/^   90       CONTINUE$/;"	l	subroutine:ZCHK3	file:
90	blas/testing/zblat2.f	/^   90    CONTINUE$/;"	l	subroutine:ZCHK5	file:
90	blas/testing/zblat2.f	/^   90    CONTINUE$/;"	l	subroutine:ZMAKE	file:
90	blas/testing/zblat2.f	/^   90 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
90	blas/testing/zblat3.f	/^   90                CONTINUE$/;"	l	subroutine:ZCHK3	file:
90	blas/testing/zblat3.f	/^   90             CONTINUE$/;"	l	subroutine:ZCHK5	file:
90	blas/testing/zblat3.f	/^   90          CONTINUE$/;"	l	subroutine:ZMMCH	file:
90	blas/testing/zblat3.f	/^   90       CONTINUE$/;"	l	subroutine:ZCHK1	file:
90	blas/testing/zblat3.f	/^   90    CONTINUE$/;"	l	program:ZBLAT3	file:
90	blas/testing/zblat3.f	/^   90    CONTINUE$/;"	l	subroutine:ZCHK2	file:
90	blas/testing/zblat3.f	/^   90    CONTINUE$/;"	l	subroutine:ZCHK4	file:
90	blas/testing/zblat3.f	/^   90    CONTINUE$/;"	l	subroutine:ZMAKE	file:
90	blas/testing/zblat3.f	/^   90 INFOT = 1$/;"	l	subroutine:ZCHKE	file:
90	lapack/clarfb.f	/^   90          CONTINUE$/;"	l	subroutine:CLARFB	file:
90	lapack/dlarfb.f	/^   90          CONTINUE$/;"	l	subroutine:DLARFB	file:
90	lapack/slarfb.f	/^   90          CONTINUE$/;"	l	subroutine:SLARFB	file:
90	lapack/zlarfb.f	/^   90          CONTINUE$/;"	l	subroutine:ZLARFB	file:
9980	blas/testing/cblat2.f	/^ 9980 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:CBLAT2	file:
9980	blas/testing/dblat2.f	/^ 9980 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:DBLAT2	file:
9980	blas/testing/sblat2.f	/^ 9980 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:SBLAT2	file:
9980	blas/testing/zblat2.f	/^ 9980 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:ZBLAT2	file:
9981	blas/testing/cblat2.f	/^ 9981 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:CBLAT2	file:
9981	blas/testing/dblat2.f	/^ 9981 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:DBLAT2	file:
9981	blas/testing/sblat2.f	/^ 9981 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:SBLAT2	file:
9981	blas/testing/zblat2.f	/^ 9981 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:ZBLAT2	file:
9982	blas/testing/cblat2.f	/^ 9982 FORMAT( \/' END OF TESTS' )$/;"	l	program:CBLAT2	file:
9982	blas/testing/dblat2.f	/^ 9982 FORMAT( \/' END OF TESTS' )$/;"	l	program:DBLAT2	file:
9982	blas/testing/sblat2.f	/^ 9982 FORMAT( \/' END OF TESTS' )$/;"	l	program:SBLAT2	file:
9982	blas/testing/zblat2.f	/^ 9982 FORMAT( \/' END OF TESTS' )$/;"	l	program:ZBLAT2	file:
9983	blas/testing/cblat2.f	/^ 9983 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:CBLAT2	file:
9983	blas/testing/dblat2.f	/^ 9983 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:DBLAT2	file:
9983	blas/testing/sblat2.f	/^ 9983 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:SBLAT2	file:
9983	blas/testing/zblat2.f	/^ 9983 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:ZBLAT2	file:
9984	blas/testing/cblat2.f	/^ 9984 FORMAT( A6, L2 )$/;"	l	program:CBLAT2	file:
9984	blas/testing/cblat3.f	/^ 9984 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:CBLAT3	file:
9984	blas/testing/dblat2.f	/^ 9984 FORMAT( A6, L2 )$/;"	l	program:DBLAT2	file:
9984	blas/testing/dblat3.f	/^ 9984 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:DBLAT3	file:
9984	blas/testing/sblat2.f	/^ 9984 FORMAT( A6, L2 )$/;"	l	program:SBLAT2	file:
9984	blas/testing/sblat3.f	/^ 9984 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:SBLAT3	file:
9984	blas/testing/zblat2.f	/^ 9984 FORMAT( A6, L2 )$/;"	l	program:ZBLAT2	file:
9984	blas/testing/zblat3.f	/^ 9984 FORMAT( ' ERROR-EXITS WILL NOT BE TESTED' )$/;"	l	program:ZBLAT3	file:
9985	blas/testing/cblat2.f	/^ 9985 FORMAT( ' ERROR IN CMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:CBLAT2	file:
9985	blas/testing/cblat3.f	/^ 9985 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:CBLAT3	file:
9985	blas/testing/dblat2.f	/^ 9985 FORMAT( ' ERROR IN DMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:DBLAT2	file:
9985	blas/testing/dblat3.f	/^ 9985 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:DBLAT3	file:
9985	blas/testing/sblat2.f	/^ 9985 FORMAT( ' ERROR IN SMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:SBLAT2	file:
9985	blas/testing/sblat3.f	/^ 9985 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:SBLAT3	file:
9985	blas/testing/zblat2.f	/^ 9985 FORMAT( ' ERROR IN ZMVCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:ZBLAT2	file:
9985	blas/testing/zblat3.f	/^ 9985 FORMAT( \/' ******* FATAL ERROR - TESTS ABANDONED *******' )$/;"	l	program:ZBLAT3	file:
9986	blas/testing/cblat2.f	/^ 9986 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:CBLAT2	file:
9986	blas/testing/cblat3.f	/^ 9986 FORMAT( \/' END OF TESTS' )$/;"	l	program:CBLAT3	file:
9986	blas/testing/dblat2.f	/^ 9986 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:DBLAT2	file:
9986	blas/testing/dblat3.f	/^ 9986 FORMAT( \/' END OF TESTS' )$/;"	l	program:DBLAT3	file:
9986	blas/testing/sblat2.f	/^ 9986 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:SBLAT2	file:
9986	blas/testing/sblat3.f	/^ 9986 FORMAT( \/' END OF TESTS' )$/;"	l	program:SBLAT3	file:
9986	blas/testing/zblat2.f	/^ 9986 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:ZBLAT2	file:
9986	blas/testing/zblat3.f	/^ 9986 FORMAT( \/' END OF TESTS' )$/;"	l	program:ZBLAT3	file:
9987	blas/testing/cblat2.f	/^ 9987 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:CBLAT2	file:
9987	blas/testing/cblat3.f	/^ 9987 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:CBLAT3	file:
9987	blas/testing/dblat2.f	/^ 9987 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:DBLAT2	file:
9987	blas/testing/dblat3.f	/^ 9987 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:DBLAT3	file:
9987	blas/testing/sblat2.f	/^ 9987 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:SBLAT2	file:
9987	blas/testing/sblat3.f	/^ 9987 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:SBLAT3	file:
9987	blas/testing/zblat2.f	/^ 9987 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:ZBLAT2	file:
9987	blas/testing/zblat3.f	/^ 9987 FORMAT( 1X, A6, ' WAS NOT TESTED' )$/;"	l	program:ZBLAT3	file:
9988	blas/testing/cblat2.f	/^ 9988 FORMAT( '   FOR BETA           ',$/;"	l	program:CBLAT2	file:
9988	blas/testing/cblat3.f	/^ 9988 FORMAT( A6, L2 )$/;"	l	program:CBLAT3	file:
9988	blas/testing/dblat2.f	/^ 9988 FORMAT( '   FOR BETA           ', 7F6.1 )$/;"	l	program:DBLAT2	file:
9988	blas/testing/dblat3.f	/^ 9988 FORMAT( A6, L2 )$/;"	l	program:DBLAT3	file:
9988	blas/testing/sblat2.f	/^ 9988 FORMAT( '   FOR BETA           ', 7F6.1 )$/;"	l	program:SBLAT2	file:
9988	blas/testing/sblat3.f	/^ 9988 FORMAT( A6, L2 )$/;"	l	program:SBLAT3	file:
9988	blas/testing/zblat2.f	/^ 9988 FORMAT( '   FOR BETA           ',$/;"	l	program:ZBLAT2	file:
9988	blas/testing/zblat3.f	/^ 9988 FORMAT( A6, L2 )$/;"	l	program:ZBLAT3	file:
9989	blas/testing/cblat2.f	/^ 9989 FORMAT( '   FOR ALPHA          ',$/;"	l	program:CBLAT2	file:
9989	blas/testing/cblat3.f	/^ 9989 FORMAT( ' ERROR IN CMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:CBLAT3	file:
9989	blas/testing/dblat2.f	/^ 9989 FORMAT( '   FOR ALPHA          ', 7F6.1 )$/;"	l	program:DBLAT2	file:
9989	blas/testing/dblat3.f	/^ 9989 FORMAT( ' ERROR IN DMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:DBLAT3	file:
9989	blas/testing/sblat2.f	/^ 9989 FORMAT( '   FOR ALPHA          ', 7F6.1 )$/;"	l	program:SBLAT2	file:
9989	blas/testing/sblat3.f	/^ 9989 FORMAT( ' ERROR IN SMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:SBLAT3	file:
9989	blas/testing/zblat2.f	/^ 9989 FORMAT( '   FOR ALPHA          ',$/;"	l	program:ZBLAT2	file:
9989	blas/testing/zblat3.f	/^ 9989 FORMAT( ' ERROR IN ZMMCH -  IN-LINE DOT PRODUCTS ARE BEING EVALU',$/;"	l	program:ZBLAT3	file:
9990	blas/testing/cblat2.f	/^ 9990 FORMAT( '   FOR INCX AND INCY  ', 7I6 )$/;"	l	program:CBLAT2	file:
9990	blas/testing/cblat3.f	/^ 9990 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:CBLAT3	file:
9990	blas/testing/dblat2.f	/^ 9990 FORMAT( '   FOR INCX AND INCY  ', 7I6 )$/;"	l	program:DBLAT2	file:
9990	blas/testing/dblat3.f	/^ 9990 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:DBLAT3	file:
9990	blas/testing/sblat2.f	/^ 9990 FORMAT( '   FOR INCX AND INCY  ', 7I6 )$/;"	l	program:SBLAT2	file:
9990	blas/testing/sblat3.f	/^ 9990 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:SBLAT3	file:
9990	blas/testing/zblat2.f	/^ 9990 FORMAT( '   FOR INCX AND INCY  ', 7I6 )$/;"	l	program:ZBLAT2	file:
9990	blas/testing/zblat3.f	/^ 9990 FORMAT( ' SUBPROGRAM NAME ', A6, ' NOT RECOGNIZED', \/' ******* T',$/;"	l	program:ZBLAT3	file:
9991	blas/testing/cblat2.f	/^ 9991 FORMAT( '   FOR K              ', 7I6 )$/;"	l	program:CBLAT2	file:
9991	blas/testing/cblat3.f	/^ 9991 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:CBLAT3	file:
9991	blas/testing/dblat2.f	/^ 9991 FORMAT( '   FOR K              ', 7I6 )$/;"	l	program:DBLAT2	file:
9991	blas/testing/dblat3.f	/^ 9991 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:DBLAT3	file:
9991	blas/testing/sblat2.f	/^ 9991 FORMAT( '   FOR K              ', 7I6 )$/;"	l	program:SBLAT2	file:
9991	blas/testing/sblat3.f	/^ 9991 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:SBLAT3	file:
9991	blas/testing/zblat2.f	/^ 9991 FORMAT( '   FOR K              ', 7I6 )$/;"	l	program:ZBLAT2	file:
9991	blas/testing/zblat3.f	/^ 9991 FORMAT( ' AMEND DATA FILE OR INCREASE ARRAY SIZES IN PROGRAM',$/;"	l	program:ZBLAT3	file:
9992	blas/testing/cblat2.f	/^ 9992 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:CBLAT2	file:
9992	blas/testing/cblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK2	file:
9992	blas/testing/cblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK3	file:
9992	blas/testing/cblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK5	file:
9992	blas/testing/cblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK6	file:
9992	blas/testing/cblat3.f	/^ 9992 FORMAT( '   FOR BETA           ',$/;"	l	program:CBLAT3	file:
9992	blas/testing/cblat3.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK4	file:
9992	blas/testing/cblat3.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK5	file:
9992	blas/testing/dblat2.f	/^ 9992 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:DBLAT2	file:
9992	blas/testing/dblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK2	file:
9992	blas/testing/dblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK3	file:
9992	blas/testing/dblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK5	file:
9992	blas/testing/dblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK6	file:
9992	blas/testing/dblat3.f	/^ 9992 FORMAT( '   FOR BETA           ', 7F6.1 )$/;"	l	program:DBLAT3	file:
9992	blas/testing/sblat2.f	/^ 9992 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:SBLAT2	file:
9992	blas/testing/sblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK2	file:
9992	blas/testing/sblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK3	file:
9992	blas/testing/sblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK5	file:
9992	blas/testing/sblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK6	file:
9992	blas/testing/sblat3.f	/^ 9992 FORMAT( '   FOR BETA           ', 7F6.1 )$/;"	l	program:SBLAT3	file:
9992	blas/testing/zblat2.f	/^ 9992 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:ZBLAT2	file:
9992	blas/testing/zblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK2	file:
9992	blas/testing/zblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK3	file:
9992	blas/testing/zblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK5	file:
9992	blas/testing/zblat2.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK6	file:
9992	blas/testing/zblat3.f	/^ 9992 FORMAT( '   FOR BETA           ',$/;"	l	program:ZBLAT3	file:
9992	blas/testing/zblat3.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK4	file:
9992	blas/testing/zblat3.f	/^ 9992 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK5	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK1	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK4	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( ' TESTS OF THE COMPLEX          LEVEL 2 BLAS', \/\/' THE F',$/;"	l	program:CBLAT2	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:CCHK5	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:CCHK2	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:CCHK6	file:
9993	blas/testing/cblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', A,',$/;"	l	subroutine:CCHK3	file:
9993	blas/testing/cblat3.f	/^ 9993 FORMAT( '   FOR ALPHA          ',$/;"	l	program:CBLAT3	file:
9993	blas/testing/cblat3.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK4	file:
9993	blas/testing/cblat3.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK5	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK1	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK4	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( ' TESTS OF THE DOUBLE PRECISION LEVEL 2 BLAS', \/\/' THE F',$/;"	l	program:DBLAT2	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', A,',$/;"	l	subroutine:DCHK2	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:DCHK5	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:DCHK6	file:
9993	blas/testing/dblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', A,',$/;"	l	subroutine:DCHK3	file:
9993	blas/testing/dblat3.f	/^ 9993 FORMAT( '   FOR ALPHA          ', 7F6.1 )$/;"	l	program:DBLAT3	file:
9993	blas/testing/dblat3.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK4	file:
9993	blas/testing/dblat3.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK5	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK1	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK4	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( ' TESTS OF THE REAL             LEVEL 2 BLAS', \/\/' THE F',$/;"	l	program:SBLAT2	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', A,',$/;"	l	subroutine:SCHK2	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:SCHK5	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:SCHK6	file:
9993	blas/testing/sblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', A,',$/;"	l	subroutine:SCHK3	file:
9993	blas/testing/sblat3.f	/^ 9993 FORMAT( '   FOR ALPHA          ', 7F6.1 )$/;"	l	program:SBLAT3	file:
9993	blas/testing/sblat3.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK4	file:
9993	blas/testing/sblat3.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK5	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK1	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK4	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( ' TESTS OF THE COMPLEX*16       LEVEL 2 BLAS', \/\/' THE F',$/;"	l	program:ZBLAT2	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:ZCHK5	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:ZCHK2	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:ZCHK6	file:
9993	blas/testing/zblat2.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', A,',$/;"	l	subroutine:ZCHK3	file:
9993	blas/testing/zblat3.f	/^ 9993 FORMAT( '   FOR ALPHA          ',$/;"	l	program:ZBLAT3	file:
9993	blas/testing/zblat3.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK4	file:
9993	blas/testing/zblat3.f	/^ 9993 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK5	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( ' ABSOLUTE VALUE OF INCX OR INCY IS 0 OR GREATER THAN ',$/;"	l	program:CBLAT2	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), '(',$/;"	l	subroutine:CCHK1	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), '(',$/;"	l	subroutine:CCHK2	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:CCHK5	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:CCHK6	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( I3, ',' ), '(', F4.1, ',', F4.1,$/;"	l	subroutine:CCHK4	file:
9994	blas/testing/cblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK3	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:CBLAT3	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK1	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK2	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:CCHK3	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK4	file:
9994	blas/testing/cblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK5	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( ' ABSOLUTE VALUE OF INCX OR INCY IS 0 OR GREATER THAN ',$/;"	l	program:DBLAT2	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), F4.1,$/;"	l	subroutine:DCHK1	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), F4.1,$/;"	l	subroutine:DCHK2	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:DCHK5	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:DCHK6	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( I3, ',' ), F4.1, ', X,', I2,$/;"	l	subroutine:DCHK4	file:
9994	blas/testing/dblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:DCHK3	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:DBLAT3	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK1	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK2	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:DCHK3	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:DCHK4	file:
9994	blas/testing/dblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:DCHK5	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( ' ABSOLUTE VALUE OF INCX OR INCY IS 0 OR GREATER THAN ',$/;"	l	program:SBLAT2	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), F4.1,$/;"	l	subroutine:SCHK1	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), F4.1,$/;"	l	subroutine:SCHK2	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:SCHK5	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:SCHK6	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( I3, ',' ), F4.1, ', X,', I2,$/;"	l	subroutine:SCHK4	file:
9994	blas/testing/sblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:SCHK3	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:SBLAT3	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK1	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK2	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:SCHK3	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:SCHK4	file:
9994	blas/testing/sblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:SCHK5	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( ' ABSOLUTE VALUE OF INCX OR INCY IS 0 OR GREATER THAN ',$/;"	l	program:ZBLAT2	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), '(',$/;"	l	subroutine:ZCHK1	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 2( I3, ',' ), '(',$/;"	l	subroutine:ZCHK2	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', X,',$/;"	l	subroutine:ZCHK5	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:ZCHK6	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( I3, ',' ), '(', F4.1, ',', F4.1,$/;"	l	subroutine:ZCHK4	file:
9994	blas/testing/zblat2.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK3	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( '   FOR N              ', 9I6 )$/;"	l	program:ZBLAT3	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK1	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK2	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( ' ******* FATAL ERROR - ERROR-EXIT TAKEN ON VALID CALL *',$/;"	l	subroutine:ZCHK3	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK4	file:
9994	blas/testing/zblat3.f	/^ 9994 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK5	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CCHK4	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CCHK5	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CCHK6	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( ' VALUE OF K IS LESS THAN 0' )$/;"	l	program:CBLAT2	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 4( I3, ',' ), '(',$/;"	l	subroutine:CCHK1	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:CCHK2	file:
9995	blas/testing/cblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', AP, ',$/;"	l	subroutine:CCHK3	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CCHK4	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CCHK5	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( ' TESTS OF THE COMPLEX          LEVEL 3 BLAS', \/\/' THE F',$/;"	l	program:CBLAT3	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',''', A1, ''',',$/;"	l	subroutine:CCHK1	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK2	file:
9995	blas/testing/cblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 4( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:CCHK3	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DCHK4	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DCHK5	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DCHK6	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( ' VALUE OF K IS LESS THAN 0' )$/;"	l	program:DBLAT2	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 4( I3, ',' ), F4.1,$/;"	l	subroutine:DCHK1	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', AP',$/;"	l	subroutine:DCHK2	file:
9995	blas/testing/dblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', AP, ',$/;"	l	subroutine:DCHK3	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DCHK4	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DCHK5	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( ' TESTS OF THE DOUBLE PRECISION LEVEL 3 BLAS', \/\/' THE F',$/;"	l	program:DBLAT3	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',''', A1, ''',',$/;"	l	subroutine:DCHK1	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:DCHK2	file:
9995	blas/testing/dblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 4( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:DCHK3	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SCHK4	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SCHK5	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SCHK6	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( ' VALUE OF K IS LESS THAN 0' )$/;"	l	program:SBLAT2	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 4( I3, ',' ), F4.1,$/;"	l	subroutine:SCHK1	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',', F4.1, ', AP',$/;"	l	subroutine:SCHK2	file:
9995	blas/testing/sblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', AP, ',$/;"	l	subroutine:SCHK3	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SCHK4	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SCHK5	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( ' TESTS OF THE REAL             LEVEL 3 BLAS', \/\/' THE F',$/;"	l	program:SBLAT3	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',''', A1, ''',',$/;"	l	subroutine:SCHK1	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:SCHK2	file:
9995	blas/testing/sblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 4( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:SCHK3	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZCHK4	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZCHK5	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZCHK6	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( ' VALUE OF K IS LESS THAN 0' )$/;"	l	program:ZBLAT2	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', 4( I3, ',' ), '(',$/;"	l	subroutine:ZCHK1	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',', I3, ',(', F4.1, ',',$/;"	l	subroutine:ZCHK2	file:
9995	blas/testing/zblat2.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 3( '''', A1, ''',' ), I3, ', AP, ',$/;"	l	subroutine:ZCHK3	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZCHK4	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZCHK5	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( ' TESTS OF THE COMPLEX*16       LEVEL 3 BLAS', \/\/' THE F',$/;"	l	program:ZBLAT3	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(''', A1, ''',''', A1, ''',',$/;"	l	subroutine:ZCHK1	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 2( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK2	file:
9995	blas/testing/zblat3.f	/^ 9995 FORMAT( 1X, I6, ': ', A6, '(', 4( '''', A1, ''',' ), 2( I3, ',' ),$/;"	l	subroutine:ZCHK3	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK1	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK2	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK3	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK4	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK5	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK6	file:
9996	blas/testing/cblat2.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:CBLAT2	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK1	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK2	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK3	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK4	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:CCHK5	file:
9996	blas/testing/cblat3.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:CBLAT3	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK1	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK2	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK3	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK4	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK5	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK6	file:
9996	blas/testing/dblat2.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:DBLAT2	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK1	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK2	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK3	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK4	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:DCHK5	file:
9996	blas/testing/dblat3.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:DBLAT3	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK1	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK2	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK3	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK4	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK5	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK6	file:
9996	blas/testing/sblat2.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:SBLAT2	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK1	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK2	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK3	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK4	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:SCHK5	file:
9996	blas/testing/sblat3.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:SBLAT3	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK1	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK2	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK3	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK4	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK5	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK6	file:
9996	blas/testing/zblat2.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:ZBLAT2	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK1	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK2	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK3	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK4	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' ******* ', A6, ' FAILED ON CALL NUMBER:' )$/;"	l	subroutine:ZCHK5	file:
9996	blas/testing/zblat3.f	/^ 9996 FORMAT( ' VALUE OF N IS LESS THAN 0 OR GREATER THAN ', I2 )$/;"	l	program:ZBLAT3	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK1	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK2	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK3	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK4	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK5	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK6	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/cblat2.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:CBLAT2	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:CMMCH	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK1	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK2	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK3	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK4	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:CCHK5	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/cblat3.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:CBLAT3	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK1	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK2	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK3	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK4	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK5	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK6	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/dblat2.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:DBLAT2	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:DMMCH	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK1	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK2	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK3	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK4	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:DCHK5	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/dblat3.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:DBLAT3	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK1	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK2	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK3	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK4	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK5	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK6	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/sblat2.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:SBLAT2	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:SMMCH	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK1	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK2	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK3	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK4	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:SCHK5	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/sblat3.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:SBLAT3	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK1	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK2	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK3	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK4	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK5	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK6	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/zblat2.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:ZBLAT2	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( '      THESE ARE THE RESULTS FOR COLUMN ', I3 )$/;"	l	subroutine:ZMMCH	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK1	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK2	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK3	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK4	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ', A6, ' COMPLETED THE COMPUTATIONAL TESTS (', I6, ' C',$/;"	l	subroutine:ZCHK5	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6,$/;"	l	subroutine:XERBLA	file:
9997	blas/testing/zblat3.f	/^ 9997 FORMAT( ' NUMBER OF VALUES OF ', A, ' IS LESS THAN 1 OR GREATER ',$/;"	l	program:ZBLAT3	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:CCHKE	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK1	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK2	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK3	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK4	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK5	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK6	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, E9.1 )$/;"	l	program:CBLAT2	file:
9998	blas/testing/cblat2.f	/^ 9998 FORMAT( 1X, I7, 2( '  (', G15.6, ',', G15.6, ')' ) )$/;"	l	subroutine:CMVCH	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:CCHKE	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK1	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK2	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK3	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK4	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:CCHK5	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, E9.1 )$/;"	l	program:CBLAT3	file:
9998	blas/testing/cblat3.f	/^ 9998 FORMAT( 1X, I7, 2( '  (', G15.6, ',', G15.6, ')' ) )$/;"	l	subroutine:CMMCH	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:DCHKE	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK1	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK2	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK3	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK4	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK5	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK6	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, D9.1 )$/;"	l	program:DBLAT2	file:
9998	blas/testing/dblat2.f	/^ 9998 FORMAT( 1X, I7, 2G18.6 )$/;"	l	subroutine:DMVCH	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:DCHKE	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK1	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK2	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK3	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK4	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:DCHK5	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, D9.1 )$/;"	l	program:DBLAT3	file:
9998	blas/testing/dblat3.f	/^ 9998 FORMAT( 1X, I7, 2G18.6 )$/;"	l	subroutine:DMMCH	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:SCHKE	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK1	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK2	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK3	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK4	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK5	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK6	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, E9.1 )$/;"	l	program:SBLAT2	file:
9998	blas/testing/sblat2.f	/^ 9998 FORMAT( 1X, I7, 2G18.6 )$/;"	l	subroutine:SMVCH	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:SCHKE	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK1	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK2	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK3	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK4	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:SCHK5	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, E9.1 )$/;"	l	program:SBLAT3	file:
9998	blas/testing/sblat3.f	/^ 9998 FORMAT( 1X, I7, 2G18.6 )$/;"	l	subroutine:SMMCH	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:ZCHKE	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK1	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK2	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK3	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK4	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK5	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK6	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, D9.1 )$/;"	l	program:ZBLAT2	file:
9998	blas/testing/zblat2.f	/^ 9998 FORMAT( 1X, I7, 2( '  (', G15.6, ',', G15.6, ')' ) )$/;"	l	subroutine:ZMVCH	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* ', A6, ' FAILED THE TESTS OF ERROR-EXITS *****',$/;"	l	subroutine:ZCHKE	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK1	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK2	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK3	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK4	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* FATAL ERROR - PARAMETER NUMBER ', I2, ' WAS CH',$/;"	l	subroutine:ZCHK5	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' ******* XERBLA WAS CALLED WITH SRNAME = ', A6, ' INSTE',$/;"	l	subroutine:XERBLA	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( ' RELATIVE MACHINE PRECISION IS TAKEN TO BE', 1P, D9.1 )$/;"	l	program:ZBLAT3	file:
9998	blas/testing/zblat3.f	/^ 9998 FORMAT( 1X, I7, 2( '  (', G15.6, ',', G15.6, ')' ) )$/;"	l	subroutine:ZMMCH	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK1	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK2	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK3	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK4	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK5	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK6	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:CCHKE	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:CMVCH	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/cblat2.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:CBLAT2	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK1	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK2	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK3	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK4	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:CCHK5	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:CCHKE	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:CMMCH	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/cblat3.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:CBLAT3	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK1	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK2	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK3	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK4	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK5	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK6	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:DCHKE	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:DMVCH	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/dblat2.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:DBLAT2	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK1	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK2	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK3	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK4	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:DCHK5	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:DCHKE	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:DMMCH	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/dblat3.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:DBLAT3	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK1	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK2	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK3	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK4	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK5	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK6	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:SCHKE	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:SMVCH	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/sblat2.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:SBLAT2	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK1	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK2	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK3	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK4	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:SCHK5	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:SCHKE	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:SMMCH	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/sblat3.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:SBLAT3	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK1	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK2	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK3	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK4	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK5	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK6	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:ZCHKE	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:ZMVCH	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/zblat2.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:ZBLAT2	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK1	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK2	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK3	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK4	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE COMPUTATIONAL TESTS (', I6, ' CALL',$/;"	l	subroutine:ZCHK5	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ', A6, ' PASSED THE TESTS OF ERROR-EXITS' )$/;"	l	subroutine:ZCHKE	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ***** ILLEGAL VALUE OF PARAMETER NUMBER ', I2, ' NOT D',$/;"	l	subroutine:CHKXER	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ******* FATAL ERROR - COMPUTED RESULT IS LESS THAN HAL',$/;"	l	subroutine:ZMMCH	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ******* XERBLA WAS CALLED WITH INFO = ', I6, ' INSTEAD',$/;"	l	subroutine:XERBLA	file:
9999	blas/testing/zblat3.f	/^ 9999 FORMAT( ' ROUTINES PASS COMPUTATIONAL TESTS IF TEST RATIO IS LES',$/;"	l	program:ZBLAT3	file:
99997	blas/testing/cblat1.f	/^99997 FORMAT (1X,I4,I3,3I5,2I36,I12)$/;"	l	subroutine:ITEST1	file:
99997	blas/testing/cblat1.f	/^99997 FORMAT (1X,I4,I3,3I5,I3,2E36.8,2E12.4)$/;"	l	subroutine:STEST	file:
99997	blas/testing/dblat1.f	/^99997 FORMAT (1X,I4,I3,1I5,I3,2E36.8,2E12.4)$/;"	l	subroutine:TESTDSDOT	file:
99997	blas/testing/dblat1.f	/^99997 FORMAT (1X,I4,I3,2I5,2I36,I12)$/;"	l	subroutine:ITEST1	file:
99997	blas/testing/dblat1.f	/^99997 FORMAT (1X,I4,I3,2I5,I3,2D36.8,2D12.4)$/;"	l	subroutine:STEST	file:
99997	blas/testing/sblat1.f	/^99997 FORMAT (1X,I4,I3,2I5,2I36,I12)$/;"	l	subroutine:ITEST1	file:
99997	blas/testing/sblat1.f	/^99997 FORMAT (1X,I4,I3,2I5,I3,2E36.8,2E12.4)$/;"	l	subroutine:STEST	file:
99997	blas/testing/zblat1.f	/^99997 FORMAT (1X,I4,I3,3I5,2I36,I12)$/;"	l	subroutine:ITEST1	file:
99997	blas/testing/zblat1.f	/^99997 FORMAT (1X,I4,I3,3I5,I3,2D36.8,2D12.4)$/;"	l	subroutine:STEST	file:
99998	blas/testing/cblat1.f	/^99998 FORMAT ('                                    ----- PASS -----')$/;"	l	program:CBLAT1	file:
99998	blas/testing/cblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY MODE                               ',$/;"	l	subroutine:ITEST1	file:
99998	blas/testing/cblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY MODE  I                            ',$/;"	l	subroutine:STEST	file:
99998	blas/testing/dblat1.f	/^99998 FORMAT ('                                    ----- PASS -----')$/;"	l	program:DBLAT1	file:
99998	blas/testing/dblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY                               ',$/;"	l	subroutine:ITEST1	file:
99998	blas/testing/dblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY                           ',$/;"	l	subroutine:TESTDSDOT	file:
99998	blas/testing/dblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY  I                            ',$/;"	l	subroutine:STEST	file:
99998	blas/testing/sblat1.f	/^99998 FORMAT ('                                    ----- PASS -----')$/;"	l	program:SBLAT1	file:
99998	blas/testing/sblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY                               ',$/;"	l	subroutine:ITEST1	file:
99998	blas/testing/sblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY  I                            ',$/;"	l	subroutine:STEST	file:
99998	blas/testing/zblat1.f	/^99998 FORMAT ('                                    ----- PASS -----')$/;"	l	program:ZBLAT1	file:
99998	blas/testing/zblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY MODE                               ',$/;"	l	subroutine:ITEST1	file:
99998	blas/testing/zblat1.f	/^99998 FORMAT (\/' CASE  N INCX INCY MODE  I                            ',$/;"	l	subroutine:STEST	file:
99999	blas/testing/cblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:ITEST1	file:
99999	blas/testing/cblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:STEST	file:
99999	blas/testing/cblat1.f	/^99999 FORMAT (' Complex BLAS Test Program Results',\/1X)$/;"	l	program:CBLAT1	file:
99999	blas/testing/cblat1.f	/^99999 FORMAT (\/' Test of subprogram number',I3,12X,A6)$/;"	l	subroutine:HEADER	file:
99999	blas/testing/dblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:ITEST1	file:
99999	blas/testing/dblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:STEST	file:
99999	blas/testing/dblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:TESTDSDOT	file:
99999	blas/testing/dblat1.f	/^99999 FORMAT (' Real BLAS Test Program Results',\/1X)$/;"	l	program:DBLAT1	file:
99999	blas/testing/dblat1.f	/^99999 FORMAT (\/' Test of subprogram number',I3,12X,A6)$/;"	l	subroutine:HEADER	file:
99999	blas/testing/sblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:ITEST1	file:
99999	blas/testing/sblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:STEST	file:
99999	blas/testing/sblat1.f	/^99999 FORMAT (' Real BLAS Test Program Results',\/1X)$/;"	l	program:SBLAT1	file:
99999	blas/testing/sblat1.f	/^99999 FORMAT (\/' Test of subprogram number',I3,12X,A6)$/;"	l	subroutine:HEADER	file:
99999	blas/testing/zblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:ITEST1	file:
99999	blas/testing/zblat1.f	/^99999 FORMAT ('                                       FAIL')$/;"	l	subroutine:STEST	file:
99999	blas/testing/zblat1.f	/^99999 FORMAT (' Complex BLAS Test Program Results',\/1X)$/;"	l	program:ZBLAT1	file:
99999	blas/testing/zblat1.f	/^99999 FORMAT (\/' Test of subprogram number',I3,12X,A6)$/;"	l	subroutine:HEADER	file:
A	bench/bench_gemm.cpp	/^typedef Matrix<SCALARA,Dynamic,Dynamic> A;$/;"	t	file:
A	bench/btl/actions/action_aat_product.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_aat_product
A	bench/btl/actions/action_ata_product.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_ata_product
A	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_atv_product
A	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_ger
A	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_matrix_matrix_product
A	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_matrix_vector_product
A	bench/btl/actions/action_rot.hh	/^  typename Interface::gene_vector A;$/;"	m	class:Action_rot
A	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_symv
A	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_syr2
A	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_trisolve_matrix
A	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix A;$/;"	m	class:Action_trmm
A	bench/geometry.cpp	/^typedef Matrix<RealScalar,Dynamic,Dynamic> A;$/;"	t	file:
A	blas/testing/cblat2.f	/^      COMPLEX            A(/;"	v	program:CBLAT2
A	blas/testing/dblat2.f	/^      DOUBLE PRECISION   A(/;"	v	program:DBLAT2
A	blas/testing/sblat2.f	/^      REAL/;"	v	program:SBLAT2
A	blas/testing/zblat2.f	/^      COMPLEX*16         A(/;"	v	program:ZBLAT2
A	doc/snippets/ComplexEigenSolver_compute.cpp	/^MatrixXcf A = MatrixXcf::Random(4,4);$/;"	v
A	doc/snippets/ComplexSchur_compute.cpp	/^MatrixXcf A = MatrixXcf::Random(4,4);$/;"	v
A	doc/snippets/ComplexSchur_matrixT.cpp	/^MatrixXcf A = MatrixXcf::Random(4,4);$/;"	v
A	doc/snippets/ComplexSchur_matrixU.cpp	/^MatrixXcf A = MatrixXcf::Random(4,4);$/;"	v
A	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^MatrixXd A = MatrixXd::Random(6,6);$/;"	v
A	doc/snippets/EigenSolver_compute.cpp	/^MatrixXf A = MatrixXf::Random(4,4);$/;"	v
A	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^MatrixXd A = MatrixXd::Random(6,6);$/;"	v
A	doc/snippets/GeneralizedEigenSolver.cpp	/^MatrixXf A = MatrixXf::Random(4,4);$/;"	v
A	doc/snippets/HessenbergDecomposition_compute.cpp	/^MatrixXcf A = MatrixXcf::Random(4,4);$/;"	v
A	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^Matrix4f A = MatrixXf::Random(4,4);$/;"	v
A	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^Matrix4d A = Matrix4d::Random(4,4);$/;"	v
A	doc/snippets/LeastSquaresNormalEquations.cpp	/^MatrixXf A = MatrixXf::Random(3, 2);$/;"	v
A	doc/snippets/LeastSquaresQR.cpp	/^MatrixXf A = MatrixXf::Random(3, 2);$/;"	v
A	doc/snippets/MatrixBase_applyOnTheLeft.cpp	/^Matrix3f A = Matrix3f::Random(3,3), B;$/;"	v
A	doc/snippets/MatrixBase_applyOnTheRight.cpp	/^Matrix3f A = Matrix3f::Random(3,3), B;$/;"	v
A	doc/snippets/Matrix_Map_stride.cpp	/^Matrix4i A;$/;"	v
A	doc/snippets/PartialPivLU_solve.cpp	/^MatrixXd A = MatrixXd::Random(3,3);$/;"	v
A	doc/snippets/RealQZ_compute.cpp	/^MatrixXf A = MatrixXf::Random(4,4);$/;"	v
A	doc/snippets/RealSchur_RealSchur_MatrixType.cpp	/^MatrixXd A = MatrixXd::Random(6,6);$/;"	v
A	doc/snippets/RealSchur_compute.cpp	/^MatrixXf A = MatrixXf::Random(4,4);$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver.cpp	/^Matrix4f A = X + X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^MatrixXd A = X + X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^MatrixXd A = X + X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_compute_MatrixType.cpp	/^MatrixXf A = X + X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp	/^MatrixXd A = X * X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp	/^MatrixXd A = X * X.transpose();$/;"	v
A	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^MatrixXd A = X * X.transpose();$/;"	v
A	doc/snippets/TopicAliasing_mult4.cpp	/^cout << A;/;"	v
A	doc/snippets/TopicAliasing_mult5.cpp	/^cout << A;$/;"	v
A	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^MatrixXd A = X + X.transpose();$/;"	v
A	doc/snippets/Tridiagonalization_compute.cpp	/^MatrixXf A = X + X.transpose();$/;"	v
A	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^MatrixXd A = X + X.transpose();$/;"	v
A	doc/snippets/Tridiagonalization_diagonal.cpp	/^MatrixXcd A = X + X.adjoint();$/;"	v
A	doc/snippets/Tridiagonalization_householderCoefficients.cpp	/^Matrix4d A = X + X.transpose();$/;"	v
A	doc/snippets/Tridiagonalization_packedMatrix.cpp	/^Matrix4d A = X + X.transpose();$/;"	v
A	doc/snippets/Tutorial_solve_matrix_inverse.cpp	/^Matrix3f A;$/;"	v
A	doc/snippets/Tutorial_solve_singular.cpp	/^Matrix3f A;$/;"	v
A	doc/snippets/Tutorial_solve_triangular.cpp	/^Matrix3f A;$/;"	v
A	doc/snippets/Tutorial_solve_triangular_inplace.cpp	/^Matrix3f A;$/;"	v
A	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols> A;$/;"	t	struct:Eigen::internal::make_coherent_impl
AA	blas/testing/cblat2.f	/^      COMPLEX            A( NMAX, NMAX ), AA(/;"	v	program:CBLAT2
AA	blas/testing/cblat3.f	/^      COMPLEX            AA(/;"	v	program:CBLAT3
AA	blas/testing/dblat2.f	/^      DOUBLE PRECISION   A( NMAX, NMAX ), AA(/;"	v	program:DBLAT2
AA	blas/testing/dblat3.f	/^      DOUBLE PRECISION   AA(/;"	v	program:DBLAT3
AA	blas/testing/sblat2.f	/^      REAL               A( NMAX, NMAX ), AA(/;"	v	program:SBLAT2
AA	blas/testing/sblat3.f	/^      REAL               AA(/;"	v	program:SBLAT3
AA	blas/testing/zblat2.f	/^      COMPLEX*16         A( NMAX, NMAX ), AA(/;"	v	program:ZBLAT2
AA	blas/testing/zblat3.f	/^      COMPLEX*16         AA(/;"	v	program:ZBLAT3
AAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    AAlignment = traits<Derived>::Alignment,$/;"	e	enum:Eigen::internal::quat_product::__anon272
AB	blas/testing/cblat3.f	/^      COMPLEX            AA( NMAX*NMAX ), AB(/;"	v	program:CBLAT3
AB	blas/testing/dblat3.f	/^      DOUBLE PRECISION   AA( NMAX*NMAX ), AB(/;"	v	program:DBLAT3
AB	blas/testing/sblat3.f	/^      REAL               AA( NMAX*NMAX ), AB(/;"	v	program:SBLAT3
AB	blas/testing/zblat3.f	/^      COMPLEX*16         AA( NMAX*NMAX ), AB(/;"	v	program:ZBLAT3
ABx_lx	Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
ACTION_AAT_PRODUCT	bench/btl/actions/action_aat_product.hh	21;"	d
ACTION_ATA_PRODUCT	bench/btl/actions/action_ata_product.hh	21;"	d
ACTION_ATV_PRODUCT	bench/btl/actions/action_atv_product.hh	21;"	d
ACTION_AXPBY	bench/btl/actions/action_axpby.hh	20;"	d
ACTION_AXPY	bench/btl/actions/action_axpy.hh	21;"	d
ACTION_CHOLESKY	bench/btl/actions/action_cholesky.hh	20;"	d
ACTION_GER	bench/btl/actions/action_ger.hh	16;"	d
ACTION_HESSENBERG	bench/btl/actions/action_hessenberg.hh	20;"	d
ACTION_LU_DECOMP	bench/btl/actions/action_lu_decomp.hh	20;"	d
ACTION_LU_SOLVE	bench/btl/actions/action_lu_solve.hh	21;"	d
ACTION_MATRIX_MATRIX_PRODUCT	bench/btl/actions/action_matrix_matrix_product.hh	21;"	d
ACTION_MATRIX_MATRIX_PRODUCT_BIS	bench/btl/actions/action_matrix_matrix_product_bis.hh	21;"	d
ACTION_MATRIX_VECTOR_PRODUCT	bench/btl/actions/action_matrix_vector_product.hh	21;"	d
ACTION_PARTIAL_LU	bench/btl/actions/action_partial_lu.hh	20;"	d
ACTION_ROT	bench/btl/actions/action_rot.hh	16;"	d
ACTION_SYMV	bench/btl/actions/action_symv.hh	21;"	d
ACTION_SYR2	bench/btl/actions/action_syr2.hh	21;"	d
ACTION_TRISOLVE	bench/btl/actions/action_trisolve.hh	20;"	d
ACTION_TRISOLVE_MATRIX_PRODUCT	bench/btl/actions/action_trisolve_matrix.hh	21;"	d
ACTION_TRMM	bench/btl/actions/action_trmm.hh	21;"	d
ADJ	blas/common.h	26;"	d
ALF	blas/testing/cblat2.f	/^      COMPLEX            A( NMAX, NMAX ), AA( NMAX*NMAX ),$/;"	v	program:CBLAT2
ALF	blas/testing/cblat3.f	/^      COMPLEX            AA( NMAX*NMAX ), AB( NMAX, 2*NMAX ),$/;"	v	program:CBLAT3
ALF	blas/testing/dblat2.f	/^      DOUBLE PRECISION   A( NMAX, NMAX ), AA( NMAX*NMAX ),$/;"	v	program:DBLAT2
ALF	blas/testing/dblat3.f	/^      DOUBLE PRECISION   AA( NMAX*NMAX ), AB( NMAX, 2*NMAX ),$/;"	v	program:DBLAT3
ALF	blas/testing/sblat2.f	/^      REAL               A( NMAX, NMAX ), AA( NMAX*NMAX ),$/;"	v	program:SBLAT2
ALF	blas/testing/sblat3.f	/^      REAL               AA( NMAX*NMAX ), AB( NMAX, 2*NMAX ),$/;"	v	program:SBLAT3
ALF	blas/testing/zblat2.f	/^      COMPLEX*16         A( NMAX, NMAX ), AA( NMAX*NMAX ),$/;"	v	program:ZBLAT2
ALF	blas/testing/zblat3.f	/^      COMPLEX*16         AA( NMAX*NMAX ), AB( NMAX, 2*NMAX ),$/;"	v	program:ZBLAT3
ALIGNMENT	test/dynalloc.cpp	13;"	d	file:
ALIGNMENT	test/dynalloc.cpp	15;"	d	file:
ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	108;"	d
AMDOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class AMDOrdering$/;"	c	namespace:Eigen
APIBase	Eigen/src/SparseLU/SparseLU.h	/^    typedef SparseSolverBase<SparseLU<_MatrixType,_OrderingType> > APIBase;$/;"	t	class:Eigen::SparseLU
AS	blas/testing/cblat2.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:CBLAT2
AS	blas/testing/cblat3.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:CBLAT3
AS	blas/testing/dblat2.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:DBLAT2
AS	blas/testing/dblat3.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:DBLAT3
AS	blas/testing/sblat2.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:SBLAT2
AS	blas/testing/sblat3.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:SBLAT3
AS	blas/testing/zblat2.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:ZBLAT2
AS	blas/testing/zblat3.f	/^     $                   ALF( NALMAX ), AS(/;"	v	program:ZBLAT3
ASSERT	bench/btl/generic_bench/utils/utilities.h	63;"	d
ASSERT	bench/btl/generic_bench/utils/utilities.h	80;"	d
ASSIGN	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	147;"	d
ASSIGN	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	163;"	d
ASSIGNCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	84;"	d
ASSIGNCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	91;"	d
ASSIGNEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	112;"	d
ASSIGNEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	120;"	d
A_ref	bench/btl/actions/action_aat_product.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_aat_product
A_ref	bench/btl/actions/action_ata_product.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_ata_product
A_ref	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_atv_product
A_ref	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_ger
A_ref	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_matrix_matrix_product
A_ref	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_matrix_vector_product
A_ref	bench/btl/actions/action_rot.hh	/^  typename Interface::gene_vector A_ref;$/;"	m	class:Action_rot
A_ref	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_symv
A_ref	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_syr2
A_ref	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_trisolve_matrix
A_ref	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix A_ref;$/;"	m	class:Action_trmm
A_stl	bench/btl/actions/action_aat_product.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_aat_product
A_stl	bench/btl/actions/action_ata_product.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_ata_product
A_stl	bench/btl/actions/action_atv_product.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_atv_product
A_stl	bench/btl/actions/action_ger.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_ger
A_stl	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_matrix_matrix_product
A_stl	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_matrix_vector_product
A_stl	bench/btl/actions/action_rot.hh	/^  typename Interface::stl_vector A_stl;$/;"	m	class:Action_rot
A_stl	bench/btl/actions/action_symv.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_symv
A_stl	bench/btl/actions/action_syr2.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_syr2
A_stl	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_trisolve_matrix
A_stl	bench/btl/actions/action_trmm.hh	/^  typename Interface::stl_matrix A_stl;$/;"	m	class:Action_trmm
Abs	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    struct Abs$/;"	s	namespace:Eigen::internal
Abs	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    struct Abs<Num, false>$/;"	s	namespace:Eigen::internal
Abs2ReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived> Abs2ReturnType;$/;"	t
AbsReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived> AbsReturnType;$/;"	t
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacketType,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccessorConstructor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct AccessorConstructor{$/;"	s	namespace:Eigen::TensorSycl::internal
AccessorLevels	Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
Acolmajor	doc/snippets/TopicStorageOrders_example.cpp	/^Matrix<int, 3, 4, ColMajor> Acolmajor;$/;"	v
AcosReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_acos_op<Scalar>, const Derived> AcosReturnType;$/;"	t
Action	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
Action_aat_product	bench/btl/actions/action_aat_product.hh	/^  Action_aat_product( const  Action_aat_product & )$/;"	f	class:Action_aat_product
Action_aat_product	bench/btl/actions/action_aat_product.hh	/^  Action_aat_product( int size ):_size(size)$/;"	f	class:Action_aat_product
Action_aat_product	bench/btl/actions/action_aat_product.hh	/^class Action_aat_product {$/;"	c
Action_ata_product	bench/btl/actions/action_ata_product.hh	/^  Action_ata_product( const  Action_ata_product & )$/;"	f	class:Action_ata_product
Action_ata_product	bench/btl/actions/action_ata_product.hh	/^  Action_ata_product( int size ):_size(size)$/;"	f	class:Action_ata_product
Action_ata_product	bench/btl/actions/action_ata_product.hh	/^class Action_ata_product {$/;"	c
Action_atv_product	bench/btl/actions/action_atv_product.hh	/^  Action_atv_product( const  Action_atv_product & )$/;"	f	class:Action_atv_product
Action_atv_product	bench/btl/actions/action_atv_product.hh	/^  Action_atv_product( int size ) : _size(size)$/;"	f	class:Action_atv_product
Action_atv_product	bench/btl/actions/action_atv_product.hh	/^class Action_atv_product {$/;"	c
Action_axpby	bench/btl/actions/action_axpby.hh	/^  Action_axpby( const  Action_axpby & )$/;"	f	class:Action_axpby
Action_axpby	bench/btl/actions/action_axpby.hh	/^  Action_axpby( int size ):_alpha(0.5),_beta(0.95),_size(size)$/;"	f	class:Action_axpby
Action_axpby	bench/btl/actions/action_axpby.hh	/^class Action_axpby {$/;"	c
Action_axpy	bench/btl/actions/action_axpy.hh	/^  Action_axpy( const  Action_axpy & )$/;"	f	class:Action_axpy
Action_axpy	bench/btl/actions/action_axpy.hh	/^  Action_axpy( int size ):_coef(1.0),_size(size)$/;"	f	class:Action_axpy
Action_axpy	bench/btl/actions/action_axpy.hh	/^class Action_axpy {$/;"	c
Action_cholesky	bench/btl/actions/action_cholesky.hh	/^  Action_cholesky( const  Action_cholesky & )$/;"	f	class:Action_cholesky
Action_cholesky	bench/btl/actions/action_cholesky.hh	/^  Action_cholesky( int size ):_size(size)$/;"	f	class:Action_cholesky
Action_cholesky	bench/btl/actions/action_cholesky.hh	/^class Action_cholesky {$/;"	c
Action_ger	bench/btl/actions/action_ger.hh	/^  Action_ger( const  Action_ger & )$/;"	f	class:Action_ger
Action_ger	bench/btl/actions/action_ger.hh	/^  BTL_DONT_INLINE Action_ger( int size ):_size(size)$/;"	f	class:Action_ger
Action_ger	bench/btl/actions/action_ger.hh	/^class Action_ger {$/;"	c
Action_hessenberg	bench/btl/actions/action_hessenberg.hh	/^  Action_hessenberg( const  Action_hessenberg & )$/;"	f	class:Action_hessenberg
Action_hessenberg	bench/btl/actions/action_hessenberg.hh	/^  Action_hessenberg( int size ):_size(size)$/;"	f	class:Action_hessenberg
Action_hessenberg	bench/btl/actions/action_hessenberg.hh	/^class Action_hessenberg {$/;"	c
Action_lu_decomp	bench/btl/actions/action_lu_decomp.hh	/^  Action_lu_decomp( const  Action_lu_decomp & )$/;"	f	class:Action_lu_decomp
Action_lu_decomp	bench/btl/actions/action_lu_decomp.hh	/^  Action_lu_decomp( int size ):_size(size)$/;"	f	class:Action_lu_decomp
Action_lu_decomp	bench/btl/actions/action_lu_decomp.hh	/^class Action_lu_decomp {$/;"	c
Action_lu_solve	bench/btl/actions/action_lu_solve.hh	/^class Action_lu_solve $/;"	c
Action_matrix_matrix_product	bench/btl/actions/action_matrix_matrix_product.hh	/^  Action_matrix_matrix_product( const  Action_matrix_matrix_product & )$/;"	f	class:Action_matrix_matrix_product
Action_matrix_matrix_product	bench/btl/actions/action_matrix_matrix_product.hh	/^  Action_matrix_matrix_product( int size ):_size(size)$/;"	f	class:Action_matrix_matrix_product
Action_matrix_matrix_product	bench/btl/actions/action_matrix_matrix_product.hh	/^class Action_matrix_matrix_product {$/;"	c
Action_matrix_matrix_product_bis	bench/btl/actions/action_matrix_matrix_product_bis.hh	/^class Action_matrix_matrix_product_bis {$/;"	c
Action_matrix_vector_product	bench/btl/actions/action_matrix_vector_product.hh	/^  Action_matrix_vector_product( const  Action_matrix_vector_product & )$/;"	f	class:Action_matrix_vector_product
Action_matrix_vector_product	bench/btl/actions/action_matrix_vector_product.hh	/^  BTL_DONT_INLINE Action_matrix_vector_product( int size ):_size(size)$/;"	f	class:Action_matrix_vector_product
Action_matrix_vector_product	bench/btl/actions/action_matrix_vector_product.hh	/^class Action_matrix_vector_product {$/;"	c
Action_partial_lu	bench/btl/actions/action_partial_lu.hh	/^  Action_partial_lu( const  Action_partial_lu & )$/;"	f	class:Action_partial_lu
Action_partial_lu	bench/btl/actions/action_partial_lu.hh	/^  Action_partial_lu( int size ):_size(size)$/;"	f	class:Action_partial_lu
Action_partial_lu	bench/btl/actions/action_partial_lu.hh	/^class Action_partial_lu {$/;"	c
Action_rot	bench/btl/actions/action_rot.hh	/^  Action_rot( const  Action_rot & )$/;"	f	class:Action_rot
Action_rot	bench/btl/actions/action_rot.hh	/^  BTL_DONT_INLINE Action_rot( int size ):_size(size)$/;"	f	class:Action_rot
Action_rot	bench/btl/actions/action_rot.hh	/^class Action_rot {$/;"	c
Action_symv	bench/btl/actions/action_symv.hh	/^  Action_symv( const  Action_symv & )$/;"	f	class:Action_symv
Action_symv	bench/btl/actions/action_symv.hh	/^  BTL_DONT_INLINE Action_symv( int size ):_size(size)$/;"	f	class:Action_symv
Action_symv	bench/btl/actions/action_symv.hh	/^class Action_symv {$/;"	c
Action_syr2	bench/btl/actions/action_syr2.hh	/^  Action_syr2( const  Action_syr2 & )$/;"	f	class:Action_syr2
Action_syr2	bench/btl/actions/action_syr2.hh	/^  BTL_DONT_INLINE Action_syr2( int size ):_size(size)$/;"	f	class:Action_syr2
Action_syr2	bench/btl/actions/action_syr2.hh	/^class Action_syr2 {$/;"	c
Action_tridiagonalization	bench/btl/actions/action_hessenberg.hh	/^  Action_tridiagonalization( const  Action_tridiagonalization & )$/;"	f	class:Action_tridiagonalization
Action_tridiagonalization	bench/btl/actions/action_hessenberg.hh	/^  Action_tridiagonalization( int size ):_size(size)$/;"	f	class:Action_tridiagonalization
Action_tridiagonalization	bench/btl/actions/action_hessenberg.hh	/^class Action_tridiagonalization {$/;"	c
Action_trisolve	bench/btl/actions/action_trisolve.hh	/^  Action_trisolve( const  Action_trisolve & )$/;"	f	class:Action_trisolve
Action_trisolve	bench/btl/actions/action_trisolve.hh	/^  Action_trisolve( int size ):_size(size)$/;"	f	class:Action_trisolve
Action_trisolve	bench/btl/actions/action_trisolve.hh	/^class Action_trisolve {$/;"	c
Action_trisolve_matrix	bench/btl/actions/action_trisolve_matrix.hh	/^  Action_trisolve_matrix( const  Action_trisolve_matrix & )$/;"	f	class:Action_trisolve_matrix
Action_trisolve_matrix	bench/btl/actions/action_trisolve_matrix.hh	/^  Action_trisolve_matrix( int size ):_size(size)$/;"	f	class:Action_trisolve_matrix
Action_trisolve_matrix	bench/btl/actions/action_trisolve_matrix.hh	/^class Action_trisolve_matrix {$/;"	c
Action_trmm	bench/btl/actions/action_trmm.hh	/^  Action_trmm( const  Action_trmm & )$/;"	f	class:Action_trmm
Action_trmm	bench/btl/actions/action_trmm.hh	/^  Action_trmm( int size ):_size(size)$/;"	f	class:Action_trmm
Action_trmm	bench/btl/actions/action_trmm.hh	/^class Action_trmm {$/;"	c
ActiveInput	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<ActiveScalar, InputsAtCompileTime, 1> ActiveInput;$/;"	t	class:Eigen::AutoDiffJacobian
ActiveScalar	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef AutoDiffScalar<DerivativeType> ActiveScalar;$/;"	t	class:Eigen::AutoDiffJacobian
ActiveScalar	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef AutoDiffScalar<Matrix<BaseScalar,JacobianType::RowsAtCompileTime,1> > ActiveScalar;$/;"	t	class:Eigen::AutoDiffVector
ActiveValue	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<ActiveScalar, ValuesAtCompileTime, 1> ActiveValue;$/;"	t	class:Eigen::AutoDiffJacobian
ActualCols	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon614
ActualIndex	Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon477
ActualLhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^            Lhs1, SparseView<Lhs1> >::type ActualLhs;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
ActualLhsType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualLhsType	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualLhsType	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualLhsTypeCleaned	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename internal::remove_all<ActualLhsType>::type ActualLhsTypeCleaned;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualLhsTypeCleaned	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename internal::remove_all<ActualLhsType>::type ActualLhsTypeCleaned;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualMatrixType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef MatrixType ActualMatrixType;$/;"	t	class:Eigen::internal::generic_matrix_wrapper
ActualMatrixType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef Ref<const MatrixType> ActualMatrixType;$/;"	t	class:Eigen::internal::generic_matrix_wrapper
ActualMatrixType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixWrapper::ActualMatrixType ActualMatrixType;$/;"	t	class:Eigen::IterativeSolverBase
ActualMatrixType	Eigen/src/LU/arch/Inverse_SSE.h	/^  typedef typename conditional<(MatrixType::Flags&LinearAccessBit),MatrixType const &,typename MatrixType::PlainObject>::type ActualMatrixType;$/;"	t	struct:Eigen::internal::compute_inverse_size4
ActualPacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
ActualPacketSize	Eigen/src/Core/AssignEvaluator.h	/^    ActualPacketSize    = int(Traversal)==LinearVectorizedTraversal ? LinearPacketSize$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon509
ActualRhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename conditional<NeedToTranspose,LhsT,RhsT>::type ActualRhs;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
ActualRhsType	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualRhsType	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRhsType	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRhsTypeCleaned	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;$/;"	t	struct:Eigen::internal::generic_product_impl
ActualRhsTypeCleaned	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
ActualRows	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon614
AddCost	Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
AddCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int AddCost() {$/;"	f	class:Eigen::TensorOpCost
AddCost	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^    AddCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon123
AdditionalProductEvaluationMode	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	g	namespace:Eigen
AdjointReturnType	Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase
AdjointReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;$/;"	t	class:Eigen::SelfAdjointView
AdjointReturnType	Eigen/src/Core/SolverBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SolverBase
AdjointReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;$/;"	t	class:Eigen::TriangularView
AdjointReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Affine	Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Affine2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact	Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
AffineCompact2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffinePart	Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform
AffinePart	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
AffineTransformType	Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation
AliasFreeProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
Aligned	Eigen/src/Core/util/Constants.h	/^  Aligned=16,         \/**< \\deprecated Synonym for Aligned16. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned128	Eigen/src/Core/util/Constants.h	/^  Aligned128=128,     \/**< Data pointer is aligned on a 128 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned16	Eigen/src/Core/util/Constants.h	/^  Aligned16=16,       \/**< Data pointer is aligned on a 16 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned32	Eigen/src/Core/util/Constants.h	/^  Aligned32=32,       \/**< Data pointer is aligned on a 32 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned64	Eigen/src/Core/util/Constants.h	/^  Aligned64=64,       \/**< Data pointer is aligned on a 64 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
Aligned8	Eigen/src/Core/util/Constants.h	/^  Aligned8=8,         \/**< Data pointer is aligned on a 8 bytes boundary. *\/$/;"	e	enum:Eigen::AlignmentType
AlignedBit	Eigen/src/Core/util/Constants.h	/^EIGEN_DEPRECATED const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline explicit AlignedBox(const MatrixBase<Derived>& p) : m_min(p), m_max(m_min)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, AlignedMax> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
AlignedMask	Eigen/src/Core/util/Constants.h	/^  AlignedMask=255,$/;"	e	enum:Eigen::AlignmentType
AlignedMax	Eigen/src/Core/util/Constants.h	/^  AlignedMax = Aligned128$/;"	e	enum:Eigen::AlignmentType
AlignedOnScalar	Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon497
AlignedOnScalar	Eigen/src/Core/arch/AVX/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
AlignedOnScalar	Eigen/src/Core/arch/AVX/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
AlignedOnScalar	Eigen/src/Core/arch/AVX/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
AlignedOnScalar	Eigen/src/Core/arch/AVX/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
AlignedOnScalar	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
AlignedOnScalar	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
AlignedOnScalar	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
AlignedOnScalar	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
AlignedOnScalar	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
AlignedOnScalar	Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
AlignedOnScalar	Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
AlignedOnScalar	Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
AlignedOnScalar	Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon709
AlignedOnScalar	Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
AlignedOnScalar	Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
AlignedOnScalar	Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon740
AlignedOnScalar	Eigen/src/Core/arch/ZVector/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
AlignedOnScalar	Eigen/src/Core/arch/ZVector/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
AlignedOnScalar	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
AlignedOnScalar	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
AlignedOnScalar	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
AlignedScaling2d	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
Alignment	Eigen/src/Core/Block.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::traits::__anon464
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME in some rare cases, Alignment could be preserved, like a Vector4f.$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME it is not very clear why alignment is necessarily lost...$/;"	e	enum:Eigen::internal::unary_evaluator::__anon757
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0 \/\/ FIXME this will need to be improved once PartialReduxExpr is vectorized$/;"	e	enum:Eigen::internal::evaluator::__anon767
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::evaluator::__anon770
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = 0$/;"	e	enum:Eigen::internal::evaluator_base::__anon750
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = AlignedMax$/;"	e	enum:Eigen::internal::evaluator::__anon753
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN($/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)$/;"	e	enum:Eigen::internal::evaluator::__anon761
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ThenMatrixType>::Alignment, evaluator<ElseMatrixType>::Alignment)$/;"	e	enum:Eigen::internal::evaluator::__anon763
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon768
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon752
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgType>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon754
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<ArgTypeNestedCleaned>::Alignment$/;"	e	enum:Eigen::internal::unary_evaluator::__anon765
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Alignment$/;"	e	enum:Eigen::internal::evaluator::__anon760
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = int(MapOptions)&int(AlignedMask)$/;"	e	enum:Eigen::internal::evaluator::__anon759
Alignment	Eigen/src/Core/CoreEvaluators.h	/^    Alignment = traits<Derived>::Alignment$/;"	e	enum:Eigen::internal::evaluator::__anon751
Alignment	Eigen/src/Core/Map.h	/^    Alignment = int(MapOptions)&int(AlignedMask),$/;"	e	enum:Eigen::internal::traits::__anon748
Alignment	Eigen/src/Core/Matrix.h	/^    Alignment = actual_alignment$/;"	e	enum:Eigen::internal::traits::__anon439
Alignment	Eigen/src/Core/ProductEvaluators.h	/^    Alignment = bool(CanVectorizeLhs) ? (LhsOuterStrideBytes<=0 || (int(LhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,LhsAlignment))!=0 ? 0 : LhsAlignment)$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
Alignment	Eigen/src/Core/ProductEvaluators.h	/^    Alignment = evaluator<MatrixType>::Alignment,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
Alignment	Eigen/src/Core/Redux.h	/^    Alignment = evaluator<XprType>::Alignment$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
Alignment	Eigen/src/Core/Ref.h	/^    Alignment = traits<Map<_PlainObjectType, _Options, _StrideType> >::Alignment$/;"	e	enum:Eigen::internal::traits::__anon473
Alignment	Eigen/src/Geometry/Quaternion.h	/^    Alignment = internal::traits<Coefficients>::Alignment,$/;"	e	enum:Eigen::internal::traits::__anon250
Alignment	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon812
Alignment	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon811
Alignment0	Eigen/src/Core/CoreEvaluators.h	/^    Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic)$/;"	e	enum:Eigen::internal::evaluator::__anon761
AlignmentMask	Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon244
AlignmentMatch	Eigen/src/Core/Ref.h	/^      AlignmentMatch = (int(traits<PlainObjectType>::Alignment)==int(Unaligned)) || (DerivedAlignment >= int(Alignment)), \/\/ FIXME the first condition is not very clear, it should be replaced by the required alignment$/;"	e	enum:Eigen::internal::traits::match::__anon474
AlignmentType	Eigen/src/Core/util/Constants.h	/^enum AlignmentType {$/;"	g	namespace:Eigen
AllAtOnceTraversal	Eigen/src/Core/util/Constants.h	/^  AllAtOnceTraversal$/;"	e	enum:Eigen::TraversalType
AllReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_all>::Type AllReturnType;$/;"	t	class:Eigen::VectorwiseOp
AlphaAxis	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static const int AlphaAxis = _AlphaAxis;$/;"	m	class:Eigen::EulerSystem
AlphaAxisAbs	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      AlphaAxisAbs = internal::Abs<AlphaAxis>::value, \/*!< the first rotation axis unsigned *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
AlphaAxisVector	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      static Vector3 AlphaAxisVector() {$/;"	f	class:Eigen::EulerAngles
AltiVec	Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^    explicit AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector
AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
AmbiVectorMode	Eigen/src/Core/util/Constants.h	/^enum AmbiVectorMode {$/;"	g	namespace:Eigen
AmbientDimAtCompileTime	Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon253
AmbientDimAtCompileTime	Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon248
AmbientDimAtCompileTime	Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon245
Ancestor	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
Ancestor	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_all<Arg1>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
AndReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct AndReducer$/;"	s	namespace:Eigen::internal
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxisType	Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase
AngleAxisType	Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisType	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef AngleAxis<Scalar> AngleAxisType; \/*!< the equivalent angle-axis type *\/$/;"	t	class:Eigen::EulerAngles
AngleAxisd	Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AntiHermiticity	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct AntiHermiticity$/;"	s	namespace:Eigen
AntiSymmetry	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct AntiSymmetry$/;"	s	namespace:Eigen
AnyReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_any>::Type AnyReturnType;$/;"	t	class:Eigen::VectorwiseOp
Architecture	Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Arg	bench/tensors/benchmark_main.cc	/^Benchmark* Benchmark::Arg(int arg) {$/;"	f	class:testing::Benchmark
Arg1	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg1Type>::type Arg1;$/;"	t	class:Eigen::CwiseTernaryOp
Arg1Flags	Eigen/src/Core/CoreEvaluators.h	/^    Arg1Flags = evaluator<Arg1>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Arg1Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg1::Nested Arg1Nested;$/;"	t	struct:Eigen::internal::traits
Arg1Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg1Type>::type Arg1Nested;$/;"	t	class:Eigen::CwiseTernaryOp
Arg1Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename Arg1XprType::Nested Arg1Nested;$/;"	t	struct:Eigen::internal::traits
Arg1Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg1, N - Arg2LeafCount>::Type Arg1Type;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg1Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg1, N - Arg3LeafCount - Arg2LeafCount>::Type Arg1Type;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg2	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg2Type>::type Arg2;$/;"	t	class:Eigen::CwiseTernaryOp
Arg2Flags	Eigen/src/Core/CoreEvaluators.h	/^    Arg2Flags = evaluator<Arg2>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Arg2LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  static const size_t Arg2LeafCount = LeafCount<Arg2>::Count;$/;"	m	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg2Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg2::Nested Arg2Nested;$/;"	t	struct:Eigen::internal::traits
Arg2Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg2Type>::type Arg2Nested;$/;"	t	class:Eigen::CwiseTernaryOp
Arg2Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename Arg2XprType::Nested Arg2Nested;$/;"	t	struct:Eigen::internal::traits
Arg2Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg2, N - Arg3LeafCount>::Type Arg2Type;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg2Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg2, N>::Type Arg2Type;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg3	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_all<Arg3Type>::type Arg3;$/;"	t	class:Eigen::CwiseTernaryOp
Arg3Flags	Eigen/src/Core/CoreEvaluators.h	/^    Arg3Flags = evaluator<Arg3>::Flags,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Arg3LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  static const size_t Arg3LeafCount = LeafCount<Arg3>::Count;$/;"	m	struct:Eigen::TensorSycl::internal::CalculateIndex
Arg3Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename Arg3::Nested Arg3Nested;$/;"	t	struct:Eigen::internal::traits
Arg3Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::ref_selector<Arg3Type>::type Arg3Nested;$/;"	t	class:Eigen::CwiseTernaryOp
Arg3Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename Arg3XprType::Nested Arg3Nested;$/;"	t	struct:Eigen::internal::traits
Arg3Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg3, N>::Type Arg3Type;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
ArgMaxTupleReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct ArgMaxTupleReducer$/;"	s	namespace:Eigen::internal
ArgMinTupleReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct ArgMinTupleReducer$/;"	s	namespace:Eigen::internal
ArgReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_arg_op<Scalar>, const Derived> ArgReturnType;$/;"	t
ArgType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename remove_all<typename XprType::NestedExpressionType>::type ArgType;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
ArgType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef TensorCustomUnaryOp<CustomUnaryFunc, XprType> ArgType;$/;"	t	struct:Eigen::TensorEvaluator
ArgType	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Arg, N>::Type ArgType;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
ArgTypeIsRowMajor	Eigen/src/Core/CoreEvaluators.h	/^    ArgTypeIsRowMajor = (int(evaluator<ArgType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::evaluator::__anon761
ArgTypeNested	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;$/;"	t	struct:Eigen::internal::evaluator
ArgTypeNested	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::nested_eval<ArgType,Factor>::type ArgTypeNested;$/;"	t	struct:Eigen::internal::unary_evaluator
ArgTypeNestedCleaned	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;$/;"	t	struct:Eigen::internal::evaluator
ArgTypeNestedCleaned	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;$/;"	t	struct:Eigen::internal::unary_evaluator
ArgsTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef utility::tuple::Tuple<Arg1Type, Arg2Type, Arg3Type> ArgsTuple;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
ArgsTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef utility::tuple::Tuple<Arg1Type, Arg2Type> ArgsTuple;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
ArgsTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef utility::tuple::Tuple<ArgType> ArgsTuple;$/;"	t	struct:Eigen::TensorSycl::internal::CalculateIndex
Around	demos/opengl/trackball.h	/^    enum Mode {Around, Local};$/;"	e	enum:Trackball::Mode
Arowmajor	doc/snippets/TopicStorageOrders_example.cpp	/^Matrix<int, 3, 4, RowMajor> Arowmajor = Acolmajor;$/;"	v
ArpackGeneralizedSelfAdjointEigenSolver	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  ArpackGeneralizedSelfAdjointEigenSolver()$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
ArpackGeneralizedSelfAdjointEigenSolver	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  ArpackGeneralizedSelfAdjointEigenSolver(const MatrixType& A, const MatrixType& B,$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
ArpackGeneralizedSelfAdjointEigenSolver	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  ArpackGeneralizedSelfAdjointEigenSolver(const MatrixType& A,$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
ArpackGeneralizedSelfAdjointEigenSolver	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^class ArpackGeneralizedSelfAdjointEigenSolver$/;"	c	namespace:Eigen
Array	Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array() : Base()$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other,$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(const T& x)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen
ArrayApplyAndReduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct ArrayApplyAndReduce {$/;"	s	namespace:Eigen::internal
ArrayApplyAndReduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct ArrayApplyAndReduce<Reducer, Op, A, 1>  {$/;"	s	namespace:Eigen::internal
ArrayBase	Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase
ArrayBase	Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen
ArrayRef	Eigen/src/SVD/BDCSVD.h	/^  typedef Ref<ArrayXr> ArrayRef;$/;"	t	class:Eigen::BDCSVD
ArrayWrapper	Eigen/src/Core/ArrayWrapper.h	/^    explicit EIGEN_STRONG_INLINE ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper
ArrayWrapper	Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen
ArrayXI	Eigen/src/SparseCore/SparseAssign.h	/^  typedef Array<StorageIndex,Dynamic,1> ArrayXI;$/;"	t	struct:Eigen::internal::Assignment
ArrayXS	Eigen/src/SparseCore/SparseAssign.h	/^  typedef Array<Scalar,Dynamic,1> ArrayXS;$/;"	t	struct:Eigen::internal::Assignment
ArrayXi	Eigen/src/SVD/BDCSVD.h	/^  typedef Array<Index,1,Dynamic> ArrayXi;$/;"	t	class:Eigen::BDCSVD
ArrayXpr	Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
ArrayXr	Eigen/src/SVD/BDCSVD.h	/^  typedef Array<RealScalar, Dynamic, 1> ArrayXr;$/;"	t	class:Eigen::BDCSVD
ArrayZipAndReduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct ArrayZipAndReduce {$/;"	s	namespace:Eigen::internal
ArrayZipAndReduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct ArrayZipAndReduce<Reducer, Op, A, B, 1> {$/;"	s	namespace:Eigen::internal
AsScalarProduct	Eigen/src/Core/ProductEvaluators.h	/^    AsScalarProduct =     (DiagonalType::SizeAtCompileTime==1)$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
AsinReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_asin_op<Scalar>, const Derived> AsinReturnType;$/;"	t
AssignOpType	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> AssignOpType;$/;"	t	struct:Eigen::internal::Assignment
Assignment	Eigen/src/Core/AssignEvaluator.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Dense2Dense, Weak>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/AssignEvaluator.h	/^struct Assignment<DstXprType, SrcXprType, Functor, EigenBase2EigenBase, Weak>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/DiagonalMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Diagonal2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>, const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::add_assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/ProductEvaluators.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::sub_assign_op<Scalar,Scalar>, Dense2Dense,$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType>,$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/Solve.h	/^struct Assignment<DstXprType, Solve<Transpose<const DecType>,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::add_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::sub_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Dense2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Core/TriangularMatrix.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Triangular>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Geometry/Homogeneous.h	/^struct Assignment<DstXprType, Homogeneous<ArgType,Horizontal>, internal::assign_op<Scalar,typename ArgType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/Geometry/Homogeneous.h	/^struct Assignment<DstXprType, Homogeneous<ArgType,Vertical>, internal::assign_op<Scalar,typename ArgType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct Assignment<DstXprType, SolveWithGuess<DecType,RhsType,GuessType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/LU/FullPivLU.h	/^struct Assignment<DstXprType, Inverse<FullPivLU<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename FullPivLU<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/LU/InverseImpl.h	/^struct Assignment<DstXprType, Inverse<XprType>, internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/LU/PartialPivLU.h	/^struct Assignment<DstXprType, Inverse<PartialPivLU<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename PartialPivLU<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/QR/ColPivHouseholderQR.h	/^struct Assignment<DstXprType, Inverse<ColPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename ColPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^struct Assignment<DstXprType, Inverse<CompleteOrthogonalDecomposition<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/QR/FullPivHouseholderQR.h	/^struct Assignment<DstXprType, Inverse<FullPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename FullPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Diagonal2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseAssign.h	/^struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::add_assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseProduct.h	/^struct Assignment<DstXprType, Product<Lhs,Rhs,AliasFreeProduct>, internal::sub_assign_op<typename DstXprType::Scalar,typename Product<Lhs,Rhs,AliasFreeProduct>::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct Assignment<DstXprType, SparseSymmetricPermutationProduct<MatrixType,Mode>, internal::assign_op<Scalar,typename MatrixType::Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct Assignment<DstXprType, SrcXprType, Functor, SparseSelfAdjoint2Sparse>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseQR/SparseQR.h	/^struct Assignment<DstXprType, SparseQRMatrixQReturnType<SparseQRType>, internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>, Sparse2Dense>$/;"	s	namespace:Eigen::internal
Assignment	Eigen/src/SparseQR/SparseQR.h	/^struct Assignment<DstXprType, SparseQRMatrixQReturnType<SparseQRType>, internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>, Sparse2Sparse>$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/AssignEvaluator.h	/^template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/AssignEvaluator.h	/^template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/BandMatrix.h	/^template<> struct AssignmentKind<DenseShape,BandShape> { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/DiagonalMatrix.h	/^template<> struct AssignmentKind<DenseShape,DiagonalShape> { typedef Diagonal2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/PermutationMatrix.h	/^template<> struct AssignmentKind<DenseShape,PermutationShape> { typedef EigenBase2EigenBase Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<DenseShape,TriangularShape>      { typedef Triangular2Dense      Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,DenseShape>      { typedef Dense2Triangular      Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,TriangularShape> { typedef Triangular2Triangular Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/Geometry/Homogeneous.h	/^template<> struct AssignmentKind<DenseShape,HomogeneousShape> { typedef Dense2Dense Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseShape>           { typedef Sparse2Dense  Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseTriangularShape> { typedef Sparse2Dense  Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseShape>           { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseTriangularShape> { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape,DiagonalShape> { typedef Diagonal2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseSelfAdjointShape,SparseShape> { typedef Sparse2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentKind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseShape,SparseSelfAdjointShape> { typedef SparseSelfAdjoint2Sparse Kind; };$/;"	s	namespace:Eigen::internal
AssignmentTraits	Eigen/src/Core/AssignEvaluator.h	/^  typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTraits;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
AssignmentTraits	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::AssignmentTraits AssignmentTraits;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
AssignmentTraits	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::AssignmentTraits AssignmentTraits;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
AtanReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_atan_op<Scalar>, const Derived> AtanReturnType;$/;"	t
AutoAlign	Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::StorageOptions
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian() : Functor() {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const Functor& f) : Functor(f) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T& ...Values) : Functor(Values...) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0) : Functor(a0) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0, const T1& a1) : Functor(a0, a1) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0, const T1& a1, const T2& a2) : Functor(a0, a1, a2) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^template<typename Functor> class AutoDiffJacobian : public Functor$/;"	c	namespace:Eigen
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar() {}$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const AutoDiffScalar& other)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const AutoDiffScalar<OtherDerType>& other$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const Scalar& value, const DerType& der)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const Scalar& value, int nbDer, int derNumber)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    \/*explicit*\/ AutoDiffScalar(const Real& value)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^class AutoDiffScalar$/;"	c	namespace:Eigen
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector() {}$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const AutoDiffVector& other)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const AutoDiffVector<OtherValueType, OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const ValueType& values)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const ValueType& values, const JacobianType& jac)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^class AutoDiffVector$/;"	c	namespace:Eigen
Ax_lBx	Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
B	bench/bench_gemm.cpp	/^typedef Matrix<SCALARB,Dynamic,Dynamic> B;$/;"	t	file:
B	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_atv_product
B	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_ger
B	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix B;$/;"	m	class:Action_matrix_matrix_product
B	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_matrix_vector_product
B	bench/btl/actions/action_rot.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_rot
B	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_symv
B	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_syr2
B	bench/btl/actions/action_trisolve.hh	/^  typename Interface::gene_vector B;$/;"	m	class:Action_trisolve
B	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix B;$/;"	m	class:Action_trisolve_matrix
B	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix B;$/;"	m	class:Action_trmm
B	bench/geometry.cpp	/^typedef Matrix<\/*Real*\/Scalar,Dynamic,Dynamic> B;$/;"	t	file:
B	doc/snippets/GeneralizedEigenSolver.cpp	/^MatrixXf B = MatrixXf::Random(4,4);$/;"	v
B	doc/snippets/MatrixBase_applyOnTheLeft.cpp	/^Matrix3f A = Matrix3f::Random(3,3), B;$/;"	v
B	doc/snippets/MatrixBase_applyOnTheRight.cpp	/^Matrix3f A = Matrix3f::Random(3,3), B;$/;"	v
B	doc/snippets/PartialPivLU_solve.cpp	/^MatrixXd B = MatrixXd::Random(3,2);$/;"	v
B	doc/snippets/RealQZ_compute.cpp	/^MatrixXf B = MatrixXf::Random(4,4);$/;"	v
B	doc/snippets/RealQZ_compute.cpp	/^cout << "A:\\n" << A << "\\n" << "B:\\n" << B << "\\n";$/;"	v
B	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^MatrixXd B = X * X.transpose();$/;"	v
B	doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp	/^MatrixXd B = X * X.transpose();$/;"	v
B	doc/snippets/Tutorial_solve_multiple_rhs.cpp	/^Matrix<float,3,2> B;$/;"	v
B	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef Matrix<B_Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols> B;$/;"	t	struct:Eigen::internal::make_coherent_impl
B0	test/main.h	82;"	d
BAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    BAlignment = traits<OtherDerived>::Alignment,$/;"	e	enum:Eigen::internal::quat_product::__anon272
BAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    BAlignment = traits<OtherDerived>::Alignment,$/;"	e	enum:Eigen::internal::quat_product::__anon275
BAx_lx	Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
BB	blas/testing/cblat3.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ),$/;"	v	program:CBLAT3
BB	blas/testing/dblat3.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ),$/;"	v	program:DBLAT3
BB	blas/testing/sblat3.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ),$/;"	v	program:SBLAT3
BB	blas/testing/zblat3.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ),$/;"	v	program:ZBLAT3
BDCSVD	Eigen/src/SVD/BDCSVD.h	/^  BDCSVD() : m_algoswap(16), m_numIters(0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	Eigen/src/SVD/BDCSVD.h	/^  BDCSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	Eigen/src/SVD/BDCSVD.h	/^  BDCSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::BDCSVD
BDCSVD	Eigen/src/SVD/BDCSVD.h	/^class BDCSVD : public SVDBase<BDCSVD<_MatrixType> >$/;"	c	namespace:Eigen
BEGIN_OF	bench/btl/generic_bench/utils/utilities.h	67;"	d
BEGIN_OF	bench/btl/generic_bench/utils/utilities.h	84;"	d
BENCH	bench/BenchTimer.h	170;"	d
BENCH	bench/quat_slerp.cpp	228;"	d	file:
BENCH	bench/sparse_cholesky.cpp	33;"	d	file:
BENCH	bench/sparse_dense_product.cpp	28;"	d	file:
BENCH	bench/sparse_lu.cpp	33;"	d	file:
BENCH	bench/sparse_product.cpp	30;"	d	file:
BENCH	bench/sparse_randomsetter.cpp	32;"	d	file:
BENCH	bench/sparse_setter.cpp	36;"	d	file:
BENCH	bench/sparse_transpose.cpp	28;"	d	file:
BENCH	bench/sparse_trisolver.cpp	29;"	d	file:
BENCHMARK	bench/tensors/benchmark.h	47;"	d
BENCHMARK_RANGE	bench/tensors/tensor_benchmarks.h	10;"	d
BENCH_HH	bench/btl/generic_bench/bench.hh	21;"	d
BENCH_PARAMETER_HH	bench/btl/generic_bench/bench_parameter.hh	21;"	d
BENCH_PERF	bench/bench_norm.cpp	225;"	d	file:
BENCH_STATIC_HH	bench/btl/generic_bench/static/bench_static.hh	21;"	d
BET	blas/testing/cblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET(/;"	v	program:CBLAT2
BET	blas/testing/cblat3.f	/^     $                   BB( NMAX*NMAX ), BET(/;"	v	program:CBLAT3
BET	blas/testing/dblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET(/;"	v	program:DBLAT2
BET	blas/testing/dblat3.f	/^     $                   BB( NMAX*NMAX ), BET(/;"	v	program:DBLAT3
BET	blas/testing/sblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET(/;"	v	program:SBLAT2
BET	blas/testing/sblat3.f	/^     $                   BB( NMAX*NMAX ), BET(/;"	v	program:SBLAT3
BET	blas/testing/zblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET(/;"	v	program:ZBLAT2
BET	blas/testing/zblat3.f	/^     $                   BB( NMAX*NMAX ), BET(/;"	v	program:ZBLAT3
BINARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	81;"	d
BINARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	98;"	d
BLASFUNC	Eigen/src/misc/blas.h	9;"	d
BLASFUNC	bench/btl/libs/BLAS/blas.h	4;"	d
BLASLONG	Eigen/src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	Eigen/src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASLONG	bench/btl/libs/BLAS/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	bench/btl/libs/BLAS/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASULONG	Eigen/src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	Eigen/src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLASULONG	bench/btl/libs/BLAS/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	bench/btl/libs/BLAS/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLAS_FUNC	bench/btl/libs/BLAS/blas_interface_impl.hh	2;"	d
BLAS_H	Eigen/src/misc/blas.h	2;"	d
BLAS_H	bench/btl/libs/BLAS/blas.h	2;"	d
BLAZE_INTERFACE_HH	bench/btl/libs/blaze/blaze_interface.hh	19;"	d
BLITZ_INTERFACE_HH	bench/btl/libs/blitz/blitz_interface.hh	22;"	d
BLITZ_LU_SOLVE_INTERFACE_HH	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	21;"	d
BLITZ_LU_SOLVE_INTERFACE_HH	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	21;"	d
BLITZ_LU_SOLVE_INTERFACE_HH	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	21;"	d
BM_ContractionCPU	bench/tensors/contraction_benchmarks_cpu.cc	14;"	d	file:
BM_FuncCPU	bench/tensors/tensor_benchmarks_cpu.cc	12;"	d	file:
BM_FuncGPU	bench/tensors/tensor_benchmarks_sycl.cc	26;"	d	file:
BM_FuncWithInputDimsCPU	bench/tensors/tensor_benchmarks_cpu.cc	83;"	d	file:
BM_FuncWithKernelDimsCPU	bench/tensors/tensor_benchmarks_cpu.cc	137;"	d	file:
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
BS	blas/testing/cblat3.f	/^     $                   BB( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:CBLAT3
BS	blas/testing/dblat3.f	/^     $                   BB( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:DBLAT3
BS	blas/testing/sblat3.f	/^     $                   BB( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:SBLAT3
BS	blas/testing/zblat3.f	/^     $                   BB( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:ZBLAT3
BTL_ALWAYS_INLINE	bench/btl/generic_bench/btl.hh	30;"	d
BTL_ALWAYS_INLINE	bench/btl/generic_bench/btl.hh	32;"	d
BTL_ASM_COMMENT	bench/btl/generic_bench/btl.hh	42;"	d
BTL_ASM_COMMENT	bench/btl/generic_bench/btl.hh	44;"	d
BTL_C_INTERFACE_BASE_H	bench/btl/libs/BLAS/c_interface_base.h	3;"	d
BTL_DISABLE_SSE_EXCEPTIONS	bench/btl/generic_bench/btl.hh	50;"	d
BTL_DISABLE_SSE_EXCEPTIONS	bench/btl/generic_bench/btl.hh	52;"	d
BTL_DONT_INLINE	bench/btl/generic_bench/btl.hh	36;"	d
BTL_DONT_INLINE	bench/btl/generic_bench/btl.hh	38;"	d
BTL_HH	bench/btl/generic_bench/btl.hh	20;"	d
BTL_MAIN	bench/btl/generic_bench/btl.hh	239;"	d
BVIntersect	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^void BVIntersect(const BVH &tree, Intersector &intersector)$/;"	f	namespace:Eigen
BVIntersect	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^void BVIntersect(const BVH1 &tree1, const BVH2 &tree2, Intersector &intersector) \/\/TODO: tandem descent when it makes sense$/;"	f	namespace:Eigen
BVMinimize	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar BVMinimize(const BVH &tree, Minimizer &minimizer)$/;"	f	namespace:Eigen
BVMinimize	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar BVMinimize(const BVH1 &tree1, const BVH2 &tree2, Minimizer &minimizer)$/;"	f	namespace:Eigen
B_ref	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_atv_product
B_ref	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_ger
B_ref	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix B_ref;$/;"	m	class:Action_matrix_matrix_product
B_ref	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_matrix_vector_product
B_ref	bench/btl/actions/action_rot.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_rot
B_ref	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_symv
B_ref	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_vector B_ref;$/;"	m	class:Action_syr2
B_ref	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix B_ref;$/;"	m	class:Action_trisolve_matrix
B_ref	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix B_ref;$/;"	m	class:Action_trmm
B_stl	bench/btl/actions/action_atv_product.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_atv_product
B_stl	bench/btl/actions/action_ger.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_ger
B_stl	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::stl_matrix B_stl;$/;"	m	class:Action_matrix_matrix_product
B_stl	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_matrix_vector_product
B_stl	bench/btl/actions/action_rot.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_rot
B_stl	bench/btl/actions/action_symv.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_symv
B_stl	bench/btl/actions/action_syr2.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_syr2
B_stl	bench/btl/actions/action_trisolve.hh	/^  typename Interface::stl_vector B_stl;$/;"	m	class:Action_trisolve
B_stl	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::stl_matrix B_stl;$/;"	m	class:Action_trisolve_matrix
B_stl	bench/btl/actions/action_trmm.hh	/^  typename Interface::stl_matrix B_stl;$/;"	m	class:Action_trmm
Ball	unsupported/test/BVH.cpp	/^  Ball() {}$/;"	f	struct:Ball
Ball	unsupported/test/BVH.cpp	/^  Ball(const VectorType &c, double r) : center(c), radius(r) {}$/;"	f	struct:Ball
Ball	unsupported/test/BVH.cpp	/^struct Ball$/;"	s	file:
BallPointStuff	unsupported/test/BVH.cpp	/^  BallPointStuff() : calls(0), count(0) {}$/;"	f	struct:BallPointStuff
BallPointStuff	unsupported/test/BVH.cpp	/^  BallPointStuff(const VectorType &inP) : p(inP), calls(0), count(0) {}$/;"	f	struct:BallPointStuff
BallPointStuff	unsupported/test/BVH.cpp	/^struct BallPointStuff \/\/this class provides functions to be both an intersector and a minimizer, both for a ball and a point and for two trees$/;"	s	file:
BallType	unsupported/test/BVH.cpp	/^  typedef Ball<Dim> BallType;$/;"	t	struct:BallPointStuff	file:
BallType	unsupported/test/BVH.cpp	/^  typedef Ball<Dim> BallType;$/;"	t	struct:TreeTest	file:
BallTypeList	unsupported/test/BVH.cpp	/^  typedef std::vector<BallType, aligned_allocator<BallType> > BallTypeList;$/;"	t	struct:TreeTest	file:
BandMatrix	Eigen/src/Core/BandMatrix.h	/^    explicit inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix
BandMatrix	Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal
BandMatrixBase	Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal
BandMatrixWrapper	Eigen/src/Core/BandMatrix.h	/^    explicit inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper
BandMatrixWrapper	Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal
BandShape	Eigen/src/Core/BandMatrix.h	/^struct BandShape {};$/;"	s	namespace:Eigen::internal
BandShape	Eigen/src/Core/util/Constants.h	/^struct BandShape              { static std::string debugName() { return "BandShape"; } };$/;"	s	namespace:Eigen
Bar	test/jacobisvd.cpp	/^class Bar {public: Bar() {}};$/;"	c	namespace:Foo	file:
Bar	test/jacobisvd.cpp	/^class Bar {public: Bar() {}};$/;"	f	class:Foo::Bar
Barrier	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  Barrier(unsigned int count) : state_(count << 1), notified_(false) {$/;"	f	class:Eigen::Barrier
Barrier	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^class Barrier {$/;"	c	namespace:Eigen
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::CholmodBase
Base	Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array
Base	Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase
Base	Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper
Base	Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper
Base	Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Base	Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase
Base	Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::Block
Base	Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::BlockImpl
Base	Eigen/src/Core/Block.h	/^    typedef MapBase<BlockType> Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<BlockType>::type Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	Eigen/src/Core/CoreEvaluators.h	/^  typedef binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/CoreEvaluators.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/CoreEvaluators.h	/^  typedef ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename dense_xpr_base<EvalToTemp>::type Base;$/;"	t	class:Eigen::internal::EvalToTemp
Base	Eigen/src/Core/CoreEvaluators.h	/^  typedef unary_evaluator<T> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/CoreIterators.h	/^  typedef typename evaluator<XprType>::InnerIterator Base;$/;"	t	class:Eigen::internal::inner_iterator_selector
Base	Eigen/src/Core/CwiseBinaryOp.h	/^                                                      BinaryOp>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp
Base	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename internal::generic_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp
Base	Eigen/src/Core/CwiseTernaryOp.h	/^      CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >::type Base;$/;"	t	class:Eigen::CwiseTernaryOpImpl
Base	Eigen/src/Core/CwiseTernaryOp.h	/^      typename internal::traits<Arg1Type>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseTernaryOp
Base	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp
Base	Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename internal::generic_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Base	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView
Base	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename internal::generic_xpr_base<CwiseUnaryView<ViewOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	Eigen/src/Core/DenseBase.h	/^    typedef DenseCoeffsBase<Derived> Base;$/;"	t	class:Eigen::DenseBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal
Base	Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess
Base	Eigen/src/Core/Inverse.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	Eigen/src/Core/Inverse.h	/^  typedef typename internal::generic_xpr_base<Inverse<XprType> >::type Base;$/;"	t	class:Eigen::InverseImpl
Base	Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase
Base	Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase
Base	Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix
Base	Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase
Base	Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper
Base	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase
Base	Eigen/src/Core/Product.h	/^                                                        internal::product_type<Lhs,Rhs>::ret>::ret>::Base Base;$/;"	t	class:Eigen::Product
Base	Eigen/src/Core/Product.h	/^    typedef typename internal::dense_product_base<Lhs, Rhs, Option> Base;$/;"	t	class:Eigen::ProductImpl
Base	Eigen/src/Core/Product.h	/^    typedef typename internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type Base;$/;"	t	class:Eigen::ProductImpl
Base	Eigen/src/Core/Product.h	/^  typedef typename internal::dense_xpr_base<ProductXpr>::type Base;$/;"	t	class:Eigen::internal::dense_product_base
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<Product<EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar1,Lhs,product), Rhs, DefaultProduct> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef product_evaluator<BaseProduct, CoeffBasedProductMode, DenseShape, DenseShape> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/Core/ProductEvaluators.h	/^  typedef product_evaluator<XprType> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/Ref.h	/^    typedef RefBase<Ref> Base;$/;"	t	class:Eigen::Ref
Base	Eigen/src/Core/Ref.h	/^  typedef MapBase<Derived> Base;$/;"	t	class:Eigen::RefBase
Base	Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate
Base	Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue
Base	Eigen/src/Core/ReturnByValue.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse
Base	Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select
Base	Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView
Base	Eigen/src/Core/SelfAdjointView.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Base	Eigen/src/Core/Solve.h	/^    typedef typename internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type Base;$/;"	t	class:Eigen::SolveImpl
Base	Eigen/src/Core/Solve.h	/^  typedef MatrixBase<Solve<Decomposition,RhsType> > Base;$/;"	t	class:Eigen::SolveImpl
Base	Eigen/src/Core/Solve.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Base	Eigen/src/Core/SolverBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SolverBase
Base	Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride
Base	Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride
Base	Eigen/src/Core/Swap.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, swap_assign_op<typename DstEvaluatorTypeT::Scalar>, BuiltIn> Base;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Base	Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose
Base	Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	Eigen/src/Core/Transpose.h	/^  typedef typename internal::generic_xpr_base<Transpose<XprType> >::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper
Base	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularViewType> Base;$/;"	t	class:Eigen::TriangularViewImpl
Base	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularViewImpl<_MatrixType, _Mode, typename internal::traits<_MatrixType>::StorageKind > Base;$/;"	t	class:Eigen::TriangularView
Base	Eigen/src/Core/TriangularMatrix.h	/^  typedef evaluator<typename internal::remove_all<MatrixType>::type> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	Eigen/src/Core/TriangularMatrix.h	/^  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Base	Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock
Base	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr
Base	Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits
Base	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Base	Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous
Base	Eigen/src/Geometry/Homogeneous.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	Eigen/src/Geometry/Homogeneous.h	/^  typedef evaluator<RefactoredXpr> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion
Base	Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase
Base	Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef DiagonalPreconditioner<_Scalar> Base;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
Base	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB
Base	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient
Base	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> > Base;$/;"	t	class:Eigen::IncompleteCholesky
Base	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseSolverBase<IncompleteLUT> Base;$/;"	t	class:Eigen::IncompleteLUT
Base	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::IterativeSolverBase
Base	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef IterativeSolverBase<LeastSquaresConjugateGradient> Base;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Base	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type Base;$/;"	t	class:Eigen::SolveWithGuess
Base	Eigen/src/LU/FullPivLU.h	/^    typedef SolverBase<FullPivLU> Base;$/;"	t	class:Eigen::FullPivLU
Base	Eigen/src/LU/PartialPivLU.h	/^    typedef SolverBase<PartialPivLU> Base;$/;"	t	class:Eigen::PartialPivLU
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::PastixBase
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl<PardisoLU> Base;$/;"	t	class:Eigen::PardisoLU
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::PardisoImpl
Base	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseSolverBase<SPQR<_MatrixType> > Base;$/;"	t	class:Eigen::SPQR
Base	Eigen/src/SVD/BDCSVD.h	/^  typedef SVDBase<BDCSVD> Base;$/;"	t	class:Eigen::BDCSVD
Base	Eigen/src/SVD/JacobiSVD.h	/^    typedef SVDBase<JacobiSVD> Base;$/;"	t	class:Eigen::JacobiSVD
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::SimplicialCholeskyBase
Base	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef Map<SparseMatrix<_Scalar, _Flags, _StorageIndex> > Base;$/;"	t	class:Eigen::MappedSparseMatrix
Base	Eigen/src/SparseCore/MappedSparseMatrix.h	/^  typedef evaluator<SparseCompressedBase<XprType> > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseCompressedBase<Block<SparseMatrixType,BlockRows,BlockCols,true> > Base;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
Base	Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrixBase<BlockType> Base;$/;"	t	class:Eigen::BlockImpl
Base	Eigen/src/SparseCore/SparseBlock.h	/^  typedef evaluator<SparseCompressedBase<XprType> > Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	Eigen/src/SparseCore/SparseBlock.h	/^  typedef internal::sparse_matrix_block_impl<SparseMatrixType,BlockRows,BlockCols> Base;$/;"	t	class:Eigen::BlockImpl
Base	Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef SparseMatrixBase<Derived> Base;$/;"	t	class:Eigen::SparseCompressedBase
Base	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef SparseMatrixBase<Derived> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef sparse_conjunction_evaluator<XprType> Base;$/;"	t	struct:Eigen::internal::binary_evaluator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef sparse_dense_outer_product_evaluator<Lhs,Rhs, Lhs::IsRowMajor> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef sparse_dense_outer_product_evaluator<Lhs,Rhs, Rhs::IsRowMajor> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef sparse_diagonal_product_evaluator<Lhs, Transpose<const typename Rhs::DiagonalVectorType>, Lhs::Flags&RowMajorBit?SDP_AsCwiseProduct:SDP_AsScalarProduct> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef sparse_diagonal_product_evaluator<Rhs, typename Lhs::DiagonalVectorType, Rhs::Flags&RowMajorBit?SDP_AsScalarProduct:SDP_AsCwiseProduct> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseCompressedBase<Derived> Base;$/;"	t	class:Eigen::SparseMapBase
Base	Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseMapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::SparseMapBase
Base	Eigen/src/SparseCore/SparseMap.h	/^    typedef SparseMapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/SparseCore/SparseMap.h	/^  typedef evaluator<SparseCompressedBase<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseMap.h	/^  typedef evaluator<SparseCompressedBase<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseCompressedBase<SparseMatrix> Base;$/;"	t	class:Eigen::SparseMatrix
Base	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef evaluator<SparseCompressedBase<SparseMatrix<_Scalar,_Options,_StorageIndex> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SparseMatrixBase
Base	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseProduct.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::unary_evaluator
Base	Eigen/src/SparseCore/SparseRef.h	/^    typedef internal::SparseRefBase<Ref> Base;$/;"	t	class:Eigen::Ref
Base	Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseMapBase<Derived> Base;$/;"	t	class:Eigen::internal::SparseRefBase
Base	Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseRef.h	/^  typedef evaluator<SparseCompressedBase<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> > > Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef EigenBase<SparseSelfAdjointView> Base;$/;"	t	class:Eigen::SparseSelfAdjointView
Base	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef evaluator<PlainObject> Base;$/;"	t	struct:Eigen::internal::product_evaluator
Base	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef SparseCompressedBase<Transpose<MatrixType> > Base;$/;"	t	class:Eigen::internal::SparseTransposeImpl
Base	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef internal::SparseTransposeImpl<MatrixType> Base;$/;"	t	class:Eigen::TransposeImpl
Base	Eigen/src/SparseCore/SparseTriangularView.h	/^      typedef EvalIterator Base;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Base	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef SparseMatrixBase<TriangularViewType> Base;$/;"	t	class:Eigen::TriangularViewImpl
Base	Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseCompressedBase<SparseVector> Base;$/;"	t	class:Eigen::SparseVector
Base	Eigen/src/SparseCore/SparseVector.h	/^  typedef evaluator_base<SparseVectorType> Base;$/;"	t	struct:Eigen::internal::evaluator
Base	Eigen/src/SparseCore/SparseView.h	/^  typedef SparseMatrixBase<SparseView > Base;$/;"	t	class:Eigen::SparseView
Base	Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::SparseLUImpl<Scalar, StorageIndex> Base;$/;"	t	class:Eigen::SparseLU
Base	Eigen/src/SparseQR/SparseQR.h	/^    typedef SparseSolverBase<SparseQR<_MatrixType,_OrderingType> > Base;$/;"	t	class:Eigen::SparseQR
Base	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseSolverBase<Derived> Base;$/;"	t	class:Eigen::SuperLUBase
Base	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU
Base	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU
Base	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseSolverBase<UmfPackLU<_MatrixType> > Base;$/;"	t	class:Eigen::UmfPackLU
Base	Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base
Base	Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base
Base	test/denseLM.cpp	/^  typedef DenseFunctor<Scalar> Base;$/;"	t	struct:DenseLM	file:
Base	test/sparseLM.cpp	/^  typedef SparseFunctor<Scalar,int> Base;$/;"	t	struct:sparseGaussianTest	file:
Base	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef TensorBase<Tensor<Scalar_, NumIndices_, Options_, IndexType_> > Base;$/;"	t	class:Eigen::Tensor
Base	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef TensorContractionEvaluatorBase<Self> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef TensorContractionEvaluatorBase<Self> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> Base;$/;"	t	class:Eigen::internal::TensorContractionInputMapper
Base	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef TensorContractionEvaluatorBase<Self> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  typedef array<DenseIndex, NumDims> Base;$/;"	t	struct:Eigen::DSizes
Base	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  typedef internal::numeric_list<std::ptrdiff_t, Indices...> Base;$/;"	t	struct:Eigen::Sizes
Base	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef TensorBase<TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> > Base;$/;"	t	class:Eigen::TensorFixedSize
Base	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename PlainObjectType::Base Base;$/;"	t	class:Eigen::TensorMap
Base	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^                                         TensorLazyEvaluatorReadOnly<Dimensions, const Expr, Device> >::type Base;$/;"	t	class:Eigen::internal::TensorLazyEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename PlainObjectType::Base Base;$/;"	t	class:Eigen::TensorRef
Base	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef TensorEvaluator<const TensorRef<Derived>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> Base;$/;"	t	class:Eigen::internal::TensorLazyEvaluatorWritable
Base	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^                          Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef TensorEvaluator<const XprType, Device> Base;$/;"	t	struct:Eigen::TensorEvaluator
Base	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    typedef typename internal::tensor_symmetry_pre_analysis<NumIndices, Gen...>::root_type Base;$/;"	t	class:Eigen::SGroup
Base	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^                       typename NumTraits<typename internal::traits<typename internal::remove_all<_DerType>::type>::Scalar>::Real>::value> Base;$/;"	t	class:Eigen::AutoDiffScalar
Base	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef IterativeSolverBase<DGMRES> Base;$/;"	t	class:Eigen::DGMRES
Base	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef IterativeSolverBase<GMRES> Base;$/;"	t	class:Eigen::GMRES
Base	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef SparseSolverBase<IncompleteLU<_Scalar> > Base;$/;"	t	class:Eigen::IncompleteLU
Base	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        typedef IterativeSolverBase<MINRES> Base;$/;"	t	class:Eigen::MINRES
Base	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef KroneckerProductBase<KroneckerProduct> Base;$/;"	t	class:Eigen::KroneckerProduct
Base	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef KroneckerProductBase<KroneckerProductSparse> Base;$/;"	t	class:Eigen::KroneckerProductSparse
Base	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^            MatrixBase<SkylineProduct<LhsNested, RhsNested, ProductMode> > >::type Base;$/;"	t	struct:Eigen::internal::traits
Base	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef SparseMatrixBase<DynamicSparseMatrix> Base;$/;"	t	class:Eigen::DynamicSparseMatrix
Base	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef typename SparseVector<Scalar,_Options,_StorageIndex>::InnerIterator Base;$/;"	t	class:Eigen::DynamicSparseMatrix::InnerIterator
Base	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef typename SparseVector<Scalar,_Options,_StorageIndex>::ReverseInnerIterator Base;$/;"	t	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
BaseProduct	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, LazyProduct> BaseProduct;$/;"	t	struct:Eigen::internal::product_evaluator
BaseScalar	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef typename internal::traits<ValueType>::Scalar BaseScalar;$/;"	t	class:Eigen::AutoDiffVector
BaseTensorContractionMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  BaseTensorContractionMapper(const Tensor& tensor,$/;"	f	class:Eigen::internal::BaseTensorContractionMapper
BaseTensorContractionMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^class BaseTensorContractionMapper : public SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, Alignment>$/;"	c	namespace:Eigen::internal
BaseTensorContractionMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^class BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, inner_dim_reordered, Alignment> : public SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, Alignment>$/;"	c	namespace:Eigen::internal
BaseTraits	Eigen/src/Core/Inverse.h	/^  typedef traits<PlainObject> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BaseTraits	Eigen/src/Core/Solve.h	/^  typedef traits<PlainObject> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BaseTraits	Eigen/src/LU/PartialPivLU.h	/^  typedef traits<_MatrixType> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BaseTraits	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef traits<PlainObjectType> BaseTraits;$/;"	t	struct:Eigen::internal::traits
BasisDerivativeType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::BasisDerivativeType BasisDerivativeType;$/;"	t	class:Eigen::Spline
BasisDerivativeType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dynamic,Dynamic,RowMajor,NumOfDerivativesAtCompileTime,OrderAtCompileTime> BasisDerivativeType;$/;"	t	struct:Eigen::SplineTraits
BasisDerivativeType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<_Scalar,Dynamic,Dynamic,RowMajor,NumOfDerivativesAtCompileTime,OrderAtCompileTime> BasisDerivativeType;$/;"	t	struct:Eigen::SplineTraits
BasisFunctionDerivatives	unsupported/Eigen/src/Splines/Spline.h	/^  Spline<_Scalar, _Dim, _Degree>::BasisFunctionDerivatives($/;"	f	class:Eigen::Spline
BasisFunctionDerivativesImpl	unsupported/Eigen/src/Splines/Spline.h	/^  void Spline<_Scalar, _Dim, _Degree>::BasisFunctionDerivativesImpl($/;"	f	class:Eigen::Spline
BasisFunctions	unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::BasisFunctions($/;"	f	class:Eigen::Spline
BasisReturnType	Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase
BasisVectorType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::BasisVectorType BasisVectorType;$/;"	t	class:Eigen::Spline
BasisVectorType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,1,OrderAtCompileTime> BasisVectorType;$/;"	t	struct:Eigen::SplineTraits
BatchMatMul	unsupported/test/cxx11_tensor_custom_op.cpp	/^struct BatchMatMul {$/;"	s	file:
BenchTimer	bench/BenchTimer.h	/^  BenchTimer()$/;"	f	class:Eigen::BenchTimer
BenchTimer	bench/BenchTimer.h	/^class BenchTimer$/;"	c	namespace:Eigen
Benchmark	bench/tensors/benchmark.h	/^  Benchmark(const char* name, void (*fn)(int)) {$/;"	f	class:testing::Benchmark
Benchmark	bench/tensors/benchmark.h	/^  Benchmark(const char* name, void (*fn_range)(int, int)) {$/;"	f	class:testing::Benchmark
Benchmark	bench/tensors/benchmark.h	/^class Benchmark {$/;"	c	namespace:testing
BenchmarkMap	bench/tensors/benchmark_main.cc	/^typedef std::map<std::string, ::testing::Benchmark*> BenchmarkMap;$/;"	t	file:
BenchmarkMapIt	bench/tensors/benchmark_main.cc	/^typedef BenchmarkMap::iterator BenchmarkMapIt;$/;"	t	file:
BenchmarkSuite	bench/tensors/tensor_benchmarks.h	/^  BenchmarkSuite(const Device& device, size_t m)$/;"	f	class:BenchmarkSuite
BenchmarkSuite	bench/tensors/tensor_benchmarks.h	/^  BenchmarkSuite(const Device& device, size_t m, size_t k, size_t n)$/;"	f	class:BenchmarkSuite
BenchmarkSuite	bench/tensors/tensor_benchmarks.h	/^template <typename Device, typename T> class BenchmarkSuite {$/;"	c
Bennett5_functor	unsupported/test/NonLinearOptimization.cpp	/^    Bennett5_functor(void) : Functor<double>(3,154) {}$/;"	f	struct:Bennett5_functor
Bennett5_functor	unsupported/test/NonLinearOptimization.cpp	/^struct Bennett5_functor : Functor<double>$/;"	s	file:
Bennett5_functor	unsupported/test/levenberg_marquardt.cpp	/^    Bennett5_functor(void) : DenseFunctor<double>(3,154) {}$/;"	f	struct:Bennett5_functor
Bennett5_functor	unsupported/test/levenberg_marquardt.cpp	/^struct Bennett5_functor : DenseFunctor<double>$/;"	s	file:
BetaAxis	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static const int BetaAxis = _BetaAxis;$/;"	m	class:Eigen::EulerSystem
BetaAxisAbs	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      BetaAxisAbs = internal::Abs<BetaAxis>::value, \/*!< the second rotation axis unsigned *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
BetaAxisVector	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      static Vector3 BetaAxisVector() {$/;"	f	class:Eigen::EulerAngles
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
BidiagonalType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0, RowMajor> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
BinaryOp	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Functor BinaryOp;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
BlasIndex	Eigen/src/Core/util/MKL_support.h	/^typedef MKL_INT BlasIndex;$/;"	t	namespace:Eigen
BlasIndex	Eigen/src/Core/util/MKL_support.h	/^typedef int BlasIndex;$/;"	t	namespace:Eigen
BlasLinearMapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data) : m_data(data) {}$/;"	f	class:Eigen::internal::BlasLinearMapper
BlasLinearMapper	Eigen/src/Core/util/BlasUtil.h	/^class BlasLinearMapper {$/;"	c	namespace:Eigen::internal
BlasVectorMapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasVectorMapper(Scalar *data) : m_data(data) {}$/;"	f	class:Eigen::internal::BlasVectorMapper
BlasVectorMapper	Eigen/src/Core/util/BlasUtil.h	/^class BlasVectorMapper {$/;"	c	namespace:Eigen::internal
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i) : Impl(xpr,i)$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block$/;"	c	namespace:Eigen
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon100
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon99
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon137
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon138
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon148
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon142
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon136
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon94
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon95
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon129
BlockAccess	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    BlockAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon143
BlockImpl	Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index startRow, Index startCol) : Impl(xpr, startRow, startCol) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(XprType& xpr, Index i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^  inline BlockImpl(SparseMatrixType& xpr, Index i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^  inline BlockImpl(SparseMatrixType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index i)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen::internal
BlockImpl_dense	Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense$/;"	c	namespace:Eigen::internal
BlockIndexVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<StorageIndex,Dynamic,1> > BlockIndexVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockInnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockInnerIterator(const BlockSparseMatrix& mat, const Index outer)$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
BlockInnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockSparseMatrix<_Scalar, _BlockAtCompileTime, _Options, _StorageIndex>::BlockInnerIterator$/;"	c	class:Eigen::BlockSparseMatrix
BlockRealScalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Matrix<RealScalar, _BlockAtCompileTime, _BlockAtCompileTime,IsColMajor ? ColMajor : RowMajor> BlockRealScalar;$/;"	t	class:Eigen::BlockSparseMatrix
BlockScalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Matrix<Scalar, _BlockAtCompileTime, _BlockAtCompileTime,IsColMajor ? ColMajor : RowMajor> BlockScalar;$/;"	t	class:Eigen::BlockSparseMatrix
BlockScalarReturnType	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename internal::conditional<_BlockAtCompileTime==Dynamic, Scalar, BlockScalar>::type BlockScalarReturnType;$/;"	t	class:Eigen::BlockSparseMatrix
BlockScalarVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Scalar,Dynamic,1> > BlockScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockSize	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = meta_least_common_multiple<EIGEN_PLAIN_ENUM_MAX(mr,nr),EIGEN_PLAIN_ENUM_MIN(mr,nr)>::ret$/;"	e	enum:Eigen::internal::tribb_kernel::__anon626
BlockSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      BlockSize = BlockSparseMatrixT::BlockSize,$/;"	e	enum:Eigen::BlockVectorView::__anon74
BlockSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      BlockSize=_BlockAtCompileTime,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
BlockSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSize = _BlockAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon72
BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseMatrix()$/;"	f	class:Eigen::BlockSparseMatrix
BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseMatrix(Index brow, Index bcol)$/;"	f	class:Eigen::BlockSparseMatrix
BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseMatrix(const BlockSparseMatrix& other)$/;"	f	class:Eigen::BlockSparseMatrix
BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline BlockSparseMatrix(const MatrixType& spmat) : m_blockSize(BlockSize)$/;"	f	class:Eigen::BlockSparseMatrix
BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockSparseMatrix : public SparseMatrixBase<BlockSparseMatrix<_Scalar,_BlockAtCompileTime, _Options,_StorageIndex> >$/;"	c	namespace:Eigen
BlockSparseMatrixView	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseMatrixView(const BlockSparseMatrixT& spblockmat)$/;"	f	class:Eigen::BlockSparseMatrixView
BlockSparseMatrixView	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockSparseMatrixView : public SparseMatrixBase<BlockSparseMatrixT>$/;"	c	namespace:Eigen
BlockSparseTimeDenseProduct	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::BlockSparseTimeDenseProduct
BlockSparseTimeDenseProduct	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockSparseTimeDenseProduct$/;"	c	namespace:Eigen
BlockType	Eigen/src/Core/Block.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::BlockImpl_dense
BlockType	Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockVectorReturn	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockVectorReturn(const BlockSparseMatrixT& spblockmat, VectorType& vec)$/;"	f	class:Eigen::BlockVectorReturn
BlockVectorReturn	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockVectorReturn$/;"	c	namespace:Eigen
BlockVectorView	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockVectorView(const BlockSparseMatrixT& spblockmat, const VectorType& vec)$/;"	f	class:Eigen::BlockVectorView
BlockVectorView	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockVectorView$/;"	c	namespace:Eigen
BlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived> BlockXpr;$/;"	t
BlueNormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_blueNorm,RealScalar>::Type BlueNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
BooleanNotReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_boolean_not_op<Scalar>, const Derived> BooleanNotReturnType;$/;"	t
BothDirections	Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BothParts	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  BothParts = 2$/;"	e	enum:Eigen::FFTResultType
BottomLeft	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftBlock	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, Deg_1, Deg_1 >         BottomLeftBlock;$/;"	t	class:Eigen::internal::companion
BottomLeftCeil	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftDiagonal	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg_1, 1>               BottomLeftDiagonal;$/;"	t	class:Eigen::internal::companion
BottomLeftFloor	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightFloor	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Box2d	unsupported/doc/examples/BVH_Example.cpp	/^typedef AlignedBox<double, 2> Box2d;$/;"	t	file:
BoxBOD_functor	unsupported/test/NonLinearOptimization.cpp	/^    BoxBOD_functor(void) : Functor<double>(2,6) {}$/;"	f	struct:BoxBOD_functor
BoxBOD_functor	unsupported/test/NonLinearOptimization.cpp	/^struct BoxBOD_functor : Functor<double>$/;"	s	file:
BoxBOD_functor	unsupported/test/levenberg_marquardt.cpp	/^    BoxBOD_functor(void) : DenseFunctor<double>(2,6) {}$/;"	f	struct:BoxBOD_functor
BoxBOD_functor	unsupported/test/levenberg_marquardt.cpp	/^struct BoxBOD_functor : DenseFunctor<double>$/;"	s	file:
BoxType	unsupported/test/BVH.cpp	/^  typedef AlignedBox<double, Dim> BoxType;$/;"	t	struct:BallPointStuff	file:
BoxType	unsupported/test/BVH.cpp	/^  typedef AlignedBox<double, Dim> BoxType;$/;"	t	struct:TreeTest	file:
Browse_Matrices	bench/spbench/spbenchsolver.h	/^void Browse_Matrices(const string folder, bool statFileExists, std::string& statFile, int maxiters, double tol)$/;"	f
BtlConfig	bench/btl/generic_bench/btl.hh	/^  BtlConfig()$/;"	f	class:BtlConfig
BtlConfig	bench/btl/generic_bench/btl.hh	/^class BtlConfig$/;"	c
BtlString	bench/btl/generic_bench/btl.hh	/^    BtlString() : std::string() {}$/;"	f	class:BtlString
BtlString	bench/btl/generic_bench/btl.hh	/^    BtlString(const BtlString& str) : std::string(static_cast<const std::string&>(str)) {}$/;"	f	class:BtlString
BtlString	bench/btl/generic_bench/btl.hh	/^    BtlString(const char* str) : std::string(str) {}$/;"	f	class:BtlString
BtlString	bench/btl/generic_bench/btl.hh	/^    BtlString(const std::string& str) : std::string(str) {}$/;"	f	class:BtlString
BtlString	bench/btl/generic_bench/btl.hh	/^class BtlString : public std::string$/;"	c
BuildType	Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
BuiltIn	Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::SpecializedType
C	bench/bench_gemm.cpp	/^typedef Matrix<Scalar,Dynamic,Dynamic> C;$/;"	t	file:
C	bench/btl/actions/action_cholesky.hh	/^  typename Interface::gene_matrix C;$/;"	m	class:Action_cholesky
C	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix C;$/;"	m	class:Action_hessenberg
C	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix C;$/;"	m	class:Action_tridiagonalization
C	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::gene_matrix C;$/;"	m	class:Action_lu_decomp
C	bench/btl/actions/action_partial_lu.hh	/^  typename Interface::gene_matrix C;$/;"	m	class:Action_partial_lu
C	bench/geometry.cpp	/^typedef Matrix<Scalar,Dynamic,Dynamic> C;$/;"	t	file:
C	blas/testing/cblat3.f	/^     $                   BS( NMAX*NMAX ), C(/;"	v	program:CBLAT3
C	blas/testing/dblat3.f	/^     $                   BS( NMAX*NMAX ), C(/;"	v	program:DBLAT3
C	blas/testing/sblat3.f	/^     $                   BS( NMAX*NMAX ), C(/;"	v	program:SBLAT3
C	blas/testing/zblat3.f	/^     $                   BS( NMAX*NMAX ), C(/;"	v	program:ZBLAT3
CALL_ALL	test/product_trmm.cpp	109;"	d	file:
CALL_ALL_ORDERS	test/product_trmm.cpp	95;"	d	file:
CALL_SUBTEST	test/main.h	342;"	d
CAT	bench/btl/libs/BLAS/blas_interface.hh	51;"	d
CAT2	bench/btl/libs/BLAS/blas_interface.hh	50;"	d
CATEGORYCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	62;"	d
CATEGORYCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	69;"	d
CBEG	blas/testing/cblat2.f	/^      COMPLEX FUNCTION CBEG(/;"	f
CBEG	blas/testing/cblat3.f	/^      COMPLEX FUNCTION CBEG(/;"	f
CBLAS_GEMM	bench/benchBlasGemm.cpp	22;"	d	file:
CBLAS_GEMM	bench/benchBlasGemm.cpp	25;"	d	file:
CBLAT1	blas/testing/cblat1.f	/^      PROGRAM CBLAT1$/;"	p
CBLAT2	blas/testing/cblat2.f	/^      PROGRAM CBLAT2$/;"	p
CBLAT3	blas/testing/cblat3.f	/^      PROGRAM CBLAT3$/;"	p
CC	blas/testing/cblat3.f	/^     $                   BS( NMAX*NMAX ), C( NMAX, NMAX ),$/;"	v	program:CBLAT3
CC	blas/testing/dblat3.f	/^     $                   BS( NMAX*NMAX ), C( NMAX, NMAX ),$/;"	v	program:DBLAT3
CC	blas/testing/sblat3.f	/^     $                   BS( NMAX*NMAX ), C( NMAX, NMAX ),$/;"	v	program:SBLAT3
CC	blas/testing/zblat3.f	/^     $                   BS( NMAX*NMAX ), C( NMAX, NMAX ),$/;"	v	program:ZBLAT3
CCHK1	blas/testing/cblat2.f	/^      SUBROUTINE CCHK1(/;"	s
CCHK1	blas/testing/cblat3.f	/^      SUBROUTINE CCHK1(/;"	s
CCHK2	blas/testing/cblat2.f	/^      SUBROUTINE CCHK2(/;"	s
CCHK2	blas/testing/cblat3.f	/^      SUBROUTINE CCHK2(/;"	s
CCHK3	blas/testing/cblat2.f	/^      SUBROUTINE CCHK3(/;"	s
CCHK3	blas/testing/cblat3.f	/^      SUBROUTINE CCHK3(/;"	s
CCHK4	blas/testing/cblat2.f	/^      SUBROUTINE CCHK4(/;"	s
CCHK4	blas/testing/cblat3.f	/^      SUBROUTINE CCHK4(/;"	s
CCHK5	blas/testing/cblat2.f	/^      SUBROUTINE CCHK5(/;"	s
CCHK5	blas/testing/cblat3.f	/^      SUBROUTINE CCHK5(/;"	s
CCHK6	blas/testing/cblat2.f	/^      SUBROUTINE CCHK6(/;"	s
CCHKE	blas/testing/cblat2.f	/^      SUBROUTINE CCHKE(/;"	s
CCHKE	blas/testing/cblat3.f	/^      SUBROUTINE CCHKE(/;"	s
CDOTC	blas/fortran/complexdots.f	/^      COMPLEX FUNCTION CDOTC(/;"	f
CDOTU	blas/fortran/complexdots.f	/^      COMPLEX FUNCTION CDOTU(/;"	f
CEIL_DIV	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	796;"	d
CEIL_DIV	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	949;"	d
CHECK0	blas/testing/dblat1.f	/^      SUBROUTINE CHECK0(/;"	s
CHECK0	blas/testing/sblat1.f	/^      SUBROUTINE CHECK0(/;"	s
CHECK1	blas/testing/cblat1.f	/^      SUBROUTINE CHECK1(/;"	s
CHECK1	blas/testing/dblat1.f	/^      SUBROUTINE CHECK1(/;"	s
CHECK1	blas/testing/sblat1.f	/^      SUBROUTINE CHECK1(/;"	s
CHECK1	blas/testing/zblat1.f	/^      SUBROUTINE CHECK1(/;"	s
CHECK2	blas/testing/cblat1.f	/^      SUBROUTINE CHECK2(/;"	s
CHECK2	blas/testing/dblat1.f	/^      SUBROUTINE CHECK2(/;"	s
CHECK2	blas/testing/sblat1.f	/^      SUBROUTINE CHECK2(/;"	s
CHECK2	blas/testing/zblat1.f	/^      SUBROUTINE CHECK2(/;"	s
CHECK3	blas/testing/dblat1.f	/^      SUBROUTINE CHECK3(/;"	s
CHECK3	blas/testing/sblat1.f	/^      SUBROUTINE CHECK3(/;"	s
CHECK_CWISE1	test/packetmath.cpp	64;"	d	file:
CHECK_CWISE1_IF	test/packetmath.cpp	91;"	d	file:
CHECK_CWISE2_IF	test/packetmath.cpp	99;"	d	file:
CHECK_MEM	bench/sparse_setter.cpp	33;"	d	file:
CHECK_MEMLEAK	test/exceptions.cpp	80;"	d	file:
CHECK_MMTR	test/product_mmtr.cpp	12;"	d	file:
CHKXER	blas/testing/cblat2.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/cblat3.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/dblat2.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/dblat3.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/sblat2.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/sblat3.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/zblat2.f	/^      SUBROUTINE CHKXER(/;"	s
CHKXER	blas/testing/zblat3.f	/^      SUBROUTINE CHKXER(/;"	s
CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
CJMADD	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1679;"	d
CJMADD	Eigen/src/Core/products/GeneralBlockPanelKernel.h	311;"	d
CJMADD	Eigen/src/Core/products/GeneralBlockPanelKernel.h	336;"	d
CLACGV	lapack/clacgv.f	/^      SUBROUTINE CLACGV(/;"	s
CLADIV	lapack/cladiv.f	/^      COMPLEX FUNCTION CLADIV(/;"	f
CLARF	lapack/clarf.f	/^      SUBROUTINE CLARF(/;"	s
CLARFB	lapack/clarfb.f	/^      SUBROUTINE CLARFB(/;"	s
CLARFG	lapack/clarfg.f	/^      SUBROUTINE CLARFG(/;"	s
CLARFT	lapack/clarft.f	/^      SUBROUTINE CLARFT(/;"	s
CMAKE	blas/testing/cblat2.f	/^      SUBROUTINE CMAKE(/;"	s
CMAKE	blas/testing/cblat3.f	/^      SUBROUTINE CMAKE(/;"	s
CMMCH	blas/testing/cblat3.f	/^      SUBROUTINE CMMCH(/;"	s
CMVCH	blas/testing/cblat2.f	/^      SUBROUTINE CMVCH(/;"	s
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
COLAMDOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class COLAMDOrdering$/;"	c	namespace:Eigen
COLAMD_ASSERT	Eigen/src/OrderingMethods/Eigen_Colamd.h	239;"	d
COLAMD_DEBUG0	Eigen/src/OrderingMethods/Eigen_Colamd.h	233;"	d
COLAMD_DEBUG1	Eigen/src/OrderingMethods/Eigen_Colamd.h	234;"	d
COLAMD_DEBUG2	Eigen/src/OrderingMethods/Eigen_Colamd.h	235;"	d
COLAMD_DEBUG3	Eigen/src/OrderingMethods/Eigen_Colamd.h	236;"	d
COLAMD_DEBUG4	Eigen/src/OrderingMethods/Eigen_Colamd.h	237;"	d
COLAMD_DEFRAG_COUNT	Eigen/src/OrderingMethods/Eigen_Colamd.h	72;"	d
COLAMD_DENSE_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	69;"	d
COLAMD_DENSE_ROW	Eigen/src/OrderingMethods/Eigen_Colamd.h	66;"	d
COLAMD_EMPTY	Eigen/src/OrderingMethods/Eigen_Colamd.h	105;"	d
COLAMD_ERROR_A_not_present	Eigen/src/OrderingMethods/Eigen_Colamd.h	85;"	d
COLAMD_ERROR_A_too_small	Eigen/src/OrderingMethods/Eigen_Colamd.h	91;"	d
COLAMD_ERROR_col_length_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	92;"	d
COLAMD_ERROR_internal_error	Eigen/src/OrderingMethods/Eigen_Colamd.h	95;"	d
COLAMD_ERROR_ncol_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	88;"	d
COLAMD_ERROR_nnz_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	89;"	d
COLAMD_ERROR_nrow_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	87;"	d
COLAMD_ERROR_out_of_memory	Eigen/src/OrderingMethods/Eigen_Colamd.h	94;"	d
COLAMD_ERROR_p0_nonzero	Eigen/src/OrderingMethods/Eigen_Colamd.h	90;"	d
COLAMD_ERROR_p_not_present	Eigen/src/OrderingMethods/Eigen_Colamd.h	86;"	d
COLAMD_ERROR_row_index_out_of_bounds	Eigen/src/OrderingMethods/Eigen_Colamd.h	93;"	d
COLAMD_INFO1	Eigen/src/OrderingMethods/Eigen_Colamd.h	78;"	d
COLAMD_INFO2	Eigen/src/OrderingMethods/Eigen_Colamd.h	79;"	d
COLAMD_INFO3	Eigen/src/OrderingMethods/Eigen_Colamd.h	80;"	d
COLAMD_KNOBS	Eigen/src/OrderingMethods/Eigen_Colamd.h	60;"	d
COLAMD_NDEBUG	Eigen/src/OrderingMethods/Eigen_Colamd.h	53;"	d
COLAMD_OK	Eigen/src/OrderingMethods/Eigen_Colamd.h	83;"	d
COLAMD_OK_BUT_JUMBLED	Eigen/src/OrderingMethods/Eigen_Colamd.h	84;"	d
COLAMD_STATS	Eigen/src/OrderingMethods/Eigen_Colamd.h	63;"	d
COLAMD_STATUS	Eigen/src/OrderingMethods/Eigen_Colamd.h	75;"	d
COL_IS_ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	120;"	d
COL_IS_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	119;"	d
COL_IS_DEAD_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	121;"	d
COMBLA	blas/testing/cblat1.f	100;"	c	subroutine:HEADER
COMBLA	blas/testing/cblat1.f	145;"	c	subroutine:CHECK1
COMBLA	blas/testing/cblat1.f	344;"	c	subroutine:CHECK2
COMBLA	blas/testing/cblat1.f	593;"	c	subroutine:STEST
COMBLA	blas/testing/cblat1.f	59;"	c	program:CBLAT1
COMBLA	blas/testing/cblat1.f	703;"	c	subroutine:ITEST1
COMBLA	blas/testing/dblat1.f	1043;"	c	subroutine:ITEST1
COMBLA	blas/testing/dblat1.f	105;"	c	subroutine:HEADER
COMBLA	blas/testing/dblat1.f	144;"	c	subroutine:CHECK0
COMBLA	blas/testing/dblat1.f	266;"	c	subroutine:CHECK1
COMBLA	blas/testing/dblat1.f	367;"	c	subroutine:CHECK2
COMBLA	blas/testing/dblat1.f	59;"	c	program:DBLAT1
COMBLA	blas/testing/dblat1.f	705;"	c	subroutine:CHECK3
COMBLA	blas/testing/dblat1.f	916;"	c	subroutine:STEST
COMBLA	blas/testing/dblat1.f	965;"	c	subroutine:TESTDSDOT
COMBLA	blas/testing/sblat1.f	105;"	c	subroutine:HEADER
COMBLA	blas/testing/sblat1.f	144;"	c	subroutine:CHECK0
COMBLA	blas/testing/sblat1.f	266;"	c	subroutine:CHECK1
COMBLA	blas/testing/sblat1.f	368;"	c	subroutine:CHECK2
COMBLA	blas/testing/sblat1.f	59;"	c	program:SBLAT1
COMBLA	blas/testing/sblat1.f	709;"	c	subroutine:CHECK3
COMBLA	blas/testing/sblat1.f	920;"	c	subroutine:STEST
COMBLA	blas/testing/sblat1.f	999;"	c	subroutine:ITEST1
COMBLA	blas/testing/zblat1.f	100;"	c	subroutine:HEADER
COMBLA	blas/testing/zblat1.f	145;"	c	subroutine:CHECK1
COMBLA	blas/testing/zblat1.f	344;"	c	subroutine:CHECK2
COMBLA	blas/testing/zblat1.f	593;"	c	subroutine:STEST
COMBLA	blas/testing/zblat1.f	59;"	c	program:ZBLAT1
COMBLA	blas/testing/zblat1.f	703;"	c	subroutine:ITEST1
COMPARE_CORNER	test/corners.cpp	12;"	d	file:
COMPILER	bench/btl/generic_bench/utils/utilities.h	28;"	d
COMPILER	bench/btl/generic_bench/utils/utilities.h	30;"	d
COMPILER	bench/btl/generic_bench/utils/utilities.h	32;"	d
COMPILER	bench/btl/generic_bench/utils/utilities.h	34;"	d
COMPILER	bench/btl/generic_bench/utils/utilities.h	36;"	d
CPU_TIMER	bench/BenchTimer.h	/^  CPU_TIMER = 0,$/;"	e	enum:Eigen::__anon13
CREATE_THREAD_POOL	bench/tensors/contraction_benchmarks_cpu.cc	7;"	d	file:
CREATE_THREAD_POOL	bench/tensors/tensor_benchmarks_cpu.cc	7;"	d	file:
CS	blas/testing/cblat3.f	/^     $                   CC( NMAX*NMAX ), CS(/;"	v	program:CBLAT3
CS	blas/testing/dblat3.f	/^     $                   CC( NMAX*NMAX ), CS(/;"	v	program:DBLAT3
CS	blas/testing/sblat3.f	/^     $                   CC( NMAX*NMAX ), CS(/;"	v	program:SBLAT3
CS	blas/testing/zblat3.f	/^     $                   CC( NMAX*NMAX ), CS(/;"	v	program:ZBLAT3
CT	blas/testing/cblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT(/;"	v	program:CBLAT3
CT	blas/testing/dblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT(/;"	v	program:DBLAT3
CT	blas/testing/sblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT(/;"	v	program:SBLAT3
CT	blas/testing/zblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT(/;"	v	program:ZBLAT3
CTEST	blas/testing/cblat1.f	/^      SUBROUTINE CTEST(/;"	s
CTEST	blas/testing/zblat1.f	/^      SUBROUTINE CTEST(/;"	s
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_0.cpp	4;"	d	file:
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_0.cpp	6;"	d	file:
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_2.cpp	4;"	d	file:
CV_QUALIFIER	failtest/block_nonconst_ctor_on_const_xpr_2.cpp	6;"	d	file:
CV_QUALIFIER	failtest/block_on_const_type_actually_const_0.cpp	4;"	d	file:
CV_QUALIFIER	failtest/block_on_const_type_actually_const_0.cpp	6;"	d	file:
CV_QUALIFIER	failtest/block_on_const_type_actually_const_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/block_on_const_type_actually_const_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/const_qualified_block_method_retval_0.cpp	4;"	d	file:
CV_QUALIFIER	failtest/const_qualified_block_method_retval_0.cpp	6;"	d	file:
CV_QUALIFIER	failtest/const_qualified_block_method_retval_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/const_qualified_block_method_retval_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/const_qualified_diagonal_method_retval.cpp	4;"	d	file:
CV_QUALIFIER	failtest/const_qualified_diagonal_method_retval.cpp	6;"	d	file:
CV_QUALIFIER	failtest/const_qualified_transpose_method_retval.cpp	4;"	d	file:
CV_QUALIFIER	failtest/const_qualified_transpose_method_retval.cpp	6;"	d	file:
CV_QUALIFIER	failtest/cwiseunaryview_nonconst_ctor_on_const_xpr.cpp	4;"	d	file:
CV_QUALIFIER	failtest/cwiseunaryview_nonconst_ctor_on_const_xpr.cpp	6;"	d	file:
CV_QUALIFIER	failtest/cwiseunaryview_on_const_type_actually_const.cpp	4;"	d	file:
CV_QUALIFIER	failtest/cwiseunaryview_on_const_type_actually_const.cpp	6;"	d	file:
CV_QUALIFIER	failtest/diagonal_nonconst_ctor_on_const_xpr.cpp	4;"	d	file:
CV_QUALIFIER	failtest/diagonal_nonconst_ctor_on_const_xpr.cpp	6;"	d	file:
CV_QUALIFIER	failtest/diagonal_on_const_type_actually_const.cpp	4;"	d	file:
CV_QUALIFIER	failtest/diagonal_on_const_type_actually_const.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_0.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_0.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_2.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_2.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_3.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_3.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_4.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_nonconst_ctor_on_const_ptr_4.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_on_const_type_actually_const_0.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_on_const_type_actually_const_0.cpp	6;"	d	file:
CV_QUALIFIER	failtest/map_on_const_type_actually_const_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/map_on_const_type_actually_const_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/ref_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/ref_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/selfadjointview_nonconst_ctor_on_const_xpr.cpp	4;"	d	file:
CV_QUALIFIER	failtest/selfadjointview_nonconst_ctor_on_const_xpr.cpp	6;"	d	file:
CV_QUALIFIER	failtest/selfadjointview_on_const_type_actually_const.cpp	4;"	d	file:
CV_QUALIFIER	failtest/selfadjointview_on_const_type_actually_const.cpp	6;"	d	file:
CV_QUALIFIER	failtest/sparse_ref_1.cpp	4;"	d	file:
CV_QUALIFIER	failtest/sparse_ref_1.cpp	6;"	d	file:
CV_QUALIFIER	failtest/transpose_nonconst_ctor_on_const_xpr.cpp	4;"	d	file:
CV_QUALIFIER	failtest/transpose_nonconst_ctor_on_const_xpr.cpp	6;"	d	file:
CV_QUALIFIER	failtest/transpose_on_const_type_actually_const.cpp	4;"	d	file:
CV_QUALIFIER	failtest/transpose_on_const_type_actually_const.cpp	6;"	d	file:
CV_QUALIFIER	failtest/triangularview_nonconst_ctor_on_const_xpr.cpp	4;"	d	file:
CV_QUALIFIER	failtest/triangularview_nonconst_ctor_on_const_xpr.cpp	6;"	d	file:
CV_QUALIFIER	failtest/triangularview_on_const_type_actually_const.cpp	4;"	d	file:
CV_QUALIFIER	failtest/triangularview_on_const_type_actually_const.cpp	6;"	d	file:
C_Map_MatrixXd	demos/mix_eigen_and_c/binary_library.h	/^  struct C_Map_MatrixXd {};$/;"	s
C_MatrixXd	demos/mix_eigen_and_c/binary_library.h	/^  struct C_MatrixXd {};$/;"	s
C_stl	bench/btl/actions/action_cholesky.hh	/^  typename Interface::stl_matrix C_stl;$/;"	m	class:Action_cholesky
C_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix C_stl;$/;"	m	class:Action_hessenberg
C_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix C_stl;$/;"	m	class:Action_tridiagonalization
C_stl	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::stl_matrix C_stl;$/;"	m	class:Action_lu_decomp
C_stl	bench/btl/actions/action_partial_lu.hh	/^  typename Interface::stl_matrix C_stl;$/;"	m	class:Action_partial_lu
CacheSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  CacheSizes(): m_l1(-1),m_l2(-1),m_l3(-1) {$/;"	f	struct:Eigen::internal::CacheSizes
CacheSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct CacheSizes {$/;"	s	namespace:Eigen::internal
CalcEulerAngles	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static void CalcEulerAngles($/;"	f	class:Eigen::EulerSystem
CalcEulerAngles_imp	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static void CalcEulerAngles_imp(Matrix<typename MatrixBase<Derived>::Scalar, 3, 1>& res, const MatrixBase<Derived>& mat, internal::true_type \/*isTaitBryan*\/)$/;"	f	class:Eigen::EulerSystem
CalcEulerAngles_imp	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static void CalcEulerAngles_imp(Matrix<typename MatrixBase<Derived>::Scalar,3,1>& res, const MatrixBase<Derived>& mat, internal::false_type \/*isTaitBryan*\/)$/;"	f	class:Eigen::EulerSystem
CalculateIndex	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct CalculateIndex<N, Arg1, Arg2, Arg3> {$/;"	s	namespace:Eigen::TensorSycl::internal
CalculateIndex	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct CalculateIndex<N, Arg1, Arg2>{$/;"	s	namespace:Eigen::TensorSycl::internal
CalculateIndex	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct CalculateIndex<N, Arg>{$/;"	s	namespace:Eigen::TensorSycl::internal
Camera	demos/opengl/camera.cpp	/^Camera::Camera()$/;"	f	class:Camera
Camera	demos/opengl/camera.cpp	/^Camera::Camera(const Camera& other)$/;"	f	class:Camera
Camera	demos/opengl/camera.h	/^class Camera$/;"	c
CanVectorizeInner	Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
CanVectorizeLhs	Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit) && (RowsAtCompileTime!=1),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
CanVectorizeRhs	Eigen/src/Core/ProductEvaluators.h	/^    CanVectorizeRhs = bool(RhsRowMajor) && (RhsFlags & PacketAccessBit) && (ColsAtCompileTime!=1),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
CancelWait	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void CancelWait(Waiter* w) {$/;"	f	class:Eigen::EventCount
CastCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int CastCost() {$/;"	f	class:Eigen::TensorOpCost
CastXpr	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^template<class NewType> struct CastXpr { typedef typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<Scalar, NewType>, const Derived> >::type Type; };$/;"	s
CategoryCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct CategoryCount<Arg,Args...>{$/;"	s	namespace:Eigen::TensorSycl::internal
CategoryCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^template<> struct CategoryCount<>$/;"	s	namespace:Eigen::TensorSycl::internal
CategoryHelper	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct CategoryHelper<Category, NoOP, utility::tuple::Tuple<T...> > {$/;"	s	namespace:Eigen::TensorSycl::internal
CategoryHelper	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct CategoryHelper<Category, OP, utility::tuple::Tuple<T...> > {$/;"	s	namespace:Eigen::TensorSycl::internal
CauchyBounds	unsupported/test/polynomialutils.cpp	/^void CauchyBounds(int deg)$/;"	f
CauchyBounds_scalar	unsupported/test/polynomialutils.cpp	/^template<typename _Scalar> void CauchyBounds_scalar()$/;"	f
CeilReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_ceil_op<Scalar>, const Derived> CeilReturnType;$/;"	t
Central	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Central$/;"	e	enum:Eigen::NumericalDiffMode
ChildType	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef ArgType ChildType;$/;"	t	struct:Eigen::TensorEvaluator
CholMatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, StorageIndex>            CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, StorageIndex>        CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholmodAuto	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    explicit CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodLDLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSupernodalLLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
ChordLengths	unsupported/Eigen/src/Splines/SplineFitting.h	/^  void ChordLengths(const PointArrayType& pts, KnotVectorType& chord_lengths)$/;"	f	namespace:Eigen
CodType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef CompleteOrthogonalDecomposition<MatrixType> CodType;$/;"	t	struct:Eigen::internal::Assignment
CoeffBasedProductMode	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
CoeffLoader	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffLoader(const Tensor& tensor) : m_data(tensor.data()) {}$/;"	f	struct:Eigen::internal::CoeffLoader
CoeffLoader	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffLoader(const Tensor& tensor) : m_tensor(tensor) { }$/;"	f	struct:Eigen::internal::CoeffLoader
CoeffLoader	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^template <typename Tensor, bool HasRawAccess> struct CoeffLoader {$/;"	s	namespace:Eigen::internal
CoeffLoader	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^template <typename Tensor> struct CoeffLoader<Tensor, true> {$/;"	s	namespace:Eigen::internal
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon478
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon479
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon758
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon751
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = TraversalSize==Dynamic ? HugeCost$/;"	e	enum:Eigen::internal::evaluator::__anon767
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<Arg1>::CoeffReadCost + evaluator<Arg2>::CoeffReadCost + evaluator<Arg3>::CoeffReadCost + functor_traits<TernaryOp>::Cost,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon754
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon757
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    $/;"	e	enum:Eigen::internal::unary_evaluator::__anon752
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon761
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon770
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon768
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ArgTypeNestedCleaned>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon765
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<ConditionMatrixType>::CoeffReadCost$/;"	e	enum:Eigen::internal::evaluator::__anon763
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
CoeffReadCost	Eigen/src/Core/CoreEvaluators.h	/^    CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,$/;"	e	enum:Eigen::internal::evaluator::__anon753
CoeffReadCost	Eigen/src/Core/ProductEvaluators.h	/^    CoeffReadCost = InnerSize==0 ? NumTraits<Scalar>::ReadCost$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
CoeffReadCost	Eigen/src/Core/ProductEvaluators.h	/^    CoeffReadCost = NumTraits<Scalar>::MulCost + evaluator<MatrixType>::CoeffReadCost + evaluator<DiagonalType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
CoeffReadCost	Eigen/src/Core/Redux.h	/^    CoeffReadCost = evaluator<XprType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
CoeffReadCost	Eigen/src/Core/Solve.h	/^    CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::traits::__anon494
CoeffReadCost	Eigen/src/Core/Visitor.h	/^    CoeffReadCost = internal::evaluator<XprType>::CoeffReadCost$/;"	e	enum:Eigen::internal::visitor_evaluator::__anon643
CoeffReadCost	Eigen/src/LU/PartialPivLU.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon228
CoeffReadCost	Eigen/src/SparseCore/SparseBlock.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon807
CoeffReadCost	Eigen/src/SparseCore/SparseCompressedBase.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon844
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon813
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon815
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon817
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon818
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon820
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon822
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon840
CoeffReadCost	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon841
CoeffReadCost	Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::sparse_dense_outer_product_evaluator::__anon833
CoeffReadCost	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon812
CoeffReadCost	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon811
CoeffReadCost	Eigen/src/SparseCore/SparseTranspose.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon850
CoeffReadCost	Eigen/src/SparseCore/SparseTriangularView.h	/^    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon826
CoeffReadCost	Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<_Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon849
CoeffReadCost	Eigen/src/SparseCore/SparseView.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon852
CoeffReadCost	Eigen/src/SparseCore/SparseView.h	/^      CoeffReadCost = evaluator<ArgType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon854
CoeffReadCost	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::traits::__anon29
CoeffReadCost	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon41
CoeffReadCost	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
CoeffReadCost	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        CoeffReadCost = HugeCost$/;"	e	enum:Eigen::internal::traits::__anon40
CoeffReadCost	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon72
CoeffReadCost	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    CoeffReadCost = internal::traits<BlockSparseMatrixT>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon76
CoeffReadCost	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon63
CoeffReadCost	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    CoeffReadCost = NumTraits<_Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::evaluator::__anon65
CoeffReturnType	Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::binary_evaluator
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::ternary_evaluator
CoeffReturnType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::unary_evaluator
CoeffReturnType	Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase
CoeffReturnType	Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
CoeffReturnType	Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase
CoeffReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase
CoeffReturnType	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::product_evaluator
CoeffReturnType	Eigen/src/Core/Redux.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::internal::redux_evaluator
CoeffReturnType	Eigen/src/Core/SolverBase.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::SolverBase
CoeffReturnType	Eigen/src/Core/Visitor.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::internal::visitor_evaluator
CoeffReturnType	Eigen/src/Geometry/Quaternion.h	/^  typedef typename Coefficients::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::QuaternionBase
CoeffReturnType	Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename DenseCoeffsBase<Derived,ReadOnlyAccessors>::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::evaluator
CoeffReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::Tensor
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef Index CoeffReturnType;$/;"	t	class:Eigen::TensorTupleReducerOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef Tuple<Index, typename XprType::CoeffReturnType> CoeffReturnType;$/;"	t	class:Eigen::TensorIndexTupleOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename LhsXprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorAssignOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::TensorBase
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef typename internal::remove_const<Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::TensorBase
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorBroadcastingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorChippingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^                                                    typename RhsXprType::CoeffReturnType>::ret CoeffReturnType;$/;"	t	class:Eigen::TensorConcatenationOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^                                                   typename RhsXprType::CoeffReturnType>::ResScalar CoeffReturnType;$/;"	t	class:Eigen::TensorContractionOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::TensorConversionOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef TargetType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^                                                  typename KernelXprType::CoeffReturnType>::ret CoeffReturnType;$/;"	t	class:Eigen::TensorConvolutionOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^                                                  typename RhsXprType::CoeffReturnType>::ret CoeffReturnType;$/;"	t	struct:Eigen::internal::traits
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorCustomUnaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomBinaryOp>::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorCustomBinaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	class:Eigen::TensorEvalToOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename Derived::Scalar CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename internal::traits<XprType>::Scalar CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^                                                    typename ElseXprType::CoeffReturnType>::ret CoeffReturnType;$/;"	t	class:Eigen::TensorSelectOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::TensorCwiseBinaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::TensorCwiseTernaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef Scalar CoeffReturnType;$/;"	t	class:Eigen::TensorCwiseUnaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorCwiseNullaryOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef OutputScalar CoeffReturnType;$/;"	t	class:Eigen::TensorFFTOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef OutputScalar CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorFixedSize
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	class:Eigen::TensorForcedEvalOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorGeneratorOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorImagePatchOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorInflationOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	class:Eigen::TensorLayoutSwapOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorMap
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorSlicingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorStridingSlicingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	class:Eigen::TensorReshapingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorPaddingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorPatchOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	class:Eigen::TensorReductionOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename internal::remove_const<typename XprType::CoeffReturnType>::type CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  typedef typename Self::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::FullReducer
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  typedef typename Self::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::internal::InnerReducer
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorRef
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Derived::Scalar CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorReverseOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorScanOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorShufflingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorStridingOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::TensorVolumePatchOp
CoeffReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprType::CoeffReturnType CoeffReturnType;$/;"	t	struct:Eigen::TensorEvaluator
CoeffType	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef AutoDiffScalar<typename JacobianType::ColXpr> CoeffType;$/;"	t	class:Eigen::AutoDiffVector
CoeffVectorType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition
CoeffVectorType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization
CoeffVectorType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Coefficients	Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoherentAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
ColMajor	Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::StorageOptions
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    explicit ColPivHouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    explicit ColPivHouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU
ColType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD
ColVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
ColVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
ColXpr	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase
ColXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
Colamd_Row	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct Colamd_Row$/;"	s	namespace:internal
Color	demos/opengl/gpuhelper.h	/^typedef Vector4f Color;$/;"	t
Cols	Eigen/src/Core/GeneralProduct.h	/^    Cols    = traits<_Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
Cols	Eigen/src/Geometry/Homogeneous.h	/^    Cols = Rhs::ColsAtCompileTime$/;"	e	enum:Eigen::internal::homogeneous_left_product_refactoring_helper::__anon261
Cols	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    Cols = size_at_compile_time<traits<Lhs>::ColsAtCompileTime, traits<Rhs>::ColsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon28
ColsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon242
ColsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon243
ColsAtCompileTime	Eigen/src/CholmodSupport/CholmodSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::CholmodBase::__anon281
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon478
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon479
ColsAtCompileTime	Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon464
ColsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = PlainObjectType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon751
ColsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = XprType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon758
ColsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    ColsAtCompileTime = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon761
ColsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon446
ColsAtCompileTime	Eigen/src/Core/CwiseTernaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon514
ColsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
ColsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon500
ColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon282
ColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon284
ColsAtCompileTime	Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon436
ColsAtCompileTime	Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon439
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = PermTraits::ColsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon468
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon466
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon467
ColsAtCompileTime	Eigen/src/Core/Product.h	/^    ColsAtCompileTime    = RhsTraits::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
ColsAtCompileTime	Eigen/src/Core/ProductEvaluators.h	/^    ColsAtCompileTime = RhsNestedCleaned::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon427
ColsAtCompileTime	Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon772
ColsAtCompileTime	Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon433
ColsAtCompileTime	Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
ColsAtCompileTime	Eigen/src/Core/SolverBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
ColsAtCompileTime	Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon443
ColsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
ColsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon637
ColsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon861
ColsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon862
ColsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon864
ColsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon860
ColsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon859
ColsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon855
ColsAtCompileTime	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon863
ColsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon258
ColsAtCompileTime	Eigen/src/Geometry/Transform.h	/^    ColsAtCompileTime = Dim1,$/;"	e	enum:Eigen::internal::traits::__anon264
ColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon278
ColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon277
ColsAtCompileTime	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::DiagonalPreconditioner::__anon232
ColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::IncompleteCholesky::__anon240
ColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::IncompleteLUT::__anon241
ColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::IterativeSolverBase::__anon237
ColsAtCompileTime	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PastixBase::__anon213
ColsAtCompileTime	Eigen/src/PardisoSupport/PardisoSupport.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::PardisoImpl::__anon787
ColsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon212
ColsAtCompileTime	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon210
ColsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon208
ColsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon206
ColsAtCompileTime	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::SPQR::__anon790
ColsAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon777
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon784
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon781
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon782
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon783
ColsAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon786
ColsAtCompileTime	Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon785
ColsAtCompileTime	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon217
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon837
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon836
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
ColsAtCompileTime	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      ColsAtCompileTime = internal::traits<SparseSelfAdjointView>::ColsAtCompileTime$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon834
ColsAtCompileTime	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      ColsAtCompileTime = internal::traits<SparseSymmetricPermutationProduct>::ColsAtCompileTime$/;"	e	enum:Eigen::SparseSymmetricPermutationProduct::__anon835
ColsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon845
ColsAtCompileTime	Eigen/src/SparseLU/SparseLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseLU::__anon874
ColsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^      ColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon774
ColsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseQR::__anon775
ColsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^    ColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::SparseQRMatrixQReturnType::__anon776
ColsAtCompileTime	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SuperLUBase::__anon867
ColsAtCompileTime	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::UmfPackLU::__anon791
ColsAtCompileTime	doc/examples/matrixfree_cg.cpp	/^    ColsAtCompileTime = Eigen::Dynamic,$/;"	e	enum:MatrixReplacement::__anon191	file:
ColsAtCompileTime	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    ColsAtCompileTime = size_at_compile_time<traits<Lhs>::ColsAtCompileTime, traits<Rhs>::ColsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon29
ColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon41
ColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
ColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon40
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      ColsAtCompileTime = BlockSparseMatrixT::ColsAtCompileTime,$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      ColsAtCompileTime = VectorType::ColsAtCompileTime,$/;"	e	enum:Eigen::BlockVectorReturn::__anon75
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      ColsAtCompileTime = VectorType::ColsAtCompileTime,$/;"	e	enum:Eigen::BlockVectorView::__anon74
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon72
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon76
ColsAtCompileTime	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon63
ColsAtCompileTimeMinusOne	Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon785
ColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
ColsPlusOne	Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon258
ColumnVectorType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver
ColumnVectorType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealQZ
ColumnVectorType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur
ColwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(const CommaInitializer& o)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
CommitWait	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void CommitWait(Waiter* w) {$/;"	f	class:Eigen::EventCount
CompactVectorType	blas/common.h	/^typedef Map<Matrix<Scalar,Dynamic,1> > CompactVectorType;$/;"	t
CompanionMatrixType	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef Matrix<Scalar,_Deg,_Deg>                 CompanionMatrixType;$/;"	t	class:Eigen::PolynomialSolver
ComparisonName	Eigen/src/Core/util/Constants.h	/^enum ComparisonName {$/;"	g	namespace:Eigen::internal
CompleteOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition() : m_cpqr(), m_zCoeffs(), m_temp() {}$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition(Index rows, Index cols)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  explicit CompleteOrthogonalDecomposition(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  explicit CompleteOrthogonalDecomposition(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
CompleteOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^class CompleteOrthogonalDecomposition {$/;"	c	namespace:Eigen
CompleteUnrolling	Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::UnrollingType
Complex	blas/common.h	/^typedef std::complex<RealScalar> Complex;$/;"	t
Complex	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::fftw_impl
Complex	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::kiss_cpx_fft
Complex	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::kissfft_impl
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    explicit ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    explicit ComplexEigenSolver(const EigenBase<InputType>& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexMatrix	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^              MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime> ComplexMatrix;$/;"	t	class:Eigen::MatrixPower
ComplexMatrixType	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function
ComplexScalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver
ComplexScalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver
ComplexScalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
ComplexScalar	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealQZ
ComplexScalar	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur
ComplexScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::TensorFFTOp
ComplexScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename std::complex<RealScalar> ComplexScalar;$/;"	t	struct:Eigen::TensorEvaluator
ComplexScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename std::complex<RealScalar> ComplexScalar;$/;"	t	struct:Eigen::internal::traits
ComplexScalar	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  typedef std::complex<RealScalar> ComplexScalar;$/;"	t	struct:Eigen::internal::MatrixExponentialScalingOp
ComplexScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::MatrixPower
ComplexScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::MatrixPowerAtomic
ComplexScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename std::complex<typename Derived::RealScalar> ComplexScalar;$/;"	t	class:Eigen::MatrixComplexPowerReturnValue
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^    explicit ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^    explicit ComplexSchur(const EigenBase<InputType>& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
ComplexVector	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef Matrix<std::complex<RealScalar>, Dynamic, 1> ComplexVector;$/;"	t	class:Eigen::DGMRES
ComplexVectorType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ComplexVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
CompressedAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int CompressedAccessBit = 0x400;$/;"	m	namespace:Eigen
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    explicit CompressedStorage(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
ComputationInfo	Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
ComputeEigenvectors	Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullU	Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinU	Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
Cond	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^template<bool cond> struct Cond {};$/;"	s	namespace:Eigen
ConditionMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits
Conj	Eigen/src/Core/functors/BinaryFunctors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon380
Conj	blas/common.h	/^  Conj = IsComplex$/;"	e	enum:__anon202
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
Conjugate	Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon477
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen
ConjugateReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const MatrixConjugateReturnType,UpLo> ConjugateReturnType;$/;"	t	class:Eigen::SelfAdjointView
ConjugateReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const MatrixConjugateReturnType,Mode> ConjugateReturnType;$/;"	t	class:Eigen::TriangularView
ConjugateReturnType	Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence
ConjugateReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
ConjugationFlag	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  ConjugationFlag        = 0x02$/;"	e	enum:Eigen::__anon189
ConstAffinePart	Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform
ConstAffinePart	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
ConstAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, AlignedMax> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived> ConstBlockXpr;$/;"	t
ConstCholMatrixPtr	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef CholMatrixType const * ConstCholMatrixPtr;$/;"	t	class:Eigen::SimplicialCholeskyBase
ConstCholMatrixPtr	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef CholMatrixType const * ConstCholMatrixPtr;$/;"	t	struct:Eigen::internal::simplicial_cholesky_grab_input
ConstColXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
ConstColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstDiagonalDynamicIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
ConstDiagonalIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
ConstDiagonalReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
ConstDiagonalReturnType	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef Diagonal<const SparseMatrix> ConstDiagonalReturnType;$/;"	t	class:Eigen::SparseMatrix
ConstFixedBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct ConstFixedBlockXpr { typedef Block<const Derived,Rows,Cols> Type; };$/;"	s
ConstFixedSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s
ConstInnerVectorReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstInnerVectorsReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstLinearPart	Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstMatrixPtr	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef MatrixType const * ConstMatrixPtr;$/;"	t	struct:Eigen::internal::simplicial_cholesky_grab_input
ConstMatrixType	Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform
ConstMatrixType	blas/common.h	/^typedef Map<const Matrix<Scalar,Dynamic,Dynamic,ColMajor>, 0, OuterStride<> > ConstMatrixType;$/;"	t
ConstNColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNormalReturnType	Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane
ConstReverseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase
ConstReverseReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef Reverse<const ExpressionType, Direction> ConstReverseReturnType;$/;"	t	class:Eigen::VectorwiseOp
ConstRowXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
ConstRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t
ConstSelfAdjointViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
ConstSelfAdjointViewReturnType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<int UpLo> struct ConstSelfAdjointViewReturnType {$/;"	s	class:Eigen::internal::generic_matrix_wrapper
ConstSelfAdjointViewReturnType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<int UpLo> struct ConstSelfAdjointViewReturnType$/;"	s	class:Eigen::internal::generic_matrix_wrapper
ConstSelfAdjointViewReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SparseSelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::SparseMatrixBase
ConstStartMinusOne	Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase
ConstTranslationPart	Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTransposeReturnType	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase
ConstTransposeReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase
ConstTransposeReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;$/;"	t	class:Eigen::SelfAdjointView
ConstTransposeReturnType	Eigen/src/Core/SolverBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::SolverBase
ConstTransposeReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;$/;"	t	class:Eigen::TriangularView
ConstTransposeReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstTriangularViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase
ConstantBlock	Eigen/src/Geometry/Homogeneous.h	/^  typedef Replicate<const ConstantColumn,1,Cols>                        ConstantBlock;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
ConstantBlock	Eigen/src/Geometry/Homogeneous.h	/^  typedef Replicate<const ConstantColumn,Rows,1>                        ConstantBlock;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
ConstantBlock	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename helper::ConstantBlock ConstantBlock;$/;"	t	struct:Eigen::internal::product_evaluator
ConstantColumn	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Lhs::ConstColXpr                                     ConstantColumn;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
ConstantColumn	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Rhs::ConstRowXpr                                     ConstantColumn;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
ConstantReturnType	Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase
ConstantReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::DenseBase
ConstantReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase
ConstantReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Context	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Context(const Device& device, int num_threads, LhsMapper& lhs,$/;"	f	class:Eigen::TensorEvaluator::Context
Context	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  class Context {$/;"	c	struct:Eigen::TensorEvaluator
ContractDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int ContractDims = internal::array_size<Indices>::value;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
ContractDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int ContractDims = internal::array_size<Indices>::value;$/;"	m	struct:Eigen::TensorEvaluator
ContractDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  static const int ContractDims = internal::array_size<Indices>::value;$/;"	m	struct:Eigen::TensorEvaluator
ContractDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static const int ContractDims = internal::array_size<Indices>::value;$/;"	m	struct:Eigen::TensorEvaluator
ControlPointVectorType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::ControlPointVectorType ControlPointVectorType;$/;"	t	class:Eigen::Spline
ControlPointVectorType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,Dynamic> ControlPointVectorType;$/;"	t	struct:Eigen::SplineTraits
ConversionSubExprEval	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^template <bool SameType, typename Eval, typename Scalar> struct ConversionSubExprEval {$/;"	s	namespace:Eigen
ConversionSubExprEval	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^template <typename Eval, typename Scalar> struct ConversionSubExprEval<true, Eval, Scalar> {$/;"	s	namespace:Eigen
ConvertToPacket2l	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static inline Packet2l ConvertToPacket2l(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      CoordAccess = true,$/;"	e	enum:Eigen::Tensor::__anon122
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon100
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon99
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon124
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorContractionEvaluatorBase::__anon165
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon145
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon146
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon137
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon138
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon141
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = NumCoords > 0,$/;"	e	enum:Eigen::TensorEvaluator::__anon109
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = NumCoords > 0,$/;"	e	enum:Eigen::TensorEvaluator::__anon111
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon112
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon113
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon114
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon115
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon116
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon148
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^      CoordAccess = true,$/;"	e	enum:Eigen::TensorFixedSize::__anon87
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon142
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon130
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon136
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    CoordAccess = false  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon86
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon85
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^      CoordAccess = true,$/;"	e	enum:Eigen::TensorMap::__anon127
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    CoordAccess = TensorEvaluator<ArgType, Device>::CoordAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon95
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon89
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon90
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon92
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon93
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    CoordAccess = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon147
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon88
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon128
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^      CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorRef::__anon152
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon153
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon183
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon184
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon129
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon150
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon185
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    CoordAccess = false,  \/\/ to be implemented$/;"	e	enum:Eigen::TensorEvaluator::__anon186
CoordAccess	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    CoordAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon143
Coordinates	bench/sparse_setter.cpp	/^typedef std::vector<Vector2i> Coordinates;$/;"	t	file:
CornerType	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox
CosReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cos_op<Scalar>, const Derived> CosReturnType;$/;"	t
CoshReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cosh_op<Scalar>, const Derived> CoshReturnType;$/;"	t
CosinusTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        CosinusTooSmall = 4,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
CosinusTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        CosinusTooSmall = 4,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Cost	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon516
Cost	Eigen/src/Core/Redux.h	/^    Cost = Derived::SizeAtCompileTime == Dynamic ? HugeCost$/;"	e	enum:Eigen::internal::redux_traits::__anon485
Cost	Eigen/src/Core/VectorwiseOp.h	/^  template<typename Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_lpnorm
Cost	Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux
Cost	Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon644
Cost	Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon645
Cost	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon672
Cost	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon673
Cost	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon674
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = 3 * NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon397
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon393
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon394
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon395
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon396
Cost	Eigen/src/Core/functors/AssignmentFunctors.h	/^    Cost = NumTraits<DstScalar>::ReadCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon392
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon378
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon382
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon383
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon384
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)\/2,$/;"	e	enum:Eigen::internal::functor_traits::__anon387
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon379
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = 3 * NumTraits<Scalar>::AddCost +$/;"	e	enum:Eigen::internal::functor_traits::__anon385
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon381
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon389
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon390
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon391
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^    Cost = scalar_div_cost<result_type,PacketAccess>::value$/;"	e	enum:Eigen::internal::functor_traits::__anon388
Cost	Eigen/src/Core/functors/BinaryFunctors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon386
Cost	Eigen/src/Core/functors/NullaryFunctors.h	/^    Cost = 1,$/;"	e	enum:Eigen::internal::functor_traits::__anon364
Cost	Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = 0 \/* as the constant value should be loaded in register only once for the whole expression *\/,$/;"	e	enum:Eigen::internal::functor_traits::__anon362
Cost	Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon363
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon416
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon417
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon418
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon419
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon414
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon415
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon403
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon404
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon405
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon406
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon407
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon408
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon409
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon410
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon411
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon400
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon401
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon402
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon398
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon399
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon421
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon420
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon412
Cost	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon413
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = $/;"	e	enum:Eigen::internal::functor_traits::__anon361
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = ( (EIGEN_FAST_MATH && is_same<Scalar,float>::value)$/;"	e	enum:Eigen::internal::functor_traits::__anon348
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = (sizeof(Scalar) == 8 ? 28$/;"	e	enum:Eigen::internal::functor_traits::__anon340
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon341
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon342
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon343
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon344
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon345
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon346
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon347
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon349
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon350
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon326
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon327
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? 5 * NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon330
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon329
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon354
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon355
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon356
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon357
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon358
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon359
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon360
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost = functor_traits<scalar_log_op<Scalar> >::Cost \/\/ TODO measure cost of log1p$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost =$/;"	e	enum:Eigen::internal::functor_traits::__anon336
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^    Cost =$/;"	e	enum:Eigen::internal::functor_traits::__anon337
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon332
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon333
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon328
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
Cost	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon331
Cost	blas/level1_cplx_impl.h	/^      enum { Cost = 3 * NumTraits<Scalar>::AddCost, PacketAccess = 0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon205
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = 1,$/;"	e	enum:Eigen::internal::reducer_traits::__anon171
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = 1,$/;"	e	enum:Eigen::internal::reducer_traits::__anon177
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = 1,$/;"	e	enum:Eigen::internal::reducer_traits::__anon178
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumDims * (2 * NumTraits<T>::AddCost + NumTraits<T>::MulCost +$/;"	e	enum:Eigen::internal::functor_traits::__anon181
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost * 2 + NumTraits<T>::MulCost * 6,$/;"	e	enum:Eigen::internal::functor_traits::__anon170
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon172
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon173
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon174
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon175
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon179
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::AddCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon180
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    Cost = NumTraits<T>::MulCost,$/;"	e	enum:Eigen::internal::reducer_traits::__anon176
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  enum { Cost = 13,  \/\/ Reciprocal throughput of FPREM on Haswell.$/;"	e	enum:Eigen::internal::functor_traits::__anon169
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^{ enum { Cost = scalar_div_cost<Scalar,false>::value, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon167
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^{ enum { Cost = scalar_div_cost<Scalar,false>::value, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon168
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^    Cost = 12 * NumTraits<Scalar>::AddCost *$/;"	e	enum:Eigen::internal::functor_traits::__anon102
Cost	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^    Cost = 3 * functor_traits<UniformRandomGenerator<Scalar> >::Cost +$/;"	e	enum:Eigen::internal::functor_traits::__anon103
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^        Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon36
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^        Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon37
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon34
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon35
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon38
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 10 * NumTraits<Scalar>::MulCost + 5 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon39
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 20 * NumTraits<Scalar>::MulCost + 10 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon31
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 20 * NumTraits<Scalar>::MulCost + 10 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon32
Cost	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    Cost = 400 * NumTraits<Scalar>::MulCost + 400 * NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon33
CostOpType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::evaluator
Count	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^    static const size_t Count =1;$/;"	m	struct:Eigen::TensorSycl::internal::LeafCount
Count	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^  static const size_t Count = 1 + CategoryCount<Expr>::Count;$/;"	m	struct:Eigen::TensorSycl::internal::LeafCount
Count	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^  static const size_t Count = LeafCount<Arg>::Count + CategoryCount<Args...>::Count;$/;"	m	struct:Eigen::TensorSycl::internal::CategoryCount
Count	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^  static const size_t Count =0;$/;"	m	struct:Eigen::TensorSycl::internal::CategoryCount
Count	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^  static const size_t Count =1;$/;"	m	struct:Eigen::TensorSycl::internal::LeafCount
CountReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> CountReturnType;$/;"	t	class:Eigen::VectorwiseOp
CreateTask	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^  Task CreateTask(std::function<void()> f) { return Task{std::move(f)}; }$/;"	f	struct:Eigen::StlThreadEnvironment
CreateThread	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^  EnvThread* CreateThread(std::function<void()> f) { return new EnvThread(std::move(f)); }$/;"	f	struct:Eigen::StlThreadEnvironment
CrossReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp
CubeReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_cube_op<Scalar>, const Derived> CubeReturnType;$/;"	t
CudaStreamDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  CudaStreamDevice() : stream_(&default_stream), scratch_(NULL), semaphore_(NULL) {$/;"	f	class:Eigen::CudaStreamDevice
CudaStreamDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  CudaStreamDevice(const cudaStream_t* stream, int device = -1)$/;"	f	class:Eigen::CudaStreamDevice
CudaStreamDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  CudaStreamDevice(int device) : stream_(&default_stream), device_(device), scratch_(NULL), semaphore_(NULL) {$/;"	f	class:Eigen::CudaStreamDevice
CudaStreamDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^class CudaStreamDevice : public StreamInterface {$/;"	c	namespace:Eigen
CwiseAbs2ReturnType	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived> CwiseAbs2ReturnType;$/;"	t
CwiseAbsReturnType	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived> CwiseAbsReturnType;$/;"	t
CwiseBinaryOp	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp
CwiseBinaryOp	Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : $/;"	c	namespace:Eigen
CwiseBinaryOpImpl	Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl
CwiseBinaryOpImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen
CwiseClampOp	doc/examples/class_CwiseUnaryOp.cpp	/^  CwiseClampOp(const Scalar& inf, const Scalar& sup) : m_inf(inf), m_sup(sup) {}$/;"	f	struct:CwiseClampOp
CwiseClampOp	doc/examples/class_CwiseUnaryOp.cpp	/^struct CwiseClampOp {$/;"	s	file:
CwiseInverseReturnType	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> CwiseInverseReturnType;$/;"	t
CwiseNullaryOp	Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp
CwiseNullaryOp	Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : public internal::dense_xpr_base< CwiseNullaryOp<NullaryOp, PlainObjectType> >::type, internal::no_assignment_operator$/;"	c	namespace:Eigen
CwiseProductDenseReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> struct CwiseProductDenseReturnType {$/;"	s	class:Eigen::SparseMatrixBase
CwiseScalarEqualReturnType	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,Scalar,internal::cmp_EQ>, const Derived, const ConstantReturnType> CwiseScalarEqualReturnType;$/;"	t
CwiseSignReturnType	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> CwiseSignReturnType;$/;"	t
CwiseSqrtReturnType	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> CwiseSqrtReturnType;$/;"	t
CwiseTernaryOp	Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE CwiseTernaryOp(const Arg1& a1, const Arg2& a2,$/;"	f	class:Eigen::CwiseTernaryOp
CwiseTernaryOp	Eigen/src/Core/CwiseTernaryOp.h	/^class CwiseTernaryOp : public CwiseTernaryOpImpl<$/;"	c	namespace:Eigen
CwiseTernaryOpImpl	Eigen/src/Core/CwiseTernaryOp.h	/^class CwiseTernaryOpImpl$/;"	c	namespace:Eigen
CwiseUnaryOp	Eigen/src/Core/CwiseUnaryOp.h	/^    explicit CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp
CwiseUnaryOp	Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : public CwiseUnaryOpImpl<UnaryOp, XprType, typename internal::traits<XprType>::StorageKind>, internal::no_assignment_operator$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl$/;"	c	namespace:Eigen
CwiseUnaryView	Eigen/src/Core/CwiseUnaryView.h	/^    explicit inline CwiseUnaryView(MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView
CwiseUnaryView	Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen
D	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^MatrixXcd D = es.eigenvalues().asDiagonal();$/;"	v
D	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^MatrixXd D = es.pseudoEigenvalueMatrix();$/;"	v
D	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^MatrixXd D = es.eigenvalues().asDiagonal();$/;"	v
DBEG	blas/testing/dblat2.f	/^      DOUBLE PRECISION FUNCTION DBEG(/;"	f
DBEG	blas/testing/dblat3.f	/^      DOUBLE PRECISION FUNCTION DBEG(/;"	f
DBLAT1	blas/testing/dblat1.f	/^      PROGRAM DBLAT1$/;"	p
DBLAT2	blas/testing/dblat2.f	/^      PROGRAM DBLAT2$/;"	p
DBLAT3	blas/testing/dblat3.f	/^      PROGRAM DBLAT3$/;"	p
DCHK1	blas/testing/dblat2.f	/^      SUBROUTINE DCHK1(/;"	s
DCHK1	blas/testing/dblat3.f	/^      SUBROUTINE DCHK1(/;"	s
DCHK2	blas/testing/dblat2.f	/^      SUBROUTINE DCHK2(/;"	s
DCHK2	blas/testing/dblat3.f	/^      SUBROUTINE DCHK2(/;"	s
DCHK3	blas/testing/dblat2.f	/^      SUBROUTINE DCHK3(/;"	s
DCHK3	blas/testing/dblat3.f	/^      SUBROUTINE DCHK3(/;"	s
DCHK4	blas/testing/dblat2.f	/^      SUBROUTINE DCHK4(/;"	s
DCHK4	blas/testing/dblat3.f	/^      SUBROUTINE DCHK4(/;"	s
DCHK5	blas/testing/dblat2.f	/^      SUBROUTINE DCHK5(/;"	s
DCHK5	blas/testing/dblat3.f	/^      SUBROUTINE DCHK5(/;"	s
DCHK6	blas/testing/dblat2.f	/^      SUBROUTINE DCHK6(/;"	s
DCHKE	blas/testing/dblat2.f	/^      SUBROUTINE DCHKE(/;"	s
DCHKE	blas/testing/dblat3.f	/^      SUBROUTINE DCHKE(/;"	s
DDIFF	blas/testing/dblat2.f	/^      DOUBLE PRECISION   DDIFF$/;"	v	program:DBLAT2
DDIFF	blas/testing/dblat2.f	/^      DOUBLE PRECISION FUNCTION DDIFF(/;"	f
DDIFF	blas/testing/dblat3.f	/^      DOUBLE PRECISION   DDIFF$/;"	v	program:DBLAT3
DDIFF	blas/testing/dblat3.f	/^      DOUBLE PRECISION FUNCTION DDIFF(/;"	f
DDIFF	blas/testing/zblat2.f	/^      DOUBLE PRECISION   DDIFF$/;"	v	program:ZBLAT2
DDIFF	blas/testing/zblat2.f	/^      DOUBLE PRECISION FUNCTION DDIFF(/;"	f
DDIFF	blas/testing/zblat3.f	/^      DOUBLE PRECISION   DDIFF$/;"	v	program:ZBLAT3
DDIFF	blas/testing/zblat3.f	/^      DOUBLE PRECISION FUNCTION DDIFF(/;"	f
DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	109;"	d
DEAD_NON_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	113;"	d
DEAD_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	112;"	d
DEBUG	test/main.h	124;"	d
DECL_GSISX	Eigen/src/SuperLUSupport/SuperLUSupport.h	76;"	d
DECL_GSSVX	Eigen/src/SuperLUSupport/SuperLUSupport.h	16;"	d
DEFAULT_NB_SAMPLE	bench/btl/generic_bench/bench_parameter.hh	48;"	d
DEFAULT_NB_TRIES	bench/btl/generic_bench/bench_parameter.hh	51;"	d
DEFAULT_REPEAT	test/main.h	136;"	d
DENSITY	bench/BenchSparseUtil.h	15;"	d
DENSITY	bench/sparse_cholesky.cpp	16;"	d	file:
DENSITY	bench/sparse_dense_product.cpp	11;"	d	file:
DENSITY	bench/sparse_lu.cpp	16;"	d	file:
DENSITY	bench/sparse_randomsetter.cpp	15;"	d	file:
DENSITY	bench/sparse_transpose.cpp	11;"	d	file:
DENSITY	bench/sparse_trisolver.cpp	12;"	d	file:
DGMRES	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  DGMRES() : Base(),m_restart(30),m_neig(0),m_r(0),m_maxNeig(5),m_isDeflAllocated(false),m_isDeflInitialized(false) {}$/;"	f	class:Eigen::DGMRES
DGMRES	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  explicit DGMRES(const EigenBase<MatrixDerived>& A) : Base(A.derived()), m_restart(30),m_neig(0),m_r(0),m_maxNeig(5),m_isDeflAllocated(false),m_isDeflInitialized(false) {}$/;"	f	class:Eigen::DGMRES
DGMRES	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^class DGMRES : public IterativeSolverBase<DGMRES<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
DIAG	blas/common.h	52;"	d
DISABLE_SSE_EXCEPTIONS	bench/BenchUtil.h	34;"	d
DISABLE_SSE_EXCEPTIONS	bench/BenchUtil.h	43;"	d
DLADIV	lapack/dladiv.f	/^      SUBROUTINE DLADIV(/;"	s
DLAMC3	lapack/dlamch.f	/^      DOUBLE PRECISION FUNCTION DLAMC3(/;"	f
DLAMCH	lapack/dlamch.f	/^      DOUBLE PRECISION FUNCTION DLAMCH(/;"	f
DLAPY2	lapack/dlapy2.f	/^      DOUBLE PRECISION FUNCTION DLAPY2(/;"	f
DLAPY3	lapack/dlapy3.f	/^      DOUBLE PRECISION FUNCTION DLAPY3(/;"	f
DLARF	lapack/dlarf.f	/^      SUBROUTINE DLARF(/;"	s
DLARFB	lapack/dlarfb.f	/^      SUBROUTINE DLARFB(/;"	s
DLARFG	lapack/dlarfg.f	/^      SUBROUTINE DLARFG(/;"	s
DLARFT	lapack/dlarft.f	/^      SUBROUTINE DLARFT(/;"	s
DMAKE	blas/testing/dblat2.f	/^      SUBROUTINE DMAKE(/;"	s
DMAKE	blas/testing/dblat3.f	/^      SUBROUTINE DMAKE(/;"	s
DMMCH	blas/testing/dblat3.f	/^      SUBROUTINE DMMCH(/;"	s
DMVCH	blas/testing/dblat2.f	/^      SUBROUTINE DMVCH(/;"	s
DSECND	lapack/dsecnd_NONE.f	/^      DOUBLE PRECISION FUNCTION DSECND(/;"	f
DST_CHAN	Eigen/src/Core/arch/AltiVec/PacketMath.h	65;"	d
DST_CTRL	Eigen/src/Core/arch/AltiVec/PacketMath.h	66;"	d
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC DSizes(const DenseIndex i0, const DenseIndex i1) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2, const DenseIndex i3) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC DSizes(const DenseIndex i0, const DenseIndex i1, const DenseIndex i2, const DenseIndex i3, const DenseIndex i4) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DSizes() {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC explicit DSizes(const DenseIndex i0) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC explicit DSizes(const array<DenseIndex, NumDims>& a) : Base(a) { }$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_STRONG_INLINE explicit DSizes(DenseIndex firstDimension, DenseIndex secondDimension, IndexTypes... otherDimensions) : Base({{firstDimension, secondDimension, otherDimensions...}}) {$/;"	f	struct:Eigen::DSizes
DSizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct DSizes : array<DenseIndex, NumDims> {$/;"	s	namespace:Eigen
DUMP_CPUID	bench/check_cache_queries.cpp	9;"	d	file:
DataMatrix	doc/snippets/LLT_solve.cpp	/^typedef Matrix<float,Dynamic,2> DataMatrix;$/;"	t	file:
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon476
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon478
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon479
DecompositionOptions	Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base
DecompositionType	Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base
Default	Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
DefaultDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^struct DefaultDevice {$/;"	s	namespace:Eigen
DefaultProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
DefaultTraversal	Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::TraversalType
Default_t	Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Defined	Eigen/src/Core/util/Meta.h	/^  enum { Defined = 0 };$/;"	e	enum:Eigen::scalar_product_traits::__anon605
Deg	unsupported/Eigen/src/Polynomials/Companion.h	/^      Deg = _Deg,$/;"	e	enum:Eigen::internal::companion::__anon51
Deg_1	unsupported/Eigen/src/Polynomials/Companion.h	/^      Deg_1=decrement_if_fixed_size<Deg>::ret$/;"	e	enum:Eigen::internal::companion::__anon51
Degree	unsupported/Eigen/src/Splines/Spline.h	/^    enum { Degree = _Degree \/*!< The spline curve's degree. *\/ };$/;"	e	enum:Eigen::Spline::__anon54
Degree	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { Degree = _Degree \/*!< The spline curve's degree. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon56
Dense	Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
Dense2Dense	Eigen/src/Core/AssignEvaluator.h	/^struct Dense2Dense {};$/;"	s	namespace:Eigen::internal
Dense2Triangular	Eigen/src/Core/TriangularMatrix.h	/^struct Dense2Triangular         {};$/;"	s	namespace:Eigen::internal
DenseBase	Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC DenseBase()$/;"	f	class:Eigen::DenseBase
DenseBase	Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen
DenseCompanionMatrixType	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg, Deg>               DenseCompanionMatrixType;$/;"	t	class:Eigen::internal::companion
DenseFunctor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  DenseFunctor() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:Eigen::DenseFunctor
DenseFunctor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  DenseFunctor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Eigen::DenseFunctor
DenseFunctor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^struct DenseFunctor$/;"	s	namespace:Eigen
DenseIndex	Eigen/src/Core/util/Meta.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseLM	test/denseLM.cpp	/^  DenseLM(int n, int m) : DenseFunctor<Scalar>(n,m) $/;"	f	struct:DenseLM
DenseLM	test/denseLM.cpp	/^struct DenseLM : DenseFunctor<Scalar>$/;"	s	file:
DenseMatrix	Eigen/src/SparseQR/SparseQR.h	/^  typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
DenseMatrix	bench/BenchSparseUtil.h	/^typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t
DenseMatrix	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix; $/;"	t	class:Eigen::DGMRES
DenseMatrixType	Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase
DenseMatrixType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase
DenseMatrixType	Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase
DenseMatrixType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::InverseImpl
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	class:Eigen::TriangularViewImpl
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::FullMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase
DenseMatrixType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
DenseRealMatrix	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef Matrix<RealScalar,Dynamic,Dynamic> DenseRealMatrix; $/;"	t	class:Eigen::DGMRES
DenseRealVector	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef Matrix<RealScalar,Dynamic,1> DenseRealVector; $/;"	t	class:Eigen::DGMRES
DenseShape	Eigen/src/Core/util/Constants.h	/^struct DenseShape             { static std::string debugName() { return "DenseShape"; } };$/;"	s	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() {$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage() {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index) : m_rows(rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index, Index, Index cols) : m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseTimeSkylineProduct	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
DenseType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase
DenseType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase
DenseType	Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase
DenseVector	bench/BenchSparseUtil.h	/^typedef Matrix<Scalar,Dynamic,1> DenseVector;$/;"	t
DenseVector	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef Matrix<Scalar,Dynamic,1> DenseVector;$/;"	t	class:Eigen::DGMRES
Depends	test/unalignedassert.cpp	/^template<bool Align> struct Depends$/;"	s	file:
Depth	Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(traits<_Lhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
DerType	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename internal::remove_all<_DerType>::type DerType;$/;"	t	class:Eigen::AutoDiffScalar
DerType	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename remove_all<_DerType>::type DerType;$/;"	t	struct:Eigen::internal::auto_diff_special_op
DerTypeCleaned	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename internal::remove_all<DerType>::type DerTypeCleaned;$/;"	t	struct:Eigen::NumTraits
DerivativeMemoryLayout	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { DerivativeMemoryLayout = Dimension==1 ? RowMajor : ColMajor \/*!< The derivative type's memory layout. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon59
DerivativeMemoryLayout	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { DerivativeMemoryLayout = _Dim==1 ? RowMajor : ColMajor \/*!< The derivative type's memory layout. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon62
DerivativeType	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<Scalar, InputsAtCompileTime, 1> DerivativeType;$/;"	t	class:Eigen::AutoDiffJacobian
DerivativeType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,Dynamic,DerivativeMemoryLayout,Dimension,NumOfDerivativesAtCompileTime> DerivativeType;$/;"	t	struct:Eigen::SplineTraits
DerivativeType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<_Scalar,_Dim,Dynamic,DerivativeMemoryLayout,_Dim,NumOfDerivativesAtCompileTime> DerivativeType;$/;"	t	struct:Eigen::SplineTraits
Derived	Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Derived	Eigen/src/Core/Product.h	/^    typedef Product<Lhs, Rhs, Option> Derived;$/;"	t	class:Eigen::ProductImpl
Derived	Eigen/src/Core/Solve.h	/^  typedef Solve<Decomposition,RhsType> Derived;$/;"	t	class:Eigen::SolveImpl
Derived	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
DerivedAlignment	Eigen/src/Core/Ref.h	/^      DerivedAlignment = int(evaluator<Derived>::Alignment),$/;"	e	enum:Eigen::internal::traits::match::__anon474
DerivedNested	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename internal::ref_selector<Derived>::type DerivedNested;$/;"	t	class:Eigen::MatrixFunctionReturnValue
DerivedNested	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename internal::ref_selector<Derived>::type DerivedNested;$/;"	t	class:Eigen::MatrixLogarithmReturnValue
DerivedNested	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    typedef typename internal::ref_selector<Derived>::type DerivedNested;$/;"	t	class:Eigen::MatrixSquareRootReturnValue
DerivedTraits	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef internal::traits<Derived> DerivedTraits;$/;"	t	class:Eigen::TensorBase
Device	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef Device_ Device;$/;"	t	struct:Eigen::internal::traits
Device	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::traits<Derived>::Device Device;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
Device	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef GpuDevice Device;$/;"	t	struct:Eigen::TensorEvaluator
Device	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef ThreadPoolDevice Device;$/;"	t	struct:Eigen::TensorEvaluator
DeviceConvertor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^struct DeviceConvertor{$/;"	s	namespace:Eigen::TensorSycl::internal
DevicePointer	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename internal::traits<const TensorEvalToOp<ArgType, MakePointer_> >::template MakePointer<CoeffReturnType>::Type DevicePointer;$/;"	t	struct:Eigen::TensorEvaluator
DiagCoeffNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                                                       : SparseXprType::ColsAtCompileTime>::type DiagCoeffNested;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
DiagFlags	Eigen/src/Core/ProductEvaluators.h	/^    DiagFlags = evaluator<DiagonalType>::Flags,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
DiagIndex	Eigen/src/Core/Diagonal.h	/^    enum { DiagIndex = _DiagIndex };$/;"	e	enum:Eigen::Diagonal::__anon501
DiagIndex	Eigen/src/Core/SolveTriangular.h	/^    DiagIndex  = IsLower ? LoopIndex : Size - LoopIndex - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon519
DiagSizeAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime, ColsAtCompileTime), $/;"	e	enum:Eigen::BDCSVD::__anon777
DiagSizeAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon784
DiagSizeAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::SVDBase::__anon786
DiagVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Diagonal	Eigen/src/Core/Diagonal.h	/^    explicit inline Diagonal(MatrixType& matrix, Index a_index = DiagIndex) : m_matrix(matrix), m_index(a_index)$/;"	f	class:Eigen::Diagonal
Diagonal	Eigen/src/Core/Diagonal.h	/^template<typename MatrixType, int _DiagIndex> class Diagonal$/;"	c	namespace:Eigen
Diagonal2Dense	Eigen/src/Core/DiagonalMatrix.h	/^struct Diagonal2Dense {};$/;"	s	namespace:Eigen::internal
Diagonal2Sparse	Eigen/src/SparseCore/SparseAssign.h	/^struct Diagonal2Sparse {};$/;"	s	namespace:Eigen::internal
DiagonalBase	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
DiagonalDynamicIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
DiagonalIntReturnType	Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalReturnType	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef Diagonal<SparseMatrix> DiagonalReturnType;$/;"	t	class:Eigen::SparseMatrix
DiagonalShape	Eigen/src/Core/util/Constants.h	/^struct DiagonalShape          { static std::string debugName() { return "DiagonalShape"; } };$/;"	s	namespace:Eigen
DiagonalSize	Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon477
DiagonalType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalWrapper	Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalWrapper(DiagonalVectorType& a_diagonal) : m_diagonal(a_diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper
DiagonalWrapper	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen
DigammaReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_digamma_op<Scalar>, const Derived> DigammaReturnType;$/;"	t
Dim	Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon257
Dim	Eigen/src/Geometry/Homogeneous.h	/^    Dim  = Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::homogeneous_right_product_refactoring_helper::__anon260
Dim	Eigen/src/Geometry/Homogeneous.h	/^    Dim = Rhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::homogeneous_left_product_refactoring_helper::__anon261
Dim	Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon247
Dim	Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon254
Dim	Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon255
Dim	Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon256
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon263
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon268
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon269
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon270
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon265
Dim	Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon262
Dim	bench/geometry.cpp	/^  enum {Dim = T::Dim};$/;"	e	enum:ToRotationMatrixWrapper::__anon10	file:
Dim	bench/geometry.cpp	/^struct get_dim<Matrix<S,R,C,O,MR,MC> > { enum { Dim = R }; };$/;"	e	enum:get_dim::__anon12	file:
Dim	bench/geometry.cpp	/^template<typename T> struct get_dim { enum { Dim = T::Dim }; };$/;"	e	enum:get_dim::__anon11	file:
Dim	demos/opengl/quaternion_demo.cpp	/^  enum { Dim = 3 };$/;"	e	enum:EulerAngles::__anon1	file:
Dim	unsupported/Eigen/src/BVH/KdBVH.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::KdBVH::__anon52
Dim1	Eigen/src/Geometry/Transform.h	/^    Dim1 = _Dim==Dynamic ? _Dim : _Dim + 1,$/;"	e	enum:Eigen::internal::traits::__anon264
DimConstr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^template<typename Dim, size_t NumOutputDim> struct DimConstr {$/;"	s	namespace:Eigen::TensorSycl::internal
DimConstr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^template<typename Dim> struct DimConstr<Dim, 0> {$/;"	s	namespace:Eigen::TensorSycl::internal
DimInitializer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^template <> struct DimInitializer<Sizes<> > {$/;"	s	namespace:Eigen::internal
DimInitializer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^template <typename OutputDims> struct DimInitializer {$/;"	s	namespace:Eigen::internal
DimPair	unsupported/test/cxx11_tensor_contraction.cpp	/^typedef Tensor<float, 1>::DimensionPair DimPair;$/;"	t	file:
Dimension	unsupported/Eigen/src/Splines/Spline.h	/^    enum { Dimension = _Dim \/*!< The spline curve's dimension. *\/ };$/;"	e	enum:Eigen::Spline::__anon53
Dimension	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { Dimension = _Dim \/*!< The spline curve's dimension. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon55
DimensionId	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DimensionId(DenseIndex dim) : actual_dim(dim) {$/;"	f	struct:Eigen::internal::DimensionId
DimensionId	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DimensionId(DenseIndex dim) {$/;"	f	struct:Eigen::internal::DimensionId
DimensionId	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct DimensionId$/;"	s	namespace:Eigen::internal
DimensionId	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct DimensionId<Dynamic>$/;"	s	namespace:Eigen::internal
DimensionList	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^template <typename Index, std::size_t Rank> struct DimensionList {$/;"	s	namespace:Eigen
DimensionPair	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef Eigen::IndexPair<Index> DimensionPair;$/;"	t	class:Eigen::TensorBase
Dimensions	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef DSizes<Index, NumIndices_> Dimensions;$/;"	t	class:Eigen::Tensor
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename TensorEvaluator<RightArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename Base::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename Derived::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename TensorEvaluator<Arg1Type, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename TensorEvaluator<IfArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename TensorEvaluator<LeftArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^  typedef Dimensions_ Dimensions;$/;"	t	class:Eigen::TensorFixedSize
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename PlainObjectType::Dimensions Dimensions;$/;"	t	class:Eigen::TensorMap
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef NewDimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef Sizes Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef Strides Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename internal::conditional<NumOutputDims==0, Sizes<>, DSizes<Index, NumOutputDims> >::type Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename PlainObjectType::Dimensions Dimensions;$/;"	t	class:Eigen::TensorRef
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Derived::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    typedef DSizes<IndexType, NumIndices_> Dimensions;$/;"	t	class:Eigen::TensorStorage
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  typedef typename Eigen::internal::conditional<Evaluator::NumOutputDims==0, DSizes<typename Evaluator::Index, 1>, typename Evaluator::Dimensions >::type Dimensions;$/;"	t	struct:Eigen::TensorSycl::internal::FunctorExtractor
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  typedef typename Evaluator::Dimensions Dimensions;$/;"	t	struct:Eigen::TensorSycl::internal::FunctorExtractor
Dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef DSizes<Index, NumDims> Dimensions;$/;"	t	struct:Eigen::TensorEvaluator
DirectAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
DirectLinearAccessType	Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits
DirectOffsets	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^    DirectOffsets = CoeffLoader<Tensor, Tensor::RawAccess>::DirectOffsets$/;"	e	enum:Eigen::internal::SimpleTensorContractionMapper::__anon134
DirectOffsets	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^    DirectOffsets = false$/;"	e	enum:Eigen::internal::CoeffLoader::__anon132
DirectOffsets	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^    DirectOffsets = true$/;"	e	enum:Eigen::internal::CoeffLoader::__anon133
DirectWriteAccessors	Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
Direction	Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon259
DirectionType	Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DivCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int DivCost() {$/;"	f	class:Eigen::TensorOpCost
DividerHelper	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  struct DividerHelper {$/;"	s	namespace:Eigen::internal::__anon139
DividerHelper	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  struct DividerHelper<64, T> {$/;"	s	namespace:Eigen::internal::__anon139
DividerTraits	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  struct DividerTraits {$/;"	s	namespace:Eigen::internal::__anon139
DontAlign	Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::StorageOptions
DontAlignCols	Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon422
DoublePacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct DoublePacket$/;"	s	namespace:Eigen::internal
DoublePacketType	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef DoublePacket<RealPacket> DoublePacketType;$/;"	t	class:Eigen::internal::gebp_traits
Dst	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluator::XprType Dst;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
DstAlignment	Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = DstEvaluator::Alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon503
DstAlignment	Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = Kernel::AssignmentTraits::DstAlignment$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon512
DstAlignment	Eigen/src/Core/AssignEvaluator.h	/^    DstAlignment = Kernel::AssignmentTraits::DstAlignment$/;"	e	enum:Eigen::internal::dense_assignment_loop::__anon513
DstEvaluatorType	Eigen/src/Core/AssignEvaluator.h	/^  typedef DstEvaluatorTypeT DstEvaluatorType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstEvaluatorType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
DstEvaluatorType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
DstEvaluatorType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::DstEvaluatorType DstEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstEvaluatorType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::DstEvaluatorType DstEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstEvaluatorType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
DstFlags	Eigen/src/Core/AssignEvaluator.h	/^    DstFlags = DstEvaluator::Flags,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon502
DstHasDirectAccess	Eigen/src/Core/AssignEvaluator.h	/^    DstHasDirectAccess = (DstFlags & DirectAccessBit) == DirectAccessBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon503
DstHasDirectAccess	Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
DstIndex	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename DstXprType::StorageIndex DstIndex;$/;"	t	struct:Eigen::internal::Assignment
DstIsRowMajor	Eigen/src/Core/AssignEvaluator.h	/^    DstIsRowMajor = DstFlags&RowMajorBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
DstScalar	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Dst::Scalar DstScalar;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
DstXprType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
DstXprType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
DstXprType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorTypeT::XprType DstXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstXprType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstXprType	Eigen/src/Core/Swap.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
DstXprType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::DstXprType DstXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
DstXprType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename DstEvaluatorType::XprType DstXprType;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
Dynamic	Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
DynamicIndex	Eigen/src/Core/util/Constants.h	/^const int DynamicIndex = 0xffffff;$/;"	m	namespace:Eigen
DynamicSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroup(DynamicSGroup&& o) : m_numIndices(o.m_numIndices), m_elements(), m_generators(o.m_generators), m_globalFlags(o.m_globalFlags) { std::swap(m_elements, o.m_elements); }$/;"	f	class:Eigen::DynamicSGroup
DynamicSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroup(const DynamicSGroup& o) : m_numIndices(o.m_numIndices), m_elements(o.m_elements), m_generators(o.m_generators), m_globalFlags(o.m_globalFlags) { }$/;"	f	class:Eigen::DynamicSGroup
DynamicSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline explicit DynamicSGroup() : m_numIndices(1), m_elements(), m_generators(), m_globalFlags(0) { m_elements.push_back(ge(Generator(0, 0, 0))); }$/;"	f	class:Eigen::DynamicSGroup
DynamicSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^class DynamicSGroup$/;"	c	namespace:Eigen
DynamicSGroupFromTemplateArgs	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroupFromTemplateArgs() : DynamicSGroup()$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
DynamicSGroupFromTemplateArgs	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroupFromTemplateArgs(DynamicSGroupFromTemplateArgs const& other) : DynamicSGroup(other) { }$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
DynamicSGroupFromTemplateArgs	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroupFromTemplateArgs(DynamicSGroupFromTemplateArgs&& other) : DynamicSGroup(other) { }$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
DynamicSGroupFromTemplateArgs	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^class DynamicSGroupFromTemplateArgs : public DynamicSGroup$/;"	c	namespace:Eigen
DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED explicit inline DynamicSparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED inline DynamicSparseMatrix()$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED inline DynamicSparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline DynamicSparseMatrix(const DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^ class  DynamicSparseMatrix$/;"	c	namespace:Eigen
EIGEN2_INTERFACE_HH	bench/btl/libs/eigen2/eigen2_interface.hh	19;"	d
EIGEN2_SUPPORT	test/eigen2support.cpp	10;"	d	file:
EIGEN3_INTERFACE_HH	bench/btl/libs/eigen3/eigen3_interface.hh	19;"	d
EIGEN_ALIGN16	Eigen/src/Core/util/Macros.h	753;"	d
EIGEN_ALIGN32	Eigen/src/Core/util/Macros.h	754;"	d
EIGEN_ALIGN64	Eigen/src/Core/util/Macros.h	755;"	d
EIGEN_ALIGN8	Eigen/src/Core/util/Macros.h	752;"	d
EIGEN_ALIGNEDBOX_H	Eigen/src/Geometry/AlignedBox.h	11;"	d
EIGEN_ALIGNED_ALLOCA	Eigen/src/Core/util/Memory.h	629;"	d
EIGEN_ALIGNED_ALLOCATOR	Eigen/src/StlSupport/details.h	15;"	d
EIGEN_ALIGN_MAX	Eigen/src/Core/util/Macros.h	757;"	d
EIGEN_ALIGN_TO_BOUNDARY	Eigen/src/Core/util/Macros.h	650;"	d
EIGEN_ALLANDANY_H	Eigen/src/Core/BooleanRedux.h	11;"	d
EIGEN_ALLOCA	Eigen/src/Core/util/Memory.h	547;"	d
EIGEN_ALLOCA	Eigen/src/Core/util/Memory.h	549;"	d
EIGEN_ALWAYS_INLINE	Eigen/src/Core/util/Macros.h	507;"	d
EIGEN_ALWAYS_INLINE	Eigen/src/Core/util/Macros.h	509;"	d
EIGEN_AMBIVECTOR_H	Eigen/src/SparseCore/AmbiVector.h	11;"	d
EIGEN_ANGLEAXIS_H	Eigen/src/Geometry/AngleAxis.h	11;"	d
EIGEN_APPLE_DOUBLE_NEON_BUG	Eigen/src/Core/arch/NEON/PacketMath.h	563;"	d
EIGEN_APPLE_DOUBLE_NEON_BUG	Eigen/src/Core/arch/NEON/PacketMath.h	565;"	d
EIGEN_ARCH_ARM	Eigen/src/Core/util/Macros.h	167;"	d
EIGEN_ARCH_ARM	Eigen/src/Core/util/Macros.h	169;"	d
EIGEN_ARCH_ARM64	Eigen/src/Core/util/Macros.h	174;"	d
EIGEN_ARCH_ARM64	Eigen/src/Core/util/Macros.h	176;"	d
EIGEN_ARCH_ARM_OR_ARM64	Eigen/src/Core/util/Macros.h	180;"	d
EIGEN_ARCH_ARM_OR_ARM64	Eigen/src/Core/util/Macros.h	182;"	d
EIGEN_ARCH_CONJ_HELPER_H	Eigen/src/Core/arch/Default/ConjHelper.h	12;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/AVX/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/AVX512/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/AltiVec/PacketMath.h	31;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/Default/Settings.h	46;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/NEON/PacketMath.h	33;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/SSE/PacketMath.h	22;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/ZVector/PacketMath.h	32;"	d
EIGEN_ARCH_IA64	Eigen/src/Core/util/Macros.h	201;"	d
EIGEN_ARCH_IA64	Eigen/src/Core/util/Macros.h	203;"	d
EIGEN_ARCH_MIPS	Eigen/src/Core/util/Macros.h	187;"	d
EIGEN_ARCH_MIPS	Eigen/src/Core/util/Macros.h	189;"	d
EIGEN_ARCH_PPC	Eigen/src/Core/util/Macros.h	208;"	d
EIGEN_ARCH_PPC	Eigen/src/Core/util/Macros.h	210;"	d
EIGEN_ARCH_SPARC	Eigen/src/Core/util/Macros.h	194;"	d
EIGEN_ARCH_SPARC	Eigen/src/Core/util/Macros.h	196;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	Eigen/src/Core/util/Macros.h	722;"	d
EIGEN_ARCH_i386	Eigen/src/Core/util/Macros.h	154;"	d
EIGEN_ARCH_i386	Eigen/src/Core/util/Macros.h	156;"	d
EIGEN_ARCH_i386_OR_x86_64	Eigen/src/Core/util/Macros.h	160;"	d
EIGEN_ARCH_i386_OR_x86_64	Eigen/src/Core/util/Macros.h	162;"	d
EIGEN_ARCH_x86_64	Eigen/src/Core/util/Macros.h	148;"	d
EIGEN_ARCH_x86_64	Eigen/src/Core/util/Macros.h	150;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	89;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	91;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	93;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	95;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	98;"	d
EIGEN_ARPACKGENERALIZEDSELFADJOINTEIGENSOLVER_H	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	26;"	d
EIGEN_ARRAYBASE_H	Eigen/src/Core/ArrayBase.h	11;"	d
EIGEN_ARRAYWRAPPER_H	Eigen/src/Core/ArrayWrapper.h	11;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	Eigen/src/Core/GlobalFunctions.h	38;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	Eigen/src/Core/GlobalFunctions.h	16;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	Eigen/src/Core/GlobalFunctions.h	29;"	d
EIGEN_ARRAY_H	Eigen/src/Core/Array.h	11;"	d
EIGEN_ASM_COMMENT	Eigen/src/Core/util/Macros.h	622;"	d
EIGEN_ASSIGNMENT_FUNCTORS_H	Eigen/src/Core/functors/AssignmentFunctors.h	11;"	d
EIGEN_ASSIGN_EVALUATOR_H	Eigen/src/Core/AssignEvaluator.h	13;"	d
EIGEN_ASSIGN_H	Eigen/src/Core/Assign.h	13;"	d
EIGEN_ASSIGN_VML_H	Eigen/src/Core/Assign_MKL.h	35;"	d
EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	531;"	d
EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	669;"	d
EIGEN_AUTODIFF_JACOBIAN_H	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	11;"	d
EIGEN_AUTODIFF_SCALAR_H	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	11;"	d
EIGEN_AUTODIFF_VECTOR_H	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	11;"	d
EIGEN_BANDMATRIX_H	Eigen/src/Core/BandMatrix.h	11;"	d
EIGEN_BAND_TRIANGULARSOLVER_H	blas/BandTriangularSolver.h	11;"	d
EIGEN_BASIC_PRECONDITIONERS_H	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	11;"	d
EIGEN_BDCSVD_H	Eigen/src/SVD/BDCSVD.h	21;"	d
EIGEN_BENCH_BASICBENCH_H	bench/basicbenchmark.h	3;"	d
EIGEN_BENCH_TIMERR_H	bench/BenchTimer.h	12;"	d
EIGEN_BENCH_UTIL_H	bench/BenchUtil.h	3;"	d
EIGEN_BICGSTAB	bench/spbench/spbenchsolver.h	59;"	d
EIGEN_BICGSTAB_H	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	12;"	d
EIGEN_BICGSTAB_ILUT	bench/spbench/spbenchsolver.h	60;"	d
EIGEN_BIDIAGONALIZATION_H	Eigen/src/SVD/UpperBidiagonalization.h	12;"	d
EIGEN_BINARY_FUNCTORS_H	Eigen/src/Core/functors/BinaryFunctors.h	11;"	d
EIGEN_BLASUTIL_H	Eigen/src/Core/util/BlasUtil.h	11;"	d
EIGEN_BLAS_COMMON_H	blas/common.h	11;"	d
EIGEN_BLAS_FUNC	blas/common.h	161;"	d
EIGEN_BLAS_GEMV_SPECIALIZATION	Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	88;"	d
EIGEN_BLAS_GEMV_SPECIALIZE	Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	52;"	d
EIGEN_BLAS_HEMM_L	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	90;"	d
EIGEN_BLAS_HEMM_R	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	212;"	d
EIGEN_BLAS_RANKUPDATE_C	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	96;"	d
EIGEN_BLAS_RANKUPDATE_R	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	75;"	d
EIGEN_BLAS_RANKUPDATE_SPECIALIZE	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	47;"	d
EIGEN_BLAS_SYMM_L	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	43;"	d
EIGEN_BLAS_SYMM_R	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	166;"	d
EIGEN_BLAS_SYMV_SPECIALIZATION	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	74;"	d
EIGEN_BLAS_SYMV_SPECIALIZE	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	50;"	d
EIGEN_BLAS_TRMM_L	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	78;"	d
EIGEN_BLAS_TRMM_R	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	196;"	d
EIGEN_BLAS_TRMM_SPECIALIZE	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	53;"	d
EIGEN_BLAS_TRMV_CM	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	74;"	d
EIGEN_BLAS_TRMV_RM	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	163;"	d
EIGEN_BLAS_TRMV_SPECIALIZE	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	50;"	d
EIGEN_BLAS_TRSM_L	Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	41;"	d
EIGEN_BLAS_TRSM_R	Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	100;"	d
EIGEN_BLOCK_H	Eigen/src/Core/Block.h	12;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	Eigen/src/Householder/BlockHouseholder.h	12;"	d
EIGEN_BROWSE_MATRICES_H	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	12;"	d
EIGEN_BT_UNDEF_NOMINMAX	bench/BenchTimer.h	17;"	d
EIGEN_BT_UNDEF_NOMINMAX	bench/BenchTimer.h	186;"	d
EIGEN_BT_UNDEF_WIN32_LEAN_AND_MEAN	bench/BenchTimer.h	191;"	d
EIGEN_BT_UNDEF_WIN32_LEAN_AND_MEAN	bench/BenchTimer.h	21;"	d
EIGEN_BVALGORITHMS_H	unsupported/Eigen/src/BVH/BVAlgorithms.h	11;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/AVX/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/AVX512/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/AltiVec/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/Default/Settings.h	31;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/NEON/PacketMath.h	20;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/SSE/PacketMath.h	18;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/ZVector/PacketMath.h	20;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	test/redux.cpp	12;"	d	file:
EIGEN_CAMERA_H	demos/opengl/camera.h	11;"	d
EIGEN_CAT	Eigen/src/Core/util/Macros.h	479;"	d
EIGEN_CAT2	Eigen/src/Core/util/Macros.h	478;"	d
EIGEN_CATCH	Eigen/src/Core/util/Macros.h	968;"	d
EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT	Eigen/src/Core/ProductEvaluators.h	228;"	d
EIGEN_CG	bench/spbench/spbenchsolver.h	72;"	d
EIGEN_CG_PRECOND	bench/spbench/spbenchsolver.h	73;"	d
EIGEN_CHECK_BINARY_COMPATIBILIY	Eigen/src/Core/util/XprHelper.h	815;"	d
EIGEN_CHOLMODSUPPORT_H	Eigen/src/CholmodSupport/CholmodSupport.h	11;"	d
EIGEN_CHOLMOD_LDLT	bench/spbench/spbenchsolver.h	64;"	d
EIGEN_CHOLMOD_SIMPLICIAL_LLT	bench/spbench/spbenchsolver.h	69;"	d
EIGEN_CHOLMOD_SUPERNODAL_LLT	bench/spbench/spbenchsolver.h	68;"	d
EIGEN_COLAMD_H	Eigen/src/OrderingMethods/Eigen_Colamd.h	48;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	Eigen/src/QR/ColPivHouseholderQR.h	12;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_LAPACKE_H	Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	35;"	d
EIGEN_COMMA	Eigen/src/Core/util/Macros.h	481;"	d
EIGEN_COMMAINITIALIZER_H	Eigen/src/Core/CommaInitializer.h	12;"	d
EIGEN_COMPANION_H	unsupported/Eigen/src/Polynomials/Companion.h	11;"	d
EIGEN_COMPLETEORTHOGONALDECOMPOSITION_H	Eigen/src/QR/CompleteOrthogonalDecomposition.h	11;"	d
EIGEN_COMPLEX32_ALTIVEC_H	Eigen/src/Core/arch/AltiVec/Complex.h	12;"	d
EIGEN_COMPLEX32_ALTIVEC_H	Eigen/src/Core/arch/ZVector/Complex.h	12;"	d
EIGEN_COMPLEX_AVX_H	Eigen/src/Core/arch/AVX/Complex.h	11;"	d
EIGEN_COMPLEX_CUDA_H	Eigen/src/Core/arch/CUDA/Complex.h	11;"	d
EIGEN_COMPLEX_EIGEN_SOLVER_H	Eigen/src/Eigenvalues/ComplexEigenSolver.h	13;"	d
EIGEN_COMPLEX_NEON_H	Eigen/src/Core/arch/NEON/Complex.h	12;"	d
EIGEN_COMPLEX_SCHUR_H	Eigen/src/Eigenvalues/ComplexSchur.h	13;"	d
EIGEN_COMPLEX_SCHUR_LAPACKE_H	Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	34;"	d
EIGEN_COMPLEX_SSE_H	Eigen/src/Core/arch/SSE/Complex.h	11;"	d
EIGEN_COMPRESSED_STORAGE_H	Eigen/src/SparseCore/CompressedStorage.h	11;"	d
EIGEN_COMP_ARM	Eigen/src/Core/util/Macros.h	106;"	d
EIGEN_COMP_ARM	Eigen/src/Core/util/Macros.h	108;"	d
EIGEN_COMP_CLANG	Eigen/src/Core/util/Macros.h	33;"	d
EIGEN_COMP_CLANG	Eigen/src/Core/util/Macros.h	35;"	d
EIGEN_COMP_EMSCRIPTEN	Eigen/src/Core/util/Macros.h	113;"	d
EIGEN_COMP_EMSCRIPTEN	Eigen/src/Core/util/Macros.h	115;"	d
EIGEN_COMP_GNUC	Eigen/src/Core/util/Macros.h	26;"	d
EIGEN_COMP_GNUC	Eigen/src/Core/util/Macros.h	28;"	d
EIGEN_COMP_GNUC_STRICT	Eigen/src/Core/util/Macros.h	121;"	d
EIGEN_COMP_GNUC_STRICT	Eigen/src/Core/util/Macros.h	123;"	d
EIGEN_COMP_IBM	Eigen/src/Core/util/Macros.h	92;"	d
EIGEN_COMP_IBM	Eigen/src/Core/util/Macros.h	94;"	d
EIGEN_COMP_ICC	Eigen/src/Core/util/Macros.h	48;"	d
EIGEN_COMP_ICC	Eigen/src/Core/util/Macros.h	50;"	d
EIGEN_COMP_LLVM	Eigen/src/Core/util/Macros.h	41;"	d
EIGEN_COMP_LLVM	Eigen/src/Core/util/Macros.h	43;"	d
EIGEN_COMP_MINGW	Eigen/src/Core/util/Macros.h	55;"	d
EIGEN_COMP_MINGW	Eigen/src/Core/util/Macros.h	57;"	d
EIGEN_COMP_MSVC	Eigen/src/Core/util/Macros.h	69;"	d
EIGEN_COMP_MSVC	Eigen/src/Core/util/Macros.h	71;"	d
EIGEN_COMP_MSVC_STRICT	Eigen/src/Core/util/Macros.h	85;"	d
EIGEN_COMP_MSVC_STRICT	Eigen/src/Core/util/Macros.h	87;"	d
EIGEN_COMP_PGI	Eigen/src/Core/util/Macros.h	101;"	d
EIGEN_COMP_PGI	Eigen/src/Core/util/Macros.h	99;"	d
EIGEN_COMP_SUNCC	Eigen/src/Core/util/Macros.h	62;"	d
EIGEN_COMP_SUNCC	Eigen/src/Core/util/Macros.h	64;"	d
EIGEN_CONDITIONESTIMATOR_H	Eigen/src/Core/ConditionEstimator.h	11;"	d
EIGEN_CONJUGATE_GRADIENT_H	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	11;"	d
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	11;"	d
EIGEN_CONSTANTS_H	Eigen/src/Core/util/Constants.h	12;"	d
EIGEN_CONSTEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	48;"	d
EIGEN_CONSTEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	50;"	d
EIGEN_CONSTRAINEDCG_H	unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	32;"	d
EIGEN_COREEVALUATORS_H	Eigen/src/Core/CoreEvaluators.h	14;"	d
EIGEN_COREITERATORS_H	Eigen/src/Core/CoreIterators.h	11;"	d
EIGEN_CPUID	Eigen/src/Core/util/Memory.h	773;"	d
EIGEN_CPUID	Eigen/src/Core/util/Memory.h	778;"	d
EIGEN_CPUID	Eigen/src/Core/util/Memory.h	782;"	d
EIGEN_CPUID	Eigen/src/Core/util/Memory.h	787;"	d
EIGEN_CUDA_SPECIALFUNCTIONS_H	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	11;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/ArrayBase.h	100;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/ArrayBase.h	89;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/DenseBase.h	570;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/DenseBase.h	577;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/MatrixBase.h	123;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/MatrixBase.h	132;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/SparseCore/SparseMatrixBase.h	147;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/SparseCore/SparseMatrixBase.h	165;"	d
EIGEN_CWISE_BINARY_OP_H	Eigen/src/Core/CwiseBinaryOp.h	12;"	d
EIGEN_CWISE_BINARY_RETURN_TYPE	Eigen/src/Core/util/Macros.h	905;"	d
EIGEN_CWISE_NULLARY_OP_H	Eigen/src/Core/CwiseNullaryOp.h	11;"	d
EIGEN_CWISE_TERNARY_OP_H	Eigen/src/Core/CwiseTernaryOp.h	13;"	d
EIGEN_CWISE_UNARY_OP_H	Eigen/src/Core/CwiseUnaryOp.h	12;"	d
EIGEN_CWISE_UNARY_VIEW_H	Eigen/src/Core/CwiseUnaryView.h	11;"	d
EIGEN_CXX11META_H	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	11;"	d
EIGEN_CXX11WORKAROUNDS_H	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	11;"	d
EIGEN_CXX11_TENSORSYMMETRY_DYNAMICSYMMETRY_H	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	11;"	d
EIGEN_CXX11_TENSORSYMMETRY_STATICSYMMETRY_H	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	11;"	d
EIGEN_CXX11_TENSORSYMMETRY_SYMMETRY_H	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	11;"	d
EIGEN_CXX11_TENSORSYMMETRY_TEMPLATEGROUPTHEORY_H	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	11;"	d
EIGEN_CXX11_TENSOR_TENSORSTORAGE_H	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	12;"	d
EIGEN_CXX11_TENSOR_TENSOR_ARG_MAX_H	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	12;"	d
EIGEN_CXX11_TENSOR_TENSOR_ASSIGN_H	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_BASE_H	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_BROADCASTING_H	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CHIPPING_H	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONCATENATION_H	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_BLOCKING_H	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_CUDA_H	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	13;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_H	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_MAPPER_H	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONTRACTION_THREAD_POOL_H	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONVERSION_H	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CONVOLUTION_H	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_COST_MODEL_H	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_CUSTOM_OP_H	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DEVICE_CUDA_H	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DEVICE_DEFAULT_H	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DEVICE_H	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DEVICE_SYCL_H	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	16;"	d
EIGEN_CXX11_TENSOR_TENSOR_DEVICE_THREAD_POOL_H	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DIMENSIONS_H	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_DIMENSION_LIST_H	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_EVALUATOR_H	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_EVAL_TO_H	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_EXECUTOR_H	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_EXPR_H	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_FFT_H	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_FIXED_SIZE_H	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_FORCED_EVAL_H	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_FORWARD_DECLARATIONS_H	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_FUNCTORS_H	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_GENERATOR_H	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_GLOBAL_FUNCTIONS_H	unsupported/Eigen/CXX11/src/Tensor/TensorGlobalFunctions.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_H	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	12;"	d
EIGEN_CXX11_TENSOR_TENSOR_IMAGE_PATCH_H	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_INDEX_LIST_H	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_INFLATION_H	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_INITIALIZER_H	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_INTDIV_H	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_IO_H	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_LAYOUT_SWAP_H	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_MAP_H	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_META_H	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_META_MACROS_H	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_MORPHING_H	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_PADDING_H	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_PATCH_H	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_RANDOM_H	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_REDUCTION_CUDA_H	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_REDUCTION_H	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	12;"	d
EIGEN_CXX11_TENSOR_TENSOR_REF_H	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_REVERSE_H	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	12;"	d
EIGEN_CXX11_TENSOR_TENSOR_SCAN_H	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_SHUFFLING_H	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_STRIDING_H	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_TRAITS_H	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_UINT128_H	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	11;"	d
EIGEN_CXX11_TENSOR_TENSOR_VOLUME_PATCH_H	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	5;"	d
EIGEN_CXX11_THREADPOOL_EVENTCOUNT_H_	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	11;"	d
EIGEN_CXX11_THREADPOOL_NONBLOCKING_THREAD_POOL_H	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	11;"	d
EIGEN_CXX11_THREADPOOL_RUNQUEUE_H_	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	11;"	d
EIGEN_CXX11_THREADPOOL_SIMPLE_THREAD_POOL_H	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	11;"	d
EIGEN_CXX11_THREADPOOL_THREAD_ENVIRONMENT_H	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	11;"	d
EIGEN_CXX11_THREADPOOL_THREAD_LOCAL_H	unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h	11;"	d
EIGEN_CXX11_THREADPOOL_THREAD_POOL_INTERFACE_H	unsupported/Eigen/CXX11/src/ThreadPool/ThreadPoolInterface.h	11;"	d
EIGEN_CXX11_THREADPOOL_THREAD_YIELD_H	unsupported/Eigen/CXX11/src/ThreadPool/ThreadYield.h	11;"	d
EIGEN_DBG_SKYLINE	unsupported/Eigen/src/Skyline/SkylineUtil.h	16;"	d
EIGEN_DBG_SPARSE	Eigen/src/SparseCore/SparseUtil.h	16;"	d
EIGEN_DEBUG_ALIGNED_LOAD	Eigen/src/Core/GenericPacketMath.h	27;"	d
EIGEN_DEBUG_ALIGNED_LOAD	test/unalignedcount.cpp	15;"	d	file:
EIGEN_DEBUG_ALIGNED_STORE	Eigen/src/Core/GenericPacketMath.h	35;"	d
EIGEN_DEBUG_ALIGNED_STORE	test/unalignedcount.cpp	17;"	d	file:
EIGEN_DEBUG_ASSIGN	test/vectorization_logic.cpp	21;"	d	file:
EIGEN_DEBUG_SMALL_PRODUCT_BLOCKS	test/main.h	87;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	Eigen/src/Core/GenericPacketMath.h	31;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	test/unalignedcount.cpp	16;"	d	file:
EIGEN_DEBUG_UNALIGNED_STORE	Eigen/src/Core/GenericPacketMath.h	39;"	d
EIGEN_DEBUG_UNALIGNED_STORE	test/unalignedcount.cpp	18;"	d	file:
EIGEN_DEBUG_VAR	Eigen/src/Core/util/Macros.h	475;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	Eigen/src/Core/util/Macros.h	530;"	d
EIGEN_DEFAULT_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	779;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	Eigen/src/Core/util/Macros.h	336;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	bench/tensors/tensor_benchmarks.h	5;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	17;"	d	file:
EIGEN_DEFAULT_DENSE_INDEX_TYPE	unsupported/test/cxx11_tensor_device_sycl.cpp	17;"	d	file:
EIGEN_DEFAULT_DENSE_INDEX_TYPE	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	17;"	d	file:
EIGEN_DEFAULT_DENSE_INDEX_TYPE	unsupported/test/cxx11_tensor_reduction_sycl.cpp	17;"	d	file:
EIGEN_DEFAULT_DENSE_INDEX_TYPE	unsupported/test/cxx11_tensor_sycl.cpp	19;"	d	file:
EIGEN_DEFAULT_IO_FORMAT	Eigen/src/Core/util/Macros.h	808;"	d
EIGEN_DEFAULT_IO_FORMAT	test/main.h	155;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	Eigen/src/Core/util/Macros.h	330;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	Eigen/src/Core/util/Macros.h	332;"	d
EIGEN_DEFAULT_SETTINGS_H	Eigen/src/Core/arch/Default/Settings.h	17;"	d
EIGEN_DEFAULT_TO_ROW_MAJOR	test/ref.cpp	12;"	d	file:
EIGEN_DEFAULT_TO_ROW_MAJOR	test/sparse_ref.cpp	12;"	d	file:
EIGEN_DEFAULT_TO_ROW_MAJOR	test/sparselu.cpp	15;"	d	file:
EIGEN_DEFAULT_TO_ROW_MAJOR	test/vectorization_logic.cpp	19;"	d	file:
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	Eigen/src/Core/util/Macros.h	531;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	Eigen/src/StlSupport/StdDeque.h	21;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	Eigen/src/StlSupport/StdList.h	20;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	Eigen/src/StlSupport/StdVector.h	21;"	d
EIGEN_DENSEBASE_H	Eigen/src/Core/DenseBase.h	12;"	d
EIGEN_DENSECOEFFSBASE_H	Eigen/src/Core/DenseCoeffsBase.h	11;"	d
EIGEN_DENSESTORAGEBASE_H	Eigen/src/Core/PlainObjectBase.h	12;"	d
EIGEN_DENSE_PUBLIC_INTERFACE	Eigen/src/Core/util/Macros.h	870;"	d
EIGEN_DENSE_STORAGE_CTOR_PLUGIN	test/main.h	104;"	d
EIGEN_DEPRECATED	Eigen/src/Core/util/Macros.h	596;"	d
EIGEN_DETERMINANT_H	Eigen/src/LU/Determinant.h	11;"	d
EIGEN_DGMRES_H	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	11;"	d
EIGEN_DIAGONALMATRIX_H	Eigen/src/Core/DiagonalMatrix.h	12;"	d
EIGEN_DIAGONALPRODUCT_H	Eigen/src/Core/DiagonalProduct.h	12;"	d
EIGEN_DIAGONAL_H	Eigen/src/Core/Diagonal.h	12;"	d
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/util/Macros.h	742;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	Eigen/src/Core/DenseBase.h	572;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	Eigen/src/Core/DenseBase.h	579;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	Eigen/src/SparseCore/SparseMatrixBase.h	151;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	Eigen/src/SparseCore/SparseMatrixBase.h	155;"	d
EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF	Eigen/src/SparseCore/SparseMatrixBase.h	168;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	Eigen/src/Core/DenseBase.h	571;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	Eigen/src/Core/DenseBase.h	578;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	Eigen/src/SparseCore/SparseMatrixBase.h	150;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	Eigen/src/SparseCore/SparseMatrixBase.h	154;"	d
EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL	Eigen/src/SparseCore/SparseMatrixBase.h	167;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/Core/ArrayBase.h	101;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/Core/ArrayBase.h	90;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/Core/MatrixBase.h	124;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/Core/MatrixBase.h	133;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/SparseCore/SparseMatrixBase.h	149;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/SparseCore/SparseMatrixBase.h	153;"	d
EIGEN_DOC_UNARY_ADDONS	Eigen/src/SparseCore/SparseMatrixBase.h	166;"	d
EIGEN_DONT_ALIGN	test/dontalign.cpp	11;"	d	file:
EIGEN_DONT_ALIGN_STATICALLY	test/dontalign.cpp	13;"	d	file:
EIGEN_DONT_INLINE	Eigen/src/Core/util/Macros.h	513;"	d
EIGEN_DONT_INLINE	Eigen/src/Core/util/Macros.h	515;"	d
EIGEN_DONT_INLINE	Eigen/src/Core/util/Macros.h	517;"	d
EIGEN_DONT_VECTORIZE	test/mixingtypes.cpp	35;"	d	file:
EIGEN_DOT_H	Eigen/src/Core/Dot.h	11;"	d
EIGEN_DYNAMIC_SPARSEMATRIX_H	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	11;"	d
EIGEN_EIGENBASE_H	Eigen/src/Core/EigenBase.h	12;"	d
EIGEN_EIGENSOLVER_H	Eigen/src/Eigenvalues/EigenSolver.h	12;"	d
EIGEN_EMPTY	Eigen/src/Core/util/Macros.h	815;"	d
EIGEN_EMPTY_STRUCT_CTOR	Eigen/src/Core/util/XprHelper.h	18;"	d
EIGEN_EMPTY_STRUCT_CTOR	Eigen/src/Core/util/XprHelper.h	22;"	d
EIGEN_EMULATE_ARRAY_H	unsupported/Eigen/CXX11/src/util/EmulateArray.h	11;"	d
EIGEN_EMULATE_CXX11_META_H	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	11;"	d
EIGEN_EULERANGLESCLASS_H	unsupported/Eigen/src/EulerAngles/EulerAngles.h	11;"	d
EIGEN_EULERANGLES_H	Eigen/src/Geometry/EulerAngles.h	11;"	d
EIGEN_EULERSYSTEM_H	unsupported/Eigen/src/EulerAngles/EulerSystem.h	11;"	d
EIGEN_EULER_ANGLES_CLASS_STATIC_ASSERT	unsupported/Eigen/src/EulerAngles/EulerSystem.h	41;"	d
EIGEN_EULER_ANGLES_SINGLE_TYPEDEF	unsupported/Eigen/src/EulerAngles/EulerAngles.h	352;"	d
EIGEN_EULER_ANGLES_TYPEDEFS	unsupported/Eigen/src/EulerAngles/EulerAngles.h	356;"	d
EIGEN_EULER_SYSTEM_TYPEDEF	unsupported/Eigen/src/EulerAngles/EulerSystem.h	306;"	d
EIGEN_EXCEPTIONS	test/main.h	158;"	d
EIGEN_EXCEPTION_SPEC	Eigen/src/Core/CommaInitializer.h	/^  EIGEN_EXCEPTION_SPEC(Eigen::eigen_assert_exception)$/;"	f	struct:Eigen::CommaInitializer
EIGEN_EXCEPTION_SPEC	Eigen/src/Core/util/Macros.h	987;"	d
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(bool) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(double) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(float) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(int) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(short) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(signed char) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned char) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned int) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned short) const {$/;"	f	struct:Eigen::half
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	40;"	d
EIGEN_EXPLICIT_CAST	Eigen/src/Core/arch/CUDA/Half.h	42;"	d
EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE	Eigen/src/Core/util/Macros.h	926;"	d
EIGEN_EXTRACT_8f_FROM_16f	Eigen/src/Core/arch/AVX512/PacketMath.h	662;"	d
EIGEN_EXTRACT_8f_FROM_16f	Eigen/src/Core/arch/AVX512/PacketMath.h	666;"	d
EIGEN_FAST_MATH	Eigen/src/Core/util/Macros.h	472;"	d
EIGEN_FIXEDSIZEVECTOR_H	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	11;"	d
EIGEN_FORCEALIGNEDACCESS_H	Eigen/src/Core/ForceAlignedAccess.h	11;"	d
EIGEN_FORWARDDECLARATIONS_H	Eigen/src/Core/util/ForwardDeclarations.h	12;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	46;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	48;"	d
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	Eigen/src/QR/FullPivHouseholderQR.h	12;"	d
EIGEN_FUZZY_H	Eigen/src/Core/Fuzzy.h	12;"	d
EIGEN_GCC3_OR_OLDER	Eigen/src/Core/util/Macros.h	139;"	d
EIGEN_GCC3_OR_OLDER	Eigen/src/Core/util/Macros.h	141;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	Eigen/src/Core/util/Macros.h	707;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1096;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1133;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1207;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1249;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1308;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1343;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1399;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1436;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1478;"	d
EIGEN_GEBGP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1511;"	d
EIGEN_GEBP_2PX4_SPILLING_WORKAROUND	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1203;"	d
EIGEN_GEBP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	1023;"	d
EIGEN_GEBP_ONESTEP	Eigen/src/Core/products/GeneralBlockPanelKernel.h	970;"	d
EIGEN_GENERALIZEDEIGENSOLVER_H	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	13;"	d
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	12;"	d
EIGEN_GENERAL_BLOCK_PANEL_H	Eigen/src/Core/products/GeneralBlockPanelKernel.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_BLAS_H	Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_H	Eigen/src/Core/products/GeneralMatrixMatrix.h	11;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_BLAS_H	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	11;"	d
EIGEN_GENERAL_MATRIX_VECTOR_BLAS_H	Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	34;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	Eigen/src/Core/products/GeneralMatrixVector.h	11;"	d
EIGEN_GENERAL_PRODUCT_H	Eigen/src/Core/GeneralProduct.h	12;"	d
EIGEN_GENERAL_RANK1UPDATE_H	blas/GeneralRank1Update.h	11;"	d
EIGEN_GENERIC_PACKET_MATH_H	Eigen/src/Core/GenericPacketMath.h	12;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	Eigen/src/Core/util/Macros.h	852;"	d
EIGEN_GEOMETRY_SSE_H	Eigen/src/Geometry/arch/Geometry_SSE.h	12;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	36;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	38;"	d
EIGEN_GLOBAL_FUNCTIONS_H	Eigen/src/Core/GlobalFunctions.h	12;"	d
EIGEN_GMRES	bench/spbench/spbenchsolver.h	61;"	d
EIGEN_GMRES_H	unsupported/Eigen/src/IterativeSolvers/GMRES.h	12;"	d
EIGEN_GMRES_ILUT	bench/spbench/spbenchsolver.h	62;"	d
EIGEN_GNUC_AT	Eigen/src/Core/util/Macros.h	130;"	d
EIGEN_GNUC_AT	Eigen/src/Core/util/Macros.h	134;"	d
EIGEN_GNUC_AT_LEAST	Eigen/src/Core/util/Macros.h	128;"	d
EIGEN_GNUC_AT_LEAST	Eigen/src/Core/util/Macros.h	132;"	d
EIGEN_GNUC_AT_MOST	Eigen/src/Core/util/Macros.h	129;"	d
EIGEN_GNUC_AT_MOST	Eigen/src/Core/util/Macros.h	133;"	d
EIGEN_GOOGLEHASH_SUPPORT	bench/sparse_setter.cpp	27;"	d	file:
EIGEN_GPUHELPER_H	demos/opengl/gpuhelper.h	11;"	d
EIGEN_HALF_CUDA_H	Eigen/src/Core/arch/CUDA/Half.h	37;"	d
EIGEN_HAS_BUILTIN	Eigen/src/Core/util/Macros.h	341;"	d
EIGEN_HAS_BUILTIN	Eigen/src/Core/util/Macros.h	343;"	d
EIGEN_HAS_C99_MATH	Eigen/src/Core/util/Macros.h	384;"	d
EIGEN_HAS_C99_MATH	Eigen/src/Core/util/Macros.h	386;"	d
EIGEN_HAS_CONSTEXPR	Eigen/src/Core/util/Macros.h	417;"	d
EIGEN_HAS_CONSTEXPR	Eigen/src/Core/util/Macros.h	421;"	d
EIGEN_HAS_CONSTEXPR	Eigen/src/Core/util/Macros.h	425;"	d
EIGEN_HAS_CXX11	Eigen/src/Core/util/Macros.h	360;"	d
EIGEN_HAS_CXX11	Eigen/src/Core/util/Macros.h	362;"	d
EIGEN_HAS_CXX11_CONTAINERS	Eigen/src/Core/util/Macros.h	447;"	d
EIGEN_HAS_CXX11_CONTAINERS	Eigen/src/Core/util/Macros.h	449;"	d
EIGEN_HAS_CXX11_MATH	Eigen/src/Core/util/Macros.h	435;"	d
EIGEN_HAS_CXX11_MATH	Eigen/src/Core/util/Macros.h	437;"	d
EIGEN_HAS_CXX11_NOEXCEPT	Eigen/src/Core/util/Macros.h	460;"	d
EIGEN_HAS_CXX11_NOEXCEPT	Eigen/src/Core/util/Macros.h	462;"	d
EIGEN_HAS_INDEX_LIST	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	16;"	d
EIGEN_HAS_RVALUE_REFERENCES	Eigen/src/Core/util/Macros.h	372;"	d
EIGEN_HAS_RVALUE_REFERENCES	Eigen/src/Core/util/Macros.h	374;"	d
EIGEN_HAS_SFINAE	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	35;"	d
EIGEN_HAS_SFINAE	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	38;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	Eigen/src/Core/arch/AltiVec/PacketMath.h	26;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	Eigen/src/Core/arch/NEON/PacketMath.h	28;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD	Eigen/src/Core/arch/ZVector/PacketMath.h	28;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/AVX/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/AVX512/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/AltiVec/PacketMath.h	22;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/NEON/PacketMath.h	24;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/SSE/PacketMath.h	27;"	d
EIGEN_HAS_SINGLE_INSTRUCTION_MADD	Eigen/src/Core/arch/ZVector/PacketMath.h	24;"	d
EIGEN_HAS_STD_RESULT_OF	Eigen/src/Core/util/Macros.h	393;"	d
EIGEN_HAS_STD_RESULT_OF	Eigen/src/Core/util/Macros.h	395;"	d
EIGEN_HAS_VARIADIC_TEMPLATES	Eigen/src/Core/util/Macros.h	405;"	d
EIGEN_HAS_VARIADIC_TEMPLATES	Eigen/src/Core/util/Macros.h	407;"	d
EIGEN_HESSENBERGDECOMPOSITION_H	Eigen/src/Eigenvalues/HessenbergDecomposition.h	12;"	d
EIGEN_HOMOGENEOUS_H	Eigen/src/Geometry/Homogeneous.h	11;"	d
EIGEN_HOUSEHOLDER_H	Eigen/src/Householder/Householder.h	12;"	d
EIGEN_HOUSEHOLDER_SEQUENCE_H	Eigen/src/Householder/HouseholderSequence.h	12;"	d
EIGEN_HYBRIDNONLINEARSOLVER_H	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	14;"	d
EIGEN_HYPERPLANE_H	Eigen/src/Geometry/Hyperplane.h	12;"	d
EIGEN_ICOSPHERE_H	demos/opengl/icosphere.h	11;"	d
EIGEN_IDEAL_MAX_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	664;"	d
EIGEN_IMPLIES	Eigen/src/Core/util/Macros.h	902;"	d
EIGEN_INCLUDE_TYPE_TRAITS	Eigen/src/Core/util/Macros.h	983;"	d
EIGEN_INCOMPLETE_CHOlESKY_H	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	12;"	d
EIGEN_INCOMPLETE_LUT_H	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	12;"	d
EIGEN_INCOMPLETE_LU_H	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	11;"	d
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	Eigen/src/Core/util/Macros.h	819;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	Eigen/src/Core/util/Macros.h	842;"	d
EIGEN_INITIALIZE_COEFFS	Eigen/src/Core/PlainObjectBase.h	15;"	d
EIGEN_INITIALIZE_COEFFS	Eigen/src/Core/PlainObjectBase.h	18;"	d
EIGEN_INITIALIZE_COEFFS	Eigen/src/Core/PlainObjectBase.h	21;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	Eigen/src/Core/PlainObjectBase.h	16;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	Eigen/src/Core/PlainObjectBase.h	19;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	Eigen/src/Core/PlainObjectBase.h	22;"	d
EIGEN_INSERT_8f_INTO_16f	Eigen/src/Core/arch/AVX512/PacketMath.h	676;"	d
EIGEN_INSERT_8f_INTO_16f	Eigen/src/Core/arch/AVX512/PacketMath.h	680;"	d
EIGEN_INTERNAL_CHECK_COST_VALUE	Eigen/src/Core/util/StaticAssert.h	215;"	d
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
EIGEN_INTERNAL_DEBUGGING	test/main.h	304;"	d
EIGEN_INTERNAL_DEBUG_CACHE_QUERY	bench/check_cache_queries.cpp	2;"	d	file:
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	Eigen/src/Core/DenseStorage.h	16;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	Eigen/src/Core/DenseStorage.h	18;"	d
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE	Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
EIGEN_INTERNAL_TENSOR_STORAGE_CTOR_PLUGIN	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	15;"	d
EIGEN_INTERNAL_TENSOR_STORAGE_CTOR_PLUGIN	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	17;"	d
EIGEN_INVERSE_H	Eigen/src/Core/Inverse.h	11;"	d
EIGEN_INVERSE_IMPL_H	Eigen/src/LU/InverseImpl.h	12;"	d
EIGEN_INVERSE_SSE_H	Eigen/src/LU/arch/Inverse_SSE.h	28;"	d
EIGEN_IO_H	Eigen/src/Core/IO.h	12;"	d
EIGEN_ITERATION_CONTROLLER_H	unsupported/Eigen/src/IterativeSolvers/IterationController.h	59;"	d
EIGEN_ITERATIVE_SOLVER_BASE_H	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	11;"	d
EIGEN_ITERSCALING_H	unsupported/Eigen/src/IterativeSolvers/Scaling.h	11;"	d
EIGEN_JACOBISVD_H	Eigen/src/SVD/JacobiSVD.h	12;"	d
EIGEN_JACOBISVD_LAPACKE_H	Eigen/src/SVD/JacobiSVD_LAPACKE.h	34;"	d
EIGEN_JACOBI_H	Eigen/src/Jacobi/Jacobi.h	12;"	d
EIGEN_LAPACKE_EIG_SELFADJ	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	76;"	d
EIGEN_LAPACKE_EIG_SELFADJ_2	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	40;"	d
EIGEN_LAPACKE_LLT	Eigen/src/Cholesky/LLT_LAPACKE.h	42;"	d
EIGEN_LAPACKE_LU_PARTPIV	Eigen/src/LU/PartialPivLU_LAPACKE.h	42;"	d
EIGEN_LAPACKE_QR_COLPIV	Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	41;"	d
EIGEN_LAPACKE_QR_NOPIV	Eigen/src/QR/HouseholderQR_LAPACKE.h	43;"	d
EIGEN_LAPACKE_SCHUR_COMPLEX	Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	40;"	d
EIGEN_LAPACKE_SCHUR_REAL	Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	40;"	d
EIGEN_LAPACKE_SVD	Eigen/src/SVD/JacobiSVD_LAPACKE.h	40;"	d
EIGEN_LAPACK_ARG_IF_COMPLEX	lapack/lapack_common.h	23;"	d
EIGEN_LAPACK_ARG_IF_COMPLEX	lapack/lapack_common.h	25;"	d
EIGEN_LAPACK_COMMON_H	lapack/lapack_common.h	11;"	d
EIGEN_LAPACK_FUNC	lapack/cholesky.cpp	/^EIGEN_LAPACK_FUNC(potrf,(char* uplo, int *n, RealScalar *pa, int *lda, int *info))$/;"	f
EIGEN_LAPACK_FUNC	lapack/cholesky.cpp	/^EIGEN_LAPACK_FUNC(potrs,(char* uplo, int *n, int *nrhs, RealScalar *pa, int *lda, RealScalar *pb, int *ldb, int *info))$/;"	f
EIGEN_LAPACK_FUNC	lapack/eigenvalues.cpp	/^EIGEN_LAPACK_FUNC(syev,(char *jobz, char *uplo, int* n, Scalar* a, int *lda, Scalar* w, Scalar* \/*work*\/, int* lwork, int *info))$/;"	f
EIGEN_LAPACK_FUNC	lapack/lapack_common.h	16;"	d
EIGEN_LAPACK_FUNC	lapack/lu.cpp	/^EIGEN_LAPACK_FUNC(getrf,(int *m, int *n, RealScalar *pa, int *lda, int *ipiv, int *info))$/;"	f
EIGEN_LAPACK_FUNC	lapack/lu.cpp	/^EIGEN_LAPACK_FUNC(getrs,(char *trans, int *n, int *nrhs, RealScalar *pa, int *lda, int *ipiv, RealScalar *pb, int *ldb, int *info))$/;"	f
EIGEN_LAPACK_FUNC	lapack/svd.cpp	/^EIGEN_LAPACK_FUNC(gesdd,(char *jobz, int *m, int* n, Scalar* a, int *lda, RealScalar *s, Scalar *u, int *ldu, Scalar *vt, int *ldvt, Scalar* \/*work*\/, int* lwork,$/;"	f
EIGEN_LAPACK_FUNC	lapack/svd.cpp	/^EIGEN_LAPACK_FUNC(gesvd,(char *jobu, char *jobv, int *m, int* n, Scalar* a, int *lda, RealScalar *s, Scalar *u, int *ldu, Scalar *vt, int *ldvt, Scalar* \/*work*\/, int* lwork,$/;"	f
EIGEN_LDLT_H	Eigen/src/Cholesky/LDLT.h	14;"	d
EIGEN_LEAST_SQUARE_CONJUGATE_GRADIENT_H	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	11;"	d
EIGEN_LEVENBERGMARQUARDT_H	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	20;"	d
EIGEN_LEVENBERGMARQUARDT__H	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	14;"	d
EIGEN_LLT_H	Eigen/src/Cholesky/LLT.h	11;"	d
EIGEN_LLT_LAPACKE_H	Eigen/src/Cholesky/LLT_LAPACKE.h	34;"	d
EIGEN_LMCOVAR_H	unsupported/Eigen/src/LevenbergMarquardt/LMcovar.h	13;"	d
EIGEN_LMONESTEP_H	unsupported/Eigen/src/LevenbergMarquardt/LMonestep.h	15;"	d
EIGEN_LMPAR_H	unsupported/Eigen/src/LevenbergMarquardt/LMpar.h	13;"	d
EIGEN_LMQRSOLV_H	unsupported/Eigen/src/LevenbergMarquardt/LMqrsolv.h	16;"	d
EIGEN_LOGICAL_XOR	Eigen/src/Core/util/Macros.h	900;"	d
EIGEN_LU_H	Eigen/src/LU/FullPivLU.h	11;"	d
EIGEN_LU_STRUCTS	Eigen/src/SparseLU/SparseLU_Structs.h	70;"	d
EIGEN_MACROS_H	Eigen/src/Core/util/Macros.h	12;"	d
EIGEN_MAJOR_VERSION	Eigen/src/Core/util/Macros.h	15;"	d
EIGEN_MAKESTRING	Eigen/src/Core/util/Macros.h	485;"	d
EIGEN_MAKESTRING2	Eigen/src/Core/util/Macros.h	484;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	Eigen/src/Core/util/Memory.h	690;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	Eigen/src/Core/util/Memory.h	662;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	Eigen/src/Core/util/Memory.h	691;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	Eigen/src/Core/util/Memory.h	657;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	Eigen/src/Core/Array.h	283;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	277;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	305;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Array.h	289;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Array.h	304;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	Eigen/src/Core/Array.h	307;"	d
EIGEN_MAKE_CONJ_HELPER_CPLX_REAL	Eigen/src/Core/arch/Default/ConjHelper.h	14;"	d
EIGEN_MAKE_CWISE_BINARY_OP	Eigen/src/Core/util/Macros.h	915;"	d
EIGEN_MAKE_CWISE_COMP_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	108;"	d
EIGEN_MAKE_CWISE_COMP_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	210;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	126;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	211;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	Eigen/src/Core/Matrix.h	432;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	Eigen/src/Core/Matrix.h	455;"	d
EIGEN_MAKE_IMAGE_HELPERS	Eigen/src/misc/Image.h	67;"	d
EIGEN_MAKE_KERNEL_HELPERS	Eigen/src/misc/Kernel.h	66;"	d
EIGEN_MAKE_SCALAR_BINARY_OP	Eigen/src/Core/util/Macros.h	959;"	d
EIGEN_MAKE_SCALAR_BINARY_OP_ONTHELEFT	Eigen/src/Core/util/Macros.h	950;"	d
EIGEN_MAKE_SCALAR_BINARY_OP_ONTHERIGHT	Eigen/src/Core/util/Macros.h	941;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Core/Matrix.h	424;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Core/Matrix.h	454;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Geometry/AlignedBox.h	372;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Geometry/AlignedBox.h	388;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Matrix.h	438;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Matrix.h	453;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Geometry/AlignedBox.h	376;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Geometry/AlignedBox.h	387;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/DenseStorage.h	62;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/DenseStorage.h	69;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/DenseStorage.h	75;"	d
EIGEN_MAKING_DOCS	test/main.h	129;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	55;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	57;"	d
EIGEN_MAPBASE_H	Eigen/src/Core/MapBase.h	12;"	d
EIGEN_MAPPED_SPARSEMATRIX_H	Eigen/src/SparseCore/MappedSparseMatrix.h	11;"	d
EIGEN_MAP_H	Eigen/src/Core/Map.h	12;"	d
EIGEN_MATHFUNCTIONSIMPL_H	Eigen/src/Core/MathFunctionsImpl.h	12;"	d
EIGEN_MATHFUNCTIONS_H	Eigen/src/Core/MathFunctions.h	11;"	d
EIGEN_MATHFUNC_IMPL	Eigen/src/Core/MathFunctions.h	68;"	d
EIGEN_MATHFUNC_RETVAL	Eigen/src/Core/MathFunctions.h	69;"	d
EIGEN_MATH_FUNCTIONS_ALTIVEC_H	Eigen/src/Core/arch/AltiVec/MathFunctions.h	17;"	d
EIGEN_MATH_FUNCTIONS_ALTIVEC_H	Eigen/src/Core/arch/ZVector/MathFunctions.h	17;"	d
EIGEN_MATH_FUNCTIONS_AVX_H	Eigen/src/Core/arch/AVX/MathFunctions.h	11;"	d
EIGEN_MATH_FUNCTIONS_CUDA_H	Eigen/src/Core/arch/CUDA/MathFunctions.h	11;"	d
EIGEN_MATH_FUNCTIONS_NEON_H	Eigen/src/Core/arch/NEON/MathFunctions.h	13;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	Eigen/src/Core/arch/SSE/MathFunctions.h	16;"	d
EIGEN_MATRIXBASEEIGENVALUES_H	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	12;"	d
EIGEN_MATRIXBASE_H	Eigen/src/Core/MatrixBase.h	12;"	d
EIGEN_MATRIXSTORAGE_H	Eigen/src/Core/DenseStorage.h	13;"	d
EIGEN_MATRIX_EXPONENTIAL	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	12;"	d
EIGEN_MATRIX_FUNCTION	Eigen/src/Core/MatrixBase.h	447;"	d
EIGEN_MATRIX_FUNCTION_1	Eigen/src/Core/MatrixBase.h	450;"	d
EIGEN_MATRIX_FUNCTION_H	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	11;"	d
EIGEN_MATRIX_H	Eigen/src/Core/Matrix.h	12;"	d
EIGEN_MATRIX_LOGARITHM	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	12;"	d
EIGEN_MATRIX_POWER	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	11;"	d
EIGEN_MATRIX_SQUARE_ROOT	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	11;"	d
EIGEN_MAX_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	771;"	d
EIGEN_MAX_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	773;"	d
EIGEN_MAX_ALIGN_BYTES	test/unalignedassert.cpp	15;"	d	file:
EIGEN_MAX_ALIGN_BYTES	test/unalignedassert.cpp	18;"	d	file:
EIGEN_MAX_ALIGN_BYTES	test/unalignedassert.cpp	21;"	d	file:
EIGEN_MAX_CPP_VER	Eigen/src/Core/util/Macros.h	356;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	691;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	693;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	728;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	737;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	738;"	d
EIGEN_MAX_STATIC_ALIGN_BYTES	test/unalignedassert.cpp	14;"	d	file:
EIGEN_MAX_STATIC_ALIGN_BYTES	test/unalignedassert.cpp	17;"	d	file:
EIGEN_MAX_STATIC_ALIGN_BYTES	test/unalignedassert.cpp	20;"	d	file:
EIGEN_MEMBER_FUNCTOR	Eigen/src/Core/VectorwiseOp.h	84;"	d
EIGEN_MEMORY_H	Eigen/src/Core/util/Memory.h	21;"	d
EIGEN_META_H	Eigen/src/Core/util/Meta.h	12;"	d
EIGEN_MINOR_VERSION	Eigen/src/Core/util/Macros.h	16;"	d
EIGEN_MINRES_H_	unsupported/Eigen/src/IterativeSolvers/MINRES.h	13;"	d
EIGEN_MIN_ALIGN_BYTES	Eigen/src/Core/util/Macros.h	677;"	d
EIGEN_MISC_IMAGE_H	Eigen/src/misc/Image.h	11;"	d
EIGEN_MISC_KERNEL_H	Eigen/src/misc/Kernel.h	11;"	d
EIGEN_MKL_DOMAIN_ALL	Eigen/src/Core/util/MKL_support.h	82;"	d
EIGEN_MKL_DOMAIN_ALL	Eigen/src/Core/util/MKL_support.h	84;"	d
EIGEN_MKL_DOMAIN_BLAS	Eigen/src/Core/util/MKL_support.h	88;"	d
EIGEN_MKL_DOMAIN_BLAS	Eigen/src/Core/util/MKL_support.h	90;"	d
EIGEN_MKL_DOMAIN_FFT	Eigen/src/Core/util/MKL_support.h	94;"	d
EIGEN_MKL_DOMAIN_FFT	Eigen/src/Core/util/MKL_support.h	96;"	d
EIGEN_MKL_DOMAIN_PARDISO	Eigen/src/Core/util/MKL_support.h	106;"	d
EIGEN_MKL_DOMAIN_PARDISO	Eigen/src/Core/util/MKL_support.h	108;"	d
EIGEN_MKL_DOMAIN_VML	Eigen/src/Core/util/MKL_support.h	100;"	d
EIGEN_MKL_DOMAIN_VML	Eigen/src/Core/util/MKL_support.h	102;"	d
EIGEN_MKL_SUPPORT_H	Eigen/src/Core/util/MKL_support.h	34;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	Eigen/src/Core/Assign_MKL.h	141;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	Eigen/src/Core/Assign_MKL.h	82;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	Eigen/src/Core/Assign_MKL.h	115;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_CPLX	Eigen/src/Core/Assign_MKL.h	111;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	Eigen/src/Core/Assign_MKL.h	107;"	d
EIGEN_MKL_VML_THRESHOLD	Eigen/src/Core/util/MKL_support.h	77;"	d
EIGEN_MOREVECTORIZATION_MATHFUNCTIONS_H	unsupported/Eigen/src/MoreVectorization/MathFunctions.h	12;"	d
EIGEN_MPL2_ONLY	test/mpl2only.cpp	10;"	d	file:
EIGEN_MSVC10_WORKAROUND_BINARYOP_RETURN_TYPE	Eigen/src/Core/util/Macros.h	936;"	d
EIGEN_NESTBYVALUE_H	Eigen/src/Core/NestByValue.h	12;"	d
EIGEN_NOALIAS_H	Eigen/src/Core/NoAlias.h	11;"	d
EIGEN_NOEXCEPT	Eigen/src/Core/util/Macros.h	984;"	d
EIGEN_NOEXCEPT_IF	Eigen/src/Core/Array.h	/^    Array& operator=(Array&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)$/;"	f	class:Eigen::Array
EIGEN_NOEXCEPT_IF	Eigen/src/Core/Array.h	/^    Array(Array&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)$/;"	f	class:Eigen::Array
EIGEN_NOEXCEPT_IF	Eigen/src/Core/Matrix.h	/^    Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)$/;"	f	class:Eigen::Matrix
EIGEN_NOEXCEPT_IF	Eigen/src/Core/Matrix.h	/^    Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)$/;"	f	class:Eigen::Matrix
EIGEN_NOEXCEPT_IF	Eigen/src/Core/util/Macros.h	985;"	d
EIGEN_NOT_A_MACRO	Eigen/src/Core/util/Macros.h	327;"	d
EIGEN_NO_ASSERTION_CHECKING	test/cholesky.cpp	11;"	d	file:
EIGEN_NO_DEBUG	Eigen/src/Core/util/Macros.h	535;"	d
EIGEN_NO_DEBUG_SMALL_PRODUCT_BLOCKS	test/cholmod_support.cpp	10;"	d	file:
EIGEN_NO_DEBUG_SMALL_PRODUCT_BLOCKS	test/pastix_support.cpp	11;"	d	file:
EIGEN_NO_DEBUG_SMALL_PRODUCT_BLOCKS	test/spqr_support.cpp	9;"	d	file:
EIGEN_NO_DEBUG_SMALL_PRODUCT_BLOCKS	test/superlu_support.cpp	10;"	d	file:
EIGEN_NO_DEBUG_SMALL_PRODUCT_BLOCKS	test/umfpack_support.cpp	10;"	d	file:
EIGEN_NO_DEPRECATED_WARNING	unsupported/test/sparse_extra.cpp	12;"	d	file:
EIGEN_NO_INT128	unsupported/test/cxx11_tensor_uint128.cpp	16;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/adjoint.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/basicstuff.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/block.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/integer_types.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/mapped_matrix.cpp	11;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/mixingtypes.cpp	14;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/product_small.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/smallvectors.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/swap.cpp	10;"	d	file:
EIGEN_NO_STATIC_ASSERT	test/vectorwiseop.cpp	12;"	d	file:
EIGEN_NO_THROW	Eigen/src/Core/util/Macros.h	986;"	d
EIGEN_NULLARY_FUNCTORS_H	Eigen/src/Core/functors/NullaryFunctors.h	11;"	d
EIGEN_NUMERICAL_DIFF_H	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	14;"	d
EIGEN_NUMTRAITS_H	Eigen/src/Core/NumTraits.h	11;"	d
EIGEN_ONLY_USED_FOR_DEBUG	Eigen/src/Core/util/Macros.h	589;"	d
EIGEN_ORDERING_H	Eigen/src/OrderingMethods/Ordering.h	12;"	d
EIGEN_ORTHOMETHODS_H	Eigen/src/Geometry/OrthoMethods.h	12;"	d
EIGEN_OS_ANDROID	Eigen/src/Core/util/Macros.h	234;"	d
EIGEN_OS_ANDROID	Eigen/src/Core/util/Macros.h	236;"	d
EIGEN_OS_BSD	Eigen/src/Core/util/Macros.h	248;"	d
EIGEN_OS_BSD	Eigen/src/Core/util/Macros.h	250;"	d
EIGEN_OS_CYGWIN	Eigen/src/Core/util/Macros.h	290;"	d
EIGEN_OS_CYGWIN	Eigen/src/Core/util/Macros.h	292;"	d
EIGEN_OS_GNULINUX	Eigen/src/Core/util/Macros.h	241;"	d
EIGEN_OS_GNULINUX	Eigen/src/Core/util/Macros.h	243;"	d
EIGEN_OS_LINUX	Eigen/src/Core/util/Macros.h	226;"	d
EIGEN_OS_LINUX	Eigen/src/Core/util/Macros.h	228;"	d
EIGEN_OS_MAC	Eigen/src/Core/util/Macros.h	255;"	d
EIGEN_OS_MAC	Eigen/src/Core/util/Macros.h	257;"	d
EIGEN_OS_QNX	Eigen/src/Core/util/Macros.h	262;"	d
EIGEN_OS_QNX	Eigen/src/Core/util/Macros.h	264;"	d
EIGEN_OS_SOLARIS	Eigen/src/Core/util/Macros.h	311;"	d
EIGEN_OS_SOLARIS	Eigen/src/Core/util/Macros.h	313;"	d
EIGEN_OS_SUN	Eigen/src/Core/util/Macros.h	304;"	d
EIGEN_OS_SUN	Eigen/src/Core/util/Macros.h	306;"	d
EIGEN_OS_UNIX	Eigen/src/Core/util/Macros.h	219;"	d
EIGEN_OS_UNIX	Eigen/src/Core/util/Macros.h	221;"	d
EIGEN_OS_WIN	Eigen/src/Core/util/Macros.h	269;"	d
EIGEN_OS_WIN	Eigen/src/Core/util/Macros.h	271;"	d
EIGEN_OS_WIN64	Eigen/src/Core/util/Macros.h	276;"	d
EIGEN_OS_WIN64	Eigen/src/Core/util/Macros.h	278;"	d
EIGEN_OS_WINCE	Eigen/src/Core/util/Macros.h	283;"	d
EIGEN_OS_WINCE	Eigen/src/Core/util/Macros.h	285;"	d
EIGEN_OS_WIN_STRICT	Eigen/src/Core/util/Macros.h	297;"	d
EIGEN_OS_WIN_STRICT	Eigen/src/Core/util/Macros.h	299;"	d
EIGEN_PACKED_TRIANGULAR_MATRIX_VECTOR_H	blas/PackedTriangularMatrixVector.h	11;"	d
EIGEN_PACKED_TRIANGULAR_SOLVER_VECTOR_H	blas/PackedTriangularSolverVector.h	11;"	d
EIGEN_PACKET_MATH_ALTIVEC_H	Eigen/src/Core/arch/AltiVec/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_AVX512_H	Eigen/src/Core/arch/AVX512/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_AVX_H	Eigen/src/Core/arch/AVX/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_CUDA_H	Eigen/src/Core/arch/CUDA/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_HALF_CUDA_H	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	11;"	d
EIGEN_PACKET_MATH_NEON_H	Eigen/src/Core/arch/NEON/PacketMath.h	13;"	d
EIGEN_PACKET_MATH_SSE_H	Eigen/src/Core/arch/SSE/PacketMath.h	11;"	d
EIGEN_PACKET_MATH_ZVECTOR_H	Eigen/src/Core/arch/ZVector/PacketMath.h	11;"	d
EIGEN_PARALLELIZER_H	Eigen/src/Core/products/Parallelizer.h	11;"	d
EIGEN_PARAMETRIZEDLINE_H	Eigen/src/Geometry/ParametrizedLine.h	12;"	d
EIGEN_PARDISO	bench/spbench/spbenchsolver.h	56;"	d
EIGEN_PARDISOSUPPORT_H	Eigen/src/PardisoSupport/PardisoSupport.h	33;"	d
EIGEN_PARDISO_LDLT	bench/spbench/spbenchsolver.h	66;"	d
EIGEN_PARDISO_LLT	bench/spbench/spbenchsolver.h	71;"	d
EIGEN_PARTIALLU_H	Eigen/src/LU/PartialPivLU.h	12;"	d
EIGEN_PARTIALLU_LAPACK_H	Eigen/src/LU/PartialPivLU_LAPACKE.h	34;"	d
EIGEN_PARTIAL_REDUX_H	Eigen/src/Core/VectorwiseOp.h	12;"	d
EIGEN_PASTIX	bench/spbench/spbenchsolver.h	55;"	d
EIGEN_PASTIXSUPPORT_H	Eigen/src/PaStiXSupport/PaStiXSupport.h	11;"	d
EIGEN_PASTIX_LDLT	bench/spbench/spbenchsolver.h	65;"	d
EIGEN_PASTIX_LLT	bench/spbench/spbenchsolver.h	70;"	d
EIGEN_PERMISSIVE_EXPR	Eigen/src/Core/util/Macros.h	521;"	d
EIGEN_PERMISSIVE_EXPR	Eigen/src/Core/util/Macros.h	523;"	d
EIGEN_PERMUTATIONMATRIX_H	Eigen/src/Core/PermutationMatrix.h	12;"	d
EIGEN_PI	Eigen/src/Core/MathFunctions.h	15;"	d
EIGEN_PLAIN_ENUM_MAX	Eigen/src/Core/util/Macros.h	876;"	d
EIGEN_PLAIN_ENUM_MIN	Eigen/src/Core/util/Macros.h	875;"	d
EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	293;"	d
EIGEN_POLYNOMIAL_SOLVER_H	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	11;"	d
EIGEN_POLYNOMIAL_UTILS_H	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	11;"	d
EIGEN_PPC_PREFETCH	Eigen/src/Core/arch/AltiVec/PacketMath.h	127;"	d
EIGEN_PPC_PREFETCH	Eigen/src/Core/arch/AltiVec/PacketMath.h	129;"	d
EIGEN_PP_EXPAND	Eigen/src/Core/Assign_MKL.h	69;"	d
EIGEN_PREDICATE_SAME_MATRIX_SIZE	Eigen/src/Core/util/StaticAssert.h	171;"	d
EIGEN_PRODUCTEVALUATORS_H	Eigen/src/Core/ProductEvaluators.h	14;"	d
EIGEN_PRODUCT_H	Eigen/src/Core/Product.h	11;"	d
EIGEN_QR_H	Eigen/src/QR/HouseholderQR.h	13;"	d
EIGEN_QR_LAPACKE_H	Eigen/src/QR/HouseholderQR_LAPACKE.h	35;"	d
EIGEN_QUATERNION_DEMO_H	demos/opengl/quaternion_demo.h	11;"	d
EIGEN_QUATERNION_H	Eigen/src/Geometry/Quaternion.h	12;"	d
EIGEN_RANDOMSETTER_H	unsupported/Eigen/src/SparseExtra/RandomSetter.h	11;"	d
EIGEN_RANDOM_H	Eigen/src/Core/Random.h	11;"	d
EIGEN_RANK2UPDATE_H	blas/Rank2Update.h	11;"	d
EIGEN_REALSVD2X2_H	Eigen/src/misc/RealSvd2x2.h	12;"	d
EIGEN_REAL_QZ_H	Eigen/src/Eigenvalues/RealQZ.h	11;"	d
EIGEN_REAL_SCHUR_H	Eigen/src/Eigenvalues/RealSchur.h	12;"	d
EIGEN_REAL_SCHUR_LAPACKE_H	Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	34;"	d
EIGEN_REDUX_H	Eigen/src/Core/Redux.h	12;"	d
EIGEN_REF_H	Eigen/src/Core/Ref.h	11;"	d
EIGEN_REPLICATE_H	Eigen/src/Core/Replicate.h	11;"	d
EIGEN_RESTRICT	Eigen/src/Core/util/Macros.h	793;"	d
EIGEN_RESTRICT	Eigen/src/Core/util/Macros.h	796;"	d
EIGEN_RETURNBYVALUE_H	Eigen/src/Core/ReturnByValue.h	12;"	d
EIGEN_REVERSE_H	Eigen/src/Core/Reverse.h	13;"	d
EIGEN_ROTATION2D_H	Eigen/src/Geometry/Rotation2D.h	11;"	d
EIGEN_ROTATIONBASE_H	Eigen/src/Geometry/RotationBase.h	11;"	d
EIGEN_RUNTIME_NO_MALLOC	test/bdcsvd.cpp	15;"	d	file:
EIGEN_RUNTIME_NO_MALLOC	test/eigensolver_generalized_real.cpp	10;"	d	file:
EIGEN_RUNTIME_NO_MALLOC	test/jacobisvd.cpp	13;"	d	file:
EIGEN_RUNTIME_NO_MALLOC	test/nomalloc.cpp	14;"	d	file:
EIGEN_RUNTIME_NO_MALLOC	test/real_qz.cpp	10;"	d	file:
EIGEN_SAEIGENSOLVER_LAPACKE_H	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	34;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	Eigen/src/Core/util/Macros.h	320;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	Eigen/src/Core/util/Macros.h	322;"	d
EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE	Eigen/src/Core/util/Macros.h	930;"	d
EIGEN_SCALAR_BINARY_OP_PLUGIN	test/linearstructure.cpp	12;"	d	file:
EIGEN_SCALAR_BINARY_OP_PLUGIN	test/mixingtypes.cpp	41;"	d	file:
EIGEN_SCALAR_BINARY_SUPPORTED	Eigen/src/Core/util/Macros.h	923;"	d
EIGEN_SCALING_H	Eigen/src/Geometry/Scaling.h	11;"	d
EIGEN_SELECT_H	Eigen/src/Core/Select.h	11;"	d
EIGEN_SELFADJOINTEIGENSOLVER_H	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	12;"	d
EIGEN_SELFADJOINTMATRIX_H	Eigen/src/Core/SelfAdjointView.h	11;"	d
EIGEN_SELFADJOINTRANK2UPTADE_H	Eigen/src/Core/products/SelfadjointRank2Update.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_BLAS_H	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	11;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_BLAS_H	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	34;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	Eigen/src/Core/products/SelfadjointMatrixVector.h	11;"	d
EIGEN_SELFADJOINT_PACKED_PRODUCT_H	blas/PackedSelfadjointProduct.h	11;"	d
EIGEN_SELFADJOINT_PRODUCT_H	Eigen/src/Core/products/SelfadjointProduct.h	11;"	d
EIGEN_SELFCWISEBINARYOP_H	Eigen/src/Core/SelfCwiseBinaryOp.h	11;"	d
EIGEN_SFINAE_ENABLE_IF	unsupported/Eigen/CXX11/src/Tensor/TensorMacros.h	43;"	d
EIGEN_SIMPLICIAL_CHOLESKY_H	Eigen/src/SparseCholesky/SimplicialCholesky.h	11;"	d
EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	46;"	d
EIGEN_SIMPLICIAL_LDLT	bench/spbench/spbenchsolver.h	63;"	d
EIGEN_SIMPLICIAL_LLT	bench/spbench/spbenchsolver.h	67;"	d
EIGEN_SIZE_MAX	Eigen/src/Core/util/Macros.h	897;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	Eigen/src/Core/util/Macros.h	881;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	Eigen/src/Core/util/Macros.h	889;"	d
EIGEN_SKYLINEINPLACELU_H	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	11;"	d
EIGEN_SKYLINEMATRIXBASE_H	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	11;"	d
EIGEN_SKYLINEMATRIX_H	unsupported/Eigen/src/Skyline/SkylineMatrix.h	11;"	d
EIGEN_SKYLINEPRODUCT_H	unsupported/Eigen/src/Skyline/SkylineProduct.h	11;"	d
EIGEN_SKYLINEUTIL_H	unsupported/Eigen/src/Skyline/SkylineUtil.h	11;"	d
EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE	unsupported/Eigen/src/Skyline/SkylineUtil.h	60;"	d
EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATOR	unsupported/Eigen/src/Skyline/SkylineUtil.h	27;"	d
EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATORS	unsupported/Eigen/src/Skyline/SkylineUtil.h	45;"	d
EIGEN_SKYLINE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	unsupported/Eigen/src/Skyline/SkylineUtil.h	38;"	d
EIGEN_SKYLINE_STORAGE_H	unsupported/Eigen/src/Skyline/SkylineStorage.h	11;"	d
EIGEN_SOLVERBASE_H	Eigen/src/Core/SolverBase.h	11;"	d
EIGEN_SOLVETRIANGULAR_H	Eigen/src/Core/SolveTriangular.h	11;"	d
EIGEN_SOLVEWITHGUESS_H	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	11;"	d
EIGEN_SOLVE_H	Eigen/src/Core/Solve.h	11;"	d
EIGEN_SPARSEASSIGN_H	Eigen/src/SparseCore/SparseAssign.h	11;"	d
EIGEN_SPARSEBLOCKMATRIX_H	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	12;"	d
EIGEN_SPARSEDENSEPRODUCT_H	Eigen/src/SparseCore/SparseDenseProduct.h	11;"	d
EIGEN_SPARSELU_COLAMD	bench/spbench/spbenchsolver.h	57;"	d
EIGEN_SPARSELU_GEMM_KERNEL_H	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	11;"	d
EIGEN_SPARSELU_MEMORY	Eigen/src/SparseLU/SparseLU_Memory.h	32;"	d
EIGEN_SPARSELU_METIS	bench/spbench/spbenchsolver.h	58;"	d
EIGEN_SPARSELU_SUPERNODAL_MATRIX_H	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	12;"	d
EIGEN_SPARSELU_UTILS_H	Eigen/src/SparseLU/SparseLU_Utils.h	12;"	d
EIGEN_SPARSEMATRIXBASE_H	Eigen/src/SparseCore/SparseMatrixBase.h	11;"	d
EIGEN_SPARSEMATRIX_H	Eigen/src/SparseCore/SparseMatrix.h	11;"	d
EIGEN_SPARSEPRODUCT_H	Eigen/src/SparseCore/SparseProduct.h	11;"	d
EIGEN_SPARSEREDUX_H	Eigen/src/SparseCore/SparseRedux.h	11;"	d
EIGEN_SPARSESOLVERBASE_H	Eigen/src/SparseCore/SparseSolverBase.h	11;"	d
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	11;"	d
EIGEN_SPARSETRANSPOSE_H	Eigen/src/SparseCore/SparseTranspose.h	11;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	Eigen/src/SparseCore/TriangularSolver.h	11;"	d
EIGEN_SPARSEUTIL_H	Eigen/src/SparseCore/SparseUtil.h	11;"	d
EIGEN_SPARSEVECTOR_H	Eigen/src/SparseCore/SparseVector.h	11;"	d
EIGEN_SPARSEVIEW_H	Eigen/src/SparseCore/SparseView.h	12;"	d
EIGEN_SPARSE_AMD_H	Eigen/src/OrderingMethods/Amd.h	32;"	d
EIGEN_SPARSE_BLOCKFORDYNAMICMATRIX_H	unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	11;"	d
EIGEN_SPARSE_BLOCK_H	Eigen/src/SparseCore/SparseBlock.h	11;"	d
EIGEN_SPARSE_COMPRESSED_BASE_H	Eigen/src/SparseCore/SparseCompressedBase.h	11;"	d
EIGEN_SPARSE_COMPRESSED_STORAGE_REALLOCATE_PLUGIN	test/sparse_basic.cpp	13;"	d	file:
EIGEN_SPARSE_CREATE_TEMPORARY_PLUGIN	test/sparse_product.cpp	23;"	d	file:
EIGEN_SPARSE_CREATE_TEMPORARY_PLUGIN	test/sparse_ref.cpp	22;"	d	file:
EIGEN_SPARSE_CWISE_BINARY_OP_H	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	11;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	11;"	d
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	Eigen/src/SparseCore/SparseDiagonalProduct.h	11;"	d
EIGEN_SPARSE_DOT_H	Eigen/src/SparseCore/SparseDot.h	11;"	d
EIGEN_SPARSE_FUZZY_H	Eigen/src/SparseCore/SparseFuzzy.h	11;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	Eigen/src/SparseCore/SparseUtil.h	21;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	Eigen/src/SparseCore/SparseUtil.h	39;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	Eigen/src/SparseCore/SparseUtil.h	32;"	d
EIGEN_SPARSE_LU_H	Eigen/src/SparseLU/SparseLU.h	13;"	d
EIGEN_SPARSE_MAP_H	Eigen/src/SparseCore/SparseMap.h	11;"	d
EIGEN_SPARSE_MARKET_IO_H	unsupported/Eigen/src/SparseExtra/MarketIO.h	12;"	d
EIGEN_SPARSE_PERMUTATION_H	Eigen/src/SparseCore/SparsePermutation.h	11;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	Eigen/src/SparseCore/SparseUtil.h	43;"	d
EIGEN_SPARSE_QR_H	Eigen/src/SparseQR/SparseQR.h	12;"	d
EIGEN_SPARSE_REF_H	Eigen/src/SparseCore/SparseRef.h	11;"	d
EIGEN_SPARSE_SELFADJOINTVIEW_H	Eigen/src/SparseCore/SparseSelfAdjointView.h	11;"	d
EIGEN_SPARSE_TRANSPOSED_COPY_PLUGIN	test/sparse_permutations.cpp	12;"	d	file:
EIGEN_SPARSE_TRIANGULARVIEW_H	Eigen/src/SparseCore/SparseTriangularView.h	12;"	d
EIGEN_SPECIALFUNCTIONS_ARRAYAPI_H	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	12;"	d
EIGEN_SPECIALFUNCTIONS_FUNCTORS_H	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	12;"	d
EIGEN_SPECIALFUNCTIONS_HALF_H	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	9;"	d
EIGEN_SPECIALFUNCTIONS_PACKETMATH_H	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	11;"	d
EIGEN_SPECIAL_FUNCTIONS_H	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	11;"	d
EIGEN_SPLINES_FWD_H	unsupported/Eigen/src/Splines/SplineFwd.h	11;"	d
EIGEN_SPLINE_FITTING_H	unsupported/Eigen/src/Splines/SplineFitting.h	11;"	d
EIGEN_SPLINE_H	unsupported/Eigen/src/Splines/Spline.h	11;"	d
EIGEN_STABLENORM_H	Eigen/src/Core/StableNorm.h	11;"	d
EIGEN_STACK_ALLOCATION_LIMIT	Eigen/src/Core/util/Macros.h	801;"	d
EIGEN_STACK_ALLOCATION_LIMIT	test/bdcsvd.cpp	14;"	d	file:
EIGEN_STACK_ALLOCATION_LIMIT	test/exceptions.cpp	15;"	d	file:
EIGEN_STACK_ALLOCATION_LIMIT	test/jacobisvd.cpp	12;"	d	file:
EIGEN_STACK_ALLOCATION_LIMIT	test/nomalloc.cpp	12;"	d	file:
EIGEN_STATIC_ASSERT	Eigen/src/Core/util/StaticAssert.h	119;"	d
EIGEN_STATIC_ASSERT	Eigen/src/Core/util/StaticAssert.h	33;"	d
EIGEN_STATIC_ASSERT	test/main.h	263;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	Eigen/src/Core/util/StaticAssert.h	203;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	Eigen/src/Core/util/StaticAssert.h	149;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	Eigen/src/Core/util/StaticAssert.h	144;"	d
EIGEN_STATIC_ASSERT_H	Eigen/src/Core/util/StaticAssert.h	12;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	Eigen/src/Core/MapBase.h	14;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	Eigen/src/Core/MapBase.h	299;"	d
EIGEN_STATIC_ASSERT_LVALUE	Eigen/src/Core/util/StaticAssert.h	199;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	159;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	Eigen/src/Core/util/StaticAssert.h	184;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	Eigen/src/Core/util/StaticAssert.h	189;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	Eigen/src/Core/util/StaticAssert.h	164;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	Eigen/src/Core/util/StaticAssert.h	207;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	Eigen/src/Core/util/StaticAssert.h	194;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	Eigen/src/Core/util/StaticAssert.h	139;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	154;"	d
EIGEN_STDDEQUE_H	Eigen/src/StlSupport/StdDeque.h	12;"	d
EIGEN_STDLIST_H	Eigen/src/StlSupport/StdList.h	11;"	d
EIGEN_STDVECTOR_H	Eigen/src/StlSupport/StdVector.h	12;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdDeque.h	52;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdList.h	52;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdVector.h	52;"	d
EIGEN_STEM_FUNCTION	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	11;"	d
EIGEN_STL_DETAILS_H	Eigen/src/StlSupport/details.h	12;"	d
EIGEN_STL_FUNCTORS_H	Eigen/src/Core/functors/StlFunctors.h	11;"	d
EIGEN_STRIDE_H	Eigen/src/Core/Stride.h	11;"	d
EIGEN_STRONG_INLINE	Eigen/src/Core/util/Macros.h	492;"	d
EIGEN_STRONG_INLINE	Eigen/src/Core/util/Macros.h	494;"	d
EIGEN_SUITESPARSEQRSUPPORT_H	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	12;"	d
EIGEN_SUPERLU	bench/spbench/spbenchsolver.h	54;"	d
EIGEN_SUPERLUSUPPORT_H	Eigen/src/SuperLUSupport/SuperLUSupport.h	11;"	d
EIGEN_SUPERLU_HAS_ILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	70;"	d
EIGEN_SUPERLU_HAS_ILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	820;"	d
EIGEN_SUPERLU_SUPPORT	bench/sparse_lu.cpp	4;"	d	file:
EIGEN_SVDBASE_H	Eigen/src/SVD/SVDBase.h	17;"	d
EIGEN_SWAP_H	Eigen/src/Core/Swap.h	11;"	d
EIGEN_TERNARY_FUNCTORS_H	Eigen/src/Core/functors/TernaryFunctors.h	11;"	d
EIGEN_TESTMAP_MAX_SIZE	test/mapped_matrix.cpp	16;"	d	file:
EIGEN_TESTSPARSE_H	test/sparse.h	11;"	d
EIGEN_TEST_CUDACC_VER	test/main.h	55;"	d
EIGEN_TEST_CUDACC_VER	test/main.h	57;"	d
EIGEN_TEST_CUDACC_VER	test/main.h	59;"	d
EIGEN_TEST_CUDA_COMMON_H	test/cuda_common.h	3;"	d
EIGEN_TEST_FUNC	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	16;"	d	file:
EIGEN_TEST_FUNC	unsupported/test/cxx11_tensor_device_sycl.cpp	16;"	d	file:
EIGEN_TEST_FUNC	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	16;"	d	file:
EIGEN_TEST_FUNC	unsupported/test/cxx11_tensor_reduction_sycl.cpp	16;"	d	file:
EIGEN_TEST_FUNC	unsupported/test/cxx11_tensor_sycl.cpp	18;"	d	file:
EIGEN_TEST_MAX_SIZE	test/boostmultiprec.cpp	13;"	d	file:
EIGEN_TEST_MAX_SIZE	test/boostmultiprec.cpp	16;"	d	file:
EIGEN_TEST_MAX_SIZE	test/ctorleak.cpp	33;"	d	file:
EIGEN_TEST_MAX_SIZE	test/ctorleak.cpp	34;"	d	file:
EIGEN_TEST_NO_COMPLEX	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	15;"	d	file:
EIGEN_TEST_NO_COMPLEX	unsupported/test/cxx11_tensor_device_sycl.cpp	15;"	d	file:
EIGEN_TEST_NO_COMPLEX	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	15;"	d	file:
EIGEN_TEST_NO_COMPLEX	unsupported/test/cxx11_tensor_reduction_sycl.cpp	15;"	d	file:
EIGEN_TEST_NO_COMPLEX	unsupported/test/cxx11_tensor_sycl.cpp	17;"	d	file:
EIGEN_TEST_NO_LONGDOUBLE	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	14;"	d	file:
EIGEN_TEST_NO_LONGDOUBLE	unsupported/test/cxx11_tensor_device_sycl.cpp	14;"	d	file:
EIGEN_TEST_NO_LONGDOUBLE	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	14;"	d	file:
EIGEN_TEST_NO_LONGDOUBLE	unsupported/test/cxx11_tensor_reduction_sycl.cpp	14;"	d	file:
EIGEN_TEST_NO_LONGDOUBLE	unsupported/test/cxx11_tensor_sycl.cpp	16;"	d	file:
EIGEN_TEST_SPACE	unsupported/test/autodiff.cpp	321;"	d	file:
EIGEN_TEST_SPECIFIC_BLOCKING_SIZES	bench/benchmark-blocking-sizes.cpp	20;"	d	file:
EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_K	bench/benchmark-blocking-sizes.cpp	21;"	d	file:
EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_M	bench/benchmark-blocking-sizes.cpp	22;"	d	file:
EIGEN_TEST_SPECIFIC_BLOCKING_SIZE_N	bench/benchmark-blocking-sizes.cpp	23;"	d	file:
EIGEN_THREAD_LOCAL	unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h	15;"	d
EIGEN_THREAD_LOCAL	unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h	17;"	d
EIGEN_THREAD_LOCAL	unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h	19;"	d
EIGEN_THREAD_YIELD	unsupported/Eigen/CXX11/src/ThreadPool/ThreadYield.h	15;"	d
EIGEN_THREAD_YIELD	unsupported/Eigen/CXX11/src/ThreadPool/ThreadYield.h	17;"	d
EIGEN_THROW	Eigen/src/Core/util/Macros.h	966;"	d
EIGEN_THROW_X	Eigen/src/Core/util/Macros.h	965;"	d
EIGEN_TMP_NOOPT_ATTRIB	Eigen/src/Core/MathFunctions.h	777;"	d
EIGEN_TMP_NOOPT_ATTRIB	Eigen/src/Core/MathFunctions.h	781;"	d
EIGEN_TMP_NOOPT_ATTRIB	Eigen/src/Core/MathFunctions.h	791;"	d
EIGEN_TPL_PP_SPEC_HACK_DEF	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	69;"	d
EIGEN_TPL_PP_SPEC_HACK_DEF	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	74;"	d
EIGEN_TPL_PP_SPEC_HACK_DEFC	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	70;"	d
EIGEN_TPL_PP_SPEC_HACK_DEFC	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	75;"	d
EIGEN_TPL_PP_SPEC_HACK_USE	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	71;"	d
EIGEN_TPL_PP_SPEC_HACK_USE	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	76;"	d
EIGEN_TPL_PP_SPEC_HACK_USEC	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	72;"	d
EIGEN_TPL_PP_SPEC_HACK_USEC	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	77;"	d
EIGEN_TRACKBALL_H	demos/opengl/trackball.h	11;"	d
EIGEN_TRANSFORM_H	Eigen/src/Geometry/Transform.h	13;"	d
EIGEN_TRANSLATION_H	Eigen/src/Geometry/Translation.h	11;"	d
EIGEN_TRANSPOSE_H	Eigen/src/Core/Transpose.h	12;"	d
EIGEN_TRANSPOSITIONS_H	Eigen/src/Core/Transpositions.h	11;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	Eigen/src/Core/products/TriangularMatrixVector.h	11;"	d
EIGEN_TRIANGULARMATRIX_H	Eigen/src/Core/TriangularMatrix.h	12;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_BLAS_H	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	34;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	Eigen/src/Core/products/TriangularMatrixMatrix.h	11;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_BLAS_H	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_BLAS_H	Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	34;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	Eigen/src/Core/products/TriangularSolverMatrix.h	11;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	Eigen/src/Core/products/TriangularSolverVector.h	11;"	d
EIGEN_TRIDIAGONALIZATION_H	Eigen/src/Eigenvalues/Tridiagonalization.h	12;"	d
EIGEN_TRY	Eigen/src/Core/util/Macros.h	967;"	d
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	Eigen/src/Core/arch/Default/Settings.h	38;"	d
EIGEN_TYPE_CASTING_AVX_H	Eigen/src/Core/arch/AVX/TypeCasting.h	11;"	d
EIGEN_TYPE_CASTING_CUDA_H	Eigen/src/Core/arch/CUDA/TypeCasting.h	11;"	d
EIGEN_TYPE_CASTING_SSE_H	Eigen/src/Core/arch/SSE/TypeCasting.h	11;"	d
EIGEN_UMEYAMA_H	Eigen/src/Geometry/Umeyama.h	11;"	d
EIGEN_UMFPACK	bench/spbench/spbenchsolver.h	53;"	d
EIGEN_UMFPACKSUPPORT_H	Eigen/src/UmfPackSupport/UmfPackSupport.h	11;"	d
EIGEN_UMFPACK_SUPPORT	bench/sparse_lu.cpp	5;"	d	file:
EIGEN_UNALIGNED_VECTORIZE	Eigen/src/Core/util/Macros.h	786;"	d
EIGEN_UNALIGNED_VECTORIZE	test/vectorization_logic.cpp	11;"	d	file:
EIGEN_UNALIGNED_VECTORIZE	test/vectorization_logic.cpp	15;"	d	file:
EIGEN_UNARY_FUNCTORS_H	Eigen/src/Core/functors/UnaryFunctors.h	11;"	d
EIGEN_UNORDERED_MAP_SUPPORT	test/sparse.h	28;"	d
EIGEN_UNROLLING_LIMIT	Eigen/src/Core/arch/Default/Settings.h	24;"	d
EIGEN_UNUSED	Eigen/src/Core/util/Macros.h	607;"	d
EIGEN_UNUSED_VARIABLE	Eigen/src/Core/util/Macros.h	618;"	d
EIGEN_USE_BLAS	Eigen/src/Core/util/MKL_support.h	38;"	d
EIGEN_USE_CUSTOM_ASSERT	test/main.h	294;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	41;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	49;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	68;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	71;"	d
EIGEN_USE_LAPACKE_STRICT	Eigen/src/Core/util/MKL_support.h	70;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	53;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	61;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	63;"	d
EIGEN_USE_MKL_ALL	Eigen/src/Core/util/MKL_support.h	67;"	d
EIGEN_USE_MKL_VML	Eigen/src/Core/util/MKL_support.h	44;"	d
EIGEN_USE_MKL_VML	Eigen/src/Core/util/MKL_support.h	69;"	d
EIGEN_USE_STD_FPCLASSIFY	Eigen/src/Core/MathFunctions.h	691;"	d
EIGEN_USE_STD_FPCLASSIFY	Eigen/src/Core/MathFunctions.h	693;"	d
EIGEN_USE_SYCL	bench/tensors/tensor_benchmarks_sycl.cc	1;"	d	file:
EIGEN_USE_SYCL	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	18;"	d	file:
EIGEN_USE_SYCL	unsupported/test/cxx11_tensor_device_sycl.cpp	18;"	d	file:
EIGEN_USE_SYCL	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	18;"	d	file:
EIGEN_USE_SYCL	unsupported/test/cxx11_tensor_reduction_sycl.cpp	18;"	d	file:
EIGEN_USE_SYCL	unsupported/test/cxx11_tensor_sycl.cpp	20;"	d	file:
EIGEN_USE_THREADS	bench/tensors/contraction_benchmarks_cpu.cc	1;"	d	file:
EIGEN_USE_THREADS	bench/tensors/tensor_benchmarks_cpu.cc	1;"	d	file:
EIGEN_USE_THREADS	unsupported/test/cxx11_eventcount.cpp	11;"	d	file:
EIGEN_USE_THREADS	unsupported/test/cxx11_non_blocking_thread_pool.cpp	11;"	d	file:
EIGEN_USE_THREADS	unsupported/test/cxx11_runqueue.cpp	11;"	d	file:
EIGEN_USE_THREADS	unsupported/test/cxx11_tensor_notification.cpp	10;"	d	file:
EIGEN_USE_THREADS	unsupported/test/cxx11_tensor_thread_pool.cpp	10;"	d	file:
EIGEN_USING_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	320;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	Eigen/src/Core/Array.h	314;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	Eigen/src/Core/Array.h	309;"	d
EIGEN_VECTORBLOCK_H	Eigen/src/Core/VectorBlock.h	12;"	d
EIGEN_VERSION_AT_LEAST	Eigen/src/Core/util/Macros.h	18;"	d
EIGEN_VISITOR_H	Eigen/src/Core/Visitor.h	11;"	d
EIGEN_VMLMODE_EXPAND_LA	Eigen/src/Core/Assign_MKL.h	71;"	d
EIGEN_VMLMODE_EXPAND_LA	Eigen/src/Core/Assign_MKL.h	73;"	d
EIGEN_VMLMODE_EXPAND__	Eigen/src/Core/Assign_MKL.h	76;"	d
EIGEN_VMLMODE_PREFIX	Eigen/src/Core/Assign_MKL.h	80;"	d
EIGEN_VMLMODE_PREFIX_LA	Eigen/src/Core/Assign_MKL.h	78;"	d
EIGEN_VMLMODE_PREFIX__	Eigen/src/Core/Assign_MKL.h	79;"	d
EIGEN_WARNINGS_DISABLED	Eigen/src/Core/util/DisableStupidWarnings.h	2;"	d
EIGEN_WARNINGS_DISABLED	Eigen/src/Core/util/ReenableStupidWarnings.h	2;"	d
EIGEN_WEAK_LINKING	blas/xerbla.cpp	5;"	d	file:
EIGEN_WEAK_LINKING	blas/xerbla.cpp	7;"	d	file:
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	Eigen/src/StlSupport/details.h	54;"	d
EIGEN_WORK_AROUND_QT_BUG_CALLING_WRONG_OPERATOR_NEW_FIXED_IN_QT_4_5	test/qtvector.cpp	11;"	d	file:
EIGEN_WORLD_VERSION	Eigen/src/Core/util/Macros.h	14;"	d
EIGEN_XPRHELPER_H	Eigen/src/Core/util/XprHelper.h	12;"	d
EIGEN_YES_I_KNOW_SPARSE_MODULE_IS_NOT_STABLE_YET	test/sparse.h	13;"	d
EIGEN_ZVECTOR_PREFETCH	Eigen/src/Core/arch/ZVector/PacketMath.h	129;"	d
EIGEN_ZVECTOR_PREFETCH	Eigen/src/Core/arch/ZVector/PacketMath.h	131;"	d
EI_PP_MAKE_STRING	test/main.h	153;"	d
EI_PP_MAKE_STRING2	test/main.h	152;"	d
END	bench/product_threshold.cpp	9;"	d	file:
END_OF	bench/btl/generic_bench/utils/utilities.h	68;"	d
END_OF	bench/btl/generic_bench/utils/utilities.h	85;"	d
EPS	blas/testing/cblat2.f	/^      REAL               EPS,/;"	v	program:CBLAT2
EPS	blas/testing/cblat3.f	/^      REAL               EPS,/;"	v	program:CBLAT3
EPS	blas/testing/dblat2.f	/^      DOUBLE PRECISION   EPS,/;"	v	program:DBLAT2
EPS	blas/testing/dblat3.f	/^      DOUBLE PRECISION   EPS,/;"	v	program:DBLAT3
EPS	blas/testing/sblat2.f	/^      REAL               EPS,/;"	v	program:SBLAT2
EPS	blas/testing/sblat3.f	/^      REAL               EPS,/;"	v	program:SBLAT3
EPS	blas/testing/zblat2.f	/^      DOUBLE PRECISION   EPS,/;"	v	program:ZBLAT2
EPS	blas/testing/zblat3.f	/^      DOUBLE PRECISION   EPS,/;"	v	program:ZBLAT3
ERR	blas/testing/cblat2.f	/^      REAL               EPS, ERR,/;"	v	program:CBLAT2
ERR	blas/testing/cblat3.f	/^      REAL               EPS, ERR,/;"	v	program:CBLAT3
ERR	blas/testing/dblat2.f	/^      DOUBLE PRECISION   EPS, ERR,/;"	v	program:DBLAT2
ERR	blas/testing/dblat3.f	/^      DOUBLE PRECISION   EPS, ERR,/;"	v	program:DBLAT3
ERR	blas/testing/sblat2.f	/^      REAL               EPS, ERR,/;"	v	program:SBLAT2
ERR	blas/testing/sblat3.f	/^      REAL               EPS, ERR,/;"	v	program:SBLAT3
ERR	blas/testing/zblat2.f	/^      DOUBLE PRECISION   EPS, ERR,/;"	v	program:ZBLAT2
ERR	blas/testing/zblat3.f	/^      DOUBLE PRECISION   EPS, ERR,/;"	v	program:ZBLAT3
EULER_X	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    EULER_X = 1, \/*!< the X axis *\/$/;"	e	enum:Eigen::EulerAxis
EULER_Y	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    EULER_Y = 2, \/*!< the Y axis *\/$/;"	e	enum:Eigen::EulerAxis
EULER_Z	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    EULER_Z = 3  \/*!< the Z axis *\/$/;"	e	enum:Eigen::EulerAxis
EVALTO	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	166;"	d
EVALTO	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	182;"	d
EVALTO	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	148;"	d
EVALTO	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	156;"	d
E_VDW	bench/vdw_new.cpp	/^SCALAR E_VDW(const Vec &interactions1, const Vec &interactions2)$/;"	f
EarlyEval	bench/basicbenchmark.h	/^enum {LazyEval, EarlyEval, OmpEval};$/;"	e	enum:__anon4
EigVecMask	Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen	Eigen/src/Cholesky/LDLT.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Cholesky/LLT.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Cholesky/LLT_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/AssignEvaluator.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ConditionEstimator.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CoreEvaluators.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CwiseTernaryOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/GeneralProduct.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	Eigen/src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/MathFunctionsImpl.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Product.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/ProductEvaluators.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Ref.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Solve.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SolverBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/VectorwiseOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/arch/AVX/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AVX/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AVX/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AVX/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AVX512/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/Half.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/NEON/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/TypeCasting.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/ZVector/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/ZVector/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/AssignmentFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/BinaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/NullaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/StlFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/TernaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/functors/UnaryFunctors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/Parallelizer.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverVector.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Macros.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/RealQZ.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/RealSchur_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^namespace Eigen {  $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/FullPivLU.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/LU/InverseImpl.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/PartialPivLU.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/LU/PartialPivLU_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/MetisSupport/MetisSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/OrderingMethods/Ordering.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/ColPivHouseholderQR.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/HouseholderQR_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SVD/BDCSVD.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SVD/JacobiSVD_LAPACKE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SVD/SVDBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseAssign.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseBlock.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseColEtree.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseCompressedBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseFuzzy.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseMap.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseRef.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseTriangularView.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseLU/SparseLU.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLUImpl.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseQR/SparseQR.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/RealSvd2x2.h	/^namespace Eigen {$/;"	n
Eigen	bench/BenchTimer.h	/^namespace Eigen$/;"	n
Eigen	bench/bench_norm.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	blas/common.h	/^namespace Eigen {$/;"	n
Eigen	blas/level1_cplx_impl.h	/^namespace Eigen {$/;"	n
Eigen	doc/examples/matrixfree_cg.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	test/boostmultiprec.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	test/evaluators.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	test/half_float.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	test/main.h	/^    namespace Eigen$/;"	n
Eigen	test/main.h	/^  namespace Eigen$/;"	n
Eigen	test/main.h	/^namespace Eigen {$/;"	n
Eigen	test/main.h	/^namespace Eigen$/;"	n
Eigen	test/packetmath.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorGlobalFunctions.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/ThreadPool/ThreadPoolInterface.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^namespace Eigen$/;"	n
Eigen	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/BVH/KdBVH.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^namespace Eigen$/;"	n
Eigen	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^namespace Eigen$/;"	n
Eigen	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/LevenbergMarquardt/LMcovar.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/LevenbergMarquardt/LMonestep.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/LevenbergMarquardt/LMpar.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/LevenbergMarquardt/LMqrsolv.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/covar.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Polynomials/Companion.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^namespace Eigen { $/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^namespace Eigen {$/;"	n
Eigen	unsupported/Eigen/src/Splines/Spline.h	/^namespace Eigen$/;"	n
Eigen	unsupported/Eigen/src/Splines/SplineFitting.h	/^namespace Eigen$/;"	n
Eigen	unsupported/Eigen/src/Splines/SplineFwd.h	/^namespace Eigen$/;"	n
Eigen	unsupported/doc/examples/BVH_Example.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/test/BVH.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/test/alignedvector3.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/test/polynomialsolver.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/test/polynomialutils.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	unsupported/test/splines.cpp	/^namespace Eigen {$/;"	n	file:
EigenBase	Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EigenBase2EigenBase	Eigen/src/Core/AssignEvaluator.h	/^struct EigenBase2EigenBase {};$/;"	s	namespace:Eigen::internal
EigenContractionKernel	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenContractionKernel(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenContractionKernelInternal	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenContractionKernelInternal(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenConvolutionKernel1D	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^__global__ void EigenConvolutionKernel1D($/;"	f	namespace:Eigen
EigenConvolutionKernel2D	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^__global__ void EigenConvolutionKernel2D($/;"	f	namespace:Eigen
EigenConvolutionKernel3D	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^__global__ void EigenConvolutionKernel3D($/;"	f	namespace:Eigen
EigenFloatContractionKernel	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenFloatContractionKernel(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenFloatContractionKernel16x16	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenFloatContractionKernel16x16(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenFloatContractionKernelInternal	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenFloatContractionKernelInternal(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenFloatContractionKernelInternal16x16	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^EigenFloatContractionKernelInternal16x16(const LhsMapper lhs, const RhsMapper rhs,$/;"	f	namespace:Eigen
EigenMatrixPrinter	debug/gdb/printers.py	/^class EigenMatrixPrinter:$/;"	c
EigenMetaKernel	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^EigenMetaKernel(Evaluator eval, Index size) {$/;"	f	namespace:Eigen::internal
EigenMetaKernelEval	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^struct EigenMetaKernelEval {$/;"	s	namespace:Eigen::internal
EigenMetaKernelEval	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^struct EigenMetaKernelEval<Evaluator, Index, true> {$/;"	s	namespace:Eigen::internal
EigenQuaternionPrinter	debug/gdb/printers.py	/^class EigenQuaternionPrinter:$/;"	c
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^    explicit EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^    explicit EigenSolver(const EigenBase<InputType>& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
EigenSolverType	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef EigenSolver<CompanionMatrixType>         EigenSolverType;$/;"	t	class:Eigen::PolynomialSolver
EigenSparseMatrix	bench/BenchSparseUtil.h	/^typedef SparseMatrix<Scalar> EigenSparseMatrix;$/;"	t
EigenSparseSelfAdjointMatrix	bench/sparse_cholesky.cpp	/^typedef SparseMatrix<Scalar,SelfAdjoint|LowerTriangular> EigenSparseSelfAdjointMatrix;$/;"	t	file:
EigenSparseTriMatrix	bench/sparse_trisolver.cpp	/^typedef SparseMatrix<Scalar,UpperTriangular> EigenSparseTriMatrix;$/;"	t	file:
EigenSparseTriMatrixRow	bench/sparse_trisolver.cpp	/^typedef SparseMatrix<Scalar,RowMajorBit|UpperTriangular> EigenSparseTriMatrixRow;$/;"	t	file:
EigenVectorContainer	unsupported/test/FFTW.cpp	/^enum { StdVectorContainer, EigenVectorContainer };$/;"	e	enum:__anon21	file:
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase
EigenvalueType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvalueType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver
EigenvalueType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef CwiseBinaryOp<internal::scalar_quotient_op<ComplexScalar,Scalar>,ComplexVectorType,VectorType> EigenvalueType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvalueType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealQZ
EigenvalueType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur
EigenvaluesOnly	Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase
EigenvaluesReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase
EigenvaluesReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView
EigenvectorType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::EigenvectorsType EigenvectorsType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Elem	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  struct Elem {$/;"	s	class:Eigen::RunQueue
ElemTypeHolder	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct ElemTypeHolder<0, Tuple<T, Ts...> > {$/;"	s	namespace:utility::tuple
ElemTypeHolder	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct ElemTypeHolder<k, Tuple<T, Ts...> > {$/;"	s	namespace:utility::tuple
ElseMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits
ElseNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename ElseXprType::Nested ElseNested;$/;"	t	struct:Eigen::internal::traits
Empty	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  bool Empty() const { return Size() == 0; }$/;"	f	class:Eigen::RunQueue
Empty	unsupported/test/cxx11_eventcount.cpp	/^  bool Empty() { return val_.load(std::memory_order_relaxed) == 0; }$/;"	f	struct:TestQueue
EnableCoeff	Eigen/src/Core/Product.h	/^      EnableCoeff = IsOneByOne || Option==LazyProduct$/;"	e	enum:Eigen::ProductImpl::__anon325
EnableVml	Eigen/src/Core/Assign_MKL.h	/^      EnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon747
EnvThread	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^    EnvThread(std::function<void()> f) : thr_(std::move(f)) {}$/;"	f	class:Eigen::StlThreadEnvironment::EnvThread
EnvThread	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^  class EnvThread {$/;"	c	struct:Eigen::StlThreadEnvironment
ErfReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_erf_op<Scalar>, const Derived> ErfReturnType;$/;"	t
ErfcReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_erfc_op<Scalar>, const Derived> ErfcReturnType;$/;"	t
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EulerAngles	demos/opengl/quaternion_demo.cpp	/^  EulerAngles() {}$/;"	f	class:EulerAngles
EulerAngles	demos/opengl/quaternion_demo.cpp	/^  inline EulerAngles(Scalar a0, Scalar a1, Scalar a2) : m_angles(a0, a1, a2) {}$/;"	f	class:EulerAngles
EulerAngles	demos/opengl/quaternion_demo.cpp	/^  inline EulerAngles(const QuaternionType& q) { *this = q; }$/;"	f	class:EulerAngles
EulerAngles	demos/opengl/quaternion_demo.cpp	/^template<typename _Scalar> class EulerAngles$/;"	c	file:
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles($/;"	f	class:Eigen::EulerAngles
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles() {}$/;"	f	class:Eigen::EulerAngles
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::EulerAngles
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles(const RotationBase<Derived, 3>& rot) { *this = rot; }$/;"	f	class:Eigen::EulerAngles
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles(const Scalar& alpha, const Scalar& beta, const Scalar& gamma) :$/;"	f	class:Eigen::EulerAngles
EulerAngles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^  class EulerAngles : public RotationBase<EulerAngles<_Scalar, _System>, 3>$/;"	c	namespace:Eigen
EulerAxis	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^  enum EulerAxis$/;"	g	namespace:Eigen
EulerSystem	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^  class EulerSystem$/;"	c	namespace:Eigen
EvalBeforeAssigningBit	Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4; \/\/ FIXME deprecated$/;"	m	namespace:Eigen
EvalBeforeNestingBit	Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EvalIterator	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename evaluator<ArgType>::InnerIterator        EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename evaluator<ArgType>::InnerIterator        EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalIterator	Eigen/src/SparseCore/SparseView.h	/^    typedef typename evaluator<ArgType>::InnerIterator EvalIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
EvalLeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), LeftArgType, RightArgType>::type EvalLeftArgType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
EvalLeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), LeftArgType, RightArgType>::type EvalLeftArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalLeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), LeftArgType, RightArgType>::type EvalLeftArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalLeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), LeftArgType, RightArgType>::type EvalLeftArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalRange	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^struct EvalRange {$/;"	s	namespace:Eigen::internal
EvalRange	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^struct EvalRange<Evaluator, Index, true> {$/;"	s	namespace:Eigen::internal
EvalReturnType	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase
EvalRightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), RightArgType, LeftArgType>::type EvalRightArgType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
EvalRightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), RightArgType, LeftArgType>::type EvalRightArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalRightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), RightArgType, LeftArgType>::type EvalRightArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalRightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    static_cast<int>(Layout) == static_cast<int>(ColMajor), RightArgType, LeftArgType>::type EvalRightArgType;$/;"	t	struct:Eigen::TensorEvaluator
EvalToLHSConstructor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^  EvalToLHSConstructor(const utility::tuple::Tuple<Params...> &t): expr((&(*(utility::tuple::get<N>(t).get_pointer())))) {}$/;"	f	struct:Eigen::TensorSycl::internal::EvalToLHSConstructor
EvalToLHSConstructor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^struct EvalToLHSConstructor {$/;"	s	namespace:Eigen::TensorSycl::internal
EvalToRowMajor	Eigen/src/Core/ProductEvaluators.h	/^    EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
EvalToRowMajor	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    EvalToRowMajor = (LhsFlags & RhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon29
EvalToRowMajor	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon40
EvalToTemp	Eigen/src/Core/CoreEvaluators.h	/^  explicit EvalToTemp(const ArgType& arg)$/;"	f	class:Eigen::internal::EvalToTemp
EvalToTemp	Eigen/src/Core/CoreEvaluators.h	/^class EvalToTemp$/;"	c	namespace:Eigen::internal
Evaluator	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  typedef TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device> Evaluator;$/;"	t	struct:Eigen::TensorSycl::internal::FunctorExtractor
EvaluatorFlags	Eigen/src/Core/Matrix.h	/^    EvaluatorFlags = LinearAccessBit | DirectAccessBit | packet_access_bit | row_major_bit,$/;"	e	enum:Eigen::internal::traits::__anon439
EvaluatorType	Eigen/src/Core/CoreIterators.h	/^  typedef evaluator<XprType> EvaluatorType;$/;"	t	class:Eigen::internal::inner_iterator_selector
EvaluatorType	Eigen/src/Core/CoreIterators.h	/^  typedef internal::evaluator<XprType> EvaluatorType;$/;"	t	class:Eigen::InnerIterator
EventCount	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  EventCount(MaxSizeVector<Waiter>& waiters) : waiters_(waiters) {$/;"	f	class:Eigen::EventCount
EventCount	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^class EventCount {$/;"	c	namespace:Eigen
ExecuteTask	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^  void ExecuteTask(const Task& t) { t.f(); }$/;"	f	struct:Eigen::StlThreadEnvironment
ExpReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_exp_op<Scalar>, const Derived> ExpReturnType;$/;"	t
ExpandMem	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  enum { ExpandMem = true };$/;"	e	enum:Eigen::internal::column_dfs_traits::__anon879
ExpandMem	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  enum { ExpandMem = false };$/;"	e	enum:Eigen::internal::panel_dfs_traits::__anon876
ExprConstructor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^    -> decltype(ExprConstructor<OrigExpr, IndexExpr, Params...>(funcD, t)) {$/;"	f	namespace:Eigen::TensorSycl::internal
ExpressionTraits	Eigen/src/Core/CoreEvaluators.h	/^  typedef traits<ExpressionType> ExpressionTraits;$/;"	t	struct:Eigen::internal::evaluator_base
ExpressionType	Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionType	Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionTypeNested	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp
ExpressionTypeNestedCleaned	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp
ExtendedType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<BinaryCategory<OP, LHSExpr, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TensorAssignOp<LHSExpr, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TensorEvalToOp<Expr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TensorForcedEvalOp<Expr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TensorReductionOp<OP, Dim, Expr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<UnaryCategory<OP, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const BinaryCategory<OP, LHSExpr, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TensorAssignOp<LHSExpr, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TensorEvalToOp<Expr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TensorForcedEvalOp<Expr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TensorReductionOp<OP, Dim, Expr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractAccessor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^struct ExtractAccessor<TensorEvaluator<const UnaryCategory<OP, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
FATAL	blas/testing/cblat2.f	/^      LOGICAL            FATAL,/;"	v	program:CBLAT2
FATAL	blas/testing/cblat3.f	/^      LOGICAL            FATAL,/;"	v	program:CBLAT3
FATAL	blas/testing/dblat2.f	/^      LOGICAL            FATAL,/;"	v	program:DBLAT2
FATAL	blas/testing/dblat3.f	/^      LOGICAL            FATAL,/;"	v	program:DBLAT3
FATAL	blas/testing/sblat2.f	/^      LOGICAL            FATAL,/;"	v	program:SBLAT2
FATAL	blas/testing/sblat3.f	/^      LOGICAL            FATAL,/;"	v	program:SBLAT3
FATAL	blas/testing/zblat2.f	/^      LOGICAL            FATAL,/;"	v	program:ZBLAT2
FATAL	blas/testing/zblat3.f	/^      LOGICAL            FATAL,/;"	v	program:ZBLAT3
FFTDirection	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^enum FFTDirection {$/;"	g	namespace:Eigen
FFTResultType	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^enum FFTResultType {$/;"	g	namespace:Eigen
FFT_FORWARD	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^    FFT_FORWARD = 0,$/;"	e	enum:Eigen::FFTDirection
FFT_REVERSE	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^    FFT_REVERSE = 1$/;"	e	enum:Eigen::FFTDirection
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
FORBIDDEN_IDENTIFIER	test/main.h	80;"	d
FORCEDEVAL	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	186;"	d
FORCEDEVAL	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	200;"	d
FORCEDEVAL	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	136;"	d
FORCEDEVAL	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	144;"	d
FREQUENCY	bench/btl/generic_bench/timers/x86_timer.hh	39;"	d
FVectorType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef Matrix<Scalar,Dynamic,1> FVectorType;$/;"	t	class:Eigen::LevenbergMarquardt
FVectorType	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, 1 > FVectorType;$/;"	t	class:Eigen::HybridNonLinearSolver
FVectorType	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef Matrix< Scalar, Dynamic, 1 > FVectorType;$/;"	t	class:Eigen::LevenbergMarquardt
Factor	Eigen/src/Core/CoreEvaluators.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::unary_evaluator::__anon764
FactorType	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> FactorType;$/;"	t	class:Eigen::IncompleteCholesky
FactorType	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor,StorageIndex> FactorType;$/;"	t	class:Eigen::IncompleteLUT
FactorType	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLU
Fail	test/ctorleak.cpp	/^  class Fail : public std::exception {};$/;"	c	struct:Foo	file:
FancySpheres	demos/opengl/quaternion_demo.cpp	/^    FancySpheres()$/;"	f	class:FancySpheres
FancySpheres	demos/opengl/quaternion_demo.cpp	/^class FancySpheres$/;"	c	file:
Fileexists	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline bool Fileexists(std::string file)$/;"	f	class:Eigen::MatrixMarketIterator
FixedBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct FixedBlockXpr { typedef Block<Derived,Rows,Cols> Type; };$/;"	s
FixedSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s
Flags	Eigen/src/Core/ArrayWrapper.h	/^    Flags = (Flags0 & ~(NestByRefBit | LvalueBit)) | LvalueBitFlag$/;"	e	enum:Eigen::internal::traits::__anon441
Flags	Eigen/src/Core/ArrayWrapper.h	/^    Flags = (Flags0 & ~(NestByRefBit | LvalueBit)) | LvalueBitFlag$/;"	e	enum:Eigen::internal::traits::__anon442
Flags	Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
Flags	Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon478
Flags	Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon479
Flags	Eigen/src/Core/Block.h	/^    Flags = (traits<XprType>::Flags & (DirectAccessBit | (InnerPanel?CompressedAccessBit:0))) | FlagsLvalueBit | FlagsRowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon464
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (Flags0 & ~RowMajorBit) | (Arg1Flags & RowMajorBit),$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<ArgType>::Flags & (HereditaryBits | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon757
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<ArgTypeNestedCleaned>::Flags & (HereditaryBits|LinearAccessMask) & ~RowMajorBit) | (traits<XprType>::Flags & RowMajorBit),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon765
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (evaluator<PlainObjectTypeCleaned>::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon753
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (traits<XprType>::Flags&RowMajorBit) | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit))) | LinearAccessBit,$/;"	e	enum:Eigen::internal::evaluator::__anon767
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit) | LinearAccessBit,$/;"	e	enum:Eigen::internal::evaluator::__anon770
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = (unsigned int)evaluator<ThenMatrixType>::Flags & evaluator<ElseMatrixType>::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::evaluator::__anon763
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsRowMajorBit,$/;"	e	enum:Eigen::internal::evaluator::__anon761
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags ^ RowMajorBit,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon752
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon754
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<ArgType>::Flags,$/;"	e	enum:Eigen::internal::evaluator_wrapper_base::__anon768
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Flags,$/;"	e	enum:Eigen::internal::evaluator::__anon760
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = int( evaluator<PlainObjectType>::Flags) & (LinearAccessMask&PacketAccessMask),$/;"	e	enum:Eigen::internal::evaluator::__anon759
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = int(Flags0) & (HereditaryBits | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
Flags	Eigen/src/Core/CoreEvaluators.h	/^    Flags = traits<Derived>::EvaluatorFlags,$/;"	e	enum:Eigen::internal::evaluator::__anon751
Flags	Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = cwise_promote_storage_order<typename traits<Lhs>::StorageKind,typename traits<Rhs>::StorageKind,_LhsNested::Flags & RowMajorBit,_RhsNested::Flags & RowMajorBit>::value$/;"	e	enum:Eigen::internal::traits::__anon447
Flags	Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = traits<PlainObjectType>::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon771
Flags	Eigen/src/Core/CwiseTernaryOp.h	/^  enum { Flags = _Arg1Nested::Flags & RowMajorBit };$/;"	e	enum:Eigen::internal::traits::__anon515
Flags	Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & RowMajorBit $/;"	e	enum:Eigen::internal::traits::__anon472
Flags	Eigen/src/Core/CwiseUnaryView.h	/^    Flags = traits<_MatrixTypeNested>::Flags & (RowMajorBit | FlagsLvalueBit | DirectAccessBit), \/\/ FIXME DirectAccessBit should not be handled by expressions$/;"	e	enum:Eigen::internal::traits::__anon460
Flags	Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon285
Flags	Eigen/src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (RowMajorBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit, \/\/ FIXME DirectAccessBit should not be handled by expressions$/;"	e	enum:Eigen::internal::traits::__anon500
Flags	Eigen/src/Core/DiagonalMatrix.h	/^      Flags = NoPreferredStorageOrderBit$/;"	e	enum:Eigen::DiagonalBase::__anon282
Flags	Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  (traits<DiagonalVectorType>::Flags & LvalueBit) | NoPreferredStorageOrderBit$/;"	e	enum:Eigen::internal::traits::__anon284
Flags	Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit | NoPreferredStorageOrderBit$/;"	e	enum:Eigen::internal::traits::__anon283
Flags	Eigen/src/Core/Inverse.h	/^    Flags = BaseTraits::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon322
Flags	Eigen/src/Core/Inverse.h	/^  enum { Flags = Base::Flags | EvalBeforeNestingBit };$/;"	e	enum:Eigen::internal::unary_evaluator::__anon323
Flags	Eigen/src/Core/Map.h	/^    Flags = is_lvalue<PlainObjectType>::value ? int(Flags0) : (int(Flags0) & ~LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon748
Flags	Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon439
Flags	Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon466
Flags	Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon467
Flags	Eigen/src/Core/Product.h	/^    Flags = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon324
Flags	Eigen/src/Core/ProductEvaluators.h	/^    Flags = ((HereditaryBits|_LinearAccessMask) & (unsigned int)(MatrixFlags)) | (_Vectorizable ? PacketAccessBit : 0),$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
Flags	Eigen/src/Core/ProductEvaluators.h	/^    Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
Flags	Eigen/src/Core/ProductEvaluators.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon425
Flags	Eigen/src/Core/ProductEvaluators.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon429
Flags	Eigen/src/Core/Redux.h	/^    Flags = evaluator<XprType>::Flags & ~DirectAccessBit,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
Flags	Eigen/src/Core/Ref.h	/^    Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit,$/;"	e	enum:Eigen::internal::traits::__anon473
Flags	Eigen/src/Core/Replicate.h	/^    Flags = IsRowMajor ? RowMajorBit : 0$/;"	e	enum:Eigen::internal::traits::__anon772
Flags	Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon636
Flags	Eigen/src/Core/Reverse.h	/^    Flags = _MatrixTypeNested::Flags & (RowMajorBit | LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon433
Flags	Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & RowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon424
Flags	Eigen/src/Core/SelfAdjointView.h	/^      Flags = internal::traits<SelfAdjointView>::Flags,$/;"	e	enum:Eigen::SelfAdjointView::__anon481
Flags	Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits|FlagsLvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon480
Flags	Eigen/src/Core/Solve.h	/^    Flags = BaseTraits::Flags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon494
Flags	Eigen/src/Core/Solve.h	/^  enum { Flags = Base::Flags | EvalBeforeNestingBit };$/;"	e	enum:Eigen::internal::evaluator::__anon495
Flags	Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon443
Flags	Eigen/src/Core/TriangularMatrix.h	/^      Flags = internal::traits<TriangularView>::Flags,$/;"	e	enum:Eigen::TriangularView::__anon454
Flags	Eigen/src/Core/TriangularMatrix.h	/^      Flags = internal::traits<TriangularViewType>::Flags$/;"	e	enum:Eigen::TriangularViewImpl::__anon455
Flags	Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits | FlagsLvalueBit) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit)))$/;"	e	enum:Eigen::internal::traits::__anon453
Flags	Eigen/src/Core/VectorwiseOp.h	/^    Flags = RowsAtCompileTime == 1 ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon637
Flags	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon856
Flags	Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon258
Flags	Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon252
Flags	Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon249
Flags	Eigen/src/Geometry/Quaternion.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon250
Flags	Eigen/src/Geometry/Transform.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon264
Flags	Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon277
Flags	Eigen/src/LU/FullPivLU.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon224
Flags	Eigen/src/LU/PartialPivLU.h	/^    Flags = BaseTraits::Flags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon228
Flags	Eigen/src/QR/ColPivHouseholderQR.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon211
Flags	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon209
Flags	Eigen/src/QR/FullPivHouseholderQR.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon207
Flags	Eigen/src/SparseCore/SparseBlock.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon807
Flags	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Flags = Derived::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon844
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(Lhs::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon817
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(LhsArg::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon822
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(Rhs::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::binary_evaluator::__anon815
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = (XprType::Flags & ~RowMajorBit) | (int(RhsArg::Flags)&RowMajorBit)$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon820
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::binary_evaluator::__anon813
Flags	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::__anon818
Flags	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon840
Flags	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon841
Flags	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = NeedToTranspose ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::sparse_dense_outer_product_evaluator::__anon833
Flags	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Lhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon812
Flags	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  enum { CoeffReadCost = HugeCost, Flags = Rhs::Flags&RowMajorBit, Alignment = 0 }; \/\/ FIXME CoeffReadCost & Flags$/;"	e	enum:Eigen::internal::product_evaluator::__anon811
Flags	Eigen/src/SparseCore/SparseMap.h	/^    Flags = TraitsBase::Flags & (~ (NestByRefBit | LvalueBit))$/;"	e	enum:Eigen::internal::traits::__anon828
Flags	Eigen/src/SparseCore/SparseMap.h	/^    Flags = TraitsBase::Flags & (~NestByRefBit)$/;"	e	enum:Eigen::internal::traits::__anon827
Flags	Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon838
Flags	Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon837
Flags	Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit | CompressedAccessBit,$/;"	e	enum:Eigen::internal::traits::__anon836
Flags	Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
Flags	Eigen/src/SparseCore/SparsePermutation.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon793
Flags	Eigen/src/SparseCore/SparsePermutation.h	/^    Flags = Base::Flags | EvalBeforeNestingBit$/;"	e	enum:Eigen::internal::product_evaluator::__anon794
Flags	Eigen/src/SparseCore/SparseRef.h	/^    Flags = (traits<SparseMatrix<MatScalar,MatOptions,MatIndex> >::Flags | CompressedAccessBit | NestByRefBit) & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon798
Flags	Eigen/src/SparseCore/SparseRef.h	/^    Flags = (traits<SparseVector<MatScalar,MatOptions,MatIndex> >::Flags | CompressedAccessBit | NestByRefBit) & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon801
Flags	Eigen/src/SparseCore/SparseRef.h	/^    Flags = traits<PlainObjectType>::Flags | CompressedAccessBit | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon796
Flags	Eigen/src/SparseCore/SparseRef.h	/^    Flags = traits<PlainObjectType>::Flags | CompressedAccessBit | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon799
Flags	Eigen/src/SparseCore/SparseTranspose.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon850
Flags	Eigen/src/SparseCore/SparseTriangularView.h	/^    Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon826
Flags	Eigen/src/SparseCore/SparseVector.h	/^    Flags = SparseVectorType::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon849
Flags	Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit) | CompressedAccessBit,$/;"	e	enum:Eigen::internal::traits::__anon845
Flags	Eigen/src/SparseCore/SparseView.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon852
Flags	Eigen/src/SparseCore/SparseView.h	/^      Flags = XprType::Flags$/;"	e	enum:Eigen::internal::unary_evaluator::__anon854
Flags	Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon851
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon119
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon96
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon164
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  enum { Flags = 0 };$/;"	e	enum:Eigen::internal::traits::__anon107
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon144
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon140
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon104
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon105
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon106
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon117
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Flags = BaseTraits::Flags$/;"	e	enum:Eigen::internal::traits::__anon161
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Flags = BaseTraits::Flags$/;"	e	enum:Eigen::internal::traits::__anon162
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Flags = compute_tensor_flags<Scalar_, Options_>::ret | (is_const<Scalar_>::value ? 0 : LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon159
Flags	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Flags = compute_tensor_flags<Scalar_, Options_>::ret | (is_const<Scalar_>::value ? 0: LvalueBit)$/;"	e	enum:Eigen::internal::traits::__anon160
Flags	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Flags = 0;$/;"	m	struct:Eigen::Symmetry
Flags	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Flags = ConjugationFlag | NegationFlag;$/;"	m	struct:Eigen::AntiHermiticity
Flags	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Flags = ConjugationFlag;$/;"	m	struct:Eigen::Hermiticity
Flags	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Flags = NegationFlag;$/;"	m	struct:Eigen::AntiSymmetry
Flags	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    Flags = ((LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon29
Flags	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        Flags = SkylineBit | _Options,$/;"	e	enum:Eigen::internal::traits::__anon41
Flags	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
Flags	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon40
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Flags = BlockSparseMatrixT::Options,$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Flags = Options,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Flags = VectorType::Flags$/;"	e	enum:Eigen::BlockVectorReturn::__anon75
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Flags = VectorType::Flags$/;"	e	enum:Eigen::BlockVectorView::__anon74
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Flags = _Options$/;"	e	enum:Eigen::BlockSparseMatrix::BlockInnerIterator::__anon78
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon76
Flags	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon72
Flags	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Flags = SparseMatrixType::Flags$/;"	e	enum:Eigen::internal::evaluator::__anon65
Flags	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon63
Flags0	Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon441
Flags0	Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon442
Flags0	Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = (int(Arg1Flags) | int(Arg2Flags) | int(Arg3Flags)) & ($/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
Flags0	Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
Flags0	Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = evaluator<ArgType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::evaluator::__anon761
Flags0	Eigen/src/Core/CoreEvaluators.h	/^    Flags0 = evaluator<ArgType>::Flags,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
Flags0	Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon748
Flags0	Eigen/src/Core/Transpose.h	/^    Flags0 = traits<MatrixTypeNestedPlain>::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon443
Flags1	Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon443
FlagsLinearAccessBit	Eigen/src/Core/CoreEvaluators.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,    $/;"	e	enum:Eigen::internal::evaluator::__anon761
FlagsLvalueBit	Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon464
FlagsLvalueBit	Eigen/src/Core/CwiseUnaryView.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon460
FlagsLvalueBit	Eigen/src/Core/SelfAdjointView.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon480
FlagsLvalueBit	Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon443
FlagsLvalueBit	Eigen/src/Core/TriangularMatrix.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon453
FlagsRowMajorBit	Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon464
FlagsRowMajorBit	Eigen/src/Core/CoreEvaluators.h	/^    FlagsRowMajorBit = XprType::Flags&RowMajorBit,$/;"	e	enum:Eigen::internal::evaluator::__anon761
FloorReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_floor_op<Scalar>, const Derived> FloorReturnType;$/;"	t
Foo	test/bug1213.cpp	/^  Foo$/;"	e	enum:__anon192	file:
Foo	test/ctorleak.cpp	/^  Foo()$/;"	f	struct:Foo
Foo	test/ctorleak.cpp	/^struct Foo$/;"	s	file:
Foo	test/jacobisvd.cpp	/^namespace Foo {$/;"	n	file:
ForceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC explicit inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess
ForceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen
ForceAlignment	Eigen/src/Core/GeneralProduct.h	/^    ForceAlignment  = internal::packet_traits<Scalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gemv_static_vector_if::__anon316
ForceNonZeroDiag	test/sparse.h	/^  ForceNonZeroDiag = 1,$/;"	e	enum:__anon193
ForceRealDiag	test/sparse.h	/^  ForceRealDiag = 8$/;"	e	enum:__anon193
Forward	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Forward,$/;"	e	enum:Eigen::NumericalDiffMode
ForwardLinearAccess	Eigen/src/Core/CoreEvaluators.h	/^    ForwardLinearAccess = InnerPanel && bool(evaluator<ArgType>::Flags&LinearAccessBit)$/;"	e	enum:Eigen::internal::unary_evaluator::__anon762
Frame	demos/opengl/camera.h	/^    inline Frame(const Eigen::Vector3f& pos = Eigen::Vector3f::Zero(),$/;"	f	class:Frame
Frame	demos/opengl/camera.h	/^class Frame$/;"	c
FromRotation	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      static EulerAngles FromRotation(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::EulerAngles
FromRotation	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      static EulerAngles FromRotation(const RotationBase<Derived, 3>& rot)$/;"	f	class:Eigen::EulerAngles
FromTwoVectors	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
FtolTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        FtolTooSmall = 6,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
FtolTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        FtolTooSmall = 6,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
FullMatrixType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject FullMatrixType;$/;"	t	struct:Eigen::internal::traits
FullMatrixType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject FullMatrixType;$/;"	t	struct:Eigen::internal::traits
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    explicit FullPivHouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    explicit FullPivHouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
FullPivHouseholderQRMatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal
FullPivHouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon423
FullReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct FullReducer {$/;"	s	namespace:Eigen::internal
FullReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct FullReducer<Self, Op, ThreadPoolDevice, Vectorizable> {$/;"	s	namespace:Eigen::internal
FullReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct FullReducer<Self, Op, GpuDevice, Vectorizable> {$/;"	s	namespace:Eigen::internal
FullReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^struct FullReducer<Self, Op, const Eigen::SyclDevice, Vectorizable> {$/;"	s	namespace:Eigen::internal
FullReducerShard	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct FullReducerShard {$/;"	s	namespace:Eigen::internal
FullReductionKernel	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void FullReductionKernel(Reducer reducer, const Self input, Index num_coeffs,$/;"	f	namespace:Eigen::internal
FullReductionKernelHalfFloat	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void FullReductionKernelHalfFloat(Reducer reducer, const Self input, Index num_coeffs,$/;"	f	namespace:Eigen::internal
FullReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct FullReductionLauncher {$/;"	s	namespace:Eigen::internal
FullReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct FullReductionLauncher<$/;"	s	namespace:Eigen::internal
FullReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct FullReductionLauncher<Self, Op, Eigen::half, false> {$/;"	s	namespace:Eigen::internal
FullReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct FullReductionLauncher<Self, Op, Eigen::half, true> {$/;"	s	namespace:Eigen::internal
FunctionWrapperWithBarrier	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^template <typename Function, typename... Args> struct FunctionWrapperWithBarrier$/;"	s	namespace:Eigen
FunctionWrapperWithNotification	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^template <typename Function, typename... Args> struct FunctionWrapperWithNotification$/;"	s	namespace:Eigen
Functor	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<BinaryOp>::type Functor;$/;"	t	class:Eigen::CwiseBinaryOp
Functor	Eigen/src/Core/Swap.h	/^  typedef swap_assign_op<Scalar> Functor;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Functor	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef _Functor Functor;$/;"	t	class:Eigen::NumericalDiff
Functor	unsupported/test/NonLinearOptimization.cpp	/^  Functor() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:Functor
Functor	unsupported/test/NonLinearOptimization.cpp	/^  Functor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Functor
Functor	unsupported/test/NonLinearOptimization.cpp	/^struct Functor$/;"	s	file:
Functor	unsupported/test/NumericalDiff.cpp	/^  Functor() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:Functor
Functor	unsupported/test/NumericalDiff.cpp	/^  Functor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Functor
Functor	unsupported/test/NumericalDiff.cpp	/^struct Functor$/;"	s	file:
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const Evaluator& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const BinaryCategory<OP, LHSExpr, RHSExpr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const TensorAssignOp<LHSExpr, RHSExpr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const TensorEvalToOp<RHSExpr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor(const TensorEvaluator<const UnaryCategory<OP, RHSExpr>, Dev>& expr)$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor< TensorEvaluator<const TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator< TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<BinaryCategory<OP,  LHSExpr, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<TensorAssignOp<LHSExpr, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<TensorEvalToOp<RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>>$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<TensorSelectOp<IfExpr, ThenExpr, ElseExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<UnaryCategory<OP, RHSExpr>, Dev> >$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const BinaryCategory<OP, LHSExpr, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const TensorAssignOp<LHSExpr, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const TensorEvalToOp<RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>>{$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const TernaryCategory<OP, Arg1Expr, Arg2Expr, Arg3Expr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^struct FunctorExtractor<TensorEvaluator<const UnaryCategory<OP, RHSExpr>, Dev> > {$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^template <typename Evaluator> struct FunctorExtractor{$/;"	s	namespace:Eigen::TensorSycl::internal
FunctorType	Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon594
FunctorType	Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon595
FunctorType	Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon596
FunctorType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef _FunctorType FunctorType;$/;"	t	class:Eigen::LevenbergMarquardt
G	blas/testing/cblat2.f	/^      REAL               G(/;"	v	program:CBLAT2
G	blas/testing/cblat3.f	/^      REAL               G(/;"	v	program:CBLAT3
G	blas/testing/dblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:DBLAT2
G	blas/testing/dblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT( NMAX ),$/;"	v	program:DBLAT3
G	blas/testing/sblat2.f	/^     $                   ALF( NALMAX ), AS( NMAX*NMAX ), BET( NBEMAX ),$/;"	v	program:SBLAT2
G	blas/testing/sblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT( NMAX ),$/;"	v	program:SBLAT3
G	blas/testing/zblat2.f	/^      DOUBLE PRECISION   G(/;"	v	program:ZBLAT2
G	blas/testing/zblat3.f	/^      DOUBLE PRECISION   G(/;"	v	program:ZBLAT3
G	doc/snippets/Jacobi_makeGivens.cpp	/^JacobiRotation<float> G;$/;"	v
GEMM_SPECIALIZATION	Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	49;"	d
GMM_INTERFACE_HH	bench/btl/libs/gmm/gmm_interface.hh	19;"	d
GMRES	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  GMRES() : Base(), m_restart(30) {}$/;"	f	class:Eigen::GMRES
GMRES	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  explicit GMRES(const EigenBase<MatrixDerived>& A) : Base(A.derived()), m_restart(30) {}$/;"	f	class:Eigen::GMRES
GMRES	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^class GMRES : public IterativeSolverBase<GMRES<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
GammaAxis	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    static const int GammaAxis = _GammaAxis;$/;"	m	class:Eigen::EulerSystem
GammaAxisAbs	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      GammaAxisAbs = internal::Abs<GammaAxis>::value, \/*!< the third rotation axis unsigned *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
GammaAxisVector	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      static Vector3 GammaAxisVector() {$/;"	f	class:Eigen::EulerAngles
GaussianGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC GaussianGenerator(const array<T, NumDims>& means,$/;"	f	class:Eigen::internal::GaussianGenerator
GaussianGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^class GaussianGenerator {$/;"	c	namespace:Eigen::internal
GemmParallelInfo	Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), lhs_start(0), lhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo
GemmParallelInfo	Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GemvProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GenEigMask	Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver()$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    explicit GeneralizedEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^template<typename _MatrixType> class GeneralizedEigenSolver$/;"	c	namespace:Eigen
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    explicit GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen
Generator	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      constexpr inline Generator(int one_, int two_, int flags_) : one(one_), two(two_), flags(flags_) {}$/;"	f	struct:Eigen::DynamicSGroup::Generator
Generator	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    struct Generator {$/;"	s	class:Eigen::DynamicSGroup
Generator1D	unsupported/test/cxx11_tensor_generator.cpp	/^  Generator1D() { }$/;"	f	struct:Generator1D
Generator1D	unsupported/test/cxx11_tensor_generator.cpp	/^struct Generator1D {$/;"	s	file:
Generator2D	unsupported/test/cxx11_tensor_generator.cpp	/^  Generator2D() { }$/;"	f	struct:Generator2D
Generator2D	unsupported/test/cxx11_tensor_generator.cpp	/^struct Generator2D {$/;"	s	file:
Generic	Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericDimReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct GenericDimReducer {$/;"	s	namespace:Eigen::internal
GenericDimReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct GenericDimReducer<-1, Self, Op> {$/;"	s	namespace:Eigen::internal
GenericDimReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct GenericDimReducer<0, Self, Op> {$/;"	s	namespace:Eigen::internal
GenericNumTraits	Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GetAction	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
GetDifferentType	test/main.h	/^template<> struct GetDifferentType<double> { typedef float type; };$/;"	s
GetDifferentType	test/main.h	/^template<> struct GetDifferentType<float> { typedef double type; };$/;"	s
GetDifferentType	test/main.h	/^template<typename T> struct GetDifferentType<std::complex<T> >$/;"	s
GetKernelSize	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct GetKernelSize {$/;"	s	namespace:Eigen
GetKernelSize	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct GetKernelSize<Dynamic> {$/;"	s	namespace:Eigen
GetMarketLine	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline bool GetMarketLine (std::stringstream& line, IndexType& M, IndexType& N, IndexType& i, IndexType& j, Scalar& value)$/;"	f	namespace:Eigen::internal
GetMarketLine	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline bool GetMarketLine (std::stringstream& line, IndexType& M, IndexType& N, IndexType& i, IndexType& j, std::complex<Scalar>& value)$/;"	f	namespace:Eigen::internal
GetPerThread	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  static EIGEN_STRONG_INLINE PerThread* GetPerThread() {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
GetPerThread	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  PerThread* GetPerThread() const {$/;"	f	class:Eigen::SimpleThreadPoolTempl
GetType	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^template<bool IsConst, typename T> struct GetType{$/;"	s	namespace:Eigen::TensorSycl::internal
GetType	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^template<typename T> struct GetType<false, T>{$/;"	s	namespace:Eigen::TensorSycl::internal
GetVectorElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void  GetVectorElt (const std::string& line, RealScalar& val)$/;"	f	namespace:Eigen::internal
GetVectorElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void GetVectorElt (const std::string& line, std::complex<RealScalar>& val)$/;"	f	namespace:Eigen::internal
Getnextvalidmatrix	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    void Getnextvalidmatrix( )$/;"	f	class:Eigen::MatrixMarketIterator
GlMatrixHelper	demos/opengl/gpuhelper.h	/^template<int _Flags> struct GlMatrixHelper<false,_Flags>$/;"	s
GlMatrixHelper	demos/opengl/gpuhelper.h	/^template<int _Flags> struct GlMatrixHelper<true,_Flags>$/;"	s
GlobalImagFlag	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  GlobalImagFlag         = 0x02,$/;"	e	enum:Eigen::__anon190
GlobalLU_t	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef LU_GlobalLU_t<IndexVector, ScalarVector> GlobalLU_t; $/;"	t	class:Eigen::internal::SparseLUImpl
GlobalRealFlag	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  GlobalRealFlag         = 0x01,$/;"	e	enum:Eigen::__anon190
GlobalZeroFlag	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  GlobalZeroFlag         = 0x03$/;"	e	enum:Eigen::__anon190
GmmDynSparse	bench/BenchSparseUtil.h	/^typedef gmm::col_matrix< gmm::wsvector<Scalar> > GmmDynSparse;$/;"	t
GmmSparse	bench/BenchSparseUtil.h	/^typedef gmm::csc_matrix<Scalar> GmmSparse;$/;"	t
GoogleDenseHashMapTraits	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct GoogleDenseHashMapTraits$/;"	s	namespace:Eigen
GoogleSparseHashMapTraits	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct GoogleSparseHashMapTraits$/;"	s	namespace:Eigen
GpuDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  explicit GpuDevice(const StreamInterface* stream) : stream_(stream), max_blocks_(INT_MAX) {$/;"	f	struct:Eigen::GpuDevice
GpuDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  explicit GpuDevice(const StreamInterface* stream, int num_blocks) : stream_(stream), max_blocks_(num_blocks) {$/;"	f	struct:Eigen::GpuDevice
GpuDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^struct GpuDevice {$/;"	s	namespace:Eigen
GpuHelper	demos/opengl/gpuhelper.cpp	/^GpuHelper::GpuHelper()$/;"	f	class:GpuHelper
GpuHelper	demos/opengl/gpuhelper.h	/^class GpuHelper$/;"	c
GroupElement	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    struct GroupElement {$/;"	s	class:Eigen::DynamicSGroup
GtolTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        GtolTooSmall = 8,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
GtolTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        GtolTooSmall = 8,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
H	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^MatrixXf H = hessOfA.matrixH();$/;"	v
H0	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^Matrix3d H0 = Matrix3d::Identity() - h(0) * v0 * v0.adjoint();$/;"	v
H1	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^Matrix3d H1 = Matrix3d::Identity() - h(1) * v1 * v1.adjoint();$/;"	v
H2	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^Matrix3d H2 = Matrix3d::Identity() - h(2) * v2 * v2.adjoint();$/;"	v
HCoeffsType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR
HCoeffsType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
HCoeffsType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR
HCoeffsType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
HCoeffsType	Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon263
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon268
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon269
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon270
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon265
HEADER	blas/testing/cblat1.f	/^      SUBROUTINE HEADER$/;"	s
HEADER	blas/testing/dblat1.f	/^      SUBROUTINE HEADER$/;"	s
HEADER	blas/testing/sblat1.f	/^      SUBROUTINE HEADER$/;"	s
HEADER	blas/testing/zblat1.f	/^      SUBROUTINE HEADER$/;"	s
HERE	bench/btl/generic_bench/utils/utilities.h	57;"	d
HERE	bench/btl/generic_bench/utils/utilities.h	74;"	d
HEREWEARE	bench/btl/generic_bench/utils/utilities.h	21;"	d
HNormalizedReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(ConstStartMinusOne,Scalar,quotient) HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase
HNormalizedReturnType	Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Block	Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Factors	Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Size	Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon641
HNormalized_SizeMinusOne	Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon641
HalfLength	Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon487
HalfLength	Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon489
HalfPacket	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::half HalfPacket;$/;"	t	class:Eigen::internal::BlasLinearMapper
HalfPacket	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::half HalfPacket;$/;"	t	class:Eigen::internal::blas_data_mapper
HalfPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef typename unpacket_traits<Packet>::half HalfPacket;$/;"	t	class:Eigen::internal::BaseTensorContractionMapper
HalfPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef typename unpacket_traits<Packet>::half HalfPacket;$/;"	t	class:Eigen::internal::TensorContractionSubMapper
HalfPacketSize	test/vectorization_logic.cpp	/^    HalfPacketSize = internal::unpacket_traits<HalfPacketType>::size$/;"	e	enum:vectorization_logic::__anon194	file:
HalfPacketType	test/vectorization_logic.cpp	/^  typedef typename internal::unpacket_traits<PacketType>::half HalfPacketType;$/;"	t	struct:vectorization_logic	file:
HasACos	Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasASin	Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasATan	Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasAbs	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasAbs	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasAbs	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasAbs	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasAbs	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasAbs	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasAbs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasAbs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasAbs	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasAbs	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasAbs	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasAbs	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasAbs	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasAbs	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasAbs	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasAbs	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAbs  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasAbs	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasAbs	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasAbs2	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasAbs2	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasAbs2	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasAbs2	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasAbs2	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasAbs2	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasAbs2	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasAbs2	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasAbs2	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasAbs2	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasAbs2	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasAbs2	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasAbs2	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasAbs2	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasAdd	Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasAdd	Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasAdd	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasAdd	Eigen/src/Core/arch/AVX/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasAdd	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasAdd	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasAdd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasAdd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasAdd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasAdd	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasAdd	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasAdd	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasAdd	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasAdd	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasAdd	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasAdd	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasAdd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasAdd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasAdd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasAdd  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasAdd	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasAdd	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasArg	Eigen/src/Core/GenericPacketMath.h	/^    HasArg    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasArg	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasArg    = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasArg	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasArg    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasBetaInc	Eigen/src/Core/GenericPacketMath.h	/^    HasBetaInc = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasBetaInc	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBetaInc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasBetaInc	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBetaInc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasBlend	Eigen/src/Core/GenericPacketMath.h	/^    HasBlend  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasBlend	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasBlend = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasBlend	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasBlend = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasBlend	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasBlend  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasBlend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasBlend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasBlend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasBlend	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBlend = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasBlend	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasBlend = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasBlend	Eigen/src/Core/arch/SSE/Complex.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasBlend	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasBlend	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasBlend	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon740
HasBlend	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasBlend  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasBlend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasBlend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasBlend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasBlend = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasBlend	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasBlend  = 0$/;"	e	enum:Eigen::PacketType::__anon156
HasBlend	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasBlend  = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasCeil	Eigen/src/Core/GenericPacketMath.h	/^    HasCeil   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasCeil	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasCeil	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasCeil	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasCeil	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasCeil	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasCeil	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCeil = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasCeil	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasCeil	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCeil = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasConj	Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasConj	Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasConj	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasConj	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasCos	Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasCos	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasCos	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasCos	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasCos	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasCos	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasCos	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasCos	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasCos	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasCos	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasCosh	Eigen/src/Core/GenericPacketMath.h	/^    HasCosh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasDiGamma	Eigen/src/Core/GenericPacketMath.h	/^    HasDiGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasDiGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasDiGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasDirectAccess	Eigen/src/Core/Ref.h	/^      HasDirectAccess = internal::has_direct_access<Derived>::ret,$/;"	e	enum:Eigen::internal::traits::match::__anon474
HasDiv	Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasDiv	Eigen/src/Core/arch/AVX/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasDiv	Eigen/src/Core/arch/AVX/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasDiv	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasDiv	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasDiv	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasDiv = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasDiv	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasDiv = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon666
HasDiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasDiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasDiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasDiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasDiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasDiv	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasDiv	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasDiv	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasDiv	Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasDiv	Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasDiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasDiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasDiv	Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasDiv	Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasDiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasDiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasDiv	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasDiv	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasDiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasDiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasDiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasDiv	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasErf	Eigen/src/Core/GenericPacketMath.h	/^    HasErf = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasErf	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErf = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasErf	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErf = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasErfc	Eigen/src/Core/GenericPacketMath.h	/^    HasErfc = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasErfc	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErfc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasErfc	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasErfc = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasExp	Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasExp	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasExp	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasExp	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasExp = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasExp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasExp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasExp	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasExp	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasExp	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasExp    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasExp	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasExp	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasExp	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasExp	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasExp	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasExp	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasExp	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasExp    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasFloor	Eigen/src/Core/GenericPacketMath.h	/^    HasFloor  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasFloor	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasFloor	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasFloor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasFloor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasFloor	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasFloor	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasFloor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasFloor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasFloor = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasHalfPacket	Eigen/src/Core/GenericPacketMath.h	/^    HasHalfPacket = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon497
HasHalfPacket	Eigen/src/Core/GenericPacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasHalfPacket	Eigen/src/Core/arch/AVX/Complex.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasHalfPacket	Eigen/src/Core/arch/AVX/Complex.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasHalfPacket	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasHalfPacket	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasHalfPacket	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasHalfPacket	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
HasHalfPacket	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasHalfPacket	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasHalfPacket	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasHalfPacket	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasHalfPacket	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasHalfPacket	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasHalfPacket	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasHalfPacket	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasHalfPacket	Eigen/src/Core/arch/NEON/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasHalfPacket	Eigen/src/Core/arch/NEON/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasHalfPacket	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0 \/\/ Packet2i intrinsics not implemented yet$/;"	e	enum:Eigen::internal::packet_traits::__anon709
HasHalfPacket	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0, \/\/ Packet2f intrinsics not implemented yet$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasHalfPacket	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasHalfPacket=0,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasHalfPacket	Eigen/src/Core/arch/SSE/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasHalfPacket	Eigen/src/Core/arch/SSE/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasHalfPacket	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasHalfPacket	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasHalfPacket	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasHalfPacket	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasHalfPacket	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasHalfPacket	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasHalfPacket	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasHalfPacket = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasIGamma	Eigen/src/Core/GenericPacketMath.h	/^    HasIGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasIGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasIGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasIGammac	Eigen/src/Core/GenericPacketMath.h	/^    HasIGammac = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasIGammac	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGammac = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasIGammac	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasIGammac = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasLGamma	Eigen/src/Core/GenericPacketMath.h	/^    HasLGamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasLGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasLGamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLGamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasLog	Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasLog	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasLog	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasLog = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasLog	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasLog	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasLog	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasLog	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasLog	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasLog    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasLog	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasLog	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasLog	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasLog	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasLog	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasLog	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasLog    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasLog10	Eigen/src/Core/GenericPacketMath.h	/^    HasLog10  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasLog10	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasLog10  = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasLog1p	Eigen/src/Core/GenericPacketMath.h	/^    HasLog1p  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasLog1p	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasLog1p  = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasLog1p	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasLog1p  = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasMax	Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasMax	Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasMax	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasMax	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasMax	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasMax	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasMax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasMax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasMax	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasMax	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasMax	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasMax	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasMax	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasMax	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasMax	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasMax	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMax  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasMax	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasMax	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasMin	Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasMin	Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasMin	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasMin	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasMin	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasMin	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasMin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasMin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasMin	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasMin	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasMin	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasMin	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasMin	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasMin	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasMin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasMin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMin  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasMin	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasMin	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasMul	Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasMul	Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasMul	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasMul	Eigen/src/Core/arch/AVX/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasMul	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasMul	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasMul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasMul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasMul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasMul	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasMul	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasMul	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasMul	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasMul	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasMul	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasMul	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasMul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasMul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasMul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasMul  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasMul	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasMul	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasNegate	Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasNegate	Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasNegate	Eigen/src/Core/arch/AVX/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasNegate	Eigen/src/Core/arch/AVX/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasNegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasNegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasNegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasNegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasNegate	Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasNegate	Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasNegate	Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasNegate	Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasNegate	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasNegate	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasNegate	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasNegate	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasNegate	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasNegate	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasNoInnerStride	Eigen/src/Core/CoreEvaluators.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::evaluator::__anon759
HasNoOuterStride	Eigen/src/Core/CoreEvaluators.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::evaluator::__anon759
HasNoStride	Eigen/src/Core/CoreEvaluators.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::evaluator::__anon759
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool HasOptimizedImplementation = !Op::IsStateful;$/;"	m	struct:Eigen::internal::FullReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool HasOptimizedImplementation = false;$/;"	m	struct:Eigen::internal::FullReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool HasOptimizedImplementation = false;$/;"	m	struct:Eigen::internal::InnerReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool HasOptimizedImplementation = false;$/;"	m	struct:Eigen::internal::OuterReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static const bool HasOptimizedImplementation = !Op::IsStateful &&$/;"	m	struct:Eigen::internal::FullReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static const bool HasOptimizedImplementation = !Op::IsStateful &&$/;"	m	struct:Eigen::internal::InnerReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static const bool HasOptimizedImplementation = !Op::IsStateful &&$/;"	m	struct:Eigen::internal::OuterReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  static const bool HasOptimizedImplementation = false;$/;"	m	struct:Eigen::internal::FullReducer
HasOptimizedImplementation	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  static const bool HasOptimizedImplementation = false;$/;"	m	struct:Eigen::internal::InnerReducer
HasPolygamma	Eigen/src/Core/GenericPacketMath.h	/^    HasPolygamma = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasPolygamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasPolygamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasPolygamma	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasPolygamma = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasPow	Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasPow	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasPow    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasRound	Eigen/src/Core/GenericPacketMath.h	/^    HasRound  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasRound	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasRound	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasRound	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasRound	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasRound	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasRound	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasRound	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasRound	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRound = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasRsqrt	Eigen/src/Core/GenericPacketMath.h	/^    HasRsqrt  = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasRsqrt	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasRsqrt	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasRsqrt	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasRsqrt	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasRsqrt = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
HasRsqrt	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasRsqrt	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasRsqrt	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasRsqrt	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasRsqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasRsqrt  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasRsqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasRsqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasRsqrt	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasRsqrt	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasRsqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasRsqrt	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasRsqrt  = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasSameStorageOrderAsArgType	Eigen/src/Core/CoreEvaluators.h	/^    HasSameStorageOrderAsArgType = (IsRowMajor == ArgTypeIsRowMajor),$/;"	e	enum:Eigen::internal::evaluator::__anon761
HasSameStorageOrderAsXprType	Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon464
HasSetLinear	Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasSetLinear	Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSetLinear	Eigen/src/Core/arch/AVX/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasSetLinear	Eigen/src/Core/arch/AVX/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasSetLinear	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasSetLinear	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasSetLinear	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasSetLinear	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasSetLinear	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasSetLinear	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasSetLinear	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasSetLinear	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasSetLinear	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasSetLinear = 0,$/;"	e	enum:Eigen::PacketType::__anon155
HasSetLinear	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasSetLinear = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasSign	Eigen/src/Core/GenericPacketMath.h	/^    HasSign   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSin	Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSin	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasSin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasSin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasSin	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasSin	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasSin	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasSin	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasSin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasSin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasSinh	Eigen/src/Core/GenericPacketMath.h	/^    HasSinh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSqrt	Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSqrt	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasSqrt	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
HasSqrt	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
HasSqrt	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
HasSqrt	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasSqrt	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasSqrt	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasSqrt	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HasSqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    HasSqrt   = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
HasSqrt	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon708
HasSqrt	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon712
HasSqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasSqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
HasSqrt	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasSqrt	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSqrt = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasSqrt	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasSqrt   = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasSub	Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon498
HasSub	Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasSub	Eigen/src/Core/arch/AVX/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
HasSub	Eigen/src/Core/arch/AVX/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
HasSub	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
HasSub	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
HasSub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
HasSub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
HasSub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
HasSub	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
HasSub	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
HasSub	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
HasSub	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
HasSub	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
HasSub	Eigen/src/Core/arch/ZVector/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
HasSub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
HasSub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
HasSub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    HasSub  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
HasSub	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::PacketType::__anon156
HasSub	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::PacketType::__anon155
HasTan	Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasTanh	Eigen/src/Core/GenericPacketMath.h	/^    HasTanh   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasTanh	Eigen/src/Core/arch/AVX/PacketMath.h	/^    HasTanh  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
HasTanh	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasTanh  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
HasUnitDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon627
HasUnitDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon628
HasUnitDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::TriangularViewImpl::__anon824
HasUnitDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^         HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::internal::unary_evaluator::__anon825
HasUnitDiag	blas/PackedTriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon198
HasUnitDiag	blas/PackedTriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon199
HasUsableDirectAccess	Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon609
HasZeroDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon627
HasZeroDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon628
HasZeroDiag	blas/PackedTriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon198
HasZeroDiag	blas/PackedTriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon199
HasZeta	Eigen/src/Core/GenericPacketMath.h	/^    HasZeta = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon496
HasZeta	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasZeta = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
HasZeta	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    HasZeta = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
HashMapType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename MapTraits<ScalarWrapper>::Type HashMapType;$/;"	t	class:Eigen::RandomSetter
Head	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  typedef T Head;$/;"	t	struct:Eigen::internal::IndexTuple
HeadType	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef T HeadType;$/;"	t	struct:Eigen::internal::type_list
HereditaryBits	Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
Hermiticity	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct Hermiticity$/;"	s	namespace:Eigen
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    explicit HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    explicit HessenbergDecomposition(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
HessenbergDecompositionMatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal
Homogeneous	Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC explicit inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous
Homogeneous	Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen
HomogeneousDimension	Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon246
HomogeneousReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase
HomogeneousReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef Homogeneous<ExpressionType,Direction> HomogeneousReturnType;$/;"	t	class:Eigen::VectorwiseOp
HomogeneousReturnTypeDirection	Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1&&RowsAtCompileTime==1 ? ((internal::traits<Derived>::Flags&RowMajorBit)==RowMajorBit ? Horizontal : Vertical)$/;"	e	enum:Eigen::MatrixBase::__anon469
HomogeneousShape	Eigen/src/Core/util/Constants.h	/^struct HomogeneousShape       { static std::string debugName() { return "HomogeneousShape"; } };$/;"	s	namespace:Eigen
Horizontal	Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
Host	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    struct Host$/;"	s	struct:Eigen::internal::is_base_of
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    explicit HouseholderQR(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    explicit HouseholderQR(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
HouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen
HouseholderSequenceShape	Eigen/src/Householder/HouseholderSequence.h	/^struct HouseholderSequenceShape {};$/;"	s	namespace:Eigen::internal
HouseholderSequenceType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition
HouseholderSequenceType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization
HouseholderSequenceType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
HouseholderSequenceType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR
HouseholderSequenceType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      HouseholderSequenceType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
HouseholderSequenceType	Eigen/src/QR/HouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR
HouseholderUSequenceType	Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HouseholderVSequenceType	Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HugeCost	Eigen/src/Core/util/Constants.h	/^const int HugeCost = 10000;$/;"	m	namespace:Eigen
HybridNonLinearSolver	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    HybridNonLinearSolver(FunctorType &_functor)$/;"	f	class:Eigen::HybridNonLinearSolver
HybridNonLinearSolver	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^class HybridNonLinearSolver$/;"	c	namespace:Eigen
HybridNonLinearSolverSpace	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^namespace HybridNonLinearSolverSpace { $/;"	n	namespace:Eigen
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane(const VectorType& n, const Scalar& d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
HypotNormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_hypotNorm,RealScalar>::Type HypotNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
I	blas/testing/cblat2.f	/^      IN/;"	v	program:CBLAT2
I	blas/testing/cblat3.f	/^      IN/;"	v	program:CBLAT3
I	blas/testing/dblat2.f	/^      IN/;"	v	program:DBLAT2
I	blas/testing/dblat3.f	/^      IN/;"	v	program:DBLAT3
I	blas/testing/sblat2.f	/^      IN/;"	v	program:SBLAT2
I	blas/testing/sblat3.f	/^      IN/;"	v	program:SBLAT3
I	blas/testing/zblat2.f	/^      IN/;"	v	program:ZBLAT2
I	blas/testing/zblat3.f	/^      IN/;"	v	program:ZBLAT3
I	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  static constexpr size_t I = N;$/;"	m	struct:Eigen::TensorSycl::internal::PlaceHolder
I	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      I = AlphaAxisAbs - 1,$/;"	e	enum:Eigen::EulerSystem::__anon49
IC	blas/testing/cblat1.f	/^      INTEGER          IC$/;"	v	program:CBLAT1
IC	blas/testing/dblat1.f	/^      INTEGER          IC$/;"	v	program:DBLAT1
IC	blas/testing/sblat1.f	/^      INTEGER          IC$/;"	v	program:SBLAT1
IC	blas/testing/zblat1.f	/^      INTEGER          IC$/;"	v	program:ZBLAT1
ICASE	blas/testing/cblat1.f	/^      INTEGER          ICASE,/;"	v	program:CBLAT1
ICASE	blas/testing/dblat1.f	/^      INTEGER          ICASE,/;"	v	program:DBLAT1
ICASE	blas/testing/sblat1.f	/^      INTEGER          ICASE,/;"	v	program:SBLAT1
ICASE	blas/testing/zblat1.f	/^      INTEGER          ICASE,/;"	v	program:ZBLAT1
IDIM	blas/testing/cblat2.f	/^      INTEGER            IDIM(/;"	v	program:CBLAT2
IDIM	blas/testing/cblat3.f	/^      INTEGER            IDIM(/;"	v	program:CBLAT3
IDIM	blas/testing/dblat2.f	/^      INTEGER            IDIM(/;"	v	program:DBLAT2
IDIM	blas/testing/dblat3.f	/^      INTEGER            IDIM(/;"	v	program:DBLAT3
IDIM	blas/testing/sblat2.f	/^      INTEGER            IDIM(/;"	v	program:SBLAT2
IDIM	blas/testing/sblat3.f	/^      INTEGER            IDIM(/;"	v	program:SBLAT3
IDIM	blas/testing/zblat2.f	/^      INTEGER            IDIM(/;"	v	program:ZBLAT2
IDIM	blas/testing/zblat3.f	/^      INTEGER            IDIM(/;"	v	program:ZBLAT3
ILACLC	lapack/ilaclc.f	/^      INTEGER FUNCTION ILACLC(/;"	f
ILACLR	lapack/ilaclr.f	/^      INTEGER FUNCTION ILACLR(/;"	f
ILADLC	lapack/iladlc.f	/^      INTEGER FUNCTION ILADLC(/;"	f
ILADLR	lapack/iladlr.f	/^      INTEGER FUNCTION ILADLR(/;"	f
ILASLC	lapack/ilaslc.f	/^      INTEGER FUNCTION ILASLC(/;"	f
ILASLR	lapack/ilaslr.f	/^      INTEGER FUNCTION ILASLR(/;"	f
ILAZLC	lapack/ilazlc.f	/^      INTEGER FUNCTION ILAZLC(/;"	f
ILAZLR	lapack/ilazlr.f	/^      INTEGER FUNCTION ILAZLR(/;"	f
IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INC	blas/testing/cblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC(/;"	v	program:CBLAT2
INC	blas/testing/dblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC(/;"	v	program:DBLAT2
INC	blas/testing/sblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC(/;"	v	program:SBLAT2
INC	blas/testing/zblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC(/;"	v	program:ZBLAT2
INCMAX	blas/testing/cblat2.f	/^      INTEGER            NMAX, INCMAX$/;"	v	program:CBLAT2
INCMAX	blas/testing/dblat2.f	/^      INTEGER            NMAX, INCMAX$/;"	v	program:DBLAT2
INCMAX	blas/testing/sblat2.f	/^      INTEGER            NMAX, INCMAX$/;"	v	program:SBLAT2
INCMAX	blas/testing/zblat2.f	/^      INTEGER            NMAX, INCMAX$/;"	v	program:ZBLAT2
INCX	blas/testing/cblat1.f	/^      INTEGER          ICASE, INCX,/;"	v	program:CBLAT1
INCX	blas/testing/dblat1.f	/^      INTEGER          ICASE, INCX,/;"	v	program:DBLAT1
INCX	blas/testing/sblat1.f	/^      INTEGER          ICASE, INCX,/;"	v	program:SBLAT1
INCX	blas/testing/zblat1.f	/^      INTEGER          ICASE, INCX,/;"	v	program:ZBLAT1
INCY	blas/testing/cblat1.f	/^      INTEGER          ICASE, INCX, INCY,/;"	v	program:CBLAT1
INCY	blas/testing/dblat1.f	/^      INTEGER          ICASE, INCX, INCY,/;"	v	program:DBLAT1
INCY	blas/testing/sblat1.f	/^      INTEGER          ICASE, INCX, INCY,/;"	v	program:SBLAT1
INCY	blas/testing/zblat1.f	/^      INTEGER          ICASE, INCX, INCY,/;"	v	program:ZBLAT1
INFOC	blas/testing/cblat2.f	1182;"	c	subroutine:CCHK3
INFOC	blas/testing/cblat2.f	1544;"	c	subroutine:CCHK4
INFOC	blas/testing/cblat2.f	161;"	c	program:CBLAT2
INFOC	blas/testing/cblat2.f	1822;"	c	subroutine:CCHK5
INFOC	blas/testing/cblat2.f	2107;"	c	subroutine:CCHK6
INFOC	blas/testing/cblat2.f	2402;"	c	subroutine:CCHKE
INFOC	blas/testing/cblat2.f	3251;"	c	subroutine:XERBLA
INFOC	blas/testing/cblat2.f	492;"	c	subroutine:CCHK1
INFOC	blas/testing/cblat2.f	836;"	c	subroutine:CCHK2
INFOC	blas/testing/cblat3.f	1024;"	c	subroutine:CCHK3
INFOC	blas/testing/cblat3.f	1333;"	c	subroutine:CCHK4
INFOC	blas/testing/cblat3.f	140;"	c	program:CBLAT3
INFOC	blas/testing/cblat3.f	1665;"	c	subroutine:CCHK5
INFOC	blas/testing/cblat3.f	2020;"	c	subroutine:CCHKE
INFOC	blas/testing/cblat3.f	3464;"	c	subroutine:XERBLA
INFOC	blas/testing/cblat3.f	459;"	c	subroutine:CCHK1
INFOC	blas/testing/cblat3.f	744;"	c	subroutine:CCHK2
INFOC	blas/testing/dblat2.f	1162;"	c	subroutine:DCHK3
INFOC	blas/testing/dblat2.f	1519;"	c	subroutine:DCHK4
INFOC	blas/testing/dblat2.f	157;"	c	program:DBLAT2
INFOC	blas/testing/dblat2.f	1781;"	c	subroutine:DCHK5
INFOC	blas/testing/dblat2.f	2060;"	c	subroutine:DCHK6
INFOC	blas/testing/dblat2.f	2352;"	c	subroutine:DCHKE
INFOC	blas/testing/dblat2.f	3148;"	c	subroutine:XERBLA
INFOC	blas/testing/dblat2.f	482;"	c	subroutine:DCHK1
INFOC	blas/testing/dblat2.f	822;"	c	subroutine:DCHK2
INFOC	blas/testing/dblat3.f	1302;"	c	subroutine:DCHK4
INFOC	blas/testing/dblat3.f	134;"	c	program:DBLAT3
INFOC	blas/testing/dblat3.f	1577;"	c	subroutine:DCHK5
INFOC	blas/testing/dblat3.f	1874;"	c	subroutine:DCHKE
INFOC	blas/testing/dblat3.f	2845;"	c	subroutine:XERBLA
INFOC	blas/testing/dblat3.f	445;"	c	subroutine:DCHK1
INFOC	blas/testing/dblat3.f	726;"	c	subroutine:DCHK2
INFOC	blas/testing/dblat3.f	997;"	c	subroutine:DCHK3
INFOC	blas/testing/sblat2.f	1162;"	c	subroutine:SCHK3
INFOC	blas/testing/sblat2.f	1519;"	c	subroutine:SCHK4
INFOC	blas/testing/sblat2.f	157;"	c	program:SBLAT2
INFOC	blas/testing/sblat2.f	1781;"	c	subroutine:SCHK5
INFOC	blas/testing/sblat2.f	2060;"	c	subroutine:SCHK6
INFOC	blas/testing/sblat2.f	2352;"	c	subroutine:SCHKE
INFOC	blas/testing/sblat2.f	3148;"	c	subroutine:XERBLA
INFOC	blas/testing/sblat2.f	482;"	c	subroutine:SCHK1
INFOC	blas/testing/sblat2.f	822;"	c	subroutine:SCHK2
INFOC	blas/testing/sblat3.f	1302;"	c	subroutine:SCHK4
INFOC	blas/testing/sblat3.f	134;"	c	program:SBLAT3
INFOC	blas/testing/sblat3.f	1577;"	c	subroutine:SCHK5
INFOC	blas/testing/sblat3.f	1874;"	c	subroutine:SCHKE
INFOC	blas/testing/sblat3.f	2845;"	c	subroutine:XERBLA
INFOC	blas/testing/sblat3.f	445;"	c	subroutine:SCHK1
INFOC	blas/testing/sblat3.f	726;"	c	subroutine:SCHK2
INFOC	blas/testing/sblat3.f	997;"	c	subroutine:SCHK3
INFOC	blas/testing/zblat2.f	1186;"	c	subroutine:ZCHK3
INFOC	blas/testing/zblat2.f	1549;"	c	subroutine:ZCHK4
INFOC	blas/testing/zblat2.f	162;"	c	program:ZBLAT2
INFOC	blas/testing/zblat2.f	1828;"	c	subroutine:ZCHK5
INFOC	blas/testing/zblat2.f	2114;"	c	subroutine:ZCHK6
INFOC	blas/testing/zblat2.f	2409;"	c	subroutine:ZCHKE
INFOC	blas/testing/zblat2.f	3259;"	c	subroutine:XERBLA
INFOC	blas/testing/zblat2.f	494;"	c	subroutine:ZCHK1
INFOC	blas/testing/zblat2.f	839;"	c	subroutine:ZCHK2
INFOC	blas/testing/zblat3.f	1027;"	c	subroutine:ZCHK3
INFOC	blas/testing/zblat3.f	1336;"	c	subroutine:ZCHK4
INFOC	blas/testing/zblat3.f	142;"	c	program:ZBLAT3
INFOC	blas/testing/zblat3.f	1669;"	c	subroutine:ZCHK5
INFOC	blas/testing/zblat3.f	2027;"	c	subroutine:ZCHKE
INFOC	blas/testing/zblat3.f	3474;"	c	subroutine:XERBLA
INFOC	blas/testing/zblat3.f	461;"	c	subroutine:ZCHK1
INFOC	blas/testing/zblat3.f	746;"	c	subroutine:ZCHK2
INFOS	bench/btl/generic_bench/utils/utilities.h	22;"	d
INFOS_COMPILATION	bench/btl/generic_bench/utils/utilities.h	42;"	d
INFOT	blas/testing/cblat2.f	/^      INTEGER            INFOT,/;"	v	program:CBLAT2
INFOT	blas/testing/cblat3.f	/^      INTEGER            INFOT,/;"	v	program:CBLAT3
INFOT	blas/testing/dblat2.f	/^      INTEGER            INFOT,/;"	v	program:DBLAT2
INFOT	blas/testing/dblat3.f	/^      INTEGER            INFOT,/;"	v	program:DBLAT3
INFOT	blas/testing/sblat2.f	/^      INTEGER            INFOT,/;"	v	program:SBLAT2
INFOT	blas/testing/sblat3.f	/^      INTEGER            INFOT,/;"	v	program:SBLAT3
INFOT	blas/testing/zblat2.f	/^      INTEGER            INFOT,/;"	v	program:ZBLAT2
INFOT	blas/testing/zblat3.f	/^      INTEGER            INFOT,/;"	v	program:ZBLAT3
INIT_FUNCTION_HH	bench/btl/generic_bench/init/init_function.hh	21;"	d
INIT_MATRIX_HH	bench/btl/generic_bench/init/init_matrix.hh	21;"	d
INIT_VECTOR_HH	bench/btl/generic_bench/init/init_vector.hh	21;"	d
INTERRUPTION	bench/btl/generic_bench/utils/utilities.h	60;"	d
INTERRUPTION	bench/btl/generic_bench/utils/utilities.h	77;"	d
INVALID	blas/common.h	37;"	d
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INVALID_MATRIX_PRODUCT	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INVALID_MATRIX_TEMPLATE_PARAMETERS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
IOFormat	Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat
IOFormat	Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
ISCOMPLEX	blas/complex_double.cpp	14;"	d	file:
ISCOMPLEX	blas/complex_single.cpp	14;"	d	file:
ISCOMPLEX	blas/double.cpp	14;"	d	file:
ISCOMPLEX	blas/single.cpp	13;"	d	file:
ISCOMPLEX	lapack/complex_double.cpp	14;"	d	file:
ISCOMPLEX	lapack/complex_single.cpp	14;"	d	file:
ISCOMPLEX	lapack/double.cpp	13;"	d	file:
ISCOMPLEX	lapack/single.cpp	13;"	d	file:
ISNUM	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM,/;"	v	program:CBLAT2
ISNUM	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM,/;"	v	program:CBLAT3
ISNUM	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM,/;"	v	program:DBLAT2
ISNUM	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM,/;"	v	program:DBLAT3
ISNUM	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM,/;"	v	program:SBLAT2
ISNUM	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM,/;"	v	program:SBLAT3
ISNUM	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM,/;"	v	program:ZBLAT2
ISNUM	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM,/;"	v	program:ZBLAT3
ITERATE	demos/mandelbrot/mandelbrot.cpp	74;"	d	file:
ITEST1	blas/testing/cblat1.f	/^      SUBROUTINE ITEST1(/;"	s
ITEST1	blas/testing/dblat1.f	/^      SUBROUTINE ITEST1(/;"	s
ITEST1	blas/testing/sblat1.f	/^      SUBROUTINE ITEST1(/;"	s
ITEST1	blas/testing/zblat1.f	/^      SUBROUTINE ITEST1(/;"	s
IcoSphere	demos/opengl/icosphere.cpp	/^IcoSphere::IcoSphere(unsigned int levels)$/;"	f	class:IcoSphere
IcoSphere	demos/opengl/icosphere.h	/^class IcoSphere$/;"	c
Identity	Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase
Identity	Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
Identity	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC static inline const AngleAxis Identity() { return AngleAxis(Scalar(0), Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis
Identity	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(Scalar(1), Scalar(0), Scalar(0), Scalar(0)); }$/;"	f	class:Eigen::QuaternionBase
Identity	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D
Identity	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static const Transform Identity()$/;"	f	class:Eigen::Transform
Identity	Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation
Identity	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  static constexpr int Identity = 0;$/;"	m	struct:Eigen::internal::sum_op
Identity	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  static constexpr int Identity = 1;$/;"	m	struct:Eigen::internal::product_op
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,PlainObject> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase
IfNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename IfXprType::Nested IfNested;$/;"	t	struct:Eigen::internal::traits
ImagPart	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  ImagPart = 1,$/;"	e	enum:Eigen::FFTResultType
ImagReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
Impl	Eigen/src/Core/Block.h	/^    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;$/;"	t	class:Eigen::Block
Impl	Eigen/src/Core/Block.h	/^    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;$/;"	t	class:Eigen::BlockImpl
Impl	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef TensorEvaluator<ArgType, Device> Impl;$/;"	t	struct:Eigen::TensorEvaluator
Impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  EIGEN_DEVICE_FUNC static Scalar Impl(Scalar a, Scalar x) {$/;"	f	struct:Eigen::internal::igamma_impl
Impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  EIGEN_DEVICE_FUNC static Scalar Impl(Scalar a, Scalar x) {$/;"	f	struct:Eigen::internal::igammac_impl
ImproperInputParameters	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        ImproperInputParameters = 0,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
ImproperInputParameters	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        ImproperInputParameters = 0,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
ImproperInputParameters	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        ImproperInputParameters = 0,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
IncompleteCholesky	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    IncompleteCholesky() : m_initialShift(1e-3),m_factorizationIsOk(false) {}$/;"	f	class:Eigen::IncompleteCholesky
IncompleteCholesky	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    IncompleteCholesky(const MatrixType& matrix) : m_initialShift(1e-3),m_factorizationIsOk(false)$/;"	f	class:Eigen::IncompleteCholesky
IncompleteCholesky	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^class IncompleteCholesky : public SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> >$/;"	c	namespace:Eigen
IncompleteLU	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU() {}$/;"	f	class:Eigen::IncompleteLU
IncompleteLU	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteLU
IncompleteLU	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^class IncompleteLU : public SparseSolverBase<IncompleteLU<_Scalar> >$/;"	c	namespace:Eigen
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    explicit IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : public SparseSolverBase<IncompleteLUT<_Scalar, _StorageIndex> >$/;"	c	namespace:Eigen
Indefinite	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Index	Eigen/src/Cholesky/LDLT.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::LDLT
Index	Eigen/src/Cholesky/LLT.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::LLT
Index	Eigen/src/Core/EigenBase.h	/^  typedef Eigen::Index Index;$/;"	t	struct:Eigen::EigenBase
Index	Eigen/src/Core/Stride.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Stride
Index	Eigen/src/Core/Transpositions.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::TranspositionsBase
Index	Eigen/src/Core/VectorwiseOp.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::VectorwiseOp
Index	Eigen/src/Core/util/Meta.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE Index;$/;"	t	namespace:Eigen
Index	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ComplexEigenSolver
Index	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ComplexSchur
Index	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::EigenSolver
Index	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::GeneralizedEigenSolver
Index	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::HessenbergDecomposition
Index	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::RealQZ
Index	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::RealSchur
Index	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::SelfAdjointEigenSolver
Index	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Tridiagonalization
Index	Eigen/src/Geometry/AlignedBox.h	/^  typedef Eigen::Index                              Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::AlignedBox
Index	Eigen/src/Geometry/Hyperplane.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Hyperplane
Index	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::ParametrizedLine
Index	Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::Transform
Index	Eigen/src/SVD/SVDBase.h	/^  typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::SVDBase
Index	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Eigen::Index Index; \/\/\/< \\deprecated since Eigen 3.3$/;"	t	class:Eigen::internal::UpperBidiagonalization
Index	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef typename Eigen::Tensor<real,2>::Index Index;$/;"	t	class:tensor_interface
Index	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef typename internal::traits<Self>::Index Index;$/;"	t	class:Eigen::Tensor
Index	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::Index Index;$/;"	t	class:Eigen::TensorIndexTupleOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::Index Index;$/;"	t	class:Eigen::TensorTupleReducerOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^                                      typename traits<RhsXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename Eigen::internal::traits<TensorAssignOp>::Index Index;$/;"	t	class:Eigen::TensorAssignOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef typename DerivedTraits::Index Index;$/;"	t	class:Eigen::TensorBase
Index	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::Index Index;$/;"	t	class:Eigen::TensorBroadcastingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename Eigen::internal::traits<TensorChippingOp>::Index Index;$/;"	t	class:Eigen::TensorChippingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^                                      typename traits<RhsXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typedef typename internal::traits<TensorConcatenationOp>::Index Index;$/;"	t	class:Eigen::TensorConcatenationOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^                                      typename traits<RhsXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename Eigen::internal::traits<TensorContractionOp>::Index Index;$/;"	t	class:Eigen::TensorContractionOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef typename internal::traits<TensorConversionOp>::Index Index;$/;"	t	class:Eigen::TensorConversionOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename traits<XprType>::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^                                      typename traits<KernelXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename Eigen::internal::traits<TensorConvolutionOp>::Index Index;$/;"	t	class:Eigen::TensorConvolutionOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^                                      typename traits<RhsXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<ArgType>::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomBinaryOp>::Index Index;$/;"	t	class:Eigen::TensorCustomBinaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomUnaryOp>::Index Index;$/;"	t	class:Eigen::TensorCustomUnaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<XprType>::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename Eigen::internal::traits<TensorEvalToOp>::Index Index;$/;"	t	class:Eigen::TensorEvalToOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  typedef typename Expression::Index Index;$/;"	t	class:Eigen::internal::TensorExecutor
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^                                      typename traits<ThenXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^      typename traits<RhsXprType>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::Index Index;$/;"	t	class:Eigen::TensorCwiseBinaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::Index Index;$/;"	t	class:Eigen::TensorCwiseNullaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::Index Index;$/;"	t	class:Eigen::TensorCwiseTernaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::Index Index;$/;"	t	class:Eigen::TensorCwiseUnaryOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorSelectOp>::Index Index;$/;"	t	class:Eigen::TensorSelectOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename traits<Arg1XprType>::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::internal::traits<TensorFFTOp>::Index Index;$/;"	t	class:Eigen::TensorFFTOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef typename internal::traits<Self>::Index Index;$/;"	t	class:Eigen::TensorFixedSize
Index	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::Index Index;$/;"	t	class:Eigen::TensorForcedEvalOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename traits<XprType>::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename Eigen::internal::traits<TensorGeneratorOp>::Index Index;$/;"	t	class:Eigen::TensorGeneratorOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename Eigen::internal::traits<TensorImagePatchOp>::Index Index;$/;"	t	class:Eigen::TensorImagePatchOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename Eigen::internal::traits<TensorInflationOp>::Index Index;$/;"	t	class:Eigen::TensorInflationOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::Index Index;$/;"	t	class:Eigen::TensorLayoutSwapOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename internal::traits<PlainObjectType>::Index Index;$/;"	t	class:Eigen::TensorMap
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorReshapingOp>::Index Index;$/;"	t	class:Eigen::TensorReshapingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorSlicingOp>::Index Index;$/;"	t	class:Eigen::TensorSlicingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::traits<TensorStridingSlicingOp>::Index Index;$/;"	t	class:Eigen::TensorStridingSlicingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename Eigen::internal::traits<TensorPaddingOp>::Index Index;$/;"	t	class:Eigen::TensorPaddingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename Eigen::internal::traits<TensorPatchOp>::Index Index;$/;"	t	class:Eigen::TensorPatchOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename Eigen::internal::traits<TensorReductionOp>::Index Index;$/;"	t	class:Eigen::TensorReductionOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename internal::traits<PlainObjectType>::Index Index;$/;"	t	class:Eigen::TensorRef
Index	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename Eigen::internal::traits<TensorReverseOp>::Index Index;$/;"	t	class:Eigen::TensorReverseOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename Eigen::internal::traits<TensorScanOp>::Index Index;$/;"	t	class:Eigen::TensorScanOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename Eigen::internal::traits<TensorShufflingOp>::Index Index;$/;"	t	class:Eigen::TensorShufflingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    typedef IndexType Index;$/;"	t	class:Eigen::TensorStorage
Index	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename Eigen::internal::traits<TensorStridingOp>::Index Index;$/;"	t	class:Eigen::TensorStridingOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef IndexType_ Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef typename BaseTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::Index Index;$/;"	t	class:Eigen::TensorVolumePatchOp
Index	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprTraits::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::TensorEvaluator
Index	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    typedef typename Tensor_::Index Index;$/;"	t	class:Eigen::internal::tensor_symmetry_value_setter
Index	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  typedef typename Tensor_::Index Index;$/;"	t	struct:Eigen::internal::tensor_symmetry_assign_value
Index	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  typedef typename Tensor_::Index Index;$/;"	t	struct:Eigen::internal::tensor_symmetry_calculate_flags
Index	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename JacobianType::Index Index;$/;"	t	class:Eigen::AutoDiffJacobian
Index	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef typename JacobianType::Index Index;$/;"	t	class:Eigen::AutoDiffVector
Index	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef int Index;$/;"	t	class:Eigen::KdBVH
Index	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
Index	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::IncompleteLU
Index	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterScaling
Index	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::SparseFunctor
Index	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typedef typename Derived::Index Index;$/;"	t	struct:Eigen::MatrixExponentialReturnValue
Index	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixFunctionReturnValue
Index	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixLogarithmReturnValue
Index	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixComplexPowerReturnValue
Index	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixPowerReturnValue
Index	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixPower
Index	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixPowerAtomic
Index	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixPowerParenthesesReturnValue
Index	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::HybridNonLinearSolver
Index	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::LevenbergMarquardt
Index	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::internal::companion
Index	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::PolynomialSolverBase
Index	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SkylineInplaceLU
Index	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::index<StorageKind>::type Index;$/;"	t	class:Eigen::SkylineMatrixBase
Index	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    typedef SparseIndex Index;$/;"	t	class:Eigen::SkylineStorage
Index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename BlockSparseMatrixT::Index Index;$/;"	t	class:Eigen::BlockSparseMatrixView
Index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename BlockSparseMatrixT::Index Index;$/;"	t	class:Eigen::BlockVectorReturn
Index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename BlockSparseMatrixT::Index Index;$/;"	t	class:Eigen::BlockVectorView
Index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef typename BlockSparseMatrixT::Index Index;$/;"	t	struct:Eigen::internal::traits
IndexBased	Eigen/src/Core/util/Constants.h	/^struct IndexBased {};$/;"	s	namespace:Eigen::internal
IndexList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexList() : internal::IndexTuple<FirstType, OtherTypes...>() { }$/;"	f	struct:Eigen::IndexList
IndexList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexList(FirstType& first, OtherTypes... other) : internal::IndexTuple<FirstType, OtherTypes...>(first, other...) { }$/;"	f	struct:Eigen::IndexList
IndexList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexList(const internal::IndexTuple<FirstType, OtherTypes...>& other) : internal::IndexTuple<FirstType, OtherTypes...>(other) { }$/;"	f	struct:Eigen::IndexList
IndexList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct IndexList : internal::IndexTuple<FirstType, OtherTypes...> {$/;"	s	namespace:Eigen
IndexList	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct IndexList {};$/;"	s	namespace:utility::tuple
IndexMapper	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  IndexMapper(const InputDims& input_dims, const array<Index, NumKernelDims>& kernel_dims,$/;"	f	class:Eigen::internal::IndexMapper
IndexMapper	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^class IndexMapper {$/;"	c	namespace:Eigen::internal
IndexOfColMajor	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DenseIndex IndexOfColMajor(const array<DenseIndex, NumDims>& indices) const {$/;"	f	struct:Eigen::DSizes
IndexOfColMajor	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  size_t IndexOfColMajor(const array<DenseIndex, Base::count>& indices) const {$/;"	f	struct:Eigen::Sizes
IndexOfRowMajor	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DenseIndex IndexOfRowMajor(const array<DenseIndex, NumDims>& indices) const {$/;"	f	struct:Eigen::DSizes
IndexOfRowMajor	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  size_t IndexOfRowMajor(const array<DenseIndex, Base::count>& indices) const {$/;"	f	struct:Eigen::Sizes
IndexPair	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  EIGEN_CONSTEXPR EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE IndexPair() : first(0), second(0) {}$/;"	f	struct:Eigen::IndexPair
IndexPair	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  EIGEN_CONSTEXPR EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE IndexPair(Idx f, Idx s) : first(f), second(s) {}$/;"	f	struct:Eigen::IndexPair
IndexPair	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^template <typename Idx> struct IndexPair {$/;"	s	namespace:Eigen
IndexPairList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC  constexpr IndexPairList() : internal::IndexTuple<FirstType, OtherTypes...>() { }$/;"	f	struct:Eigen::IndexPairList
IndexPairList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC  constexpr IndexPairList(const internal::IndexTuple<FirstType, OtherTypes...>& other) : internal::IndexTuple<FirstType, OtherTypes...>(other) { }$/;"	f	struct:Eigen::IndexPairList
IndexPairList	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct IndexPairList : internal::IndexTuple<FirstType, OtherTypes...> {$/;"	s	namespace:Eigen
IndexPointer	Eigen/src/SparseCore/SparseMap.h	/^                         StorageIndex *, const StorageIndex *>::type IndexPointer;$/;"	t	class:Eigen::SparseMapBase
IndexRange	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct IndexRange: RangeBuilder<MIN, MAX>::type {};$/;"	s	namespace:utility::tuple
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexTuple() : head() { }$/;"	f	struct:Eigen::internal::IndexTuple
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexTuple() : head(), others() { }$/;"	f	struct:Eigen::internal::IndexTuple
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexTuple(const T& v) : head(v) { }$/;"	f	struct:Eigen::internal::IndexTuple
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr IndexTuple(const T& v, const O... o) : head(v), others(o...) { }$/;"	f	struct:Eigen::internal::IndexTuple
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct IndexTuple<T> {$/;"	s	namespace:Eigen::internal
IndexTuple	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct IndexTuple<T, O...> {$/;"	s	namespace:Eigen::internal
IndexTupleExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct IndexTupleExtractor<0, T, O...> {$/;"	s	namespace:Eigen::internal
IndexTupleExtractor	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct IndexTupleExtractor<N, T, O...> {$/;"	s	namespace:Eigen::internal
IndexType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int IndexType;$/;"	t	struct:Eigen::internal::pardiso_run_selector
IndexVector	Eigen/src/MetisSupport/MetisSupport.h	/^  typedef Matrix<StorageIndex,Dynamic,1> IndexVector; $/;"	t	class:Eigen::MetisOrdering
IndexVector	Eigen/src/OrderingMethods/Ordering.h	/^    typedef Matrix<StorageIndex, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::COLAMDOrdering
IndexVector	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
IndexVector	Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::SparseCompressedBase
IndexVector	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::IndexVector IndexVector;$/;"	t	class:Eigen::SparseMatrix
IndexVector	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseMatrixBase
IndexVector	Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseLU
IndexVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::SparseLUImpl
IndexVector	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<StorageIndex,Dynamic,1> IndexVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
IndexVector	Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<StorageIndex, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::SparseQR
Indices	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef Indices_ Indices;$/;"	t	struct:Eigen::internal::traits
Indices	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::traits<Derived>::Indices Indices;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
IndicesRef	Eigen/src/SVD/BDCSVD.h	/^  typedef Ref<ArrayXi> IndicesRef;$/;"	t	class:Eigen::BDCSVD
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<_StorageIndex,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/Transpositions.h	/^  typedef Matrix<_StorageIndex, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
Infinity	Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
InitList	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^    typename Initializer<Derived, N - 1>::InitList> InitList;$/;"	t	struct:Eigen::internal::Initializer
InitList	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^  typedef std::initializer_list<typename traits<Derived>::Scalar> InitList;$/;"	t	struct:Eigen::internal::Initializer
InitList	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^  typedef typename traits<Derived>::Scalar InitList;$/;"	t	struct:Eigen::internal::Initializer
Initializer	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^struct Initializer {$/;"	s	namespace:Eigen::internal
Initializer	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^struct Initializer<Derived, 0> {$/;"	s	namespace:Eigen::internal
Initializer	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^struct Initializer<Derived, 1> {$/;"	s	namespace:Eigen::internal
InnerIterator	Eigen/src/Core/CoreIterators.h	/^  InnerIterator(const XprType &xpr, const Index &outerId)$/;"	f	class:Eigen::InnerIterator
InnerIterator	Eigen/src/Core/CoreIterators.h	/^class InnerIterator$/;"	c	namespace:Eigen
InnerIterator	Eigen/src/Core/DenseBase.h	/^    typedef Eigen::InnerIterator<Derived> InnerIterator;$/;"	t	class:Eigen::DenseBase
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::conditional<OuterVector,OuterVectorInnerIterator,InnerVectorInnerIterator>::type InnerIterator;$/;"	t	struct:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator()$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator(const InnerIterator& other)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator(const SparseCompressedBase& mat, Index outer)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit InnerIterator(const SparseCompressedBase& mat)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit InnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename Derived::InnerIterator InnerIterator;$/;"	t	struct:Eigen::internal::evaluator
InnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase<Derived>::InnerIterator$/;"	c	class:Eigen::SparseCompressedBase
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const binary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const sparse_conjunction_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::binary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::sparse_conjunction_evaluator
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::InnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::InnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^    InnerIterator(const sparse_dense_outer_product_evaluator &xprEval, Index outer)$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  class InnerIterator : public LhsIterator$/;"	c	struct:Eigen::internal::sparse_dense_outer_product_evaluator
InnerIterator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    InnerIterator(const sparse_diagonal_product_evaluator &xprEval, Index outer)$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  class InnerIterator : public SparseXprInnerIterator$/;"	c	struct:Eigen::internal::sparse_diagonal_product_evaluator
InnerIterator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  class InnerIterator$/;"	c	struct:Eigen::internal::sparse_diagonal_product_evaluator
InnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::InnerIterator InnerIterator;$/;"	t	class:Eigen::SparseMatrix
InnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^      EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^    class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& xprEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^  class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    typedef typename Base::InnerIterator InnerIterator;$/;"	t	class:Eigen::SparseVector
InnerIterator	Eigen/src/SparseCore/SparseVector.h	/^  typedef typename SparseVectorType::InnerIterator InnerIterator;$/;"	t	struct:Eigen::internal::evaluator
InnerIterator	Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& sve, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseView.h	/^    class InnerIterator : public EvalIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseCore/SparseView.h	/^    class InnerIterator$/;"	c	struct:Eigen::internal::unary_evaluator
InnerIterator	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^     InnerIterator(const MappedSuperNodalMatrix& mat, Index outer)$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
InnerIterator	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix<Scalar,StorageIndex>::InnerIterator$/;"	c	class:Eigen::internal::MappedSuperNodalMatrix
InnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      InnerIterator(const BlockSparseMatrixView& mat, Index outer)$/;"	f	class:Eigen::BlockSparseMatrixView::InnerIterator
InnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    InnerIterator(const BlockSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
InnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    class InnerIterator : public BlockSparseMatrixT::BlockInnerIterator$/;"	c	class:Eigen::BlockSparseMatrixView
InnerIterator	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^class BlockSparseMatrix<_Scalar, _BlockAtCompileTime, _Options, _StorageIndex>::InnerIterator$/;"	c	class:Eigen::BlockSparseMatrix
InnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    InnerIterator(const DynamicSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
InnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef typename SparseMatrixType::InnerIterator InnerIterator;$/;"	t	struct:Eigen::internal::evaluator
InnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^class DynamicSparseMatrix<Scalar,_Options,_StorageIndex>::InnerIterator : public SparseVector<Scalar,_Options,_StorageIndex>::InnerIterator$/;"	c	class:Eigen::DynamicSparseMatrix
InnerLowerIterator	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    InnerLowerIterator(const SkylineMatrix& mat, Index outer)$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
InnerLowerIterator	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix<Scalar, _Options>::InnerLowerIterator {$/;"	c	class:Eigen::SkylineMatrix
InnerMaxSize	Eigen/src/Core/AssignEvaluator.h	/^    InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon504
InnerMaxSize	Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
InnerMaxSize	Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon482
InnerMostDimPreserver	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimPreserver {$/;"	s	namespace:Eigen::internal
InnerMostDimPreserver	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimPreserver<-1, Self, Op, true> {$/;"	s	namespace:Eigen::internal
InnerMostDimPreserver	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimPreserver<0, Self, Op, true> {$/;"	s	namespace:Eigen::internal
InnerMostDimPreserver	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimPreserver<DimIndex, Self, Op, true> {$/;"	s	namespace:Eigen::internal
InnerMostDimReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimReducer {$/;"	s	namespace:Eigen::internal
InnerMostDimReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerMostDimReducer<Self, Op, true> {$/;"	s	namespace:Eigen::internal
InnerPacketSize	Eigen/src/Core/AssignEvaluator.h	/^    InnerPacketSize = unpacket_traits<InnerPacketType>::size$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon505
InnerPacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename find_best_packet<DstScalar,InnerSize>::type InnerPacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
InnerProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
InnerRandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct InnerReducer {$/;"	s	namespace:Eigen::internal
InnerReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct InnerReducer<Self, Op, GpuDevice> {$/;"	s	namespace:Eigen::internal
InnerReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^struct InnerReducer<Self, Op, const Eigen::SyclDevice> {$/;"	s	namespace:Eigen::internal
InnerReductionKernel	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void InnerReductionKernel(Reducer reducer, const Self input, Index num_coeffs_to_reduce, Index num_preserved_coeffs,$/;"	f	namespace:Eigen::internal
InnerReductionKernelHalfFloat	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void InnerReductionKernelHalfFloat(Reducer reducer, const Self input, Index num_coeffs_to_reduce, Index num_preserved_coeffs,$/;"	f	namespace:Eigen::internal
InnerReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct InnerReductionLauncher {$/;"	s	namespace:Eigen::internal
InnerReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct InnerReductionLauncher<$/;"	s	namespace:Eigen::internal
InnerReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct InnerReductionLauncher<Self, Op, Eigen::half, false> {$/;"	s	namespace:Eigen::internal
InnerReductionLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct InnerReductionLauncher<Self, Op, Eigen::half, true> {$/;"	s	namespace:Eigen::internal
InnerRequiredAlignment	Eigen/src/Core/AssignEvaluator.h	/^    InnerRequiredAlignment = unpacket_traits<InnerPacketType>::alignment$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon506
InnerSize	Eigen/src/Core/AssignEvaluator.h	/^    InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon504
InnerSize	Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
InnerSize	Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon464
InnerSize	Eigen/src/Core/CoreEvaluators.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::evaluator::__anon761
InnerSize	Eigen/src/Core/Product.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsTraits::ColsAtCompileTime, RhsTraits::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon324
InnerSize	Eigen/src/Core/ProductEvaluators.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsNestedCleaned::ColsAtCompileTime, RhsNestedCleaned::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::product_evaluator::__anon427
InnerSize	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon40
InnerSizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon285
InnerSizeAtCompileTime	Eigen/src/Core/Redux.h	/^    InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
InnerSizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
InnerStride	Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride
InnerStride	Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC InnerStride(Index v) : Base(0, v) {} \/\/ FIXME making this explicit could break valid code$/;"	f	class:Eigen::InnerStride
InnerStride	Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen
InnerStrideAtCompileTime	Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon464
InnerStrideAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsArgType$/;"	e	enum:Eigen::internal::evaluator::__anon761
InnerStrideAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::evaluator::__anon759
InnerStrideAtCompileTime	Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon460
InnerStrideAtCompileTime	Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon285
InnerStrideAtCompileTime	Eigen/src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon500
InnerStrideAtCompileTime	Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon748
InnerStrideAtCompileTime	Eigen/src/Core/MapBase.h	/^      InnerStrideAtCompileTime = internal::traits<Derived>::InnerStrideAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon436
InnerStrideAtCompileTime	Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon439
InnerStrideAtCompileTime	Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon471
InnerStrideAtCompileTime	Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon443
InnerStrideMatch	Eigen/src/Core/Ref.h	/^      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)$/;"	e	enum:Eigen::internal::traits::match::__anon474
InnerUnrolling	Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::UnrollingType
InnerUpperIterator	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    InnerUpperIterator(const SkylineMatrix& mat, Index outer)$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
InnerUpperIterator	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix<Scalar, _Options>::InnerUpperIterator {$/;"	c	class:Eigen::SkylineMatrix
InnerVectorInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^  EIGEN_STRONG_INLINE InnerVectorInnerIterator(const unary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
InnerVectorInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::InnerVectorInnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
InnerVectorReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InnerVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
InnerVectorsReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InputDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename TensorEvaluator<const TensorIndexTupleOp<ArgType> , Device>::Dimensions InputDimensions;$/;"	t	struct:Eigen::TensorEvaluator
InputDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;$/;"	t	struct:Eigen::TensorEvaluator
InputDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;$/;"	t	struct:Eigen::TensorEvaluator
InputDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename TensorEvaluator<ArgType, Device>::Dimensions InputDimensions;$/;"	t	struct:Eigen::TensorEvaluator
InputPacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool InputPacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess;$/;"	m	struct:Eigen::TensorEvaluator
InputScalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::evaluator
InputScalar	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits
InputScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprTraits::Scalar InputScalar;$/;"	t	struct:Eigen::TensorEvaluator
InputScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprTraits::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits
InputType	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename Functor::InputType InputType;$/;"	t	class:Eigen::AutoDiffJacobian
InputType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef Matrix<Scalar,Dynamic,1> InputType;$/;"	t	struct:Eigen::SparseFunctor
InputType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:Eigen::DenseFunctor
InputType	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::InputType InputType;$/;"	t	class:Eigen::NumericalDiff
InputType	unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:Functor	file:
InputType	unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:Functor	file:
InputType	unsupported/test/autodiff.cpp	/^    typedef Matrix<Scalar, 2, 1> InputType;$/;"	t	struct:integratorFunctor	file:
InputType	unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:TestFunc1	file:
InputType	unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:TestFunc1	file:
InputsAtCompileTime	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^    InputsAtCompileTime = InputType::RowsAtCompileTime,$/;"	e	enum:Eigen::AutoDiffJacobian::__anon81
InputsAtCompileTime	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    InputsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::SparseFunctor::__anon84
InputsAtCompileTime	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    InputsAtCompileTime = NX,$/;"	e	enum:Eigen::DenseFunctor::__anon83
InputsAtCompileTime	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        InputsAtCompileTime = Functor::InputsAtCompileTime,$/;"	e	enum:Eigen::NumericalDiff::__anon82
InputsAtCompileTime	unsupported/test/NonLinearOptimization.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:Functor::__anon23	file:
InputsAtCompileTime	unsupported/test/NumericalDiff.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:Functor::__anon20	file:
InputsAtCompileTime	unsupported/test/autodiff.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:TestFunc1::__anon24	file:
InputsAtCompileTime	unsupported/test/forward_adolc.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:TestFunc1::__anon22	file:
InsertZeros	unsupported/test/cxx11_tensor_custom_op.cpp	/^struct InsertZeros {$/;"	s	file:
Instance	bench/btl/generic_bench/btl.hh	/^  static BtlConfig Instance;$/;"	m	class:BtlConfig
IntColVectorType	Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, StorageIndex>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU
IntColVectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<StorageIndex, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl
IntColVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase
IntColVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;   $/;"	t	class:Eigen::SuperLU
IntColVectorType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU
IntDiagSizeVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^                   EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
IntDiagSizeVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename FullPivHouseholderQR<MatrixType>::IntDiagSizeVectorType IntDiagSizeVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
IntPtr	Eigen/src/Core/util/Meta.h	/^typedef std::intptr_t  IntPtr;$/;"	t	namespace:Eigen::internal
IntRowVectorType	Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, StorageIndex>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU
IntRowVectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<StorageIndex, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl
IntRowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
IntRowVectorType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      IntRowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
IntRowVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase
IntRowVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU
IntRowVectorType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU
Interpolate	unsupported/Eigen/src/Splines/SplineFitting.h	/^  SplineType SplineFitting<SplineType>::Interpolate(const PointArrayType& pts, DenseIndex degree)$/;"	f	class:Eigen::SplineFitting
Interpolate	unsupported/Eigen/src/Splines/SplineFitting.h	/^  SplineType SplineFitting<SplineType>::Interpolate(const PointArrayType& pts, DenseIndex degree, const KnotVectorType& knot_parameters)$/;"	f	class:Eigen::SplineFitting
InterpolateWithDerivatives	unsupported/Eigen/src/Splines/SplineFitting.h	/^  SplineFitting<SplineType>::InterpolateWithDerivatives(const PointArrayType& points,$/;"	f	class:Eigen::SplineFitting
InvalidInput	Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
InvalidTraversal	Eigen/src/Core/util/Constants.h	/^  InvalidTraversal,$/;"	e	enum:Eigen::TraversalType
Inverse	Eigen/src/Core/Inverse.h	/^  explicit EIGEN_DEVICE_FUNC Inverse(const XprType &xpr)$/;"	f	class:Eigen::Inverse
Inverse	Eigen/src/Core/Inverse.h	/^class Inverse : public InverseImpl<XprType,typename internal::traits<XprType>::StorageKind>$/;"	c	namespace:Eigen
InverseImpl	Eigen/src/Core/Inverse.h	/^class InverseImpl$/;"	c	namespace:Eigen
InverseImpl	Eigen/src/Core/PermutationMatrix.h	/^    InverseImpl() {}$/;"	f	class:Eigen::InverseImpl
InverseImpl	Eigen/src/Core/PermutationMatrix.h	/^class InverseImpl<PermutationType, PermutationStorage>$/;"	c	namespace:Eigen
InverseReturnType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper<const CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const DiagonalVectorType> > InverseReturnType;$/;"	t	class:Eigen::DiagonalBase
InverseReturnType	Eigen/src/Core/PermutationMatrix.h	/^    typedef Inverse<Derived> InverseReturnType;$/;"	t	class:Eigen::PermutationBase
InverseReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> InverseReturnType;$/;"	t
InverseType	Eigen/src/Core/Inverse.h	/^  typedef Inverse<ArgType> InverseType;$/;"	t	struct:Eigen::internal::unary_evaluator
InverseType	Eigen/src/Core/PermutationMatrix.h	/^    typedef Inverse<PermutationType> InverseType;$/;"	t	class:Eigen::InverseImpl
IsAligned	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      IsAligned = bool(EIGEN_MAX_ALIGN_BYTES>0) & !(Options_&DontAlign),$/;"	e	enum:Eigen::Tensor::__anon122
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/ false,$/;"	e	enum:Eigen::TensorEvaluator::__anon100
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/ false,$/;"	e	enum:Eigen::TensorEvaluator::__anon99
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    IsAligned = TensorEvaluator<LeftArgType, Device>::IsAligned & TensorEvaluator<RightArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon120
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    IsAligned = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon126
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon124
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon125
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon97
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon98
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    IsAligned = true,$/;"	e	enum:Eigen::TensorContractionEvaluatorBase::__anon165
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon108
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    IsAligned = TensorEvaluator<InputArgType, Device>::IsAligned & TensorEvaluator<KernelArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon145
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    IsAligned = TensorEvaluator<InputArgType, GpuDevice>::IsAligned & TensorEvaluator<KernelArgType, GpuDevice>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon146
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon137
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon138
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon141
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = Derived::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon109
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = Derived::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon111
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = TensorEvaluator<Arg1Type, Device>::IsAligned & TensorEvaluator<Arg2Type, Device>::IsAligned & TensorEvaluator<Arg3Type, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon115
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon113
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = TensorEvaluator<LeftArgType, Device>::IsAligned & TensorEvaluator<RightArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon114
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = TensorEvaluator<ThenArgType, Device>::IsAligned & TensorEvaluator<ElseArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon116
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    IsAligned = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon112
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon148
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^      IsAligned = bool(EIGEN_MAX_ALIGN_BYTES>0),$/;"	e	enum:Eigen::TensorFixedSize::__anon87
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    IsAligned = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon118
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon142
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon130
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/ false,$/;"	e	enum:Eigen::TensorEvaluator::__anon136
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon85
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon86
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^      IsAligned = ((int(Options_)&Aligned)==Aligned),$/;"	e	enum:Eigen::TensorMap::__anon127
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon89
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = TensorEvaluator<ArgType, Device>::IsAligned,$/;"	e	enum:Eigen::TensorEvaluator::__anon90
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/false,$/;"	e	enum:Eigen::TensorEvaluator::__anon92
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/false,$/;"	e	enum:Eigen::TensorEvaluator::__anon93
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon94
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon95
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    IsAligned = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon147
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon88
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon128
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^      IsAligned = false,$/;"	e	enum:Eigen::TensorRef::__anon152
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon153
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon154
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon183
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon184
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon129
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon150
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon151
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/false,$/;"	e	enum:Eigen::TensorEvaluator::__anon185
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    IsAligned = \/*TensorEvaluator<ArgType, Device>::IsAligned*\/false,$/;"	e	enum:Eigen::TensorEvaluator::__anon186
IsAligned	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    IsAligned = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon143
IsAlphaOpposite	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsAlphaOpposite = (AlphaAxis < 0) ? 1 : 0, \/*!< weather alpha axis is negative *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsBetaOpposite	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsBetaOpposite = (BetaAxis < 0) ? 1 : 0, \/*!< weather beta axis is negative *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsColMajor	Eigen/src/Core/CoreEvaluators.h	/^    IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
IsColMajor	Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon434
IsColMajor	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      IsColMajor = Flags&RowMajorBit ? 0 : 1$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
IsColVector	Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon459
IsColVector	Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon845
IsColVector	Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon847
IsComplex	Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
IsComplex	Eigen/src/Core/arch/CUDA/Half.h	/^    IsComplex = false,$/;"	e	enum:Eigen::NumTraits::__anon671
IsComplex	Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon609
IsComplex	Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon610
IsComplex	blas/common.h	/^  IsComplex = Eigen::NumTraits<SCALAR>::IsComplex,$/;"	e	enum:__anon202
IsComplex	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::NumTraits::__anon123
IsDense	Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::AmbiVectorMode
IsDynamicSize	Eigen/src/Core/CoreEvaluators.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::evaluator::__anon759
IsEven	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsEven = IsOdd ? 0 : 1, \/*!< weather the Euler system is even *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsFiniteReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isfinite_op<Scalar>, const Derived> IsFiniteReturnType;$/;"	t
IsFixedSize	bench/btl/libs/eigen2/eigen2_interface.hh	/^  enum {IsFixedSize = (SIZE!=Dynamic)};$/;"	e	enum:eigen2_interface::__anon8
IsFixedSize	bench/btl/libs/eigen3/eigen3_interface.hh	/^  enum {IsFixedSize = (SIZE!=Dynamic)};$/;"	e	enum:eigen3_interface::__anon9
IsGammaOpposite	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsGammaOpposite = (GammaAxis < 0) ? 1 : 0, \/*!< weather gamma axis is negative *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsInf	unsupported/test/mpreal/mpreal.h	76;"	d
IsInf	unsupported/test/mpreal/mpreal.h	78;"	d
IsInf	unsupported/test/mpreal/mpreal.h	80;"	d
IsInfReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isinf_op<Scalar>, const Derived> IsInfReturnType;$/;"	t
IsInteger	Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
IsInteger	Eigen/src/Core/arch/CUDA/Half.h	/^    IsInteger = false,$/;"	e	enum:Eigen::NumTraits::__anon671
IsLower	Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon519
IsLower	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon618
IsLower	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon619
IsLower	Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon627
IsLower	Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon628
IsLower	Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon612
IsLower	Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon613
IsLower	blas/BandTriangularSolver.h	/^  enum { IsLower = (Mode&Lower) ? 1 : 0 };$/;"	e	enum:internal::band_solve_triangular_selector::__anon196
IsLower	blas/BandTriangularSolver.h	/^  enum { IsLower = (Mode&Lower) ? 1 : 0 };$/;"	e	enum:internal::band_solve_triangular_selector::__anon197
IsLower	blas/PackedTriangularMatrixVector.h	/^    IsLower     = (Mode & Lower)   ==Lower,$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon198
IsLower	blas/PackedTriangularMatrixVector.h	/^    IsLower     = (Mode & Lower)   ==Lower,$/;"	e	enum:internal::packed_triangular_matrix_vector_product::__anon199
IsLower	blas/PackedTriangularSolverVector.h	/^    IsLower = (Mode&Lower)==Lower$/;"	e	enum:internal::packed_triangular_solve_vector::__anon200
IsLower	blas/PackedTriangularSolverVector.h	/^    IsLower = (Mode&Lower)==Lower$/;"	e	enum:internal::packed_triangular_solve_vector::__anon201
IsNaNReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_isnan_op<Scalar>, const Derived> IsNaNReturnType;$/;"	t
IsOdd	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsOdd = ((AlphaAxisAbs)%3 == (BetaAxisAbs - 1)%3) ? 0 : 1, \/*!< weather the Euler system is odd *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsOneByOne	Eigen/src/Core/Product.h	/^      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) && $/;"	e	enum:Eigen::ProductImpl::__anon325
IsPlainObjectBase	Eigen/src/Core/DenseBase.h	/^    enum { IsPlainObjectBase = 0 };$/;"	e	enum:Eigen::DenseBase::__anon286
IsPlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    enum { IsPlainObjectBase = 1 };$/;"	e	enum:Eigen::PlainObjectBase::__anon463
IsProjective	Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon263
IsRepeatable	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon516
IsRepeatable	Eigen/src/Core/functors/NullaryFunctors.h	/^         PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon362
IsRepeatable	Eigen/src/Core/functors/NullaryFunctors.h	/^    IsRepeatable = true$/;"	e	enum:Eigen::internal::functor_traits::__anon364
IsRepeatable	Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon363
IsRowMajor	Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon464
IsRowMajor	Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::evaluator::__anon761
IsRowMajor	Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = PlainObjectType::IsRowMajor,$/;"	e	enum:Eigen::internal::evaluator::__anon751
IsRowMajor	Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
IsRowMajor	Eigen/src/Core/CoreEvaluators.h	/^    IsRowMajor = XprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::mapbase_evaluator::__anon758
IsRowMajor	Eigen/src/Core/CoreIterators.h	/^  enum { IsRowMajor = (XprType::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::inner_iterator_selector::__anon520
IsRowMajor	Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon285
IsRowMajor	Eigen/src/Core/Redux.h	/^    IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
IsRowMajor	Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon772
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^      IsRowMajor = XprType::IsRowMajor,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon807
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon802
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon806
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::internal::sparse_matrix_block_impl::__anon804
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^  enum { IsRowMajor = unary_evaluator::IsRowMajor };$/;"	e	enum:Eigen::internal::unary_evaluator::InnerVectorInnerIterator::__anon808
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^  enum { IsRowMajor = unary_evaluator::IsRowMajor };$/;"	e	enum:Eigen::internal::unary_evaluator::OuterVectorInnerIterator::__anon809
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::binary_evaluator::InnerIterator::__anon816
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(LhsArg::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::InnerIterator::__anon821
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::binary_evaluator::InnerIterator::__anon814
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(RhsArg::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_conjunction_evaluator::InnerIterator::__anon819
IsRowMajor	Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::Map::__anon831
IsRowMajor	Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::Map::__anon832
IsRowMajor	Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::SparseMapBase::__anon829
IsRowMajor	Eigen/src/SparseCore/SparseMap.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::SparseMapBase::__anon830
IsRowMajor	Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
IsRowMajor	Eigen/src/SparseCore/SparseView.h	/^    enum { IsRowMajor = (XprType::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::unary_evaluator::__anon853
IsRowMajor	doc/examples/matrixfree_cg.cpp	/^    IsRowMajor = false$/;"	e	enum:MatrixReplacement::__anon191	file:
IsRowMajor	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        IsRowMajor = Flags & RowMajorBit ? 1 : 0$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
IsSigned	Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
IsSigned	Eigen/src/Core/arch/CUDA/Half.h	/^    IsSigned = true,$/;"	e	enum:Eigen::NumTraits::__anon671
IsSkyline	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum {IsSkyline = SkylineBit};$/;"	e	enum:Eigen::__anon42
IsSorted	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::GoogleDenseHashMapTraits::__anon69
IsSorted	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::GoogleSparseHashMapTraits::__anon70
IsSorted	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::StdUnorderedMapTraits::__anon68
IsSorted	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 1$/;"	e	enum:Eigen::StdMapTraits::__anon67
IsSparse	Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::AmbiVectorMode
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::AndReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::ArgMaxTupleReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::ArgMinTupleReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::MaxReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::MinReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::OrReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::ProdReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = false;$/;"	m	struct:Eigen::internal::SumReducer
IsStateful	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool IsStateful = true;$/;"	m	struct:Eigen::internal::MeanReducer
IsTaitBryan	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      IsTaitBryan = ((unsigned)AlphaAxisAbs != (unsigned)GammaAxisAbs) ? 1 : 0 \/*!< weather the Euler system is tait bryan *\/$/;"	e	enum:Eigen::EulerSystem::__anon48
IsTransposed	Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon611
IsTransposed	Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon609
IsValidAxis	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^    struct IsValidAxis$/;"	s	namespace:Eigen::internal
IsVectorAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon751
IsVectorAtCompileTime	Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon285
IsVectorAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon282
IsVectorAtCompileTime	Eigen/src/Core/SolverBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::SolverBase::__anon493
IsVectorAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      IsVectorAtCompileTime = false$/;"	e	enum:Eigen::TriangularView::__anon454
IsVectorAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
IsVectorAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
IsVectorAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
IsVectorizable	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^struct IsVectorizable {$/;"	s	namespace:Eigen::internal
IsVectorizable	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^struct IsVectorizable<GpuDevice, Expression> {$/;"	s	namespace:Eigen::internal
Isometry	Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Isometry2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
IsometryTransformType	Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation
IterScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    IterScaling() { init(); }$/;"	f	class:Eigen::IterScaling
IterScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    IterScaling(const MatrixType& matrix)$/;"	f	class:Eigen::IterScaling
IterScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^class IterScaling$/;"	c	namespace:Eigen
IterationController	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    IterationController(double r = 1.0E-8, int noi = 0, size_t mit = size_t(-1))$/;"	f	class:Eigen::IterationController
IterationController	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^class IterationController$/;"	c	namespace:Eigen
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  explicit IterativeSolverBase(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
Iterator	Eigen/src/SparseCore/AmbiVector.h	/^    explicit Iterator(const AmbiVector& vec, const RealScalar& epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator
Iterator	Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_StorageIndex>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
IteratorBased	Eigen/src/Core/util/Constants.h	/^struct IteratorBased {};$/;"	s	namespace:Eigen::internal
IteratorType	Eigen/src/Core/CoreIterators.h	/^  typedef internal::inner_iterator_selector<XprType, typename internal::evaluator_traits<XprType>::Kind> IteratorType;$/;"	t	class:Eigen::InnerIterator
J	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:CBLAT2
J	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:CBLAT3
J	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:DBLAT2
J	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:DBLAT3
J	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:SBLAT2
J	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:SBLAT3
J	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:ZBLAT2
J	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J,/;"	v	program:ZBLAT3
J	doc/snippets/Jacobi_makeJacobi.cpp	/^JacobiRotation<float> J;$/;"	v
J	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      J = (AlphaAxisAbs - 1 + 1 + IsOdd)%3,$/;"	e	enum:Eigen::EulerSystem::__anon49
JRs	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef JacobiRotation<Scalar> JRs;$/;"	t	class:Eigen::RealQZ
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    explicit JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JacobianType	test/denseLM.cpp	/^  typedef typename Base::JacobianType JacobianType;$/;"	t	struct:DenseLM	file:
JacobianType	test/sparseLM.cpp	/^  typedef typename Base::JacobianType JacobianType;$/;"	t	struct:sparseGaussianTest	file:
JacobianType	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<Scalar, ValuesAtCompileTime, InputsAtCompileTime> JacobianType;$/;"	t	class:Eigen::AutoDiffJacobian
JacobianType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef typename FunctorType::JacobianType JacobianType;$/;"	t	class:Eigen::LevenbergMarquardt
JacobianType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:Eigen::DenseFunctor
JacobianType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index> JacobianType;$/;"	t	struct:Eigen::SparseFunctor
JacobianType	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > JacobianType;$/;"	t	class:Eigen::HybridNonLinearSolver
JacobianType	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > JacobianType;$/;"	t	class:Eigen::LevenbergMarquardt
JacobianType	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::JacobianType JacobianType;$/;"	t	class:Eigen::NumericalDiff
JacobianType	unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:Functor	file:
JacobianType	unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:Functor	file:
JacobianType	unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:TestFunc1	file:
JacobianType	unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:TestFunc1	file:
JointAlignment	Eigen/src/Core/AssignEvaluator.h	/^    JointAlignment = EIGEN_PLAIN_ENUM_MIN(DstAlignment,SrcAlignment)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon503
K	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      K = (AlphaAxisAbs - 1 + 2 - IsOdd)%3$/;"	e	enum:Eigen::EulerSystem::__anon49
KB	blas/testing/cblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC( NINMAX ), KB(/;"	v	program:CBLAT2
KB	blas/testing/dblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC( NINMAX ), KB(/;"	v	program:DBLAT2
KB	blas/testing/sblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC( NINMAX ), KB(/;"	v	program:SBLAT2
KB	blas/testing/zblat2.f	/^      INTEGER            IDIM( NIDMAX ), INC( NINMAX ), KB(/;"	v	program:ZBLAT2
KDBVH_H_INCLUDED	unsupported/Eigen/src/BVH/KdBVH.h	11;"	d
KERNELBROKERCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	104;"	d
KERNELBROKERCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	95;"	d
KERNELBROKERCONVERTREDUCTION	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	107;"	d
KERNELBROKERCONVERTREDUCTION	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	115;"	d
KILL_NON_PRINCIPAL_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	124;"	d
KILL_PRINCIPAL_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	123;"	d
KILL_ROW	Eigen/src/OrderingMethods/Eigen_Colamd.h	122;"	d
KK	bench/sparse_setter.cpp	23;"	d	file:
KMADD	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	107;"	d
KMADD	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	274;"	d
KRONECKER_TENSOR_PRODUCT_H	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	13;"	d
KdBVH	unsupported/Eigen/src/BVH/KdBVH.h	/^  KdBVH() {}$/;"	f	class:Eigen::KdBVH
KdBVH	unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename Iter> KdBVH(Iter begin, Iter end) { init(begin, end, 0, 0); } \/\/int is recognized by init as not being an iterator type$/;"	f	class:Eigen::KdBVH
KdBVH	unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename OIter, typename BIter> KdBVH(OIter begin, OIter end, BIter boxBegin, BIter boxEnd) { init(begin, end, boxBegin, boxEnd); }$/;"	f	class:Eigen::KdBVH
KdBVH	unsupported/Eigen/src/BVH/KdBVH.h	/^template<typename _Scalar, int _Dim, typename _Object> class KdBVH$/;"	c	namespace:Eigen
KernelDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename TensorEvaluator<KernelArgType, GpuDevice>::Dimensions KernelDimensions;$/;"	t	struct:Eigen::TensorEvaluator
KeyType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename MapTraits<ScalarWrapper>::KeyType KeyType;$/;"	t	class:Eigen::RandomSetter
KeyType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::GoogleDenseHashMapTraits
KeyType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::GoogleSparseHashMapTraits
KeyType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::StdMapTraits
KeyType	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::StdUnorderedMapTraits
Kind	Eigen/src/Core/AssignEvaluator.h	/^template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/AssignEvaluator.h	/^template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/BandMatrix.h	/^template<> struct AssignmentKind<DenseShape,BandShape> { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/CoreEvaluators.h	/^  typedef IndexBased Kind;$/;"	t	struct:Eigen::internal::storage_kind_to_evaluator_kind
Kind	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename storage_kind_to_evaluator_kind<typename traits<T>::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits_base
Kind	Eigen/src/Core/DiagonalMatrix.h	/^template<> struct AssignmentKind<DenseShape,DiagonalShape> { typedef Diagonal2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/PermutationMatrix.h	/^template<> struct AssignmentKind<DenseShape,PermutationShape> { typedef EigenBase2EigenBase Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<DenseShape,TriangularShape>      { typedef Triangular2Dense      Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,DenseShape>      { typedef Dense2Triangular      Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Core/TriangularMatrix.h	/^template<> struct AssignmentKind<TriangularShape,TriangularShape> { typedef Triangular2Triangular Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename storage_kind_to_evaluator_kind<typename ArgType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	Eigen/src/Geometry/Homogeneous.h	/^template<> struct AssignmentKind<DenseShape,HomogeneousShape> { typedef Dense2Dense Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^  typedef IteratorBased Kind;$/;"	t	struct:Eigen::internal::storage_kind_to_evaluator_kind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseShape>           { typedef Sparse2Dense  Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<DenseShape,  SparseTriangularShape> { typedef Sparse2Dense  Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseShape>           { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape, SparseTriangularShape> { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseAssign.h	/^template<> struct AssignmentKind<SparseShape,DiagonalShape> { typedef Diagonal2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
Kind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseSelfAdjointShape,SparseShape> { typedef Sparse2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<> struct AssignmentKind<SparseShape,SparseSelfAdjointShape> { typedef SparseSelfAdjoint2Sparse Kind; };$/;"	t	struct:Eigen::internal::AssignmentKind
Kind	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;$/;"	t	struct:Eigen::internal::evaluator_traits
KnotAveraging	unsupported/Eigen/src/Splines/SplineFitting.h	/^  void KnotAveraging(const KnotVectorType& parameters, DenseIndex degree, KnotVectorType& knots)$/;"	f	namespace:Eigen
KnotAveragingWithDerivatives	unsupported/Eigen/src/Splines/SplineFitting.h	/^  void KnotAveragingWithDerivatives(const ParameterVectorType& parameters,$/;"	f	namespace:Eigen
KnotVectorType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::KnotVectorType KnotVectorType;$/;"	t	class:Eigen::Spline
KnotVectorType	unsupported/Eigen/src/Splines/SplineFitting.h	/^    typedef typename SplineType::KnotVectorType KnotVectorType;$/;"	t	struct:Eigen::SplineFitting
KnotVectorType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,1,Dynamic> KnotVectorType;$/;"	t	struct:Eigen::SplineTraits
KroneckerProduct	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    KroneckerProduct(const Lhs& A, const Rhs& B)$/;"	f	class:Eigen::KroneckerProduct
KroneckerProduct	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^class KroneckerProduct : public KroneckerProductBase<KroneckerProduct<Lhs,Rhs> >$/;"	c	namespace:Eigen
KroneckerProductBase	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    KroneckerProductBase(const Lhs& A, const Rhs& B)$/;"	f	class:Eigen::KroneckerProductBase
KroneckerProductBase	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^class KroneckerProductBase : public ReturnByValue<Derived>$/;"	c	namespace:Eigen
KroneckerProductSparse	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    KroneckerProductSparse(const Lhs& A, const Rhs& B)$/;"	f	class:Eigen::KroneckerProductSparse
KroneckerProductSparse	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^class KroneckerProductSparse : public KroneckerProductBase<KroneckerProductSparse<Lhs,Rhs> >$/;"	c	namespace:Eigen
L	bench/btl/actions/action_trisolve.hh	/^  typename Interface::gene_matrix L;$/;"	m	class:Action_trisolve
L	doc/snippets/LLT_example.cpp	/^MatrixXd L = lltOfA.matrixL(); \/\/ retrieve factor L  in the decomposition$/;"	v
LAPACKE_free	Eigen/src/misc/lapacke.h	115;"	d
LAPACKE_malloc	Eigen/src/misc/lapacke.h	112;"	d
LAPACK_C2INT	Eigen/src/misc/lapacke.h	118;"	d
LAPACK_COL_MAJOR	Eigen/src/misc/lapacke.h	122;"	d
LAPACK_C_SELECT1	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_C_SELECT1) ( const lapack_complex_float* );$/;"	t
LAPACK_C_SELECT2	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_C_SELECT2)$/;"	t
LAPACK_D_SELECT2	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_D_SELECT2) ( const double*, const double* );$/;"	t
LAPACK_D_SELECT3	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_D_SELECT3)$/;"	t
LAPACK_GLOBAL	Eigen/src/misc/lapacke_mangling.h	10;"	d
LAPACK_GLOBAL	Eigen/src/misc/lapacke_mangling.h	12;"	d
LAPACK_GLOBAL	Eigen/src/misc/lapacke_mangling.h	6;"	d
LAPACK_GLOBAL	Eigen/src/misc/lapacke_mangling.h	8;"	d
LAPACK_H	Eigen/src/misc/lapack.h	2;"	d
LAPACK_HEADER_INCLUDED	Eigen/src/misc/lapacke_mangling.h	2;"	d
LAPACK_ROW_MAJOR	Eigen/src/misc/lapacke.h	121;"	d
LAPACK_S_SELECT2	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_S_SELECT2) ( const float*, const float* );$/;"	t
LAPACK_S_SELECT3	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_S_SELECT3)$/;"	t
LAPACK_TRANSPOSE_MEMORY_ERROR	Eigen/src/misc/lapacke.h	125;"	d
LAPACK_WORK_MEMORY_ERROR	Eigen/src/misc/lapacke.h	124;"	d
LAPACK_Z2INT	Eigen/src/misc/lapacke.h	119;"	d
LAPACK_Z_SELECT1	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_Z_SELECT1) ( const lapack_complex_double* );$/;"	t
LAPACK_Z_SELECT2	Eigen/src/misc/lapacke.h	/^typedef lapack_logical (*LAPACK_Z_SELECT2)$/;"	t
LAPACK_cbbcsd	Eigen/src/misc/lapacke.h	11569;"	d
LAPACK_cbdsqr	Eigen/src/misc/lapacke.h	11108;"	d
LAPACK_cgbbrd	Eigen/src/misc/lapacke.h	11096;"	d
LAPACK_cgbcon	Eigen/src/misc/lapacke.h	10722;"	d
LAPACK_cgbequ	Eigen/src/misc/lapacke.h	10888;"	d
LAPACK_cgbequb	Eigen/src/misc/lapacke.h	10893;"	d
LAPACK_cgbrfs	Eigen/src/misc/lapacke.h	10778;"	d
LAPACK_cgbrfsx	Eigen/src/misc/lapacke.h	10783;"	d
LAPACK_cgbsv	Eigen/src/misc/lapacke.h	10932;"	d
LAPACK_cgbsvx	Eigen/src/misc/lapacke.h	10936;"	d
LAPACK_cgbsvxx	Eigen/src/misc/lapacke.h	10941;"	d
LAPACK_cgbtrf	Eigen/src/misc/lapacke.h	10618;"	d
LAPACK_cgbtrs	Eigen/src/misc/lapacke.h	10666;"	d
LAPACK_cgebak	Eigen/src/misc/lapacke.h	11204;"	d
LAPACK_cgebal	Eigen/src/misc/lapacke.h	11200;"	d
LAPACK_cgebrd	Eigen/src/misc/lapacke.h	11092;"	d
LAPACK_cgecon	Eigen/src/misc/lapacke.h	10718;"	d
LAPACK_cgeequ	Eigen/src/misc/lapacke.h	10880;"	d
LAPACK_cgeequb	Eigen/src/misc/lapacke.h	10885;"	d
LAPACK_cgees	Eigen/src/misc/lapacke.h	11352;"	d
LAPACK_cgeesx	Eigen/src/misc/lapacke.h	11356;"	d
LAPACK_cgeev	Eigen/src/misc/lapacke.h	11360;"	d
LAPACK_cgeevx	Eigen/src/misc/lapacke.h	11364;"	d
LAPACK_cgehrd	Eigen/src/misc/lapacke.h	11188;"	d
LAPACK_cgelq2	Eigen/src/misc/lapacke.h	11510;"	d
LAPACK_cgelqf	Eigen/src/misc/lapacke.h	11040;"	d
LAPACK_cgels	Eigen/src/misc/lapacke.h	11280;"	d
LAPACK_cgelsd	Eigen/src/misc/lapacke.h	11292;"	d
LAPACK_cgelss	Eigen/src/misc/lapacke.h	11288;"	d
LAPACK_cgelsy	Eigen/src/misc/lapacke.h	11284;"	d
LAPACK_cgemqrt	Eigen/src/misc/lapacke.h	11612;"	d
LAPACK_cgeqlf	Eigen/src/misc/lapacke.h	11052;"	d
LAPACK_cgeqp3	Eigen/src/misc/lapacke.h	11028;"	d
LAPACK_cgeqpf	Eigen/src/misc/lapacke.h	11024;"	d
LAPACK_cgeqr2	Eigen/src/misc/lapacke.h	11478;"	d
LAPACK_cgeqrf	Eigen/src/misc/lapacke.h	11020;"	d
LAPACK_cgeqrfp	Eigen/src/misc/lapacke.h	11468;"	d
LAPACK_cgeqrt	Eigen/src/misc/lapacke.h	11616;"	d
LAPACK_cgeqrt2	Eigen/src/misc/lapacke.h	11620;"	d
LAPACK_cgeqrt3	Eigen/src/misc/lapacke.h	11624;"	d
LAPACK_cgerfs	Eigen/src/misc/lapacke.h	10770;"	d
LAPACK_cgerfsx	Eigen/src/misc/lapacke.h	10775;"	d
LAPACK_cgerqf	Eigen/src/misc/lapacke.h	11064;"	d
LAPACK_cgesdd	Eigen/src/misc/lapacke.h	11372;"	d
LAPACK_cgesv	Eigen/src/misc/lapacke.h	10918;"	d
LAPACK_cgesvd	Eigen/src/misc/lapacke.h	11368;"	d
LAPACK_cgesvx	Eigen/src/misc/lapacke.h	10924;"	d
LAPACK_cgesvxx	Eigen/src/misc/lapacke.h	10929;"	d
LAPACK_cgetf2	Eigen/src/misc/lapacke.h	11486;"	d
LAPACK_cgetrf	Eigen/src/misc/lapacke.h	10614;"	d
LAPACK_cgetri	Eigen/src/misc/lapacke.h	10840;"	d
LAPACK_cgetrs	Eigen/src/misc/lapacke.h	10662;"	d
LAPACK_cggbak	Eigen/src/misc/lapacke.h	11244;"	d
LAPACK_cggbal	Eigen/src/misc/lapacke.h	11240;"	d
LAPACK_cgges	Eigen/src/misc/lapacke.h	11420;"	d
LAPACK_cggesx	Eigen/src/misc/lapacke.h	11424;"	d
LAPACK_cggev	Eigen/src/misc/lapacke.h	11428;"	d
LAPACK_cggevx	Eigen/src/misc/lapacke.h	11432;"	d
LAPACK_cggglm	Eigen/src/misc/lapacke.h	11300;"	d
LAPACK_cgghrd	Eigen/src/misc/lapacke.h	11236;"	d
LAPACK_cgglse	Eigen/src/misc/lapacke.h	11296;"	d
LAPACK_cggqrf	Eigen/src/misc/lapacke.h	11084;"	d
LAPACK_cggrqf	Eigen/src/misc/lapacke.h	11088;"	d
LAPACK_cggsvd	Eigen/src/misc/lapacke.h	11380;"	d
LAPACK_cggsvp	Eigen/src/misc/lapacke.h	11272;"	d
LAPACK_cgtcon	Eigen/src/misc/lapacke.h	10726;"	d
LAPACK_cgtrfs	Eigen/src/misc/lapacke.h	10786;"	d
LAPACK_cgtsv	Eigen/src/misc/lapacke.h	10944;"	d
LAPACK_cgtsvx	Eigen/src/misc/lapacke.h	10948;"	d
LAPACK_cgttrf	Eigen/src/misc/lapacke.h	10622;"	d
LAPACK_cgttrs	Eigen/src/misc/lapacke.h	10670;"	d
LAPACK_chbev	Eigen/src/misc/lapacke.h	11332;"	d
LAPACK_chbevd	Eigen/src/misc/lapacke.h	11336;"	d
LAPACK_chbevx	Eigen/src/misc/lapacke.h	11340;"	d
LAPACK_chbgst	Eigen/src/misc/lapacke.h	11180;"	d
LAPACK_chbgv	Eigen/src/misc/lapacke.h	11408;"	d
LAPACK_chbgvd	Eigen/src/misc/lapacke.h	11412;"	d
LAPACK_chbgvx	Eigen/src/misc/lapacke.h	11416;"	d
LAPACK_chbtrd	Eigen/src/misc/lapacke.h	11138;"	d
LAPACK_checon	Eigen/src/misc/lapacke.h	10748;"	d
LAPACK_cheequb	Eigen/src/misc/lapacke.h	10915;"	d
LAPACK_cheev	Eigen/src/misc/lapacke.h	11304;"	d
LAPACK_cheevd	Eigen/src/misc/lapacke.h	11308;"	d
LAPACK_cheevr	Eigen/src/misc/lapacke.h	11316;"	d
LAPACK_cheevx	Eigen/src/misc/lapacke.h	11312;"	d
LAPACK_chegst	Eigen/src/misc/lapacke.h	11172;"	d
LAPACK_chegv	Eigen/src/misc/lapacke.h	11384;"	d
LAPACK_chegvd	Eigen/src/misc/lapacke.h	11388;"	d
LAPACK_chegvx	Eigen/src/misc/lapacke.h	11392;"	d
LAPACK_cherfs	Eigen/src/misc/lapacke.h	10816;"	d
LAPACK_cherfsx	Eigen/src/misc/lapacke.h	10819;"	d
LAPACK_chesv	Eigen/src/misc/lapacke.h	11000;"	d
LAPACK_chesvx	Eigen/src/misc/lapacke.h	11002;"	d
LAPACK_chesvxx	Eigen/src/misc/lapacke.h	11005;"	d
LAPACK_cheswapr	Eigen/src/misc/lapacke.h	11570;"	d
LAPACK_chetrd	Eigen/src/misc/lapacke.h	11118;"	d
LAPACK_chetrf	Eigen/src/misc/lapacke.h	10652;"	d
LAPACK_chetri	Eigen/src/misc/lapacke.h	10858;"	d
LAPACK_chetri2	Eigen/src/misc/lapacke.h	11571;"	d
LAPACK_chetri2x	Eigen/src/misc/lapacke.h	11572;"	d
LAPACK_chetrs	Eigen/src/misc/lapacke.h	10696;"	d
LAPACK_chetrs2	Eigen/src/misc/lapacke.h	11573;"	d
LAPACK_chfrk	Eigen/src/misc/lapacke.h	11437;"	d
LAPACK_chgeqz	Eigen/src/misc/lapacke.h	11248;"	d
LAPACK_chpcon	Eigen/src/misc/lapacke.h	10754;"	d
LAPACK_chpev	Eigen/src/misc/lapacke.h	11320;"	d
LAPACK_chpevd	Eigen/src/misc/lapacke.h	11324;"	d
LAPACK_chpevx	Eigen/src/misc/lapacke.h	11328;"	d
LAPACK_chpgst	Eigen/src/misc/lapacke.h	11176;"	d
LAPACK_chpgv	Eigen/src/misc/lapacke.h	11396;"	d
LAPACK_chpgvd	Eigen/src/misc/lapacke.h	11400;"	d
LAPACK_chpgvx	Eigen/src/misc/lapacke.h	11404;"	d
LAPACK_chprfs	Eigen/src/misc/lapacke.h	10824;"	d
LAPACK_chpsv	Eigen/src/misc/lapacke.h	11014;"	d
LAPACK_chpsvx	Eigen/src/misc/lapacke.h	11016;"	d
LAPACK_chptrd	Eigen/src/misc/lapacke.h	11130;"	d
LAPACK_chptrf	Eigen/src/misc/lapacke.h	10658;"	d
LAPACK_chptri	Eigen/src/misc/lapacke.h	10864;"	d
LAPACK_chptrs	Eigen/src/misc/lapacke.h	10702;"	d
LAPACK_chsein	Eigen/src/misc/lapacke.h	11212;"	d
LAPACK_chseqr	Eigen/src/misc/lapacke.h	11208;"	d
LAPACK_clacgv	Eigen/src/misc/lapacke.h	11470;"	d
LAPACK_clacpy	Eigen/src/misc/lapacke.h	11482;"	d
LAPACK_clag2z	Eigen/src/misc/lapacke.h	11534;"	d
LAPACK_clagge	Eigen/src/misc/lapacke.h	11542;"	d
LAPACK_claghe	Eigen/src/misc/lapacke.h	11554;"	d
LAPACK_clagsy	Eigen/src/misc/lapacke.h	11552;"	d
LAPACK_clange	Eigen/src/misc/lapacke.h	11494;"	d
LAPACK_clanhe	Eigen/src/misc/lapacke.h	11496;"	d
LAPACK_clansy	Eigen/src/misc/lapacke.h	11500;"	d
LAPACK_clantr	Eigen/src/misc/lapacke.h	11504;"	d
LAPACK_clapmr	Eigen/src/misc/lapacke.h	11558;"	d
LAPACK_clarfb	Eigen/src/misc/lapacke.h	11514;"	d
LAPACK_clarfg	Eigen/src/misc/lapacke.h	11518;"	d
LAPACK_clarft	Eigen/src/misc/lapacke.h	11522;"	d
LAPACK_clarfx	Eigen/src/misc/lapacke.h	11526;"	d
LAPACK_clarnv	Eigen/src/misc/lapacke.h	11474;"	d
LAPACK_claset	Eigen/src/misc/lapacke.h	11546;"	d
LAPACK_claswp	Eigen/src/misc/lapacke.h	11490;"	d
LAPACK_clatms	Eigen/src/misc/lapacke.h	11530;"	d
LAPACK_clauum	Eigen/src/misc/lapacke.h	11538;"	d
LAPACK_cpbcon	Eigen/src/misc/lapacke.h	10738;"	d
LAPACK_cpbequ	Eigen/src/misc/lapacke.h	10908;"	d
LAPACK_cpbrfs	Eigen/src/misc/lapacke.h	10802;"	d
LAPACK_cpbstf	Eigen/src/misc/lapacke.h	11184;"	d
LAPACK_cpbsv	Eigen/src/misc/lapacke.h	10974;"	d
LAPACK_cpbsvx	Eigen/src/misc/lapacke.h	10978;"	d
LAPACK_cpbtrf	Eigen/src/misc/lapacke.h	10642;"	d
LAPACK_cpbtrs	Eigen/src/misc/lapacke.h	10686;"	d
LAPACK_cpftrf	Eigen/src/misc/lapacke.h	10635;"	d
LAPACK_cpftri	Eigen/src/misc/lapacke.h	10849;"	d
LAPACK_cpftrs	Eigen/src/misc/lapacke.h	10679;"	d
LAPACK_cpocon	Eigen/src/misc/lapacke.h	10730;"	d
LAPACK_cpoequ	Eigen/src/misc/lapacke.h	10896;"	d
LAPACK_cpoequb	Eigen/src/misc/lapacke.h	10901;"	d
LAPACK_cporfs	Eigen/src/misc/lapacke.h	10790;"	d
LAPACK_cporfsx	Eigen/src/misc/lapacke.h	10795;"	d
LAPACK_cposv	Eigen/src/misc/lapacke.h	10952;"	d
LAPACK_cposvx	Eigen/src/misc/lapacke.h	10958;"	d
LAPACK_cposvxx	Eigen/src/misc/lapacke.h	10963;"	d
LAPACK_cpotrf	Eigen/src/misc/lapacke.h	10626;"	d
LAPACK_cpotri	Eigen/src/misc/lapacke.h	10844;"	d
LAPACK_cpotrs	Eigen/src/misc/lapacke.h	10674;"	d
LAPACK_cppcon	Eigen/src/misc/lapacke.h	10734;"	d
LAPACK_cppequ	Eigen/src/misc/lapacke.h	10904;"	d
LAPACK_cpprfs	Eigen/src/misc/lapacke.h	10798;"	d
LAPACK_cppsv	Eigen/src/misc/lapacke.h	10966;"	d
LAPACK_cppsvx	Eigen/src/misc/lapacke.h	10970;"	d
LAPACK_cpptrf	Eigen/src/misc/lapacke.h	10638;"	d
LAPACK_cpptri	Eigen/src/misc/lapacke.h	10852;"	d
LAPACK_cpptrs	Eigen/src/misc/lapacke.h	10682;"	d
LAPACK_cpstrf	Eigen/src/misc/lapacke.h	10631;"	d
LAPACK_cptcon	Eigen/src/misc/lapacke.h	10742;"	d
LAPACK_cpteqr	Eigen/src/misc/lapacke.h	11160;"	d
LAPACK_cptrfs	Eigen/src/misc/lapacke.h	10806;"	d
LAPACK_cptsv	Eigen/src/misc/lapacke.h	10982;"	d
LAPACK_cptsvx	Eigen/src/misc/lapacke.h	10986;"	d
LAPACK_cpttrf	Eigen/src/misc/lapacke.h	10646;"	d
LAPACK_cpttrs	Eigen/src/misc/lapacke.h	10690;"	d
LAPACK_cspcon	Eigen/src/misc/lapacke.h	10752;"	d
LAPACK_csprfs	Eigen/src/misc/lapacke.h	10822;"	d
LAPACK_cspsv	Eigen/src/misc/lapacke.h	11008;"	d
LAPACK_cspsvx	Eigen/src/misc/lapacke.h	11012;"	d
LAPACK_csptrf	Eigen/src/misc/lapacke.h	10656;"	d
LAPACK_csptri	Eigen/src/misc/lapacke.h	10862;"	d
LAPACK_csptrs	Eigen/src/misc/lapacke.h	10700;"	d
LAPACK_cstedc	Eigen/src/misc/lapacke.h	11152;"	d
LAPACK_cstegr	Eigen/src/misc/lapacke.h	11156;"	d
LAPACK_cstein	Eigen/src/misc/lapacke.h	11166;"	d
LAPACK_cstemr	Eigen/src/misc/lapacke.h	11148;"	d
LAPACK_csteqr	Eigen/src/misc/lapacke.h	11144;"	d
LAPACK_csycon	Eigen/src/misc/lapacke.h	10746;"	d
LAPACK_csyconv	Eigen/src/misc/lapacke.h	11574;"	d
LAPACK_csyequb	Eigen/src/misc/lapacke.h	10913;"	d
LAPACK_csyr	Eigen/src/misc/lapacke.h	11642;"	d
LAPACK_csyrfs	Eigen/src/misc/lapacke.h	10810;"	d
LAPACK_csyrfsx	Eigen/src/misc/lapacke.h	10815;"	d
LAPACK_csysv	Eigen/src/misc/lapacke.h	10990;"	d
LAPACK_csysvx	Eigen/src/misc/lapacke.h	10994;"	d
LAPACK_csysvxx	Eigen/src/misc/lapacke.h	10999;"	d
LAPACK_csyswapr	Eigen/src/misc/lapacke.h	11575;"	d
LAPACK_csytrf	Eigen/src/misc/lapacke.h	10650;"	d
LAPACK_csytri	Eigen/src/misc/lapacke.h	10856;"	d
LAPACK_csytri2	Eigen/src/misc/lapacke.h	11576;"	d
LAPACK_csytri2x	Eigen/src/misc/lapacke.h	11577;"	d
LAPACK_csytrs	Eigen/src/misc/lapacke.h	10694;"	d
LAPACK_csytrs2	Eigen/src/misc/lapacke.h	11578;"	d
LAPACK_ctbcon	Eigen/src/misc/lapacke.h	10766;"	d
LAPACK_ctbrfs	Eigen/src/misc/lapacke.h	10836;"	d
LAPACK_ctbtrs	Eigen/src/misc/lapacke.h	10714;"	d
LAPACK_ctfsm	Eigen/src/misc/lapacke.h	11441;"	d
LAPACK_ctftri	Eigen/src/misc/lapacke.h	10873;"	d
LAPACK_ctfttp	Eigen/src/misc/lapacke.h	11445;"	d
LAPACK_ctfttr	Eigen/src/misc/lapacke.h	11449;"	d
LAPACK_ctgevc	Eigen/src/misc/lapacke.h	11252;"	d
LAPACK_ctgexc	Eigen/src/misc/lapacke.h	11256;"	d
LAPACK_ctgsen	Eigen/src/misc/lapacke.h	11260;"	d
LAPACK_ctgsja	Eigen/src/misc/lapacke.h	11276;"	d
LAPACK_ctgsna	Eigen/src/misc/lapacke.h	11268;"	d
LAPACK_ctgsyl	Eigen/src/misc/lapacke.h	11264;"	d
LAPACK_ctpcon	Eigen/src/misc/lapacke.h	10762;"	d
LAPACK_ctpmqrt	Eigen/src/misc/lapacke.h	11628;"	d
LAPACK_ctpqrt	Eigen/src/misc/lapacke.h	11631;"	d
LAPACK_ctpqrt2	Eigen/src/misc/lapacke.h	11635;"	d
LAPACK_ctprfb	Eigen/src/misc/lapacke.h	11639;"	d
LAPACK_ctprfs	Eigen/src/misc/lapacke.h	10832;"	d
LAPACK_ctptri	Eigen/src/misc/lapacke.h	10876;"	d
LAPACK_ctptrs	Eigen/src/misc/lapacke.h	10710;"	d
LAPACK_ctpttf	Eigen/src/misc/lapacke.h	11453;"	d
LAPACK_ctpttr	Eigen/src/misc/lapacke.h	11457;"	d
LAPACK_ctrcon	Eigen/src/misc/lapacke.h	10758;"	d
LAPACK_ctrevc	Eigen/src/misc/lapacke.h	11216;"	d
LAPACK_ctrexc	Eigen/src/misc/lapacke.h	11224;"	d
LAPACK_ctrrfs	Eigen/src/misc/lapacke.h	10828;"	d
LAPACK_ctrsen	Eigen/src/misc/lapacke.h	11228;"	d
LAPACK_ctrsna	Eigen/src/misc/lapacke.h	11220;"	d
LAPACK_ctrsyl	Eigen/src/misc/lapacke.h	11232;"	d
LAPACK_ctrtri	Eigen/src/misc/lapacke.h	10868;"	d
LAPACK_ctrtrs	Eigen/src/misc/lapacke.h	10706;"	d
LAPACK_ctrttf	Eigen/src/misc/lapacke.h	11461;"	d
LAPACK_ctrttp	Eigen/src/misc/lapacke.h	11465;"	d
LAPACK_ctzrzf	Eigen/src/misc/lapacke.h	11076;"	d
LAPACK_cunbdb	Eigen/src/misc/lapacke.h	11579;"	d
LAPACK_cuncsd	Eigen/src/misc/lapacke.h	11580;"	d
LAPACK_cungbr	Eigen/src/misc/lapacke.h	11102;"	d
LAPACK_cunghr	Eigen/src/misc/lapacke.h	11194;"	d
LAPACK_cunglq	Eigen/src/misc/lapacke.h	11046;"	d
LAPACK_cungql	Eigen/src/misc/lapacke.h	11056;"	d
LAPACK_cungqr	Eigen/src/misc/lapacke.h	11034;"	d
LAPACK_cungrq	Eigen/src/misc/lapacke.h	11068;"	d
LAPACK_cungtr	Eigen/src/misc/lapacke.h	11120;"	d
LAPACK_cunmbr	Eigen/src/misc/lapacke.h	11104;"	d
LAPACK_cunmhr	Eigen/src/misc/lapacke.h	11196;"	d
LAPACK_cunmlq	Eigen/src/misc/lapacke.h	11048;"	d
LAPACK_cunmql	Eigen/src/misc/lapacke.h	11060;"	d
LAPACK_cunmqr	Eigen/src/misc/lapacke.h	11036;"	d
LAPACK_cunmrq	Eigen/src/misc/lapacke.h	11072;"	d
LAPACK_cunmrz	Eigen/src/misc/lapacke.h	11080;"	d
LAPACK_cunmtr	Eigen/src/misc/lapacke.h	11122;"	d
LAPACK_cupgtr	Eigen/src/misc/lapacke.h	11132;"	d
LAPACK_cupmtr	Eigen/src/misc/lapacke.h	11134;"	d
LAPACK_dbbcsd	Eigen/src/misc/lapacke.h	11581;"	d
LAPACK_dbdsdc	Eigen/src/misc/lapacke.h	11111;"	d
LAPACK_dbdsqr	Eigen/src/misc/lapacke.h	11107;"	d
LAPACK_ddisna	Eigen/src/misc/lapacke.h	11169;"	d
LAPACK_dgbbrd	Eigen/src/misc/lapacke.h	11095;"	d
LAPACK_dgbcon	Eigen/src/misc/lapacke.h	10721;"	d
LAPACK_dgbequ	Eigen/src/misc/lapacke.h	10887;"	d
LAPACK_dgbequb	Eigen/src/misc/lapacke.h	10890;"	d
LAPACK_dgbrfs	Eigen/src/misc/lapacke.h	10777;"	d
LAPACK_dgbrfsx	Eigen/src/misc/lapacke.h	10780;"	d
LAPACK_dgbsv	Eigen/src/misc/lapacke.h	10931;"	d
LAPACK_dgbsvx	Eigen/src/misc/lapacke.h	10935;"	d
LAPACK_dgbsvxx	Eigen/src/misc/lapacke.h	10938;"	d
LAPACK_dgbtrf	Eigen/src/misc/lapacke.h	10617;"	d
LAPACK_dgbtrs	Eigen/src/misc/lapacke.h	10665;"	d
LAPACK_dgebak	Eigen/src/misc/lapacke.h	11203;"	d
LAPACK_dgebal	Eigen/src/misc/lapacke.h	11199;"	d
LAPACK_dgebrd	Eigen/src/misc/lapacke.h	11091;"	d
LAPACK_dgecon	Eigen/src/misc/lapacke.h	10717;"	d
LAPACK_dgeequ	Eigen/src/misc/lapacke.h	10879;"	d
LAPACK_dgeequb	Eigen/src/misc/lapacke.h	10882;"	d
LAPACK_dgees	Eigen/src/misc/lapacke.h	11351;"	d
LAPACK_dgeesx	Eigen/src/misc/lapacke.h	11355;"	d
LAPACK_dgeev	Eigen/src/misc/lapacke.h	11359;"	d
LAPACK_dgeevx	Eigen/src/misc/lapacke.h	11363;"	d
LAPACK_dgehrd	Eigen/src/misc/lapacke.h	11187;"	d
LAPACK_dgejsv	Eigen/src/misc/lapacke.h	11374;"	d
LAPACK_dgelq2	Eigen/src/misc/lapacke.h	11509;"	d
LAPACK_dgelqf	Eigen/src/misc/lapacke.h	11039;"	d
LAPACK_dgels	Eigen/src/misc/lapacke.h	11279;"	d
LAPACK_dgelsd	Eigen/src/misc/lapacke.h	11291;"	d
LAPACK_dgelss	Eigen/src/misc/lapacke.h	11287;"	d
LAPACK_dgelsy	Eigen/src/misc/lapacke.h	11283;"	d
LAPACK_dgemqrt	Eigen/src/misc/lapacke.h	11611;"	d
LAPACK_dgeqlf	Eigen/src/misc/lapacke.h	11051;"	d
LAPACK_dgeqp3	Eigen/src/misc/lapacke.h	11027;"	d
LAPACK_dgeqpf	Eigen/src/misc/lapacke.h	11023;"	d
LAPACK_dgeqr2	Eigen/src/misc/lapacke.h	11477;"	d
LAPACK_dgeqrf	Eigen/src/misc/lapacke.h	11019;"	d
LAPACK_dgeqrfp	Eigen/src/misc/lapacke.h	11467;"	d
LAPACK_dgeqrt	Eigen/src/misc/lapacke.h	11615;"	d
LAPACK_dgeqrt2	Eigen/src/misc/lapacke.h	11619;"	d
LAPACK_dgeqrt3	Eigen/src/misc/lapacke.h	11623;"	d
LAPACK_dgerfs	Eigen/src/misc/lapacke.h	10769;"	d
LAPACK_dgerfsx	Eigen/src/misc/lapacke.h	10772;"	d
LAPACK_dgerqf	Eigen/src/misc/lapacke.h	11063;"	d
LAPACK_dgesdd	Eigen/src/misc/lapacke.h	11371;"	d
LAPACK_dgesv	Eigen/src/misc/lapacke.h	10917;"	d
LAPACK_dgesvd	Eigen/src/misc/lapacke.h	11367;"	d
LAPACK_dgesvj	Eigen/src/misc/lapacke.h	11376;"	d
LAPACK_dgesvx	Eigen/src/misc/lapacke.h	10923;"	d
LAPACK_dgesvxx	Eigen/src/misc/lapacke.h	10926;"	d
LAPACK_dgetf2	Eigen/src/misc/lapacke.h	11485;"	d
LAPACK_dgetrf	Eigen/src/misc/lapacke.h	10613;"	d
LAPACK_dgetri	Eigen/src/misc/lapacke.h	10839;"	d
LAPACK_dgetrs	Eigen/src/misc/lapacke.h	10661;"	d
LAPACK_dggbak	Eigen/src/misc/lapacke.h	11243;"	d
LAPACK_dggbal	Eigen/src/misc/lapacke.h	11239;"	d
LAPACK_dgges	Eigen/src/misc/lapacke.h	11419;"	d
LAPACK_dggesx	Eigen/src/misc/lapacke.h	11423;"	d
LAPACK_dggev	Eigen/src/misc/lapacke.h	11427;"	d
LAPACK_dggevx	Eigen/src/misc/lapacke.h	11431;"	d
LAPACK_dggglm	Eigen/src/misc/lapacke.h	11299;"	d
LAPACK_dgghrd	Eigen/src/misc/lapacke.h	11235;"	d
LAPACK_dgglse	Eigen/src/misc/lapacke.h	11295;"	d
LAPACK_dggqrf	Eigen/src/misc/lapacke.h	11083;"	d
LAPACK_dggrqf	Eigen/src/misc/lapacke.h	11087;"	d
LAPACK_dggsvd	Eigen/src/misc/lapacke.h	11379;"	d
LAPACK_dggsvp	Eigen/src/misc/lapacke.h	11271;"	d
LAPACK_dgtcon	Eigen/src/misc/lapacke.h	10725;"	d
LAPACK_dgtrfs	Eigen/src/misc/lapacke.h	10785;"	d
LAPACK_dgtsv	Eigen/src/misc/lapacke.h	10943;"	d
LAPACK_dgtsvx	Eigen/src/misc/lapacke.h	10947;"	d
LAPACK_dgttrf	Eigen/src/misc/lapacke.h	10621;"	d
LAPACK_dgttrs	Eigen/src/misc/lapacke.h	10669;"	d
LAPACK_dhgeqz	Eigen/src/misc/lapacke.h	11247;"	d
LAPACK_dhsein	Eigen/src/misc/lapacke.h	11211;"	d
LAPACK_dhseqr	Eigen/src/misc/lapacke.h	11207;"	d
LAPACK_dlacpy	Eigen/src/misc/lapacke.h	11481;"	d
LAPACK_dlag2s	Eigen/src/misc/lapacke.h	11533;"	d
LAPACK_dlagge	Eigen/src/misc/lapacke.h	11541;"	d
LAPACK_dlagsy	Eigen/src/misc/lapacke.h	11551;"	d
LAPACK_dlamch	Eigen/src/misc/lapacke.h	11507;"	d
LAPACK_dlange	Eigen/src/misc/lapacke.h	11493;"	d
LAPACK_dlansy	Eigen/src/misc/lapacke.h	11499;"	d
LAPACK_dlantr	Eigen/src/misc/lapacke.h	11503;"	d
LAPACK_dlapmr	Eigen/src/misc/lapacke.h	11557;"	d
LAPACK_dlapy2	Eigen/src/misc/lapacke.h	11561;"	d
LAPACK_dlapy3	Eigen/src/misc/lapacke.h	11563;"	d
LAPACK_dlarfb	Eigen/src/misc/lapacke.h	11513;"	d
LAPACK_dlarfg	Eigen/src/misc/lapacke.h	11517;"	d
LAPACK_dlarft	Eigen/src/misc/lapacke.h	11521;"	d
LAPACK_dlarfx	Eigen/src/misc/lapacke.h	11525;"	d
LAPACK_dlarnv	Eigen/src/misc/lapacke.h	11473;"	d
LAPACK_dlartgp	Eigen/src/misc/lapacke.h	11565;"	d
LAPACK_dlartgs	Eigen/src/misc/lapacke.h	11567;"	d
LAPACK_dlaset	Eigen/src/misc/lapacke.h	11545;"	d
LAPACK_dlasrt	Eigen/src/misc/lapacke.h	11549;"	d
LAPACK_dlaswp	Eigen/src/misc/lapacke.h	11489;"	d
LAPACK_dlatms	Eigen/src/misc/lapacke.h	11529;"	d
LAPACK_dlauum	Eigen/src/misc/lapacke.h	11537;"	d
LAPACK_dopgtr	Eigen/src/misc/lapacke.h	11127;"	d
LAPACK_dopmtr	Eigen/src/misc/lapacke.h	11129;"	d
LAPACK_dorbdb	Eigen/src/misc/lapacke.h	11582;"	d
LAPACK_dorcsd	Eigen/src/misc/lapacke.h	11583;"	d
LAPACK_dorgbr	Eigen/src/misc/lapacke.h	11099;"	d
LAPACK_dorghr	Eigen/src/misc/lapacke.h	11191;"	d
LAPACK_dorglq	Eigen/src/misc/lapacke.h	11043;"	d
LAPACK_dorgql	Eigen/src/misc/lapacke.h	11055;"	d
LAPACK_dorgqr	Eigen/src/misc/lapacke.h	11031;"	d
LAPACK_dorgrq	Eigen/src/misc/lapacke.h	11067;"	d
LAPACK_dorgtr	Eigen/src/misc/lapacke.h	11115;"	d
LAPACK_dormbr	Eigen/src/misc/lapacke.h	11101;"	d
LAPACK_dormhr	Eigen/src/misc/lapacke.h	11193;"	d
LAPACK_dormlq	Eigen/src/misc/lapacke.h	11045;"	d
LAPACK_dormql	Eigen/src/misc/lapacke.h	11059;"	d
LAPACK_dormqr	Eigen/src/misc/lapacke.h	11033;"	d
LAPACK_dormrq	Eigen/src/misc/lapacke.h	11071;"	d
LAPACK_dormrz	Eigen/src/misc/lapacke.h	11079;"	d
LAPACK_dormtr	Eigen/src/misc/lapacke.h	11117;"	d
LAPACK_dpbcon	Eigen/src/misc/lapacke.h	10737;"	d
LAPACK_dpbequ	Eigen/src/misc/lapacke.h	10907;"	d
LAPACK_dpbrfs	Eigen/src/misc/lapacke.h	10801;"	d
LAPACK_dpbstf	Eigen/src/misc/lapacke.h	11183;"	d
LAPACK_dpbsv	Eigen/src/misc/lapacke.h	10973;"	d
LAPACK_dpbsvx	Eigen/src/misc/lapacke.h	10977;"	d
LAPACK_dpbtrf	Eigen/src/misc/lapacke.h	10641;"	d
LAPACK_dpbtrs	Eigen/src/misc/lapacke.h	10685;"	d
LAPACK_dpftrf	Eigen/src/misc/lapacke.h	10632;"	d
LAPACK_dpftri	Eigen/src/misc/lapacke.h	10846;"	d
LAPACK_dpftrs	Eigen/src/misc/lapacke.h	10676;"	d
LAPACK_dpocon	Eigen/src/misc/lapacke.h	10729;"	d
LAPACK_dpoequ	Eigen/src/misc/lapacke.h	10895;"	d
LAPACK_dpoequb	Eigen/src/misc/lapacke.h	10898;"	d
LAPACK_dporfs	Eigen/src/misc/lapacke.h	10789;"	d
LAPACK_dporfsx	Eigen/src/misc/lapacke.h	10792;"	d
LAPACK_dposv	Eigen/src/misc/lapacke.h	10951;"	d
LAPACK_dposvx	Eigen/src/misc/lapacke.h	10957;"	d
LAPACK_dposvxx	Eigen/src/misc/lapacke.h	10960;"	d
LAPACK_dpotrf	Eigen/src/misc/lapacke.h	10625;"	d
LAPACK_dpotri	Eigen/src/misc/lapacke.h	10843;"	d
LAPACK_dpotrs	Eigen/src/misc/lapacke.h	10673;"	d
LAPACK_dppcon	Eigen/src/misc/lapacke.h	10733;"	d
LAPACK_dppequ	Eigen/src/misc/lapacke.h	10903;"	d
LAPACK_dpprfs	Eigen/src/misc/lapacke.h	10797;"	d
LAPACK_dppsv	Eigen/src/misc/lapacke.h	10965;"	d
LAPACK_dppsvx	Eigen/src/misc/lapacke.h	10969;"	d
LAPACK_dpptrf	Eigen/src/misc/lapacke.h	10637;"	d
LAPACK_dpptri	Eigen/src/misc/lapacke.h	10851;"	d
LAPACK_dpptrs	Eigen/src/misc/lapacke.h	10681;"	d
LAPACK_dpstrf	Eigen/src/misc/lapacke.h	10628;"	d
LAPACK_dptcon	Eigen/src/misc/lapacke.h	10741;"	d
LAPACK_dpteqr	Eigen/src/misc/lapacke.h	11159;"	d
LAPACK_dptrfs	Eigen/src/misc/lapacke.h	10805;"	d
LAPACK_dptsv	Eigen/src/misc/lapacke.h	10981;"	d
LAPACK_dptsvx	Eigen/src/misc/lapacke.h	10985;"	d
LAPACK_dpttrf	Eigen/src/misc/lapacke.h	10645;"	d
LAPACK_dpttrs	Eigen/src/misc/lapacke.h	10689;"	d
LAPACK_dsbev	Eigen/src/misc/lapacke.h	11331;"	d
LAPACK_dsbevd	Eigen/src/misc/lapacke.h	11335;"	d
LAPACK_dsbevx	Eigen/src/misc/lapacke.h	11339;"	d
LAPACK_dsbgst	Eigen/src/misc/lapacke.h	11179;"	d
LAPACK_dsbgv	Eigen/src/misc/lapacke.h	11407;"	d
LAPACK_dsbgvd	Eigen/src/misc/lapacke.h	11411;"	d
LAPACK_dsbgvx	Eigen/src/misc/lapacke.h	11415;"	d
LAPACK_dsbtrd	Eigen/src/misc/lapacke.h	11137;"	d
LAPACK_dsfrk	Eigen/src/misc/lapacke.h	11434;"	d
LAPACK_dsgesv	Eigen/src/misc/lapacke.h	10920;"	d
LAPACK_dspcon	Eigen/src/misc/lapacke.h	10751;"	d
LAPACK_dspev	Eigen/src/misc/lapacke.h	11319;"	d
LAPACK_dspevd	Eigen/src/misc/lapacke.h	11323;"	d
LAPACK_dspevx	Eigen/src/misc/lapacke.h	11327;"	d
LAPACK_dspgst	Eigen/src/misc/lapacke.h	11175;"	d
LAPACK_dspgv	Eigen/src/misc/lapacke.h	11395;"	d
LAPACK_dspgvd	Eigen/src/misc/lapacke.h	11399;"	d
LAPACK_dspgvx	Eigen/src/misc/lapacke.h	11403;"	d
LAPACK_dsposv	Eigen/src/misc/lapacke.h	10954;"	d
LAPACK_dsprfs	Eigen/src/misc/lapacke.h	10821;"	d
LAPACK_dspsv	Eigen/src/misc/lapacke.h	11007;"	d
LAPACK_dspsvx	Eigen/src/misc/lapacke.h	11011;"	d
LAPACK_dsptrd	Eigen/src/misc/lapacke.h	11125;"	d
LAPACK_dsptrf	Eigen/src/misc/lapacke.h	10655;"	d
LAPACK_dsptri	Eigen/src/misc/lapacke.h	10861;"	d
LAPACK_dsptrs	Eigen/src/misc/lapacke.h	10699;"	d
LAPACK_dstebz	Eigen/src/misc/lapacke.h	11163;"	d
LAPACK_dstedc	Eigen/src/misc/lapacke.h	11151;"	d
LAPACK_dstegr	Eigen/src/misc/lapacke.h	11155;"	d
LAPACK_dstein	Eigen/src/misc/lapacke.h	11165;"	d
LAPACK_dstemr	Eigen/src/misc/lapacke.h	11147;"	d
LAPACK_dsteqr	Eigen/src/misc/lapacke.h	11143;"	d
LAPACK_dsterf	Eigen/src/misc/lapacke.h	11141;"	d
LAPACK_dstev	Eigen/src/misc/lapacke.h	11343;"	d
LAPACK_dstevd	Eigen/src/misc/lapacke.h	11345;"	d
LAPACK_dstevr	Eigen/src/misc/lapacke.h	11349;"	d
LAPACK_dstevx	Eigen/src/misc/lapacke.h	11347;"	d
LAPACK_dsycon	Eigen/src/misc/lapacke.h	10745;"	d
LAPACK_dsyconv	Eigen/src/misc/lapacke.h	11584;"	d
LAPACK_dsyequb	Eigen/src/misc/lapacke.h	10910;"	d
LAPACK_dsyev	Eigen/src/misc/lapacke.h	11303;"	d
LAPACK_dsyevd	Eigen/src/misc/lapacke.h	11307;"	d
LAPACK_dsyevr	Eigen/src/misc/lapacke.h	11315;"	d
LAPACK_dsyevx	Eigen/src/misc/lapacke.h	11311;"	d
LAPACK_dsygst	Eigen/src/misc/lapacke.h	11171;"	d
LAPACK_dsygv	Eigen/src/misc/lapacke.h	11383;"	d
LAPACK_dsygvd	Eigen/src/misc/lapacke.h	11387;"	d
LAPACK_dsygvx	Eigen/src/misc/lapacke.h	11391;"	d
LAPACK_dsyrfs	Eigen/src/misc/lapacke.h	10809;"	d
LAPACK_dsyrfsx	Eigen/src/misc/lapacke.h	10812;"	d
LAPACK_dsysv	Eigen/src/misc/lapacke.h	10989;"	d
LAPACK_dsysvx	Eigen/src/misc/lapacke.h	10993;"	d
LAPACK_dsysvxx	Eigen/src/misc/lapacke.h	10996;"	d
LAPACK_dsyswapr	Eigen/src/misc/lapacke.h	11585;"	d
LAPACK_dsytrd	Eigen/src/misc/lapacke.h	11113;"	d
LAPACK_dsytrf	Eigen/src/misc/lapacke.h	10649;"	d
LAPACK_dsytri	Eigen/src/misc/lapacke.h	10855;"	d
LAPACK_dsytri2	Eigen/src/misc/lapacke.h	11586;"	d
LAPACK_dsytri2x	Eigen/src/misc/lapacke.h	11587;"	d
LAPACK_dsytrs	Eigen/src/misc/lapacke.h	10693;"	d
LAPACK_dsytrs2	Eigen/src/misc/lapacke.h	11588;"	d
LAPACK_dtbcon	Eigen/src/misc/lapacke.h	10765;"	d
LAPACK_dtbrfs	Eigen/src/misc/lapacke.h	10835;"	d
LAPACK_dtbtrs	Eigen/src/misc/lapacke.h	10713;"	d
LAPACK_dtfsm	Eigen/src/misc/lapacke.h	11438;"	d
LAPACK_dtftri	Eigen/src/misc/lapacke.h	10870;"	d
LAPACK_dtfttp	Eigen/src/misc/lapacke.h	11442;"	d
LAPACK_dtfttr	Eigen/src/misc/lapacke.h	11446;"	d
LAPACK_dtgevc	Eigen/src/misc/lapacke.h	11251;"	d
LAPACK_dtgexc	Eigen/src/misc/lapacke.h	11255;"	d
LAPACK_dtgsen	Eigen/src/misc/lapacke.h	11259;"	d
LAPACK_dtgsja	Eigen/src/misc/lapacke.h	11275;"	d
LAPACK_dtgsna	Eigen/src/misc/lapacke.h	11267;"	d
LAPACK_dtgsyl	Eigen/src/misc/lapacke.h	11263;"	d
LAPACK_dtpcon	Eigen/src/misc/lapacke.h	10761;"	d
LAPACK_dtpmqrt	Eigen/src/misc/lapacke.h	11627;"	d
LAPACK_dtpqrt	Eigen/src/misc/lapacke.h	11630;"	d
LAPACK_dtpqrt2	Eigen/src/misc/lapacke.h	11634;"	d
LAPACK_dtprfb	Eigen/src/misc/lapacke.h	11638;"	d
LAPACK_dtprfs	Eigen/src/misc/lapacke.h	10831;"	d
LAPACK_dtptri	Eigen/src/misc/lapacke.h	10875;"	d
LAPACK_dtptrs	Eigen/src/misc/lapacke.h	10709;"	d
LAPACK_dtpttf	Eigen/src/misc/lapacke.h	11450;"	d
LAPACK_dtpttr	Eigen/src/misc/lapacke.h	11454;"	d
LAPACK_dtrcon	Eigen/src/misc/lapacke.h	10757;"	d
LAPACK_dtrevc	Eigen/src/misc/lapacke.h	11215;"	d
LAPACK_dtrexc	Eigen/src/misc/lapacke.h	11223;"	d
LAPACK_dtrrfs	Eigen/src/misc/lapacke.h	10827;"	d
LAPACK_dtrsen	Eigen/src/misc/lapacke.h	11227;"	d
LAPACK_dtrsna	Eigen/src/misc/lapacke.h	11219;"	d
LAPACK_dtrsyl	Eigen/src/misc/lapacke.h	11231;"	d
LAPACK_dtrtri	Eigen/src/misc/lapacke.h	10867;"	d
LAPACK_dtrtrs	Eigen/src/misc/lapacke.h	10705;"	d
LAPACK_dtrttf	Eigen/src/misc/lapacke.h	11458;"	d
LAPACK_dtrttp	Eigen/src/misc/lapacke.h	11462;"	d
LAPACK_dtzrzf	Eigen/src/misc/lapacke.h	11075;"	d
LAPACK_lsame	Eigen/src/misc/lapacke.h	147;"	d
LAPACK_sbbcsd	Eigen/src/misc/lapacke.h	11589;"	d
LAPACK_sbdsdc	Eigen/src/misc/lapacke.h	11110;"	d
LAPACK_sbdsqr	Eigen/src/misc/lapacke.h	11106;"	d
LAPACK_sdisna	Eigen/src/misc/lapacke.h	11168;"	d
LAPACK_sgbbrd	Eigen/src/misc/lapacke.h	11094;"	d
LAPACK_sgbcon	Eigen/src/misc/lapacke.h	10720;"	d
LAPACK_sgbequ	Eigen/src/misc/lapacke.h	10886;"	d
LAPACK_sgbequb	Eigen/src/misc/lapacke.h	10891;"	d
LAPACK_sgbrfs	Eigen/src/misc/lapacke.h	10776;"	d
LAPACK_sgbrfsx	Eigen/src/misc/lapacke.h	10781;"	d
LAPACK_sgbsv	Eigen/src/misc/lapacke.h	10930;"	d
LAPACK_sgbsvx	Eigen/src/misc/lapacke.h	10934;"	d
LAPACK_sgbsvxx	Eigen/src/misc/lapacke.h	10939;"	d
LAPACK_sgbtrf	Eigen/src/misc/lapacke.h	10616;"	d
LAPACK_sgbtrs	Eigen/src/misc/lapacke.h	10664;"	d
LAPACK_sgebak	Eigen/src/misc/lapacke.h	11202;"	d
LAPACK_sgebal	Eigen/src/misc/lapacke.h	11198;"	d
LAPACK_sgebrd	Eigen/src/misc/lapacke.h	11090;"	d
LAPACK_sgecon	Eigen/src/misc/lapacke.h	10716;"	d
LAPACK_sgeequ	Eigen/src/misc/lapacke.h	10878;"	d
LAPACK_sgeequb	Eigen/src/misc/lapacke.h	10883;"	d
LAPACK_sgees	Eigen/src/misc/lapacke.h	11350;"	d
LAPACK_sgeesx	Eigen/src/misc/lapacke.h	11354;"	d
LAPACK_sgeev	Eigen/src/misc/lapacke.h	11358;"	d
LAPACK_sgeevx	Eigen/src/misc/lapacke.h	11362;"	d
LAPACK_sgehrd	Eigen/src/misc/lapacke.h	11186;"	d
LAPACK_sgejsv	Eigen/src/misc/lapacke.h	11375;"	d
LAPACK_sgelq2	Eigen/src/misc/lapacke.h	11508;"	d
LAPACK_sgelqf	Eigen/src/misc/lapacke.h	11038;"	d
LAPACK_sgels	Eigen/src/misc/lapacke.h	11278;"	d
LAPACK_sgelsd	Eigen/src/misc/lapacke.h	11290;"	d
LAPACK_sgelss	Eigen/src/misc/lapacke.h	11286;"	d
LAPACK_sgelsy	Eigen/src/misc/lapacke.h	11282;"	d
LAPACK_sgemqrt	Eigen/src/misc/lapacke.h	11610;"	d
LAPACK_sgeqlf	Eigen/src/misc/lapacke.h	11050;"	d
LAPACK_sgeqp3	Eigen/src/misc/lapacke.h	11026;"	d
LAPACK_sgeqpf	Eigen/src/misc/lapacke.h	11022;"	d
LAPACK_sgeqr2	Eigen/src/misc/lapacke.h	11476;"	d
LAPACK_sgeqrf	Eigen/src/misc/lapacke.h	11018;"	d
LAPACK_sgeqrfp	Eigen/src/misc/lapacke.h	11466;"	d
LAPACK_sgeqrt	Eigen/src/misc/lapacke.h	11614;"	d
LAPACK_sgeqrt2	Eigen/src/misc/lapacke.h	11618;"	d
LAPACK_sgeqrt3	Eigen/src/misc/lapacke.h	11622;"	d
LAPACK_sgerfs	Eigen/src/misc/lapacke.h	10768;"	d
LAPACK_sgerfsx	Eigen/src/misc/lapacke.h	10773;"	d
LAPACK_sgerqf	Eigen/src/misc/lapacke.h	11062;"	d
LAPACK_sgesdd	Eigen/src/misc/lapacke.h	11370;"	d
LAPACK_sgesv	Eigen/src/misc/lapacke.h	10916;"	d
LAPACK_sgesvd	Eigen/src/misc/lapacke.h	11366;"	d
LAPACK_sgesvj	Eigen/src/misc/lapacke.h	11377;"	d
LAPACK_sgesvx	Eigen/src/misc/lapacke.h	10922;"	d
LAPACK_sgesvxx	Eigen/src/misc/lapacke.h	10927;"	d
LAPACK_sgetf2	Eigen/src/misc/lapacke.h	11484;"	d
LAPACK_sgetrf	Eigen/src/misc/lapacke.h	10612;"	d
LAPACK_sgetri	Eigen/src/misc/lapacke.h	10838;"	d
LAPACK_sgetrs	Eigen/src/misc/lapacke.h	10660;"	d
LAPACK_sggbak	Eigen/src/misc/lapacke.h	11242;"	d
LAPACK_sggbal	Eigen/src/misc/lapacke.h	11238;"	d
LAPACK_sgges	Eigen/src/misc/lapacke.h	11418;"	d
LAPACK_sggesx	Eigen/src/misc/lapacke.h	11422;"	d
LAPACK_sggev	Eigen/src/misc/lapacke.h	11426;"	d
LAPACK_sggevx	Eigen/src/misc/lapacke.h	11430;"	d
LAPACK_sggglm	Eigen/src/misc/lapacke.h	11298;"	d
LAPACK_sgghrd	Eigen/src/misc/lapacke.h	11234;"	d
LAPACK_sgglse	Eigen/src/misc/lapacke.h	11294;"	d
LAPACK_sggqrf	Eigen/src/misc/lapacke.h	11082;"	d
LAPACK_sggrqf	Eigen/src/misc/lapacke.h	11086;"	d
LAPACK_sggsvd	Eigen/src/misc/lapacke.h	11378;"	d
LAPACK_sggsvp	Eigen/src/misc/lapacke.h	11270;"	d
LAPACK_sgtcon	Eigen/src/misc/lapacke.h	10724;"	d
LAPACK_sgtrfs	Eigen/src/misc/lapacke.h	10784;"	d
LAPACK_sgtsv	Eigen/src/misc/lapacke.h	10942;"	d
LAPACK_sgtsvx	Eigen/src/misc/lapacke.h	10946;"	d
LAPACK_sgttrf	Eigen/src/misc/lapacke.h	10620;"	d
LAPACK_sgttrs	Eigen/src/misc/lapacke.h	10668;"	d
LAPACK_shgeqz	Eigen/src/misc/lapacke.h	11246;"	d
LAPACK_shsein	Eigen/src/misc/lapacke.h	11210;"	d
LAPACK_shseqr	Eigen/src/misc/lapacke.h	11206;"	d
LAPACK_slacpy	Eigen/src/misc/lapacke.h	11480;"	d
LAPACK_slag2d	Eigen/src/misc/lapacke.h	11532;"	d
LAPACK_slagge	Eigen/src/misc/lapacke.h	11540;"	d
LAPACK_slagsy	Eigen/src/misc/lapacke.h	11550;"	d
LAPACK_slamch	Eigen/src/misc/lapacke.h	11506;"	d
LAPACK_slange	Eigen/src/misc/lapacke.h	11492;"	d
LAPACK_slansy	Eigen/src/misc/lapacke.h	11498;"	d
LAPACK_slantr	Eigen/src/misc/lapacke.h	11502;"	d
LAPACK_slapmr	Eigen/src/misc/lapacke.h	11556;"	d
LAPACK_slapy2	Eigen/src/misc/lapacke.h	11560;"	d
LAPACK_slapy3	Eigen/src/misc/lapacke.h	11562;"	d
LAPACK_slarfb	Eigen/src/misc/lapacke.h	11512;"	d
LAPACK_slarfg	Eigen/src/misc/lapacke.h	11516;"	d
LAPACK_slarft	Eigen/src/misc/lapacke.h	11520;"	d
LAPACK_slarfx	Eigen/src/misc/lapacke.h	11524;"	d
LAPACK_slarnv	Eigen/src/misc/lapacke.h	11472;"	d
LAPACK_slartgp	Eigen/src/misc/lapacke.h	11564;"	d
LAPACK_slartgs	Eigen/src/misc/lapacke.h	11566;"	d
LAPACK_slaset	Eigen/src/misc/lapacke.h	11544;"	d
LAPACK_slasrt	Eigen/src/misc/lapacke.h	11548;"	d
LAPACK_slaswp	Eigen/src/misc/lapacke.h	11488;"	d
LAPACK_slatms	Eigen/src/misc/lapacke.h	11528;"	d
LAPACK_slauum	Eigen/src/misc/lapacke.h	11536;"	d
LAPACK_sopgtr	Eigen/src/misc/lapacke.h	11126;"	d
LAPACK_sopmtr	Eigen/src/misc/lapacke.h	11128;"	d
LAPACK_sorbdb	Eigen/src/misc/lapacke.h	11590;"	d
LAPACK_sorcsd	Eigen/src/misc/lapacke.h	11591;"	d
LAPACK_sorgbr	Eigen/src/misc/lapacke.h	11098;"	d
LAPACK_sorghr	Eigen/src/misc/lapacke.h	11190;"	d
LAPACK_sorglq	Eigen/src/misc/lapacke.h	11042;"	d
LAPACK_sorgql	Eigen/src/misc/lapacke.h	11054;"	d
LAPACK_sorgqr	Eigen/src/misc/lapacke.h	11030;"	d
LAPACK_sorgrq	Eigen/src/misc/lapacke.h	11066;"	d
LAPACK_sorgtr	Eigen/src/misc/lapacke.h	11114;"	d
LAPACK_sormbr	Eigen/src/misc/lapacke.h	11100;"	d
LAPACK_sormhr	Eigen/src/misc/lapacke.h	11192;"	d
LAPACK_sormlq	Eigen/src/misc/lapacke.h	11044;"	d
LAPACK_sormql	Eigen/src/misc/lapacke.h	11058;"	d
LAPACK_sormqr	Eigen/src/misc/lapacke.h	11032;"	d
LAPACK_sormrq	Eigen/src/misc/lapacke.h	11070;"	d
LAPACK_sormrz	Eigen/src/misc/lapacke.h	11078;"	d
LAPACK_sormtr	Eigen/src/misc/lapacke.h	11116;"	d
LAPACK_spbcon	Eigen/src/misc/lapacke.h	10736;"	d
LAPACK_spbequ	Eigen/src/misc/lapacke.h	10906;"	d
LAPACK_spbrfs	Eigen/src/misc/lapacke.h	10800;"	d
LAPACK_spbstf	Eigen/src/misc/lapacke.h	11182;"	d
LAPACK_spbsv	Eigen/src/misc/lapacke.h	10972;"	d
LAPACK_spbsvx	Eigen/src/misc/lapacke.h	10976;"	d
LAPACK_spbtrf	Eigen/src/misc/lapacke.h	10640;"	d
LAPACK_spbtrs	Eigen/src/misc/lapacke.h	10684;"	d
LAPACK_spftrf	Eigen/src/misc/lapacke.h	10633;"	d
LAPACK_spftri	Eigen/src/misc/lapacke.h	10847;"	d
LAPACK_spftrs	Eigen/src/misc/lapacke.h	10677;"	d
LAPACK_spocon	Eigen/src/misc/lapacke.h	10728;"	d
LAPACK_spoequ	Eigen/src/misc/lapacke.h	10894;"	d
LAPACK_spoequb	Eigen/src/misc/lapacke.h	10899;"	d
LAPACK_sporfs	Eigen/src/misc/lapacke.h	10788;"	d
LAPACK_sporfsx	Eigen/src/misc/lapacke.h	10793;"	d
LAPACK_sposv	Eigen/src/misc/lapacke.h	10950;"	d
LAPACK_sposvx	Eigen/src/misc/lapacke.h	10956;"	d
LAPACK_sposvxx	Eigen/src/misc/lapacke.h	10961;"	d
LAPACK_spotrf	Eigen/src/misc/lapacke.h	10624;"	d
LAPACK_spotri	Eigen/src/misc/lapacke.h	10842;"	d
LAPACK_spotrs	Eigen/src/misc/lapacke.h	10672;"	d
LAPACK_sppcon	Eigen/src/misc/lapacke.h	10732;"	d
LAPACK_sppequ	Eigen/src/misc/lapacke.h	10902;"	d
LAPACK_spprfs	Eigen/src/misc/lapacke.h	10796;"	d
LAPACK_sppsv	Eigen/src/misc/lapacke.h	10964;"	d
LAPACK_sppsvx	Eigen/src/misc/lapacke.h	10968;"	d
LAPACK_spptrf	Eigen/src/misc/lapacke.h	10636;"	d
LAPACK_spptri	Eigen/src/misc/lapacke.h	10850;"	d
LAPACK_spptrs	Eigen/src/misc/lapacke.h	10680;"	d
LAPACK_spstrf	Eigen/src/misc/lapacke.h	10629;"	d
LAPACK_sptcon	Eigen/src/misc/lapacke.h	10740;"	d
LAPACK_spteqr	Eigen/src/misc/lapacke.h	11158;"	d
LAPACK_sptrfs	Eigen/src/misc/lapacke.h	10804;"	d
LAPACK_sptsv	Eigen/src/misc/lapacke.h	10980;"	d
LAPACK_sptsvx	Eigen/src/misc/lapacke.h	10984;"	d
LAPACK_spttrf	Eigen/src/misc/lapacke.h	10644;"	d
LAPACK_spttrs	Eigen/src/misc/lapacke.h	10688;"	d
LAPACK_ssbev	Eigen/src/misc/lapacke.h	11330;"	d
LAPACK_ssbevd	Eigen/src/misc/lapacke.h	11334;"	d
LAPACK_ssbevx	Eigen/src/misc/lapacke.h	11338;"	d
LAPACK_ssbgst	Eigen/src/misc/lapacke.h	11178;"	d
LAPACK_ssbgv	Eigen/src/misc/lapacke.h	11406;"	d
LAPACK_ssbgvd	Eigen/src/misc/lapacke.h	11410;"	d
LAPACK_ssbgvx	Eigen/src/misc/lapacke.h	11414;"	d
LAPACK_ssbtrd	Eigen/src/misc/lapacke.h	11136;"	d
LAPACK_ssfrk	Eigen/src/misc/lapacke.h	11435;"	d
LAPACK_sspcon	Eigen/src/misc/lapacke.h	10750;"	d
LAPACK_sspev	Eigen/src/misc/lapacke.h	11318;"	d
LAPACK_sspevd	Eigen/src/misc/lapacke.h	11322;"	d
LAPACK_sspevx	Eigen/src/misc/lapacke.h	11326;"	d
LAPACK_sspgst	Eigen/src/misc/lapacke.h	11174;"	d
LAPACK_sspgv	Eigen/src/misc/lapacke.h	11394;"	d
LAPACK_sspgvd	Eigen/src/misc/lapacke.h	11398;"	d
LAPACK_sspgvx	Eigen/src/misc/lapacke.h	11402;"	d
LAPACK_ssprfs	Eigen/src/misc/lapacke.h	10820;"	d
LAPACK_sspsv	Eigen/src/misc/lapacke.h	11006;"	d
LAPACK_sspsvx	Eigen/src/misc/lapacke.h	11010;"	d
LAPACK_ssptrd	Eigen/src/misc/lapacke.h	11124;"	d
LAPACK_ssptrf	Eigen/src/misc/lapacke.h	10654;"	d
LAPACK_ssptri	Eigen/src/misc/lapacke.h	10860;"	d
LAPACK_ssptrs	Eigen/src/misc/lapacke.h	10698;"	d
LAPACK_sstebz	Eigen/src/misc/lapacke.h	11162;"	d
LAPACK_sstedc	Eigen/src/misc/lapacke.h	11150;"	d
LAPACK_sstegr	Eigen/src/misc/lapacke.h	11154;"	d
LAPACK_sstein	Eigen/src/misc/lapacke.h	11164;"	d
LAPACK_sstemr	Eigen/src/misc/lapacke.h	11146;"	d
LAPACK_ssteqr	Eigen/src/misc/lapacke.h	11142;"	d
LAPACK_ssterf	Eigen/src/misc/lapacke.h	11140;"	d
LAPACK_sstev	Eigen/src/misc/lapacke.h	11342;"	d
LAPACK_sstevd	Eigen/src/misc/lapacke.h	11344;"	d
LAPACK_sstevr	Eigen/src/misc/lapacke.h	11348;"	d
LAPACK_sstevx	Eigen/src/misc/lapacke.h	11346;"	d
LAPACK_ssycon	Eigen/src/misc/lapacke.h	10744;"	d
LAPACK_ssyconv	Eigen/src/misc/lapacke.h	11592;"	d
LAPACK_ssyequb	Eigen/src/misc/lapacke.h	10911;"	d
LAPACK_ssyev	Eigen/src/misc/lapacke.h	11302;"	d
LAPACK_ssyevd	Eigen/src/misc/lapacke.h	11306;"	d
LAPACK_ssyevr	Eigen/src/misc/lapacke.h	11314;"	d
LAPACK_ssyevx	Eigen/src/misc/lapacke.h	11310;"	d
LAPACK_ssygst	Eigen/src/misc/lapacke.h	11170;"	d
LAPACK_ssygv	Eigen/src/misc/lapacke.h	11382;"	d
LAPACK_ssygvd	Eigen/src/misc/lapacke.h	11386;"	d
LAPACK_ssygvx	Eigen/src/misc/lapacke.h	11390;"	d
LAPACK_ssyrfs	Eigen/src/misc/lapacke.h	10808;"	d
LAPACK_ssyrfsx	Eigen/src/misc/lapacke.h	10813;"	d
LAPACK_ssysv	Eigen/src/misc/lapacke.h	10988;"	d
LAPACK_ssysvx	Eigen/src/misc/lapacke.h	10992;"	d
LAPACK_ssysvxx	Eigen/src/misc/lapacke.h	10997;"	d
LAPACK_ssyswapr	Eigen/src/misc/lapacke.h	11593;"	d
LAPACK_ssytrd	Eigen/src/misc/lapacke.h	11112;"	d
LAPACK_ssytrf	Eigen/src/misc/lapacke.h	10648;"	d
LAPACK_ssytri	Eigen/src/misc/lapacke.h	10854;"	d
LAPACK_ssytri2	Eigen/src/misc/lapacke.h	11594;"	d
LAPACK_ssytri2x	Eigen/src/misc/lapacke.h	11595;"	d
LAPACK_ssytrs	Eigen/src/misc/lapacke.h	10692;"	d
LAPACK_ssytrs2	Eigen/src/misc/lapacke.h	11596;"	d
LAPACK_stbcon	Eigen/src/misc/lapacke.h	10764;"	d
LAPACK_stbrfs	Eigen/src/misc/lapacke.h	10834;"	d
LAPACK_stbtrs	Eigen/src/misc/lapacke.h	10712;"	d
LAPACK_stfsm	Eigen/src/misc/lapacke.h	11439;"	d
LAPACK_stftri	Eigen/src/misc/lapacke.h	10871;"	d
LAPACK_stfttp	Eigen/src/misc/lapacke.h	11443;"	d
LAPACK_stfttr	Eigen/src/misc/lapacke.h	11447;"	d
LAPACK_stgevc	Eigen/src/misc/lapacke.h	11250;"	d
LAPACK_stgexc	Eigen/src/misc/lapacke.h	11254;"	d
LAPACK_stgsen	Eigen/src/misc/lapacke.h	11258;"	d
LAPACK_stgsja	Eigen/src/misc/lapacke.h	11274;"	d
LAPACK_stgsna	Eigen/src/misc/lapacke.h	11266;"	d
LAPACK_stgsyl	Eigen/src/misc/lapacke.h	11262;"	d
LAPACK_stpcon	Eigen/src/misc/lapacke.h	10760;"	d
LAPACK_stpmqrt	Eigen/src/misc/lapacke.h	11626;"	d
LAPACK_stpqrt2	Eigen/src/misc/lapacke.h	11633;"	d
LAPACK_stprfb	Eigen/src/misc/lapacke.h	11637;"	d
LAPACK_stprfs	Eigen/src/misc/lapacke.h	10830;"	d
LAPACK_stptri	Eigen/src/misc/lapacke.h	10874;"	d
LAPACK_stptrs	Eigen/src/misc/lapacke.h	10708;"	d
LAPACK_stpttf	Eigen/src/misc/lapacke.h	11451;"	d
LAPACK_stpttr	Eigen/src/misc/lapacke.h	11455;"	d
LAPACK_strcon	Eigen/src/misc/lapacke.h	10756;"	d
LAPACK_strevc	Eigen/src/misc/lapacke.h	11214;"	d
LAPACK_strexc	Eigen/src/misc/lapacke.h	11222;"	d
LAPACK_strrfs	Eigen/src/misc/lapacke.h	10826;"	d
LAPACK_strsen	Eigen/src/misc/lapacke.h	11226;"	d
LAPACK_strsna	Eigen/src/misc/lapacke.h	11218;"	d
LAPACK_strsyl	Eigen/src/misc/lapacke.h	11230;"	d
LAPACK_strtri	Eigen/src/misc/lapacke.h	10866;"	d
LAPACK_strtrs	Eigen/src/misc/lapacke.h	10704;"	d
LAPACK_strttf	Eigen/src/misc/lapacke.h	11459;"	d
LAPACK_strttp	Eigen/src/misc/lapacke.h	11463;"	d
LAPACK_stzrzf	Eigen/src/misc/lapacke.h	11074;"	d
LAPACK_zbbcsd	Eigen/src/misc/lapacke.h	11597;"	d
LAPACK_zbdsqr	Eigen/src/misc/lapacke.h	11109;"	d
LAPACK_zcgesv	Eigen/src/misc/lapacke.h	10921;"	d
LAPACK_zcposv	Eigen/src/misc/lapacke.h	10955;"	d
LAPACK_zgbbrd	Eigen/src/misc/lapacke.h	11097;"	d
LAPACK_zgbcon	Eigen/src/misc/lapacke.h	10723;"	d
LAPACK_zgbequ	Eigen/src/misc/lapacke.h	10889;"	d
LAPACK_zgbequb	Eigen/src/misc/lapacke.h	10892;"	d
LAPACK_zgbrfs	Eigen/src/misc/lapacke.h	10779;"	d
LAPACK_zgbrfsx	Eigen/src/misc/lapacke.h	10782;"	d
LAPACK_zgbsv	Eigen/src/misc/lapacke.h	10933;"	d
LAPACK_zgbsvx	Eigen/src/misc/lapacke.h	10937;"	d
LAPACK_zgbsvxx	Eigen/src/misc/lapacke.h	10940;"	d
LAPACK_zgbtrf	Eigen/src/misc/lapacke.h	10619;"	d
LAPACK_zgbtrs	Eigen/src/misc/lapacke.h	10667;"	d
LAPACK_zgebak	Eigen/src/misc/lapacke.h	11205;"	d
LAPACK_zgebal	Eigen/src/misc/lapacke.h	11201;"	d
LAPACK_zgebrd	Eigen/src/misc/lapacke.h	11093;"	d
LAPACK_zgecon	Eigen/src/misc/lapacke.h	10719;"	d
LAPACK_zgeequ	Eigen/src/misc/lapacke.h	10881;"	d
LAPACK_zgeequb	Eigen/src/misc/lapacke.h	10884;"	d
LAPACK_zgees	Eigen/src/misc/lapacke.h	11353;"	d
LAPACK_zgeesx	Eigen/src/misc/lapacke.h	11357;"	d
LAPACK_zgeev	Eigen/src/misc/lapacke.h	11361;"	d
LAPACK_zgeevx	Eigen/src/misc/lapacke.h	11365;"	d
LAPACK_zgehrd	Eigen/src/misc/lapacke.h	11189;"	d
LAPACK_zgelq2	Eigen/src/misc/lapacke.h	11511;"	d
LAPACK_zgelqf	Eigen/src/misc/lapacke.h	11041;"	d
LAPACK_zgels	Eigen/src/misc/lapacke.h	11281;"	d
LAPACK_zgelsd	Eigen/src/misc/lapacke.h	11293;"	d
LAPACK_zgelss	Eigen/src/misc/lapacke.h	11289;"	d
LAPACK_zgelsy	Eigen/src/misc/lapacke.h	11285;"	d
LAPACK_zgemqrt	Eigen/src/misc/lapacke.h	11613;"	d
LAPACK_zgeqlf	Eigen/src/misc/lapacke.h	11053;"	d
LAPACK_zgeqp3	Eigen/src/misc/lapacke.h	11029;"	d
LAPACK_zgeqpf	Eigen/src/misc/lapacke.h	11025;"	d
LAPACK_zgeqr2	Eigen/src/misc/lapacke.h	11479;"	d
LAPACK_zgeqrf	Eigen/src/misc/lapacke.h	11021;"	d
LAPACK_zgeqrfp	Eigen/src/misc/lapacke.h	11469;"	d
LAPACK_zgeqrt	Eigen/src/misc/lapacke.h	11617;"	d
LAPACK_zgeqrt2	Eigen/src/misc/lapacke.h	11621;"	d
LAPACK_zgeqrt3	Eigen/src/misc/lapacke.h	11625;"	d
LAPACK_zgerfs	Eigen/src/misc/lapacke.h	10771;"	d
LAPACK_zgerfsx	Eigen/src/misc/lapacke.h	10774;"	d
LAPACK_zgerqf	Eigen/src/misc/lapacke.h	11065;"	d
LAPACK_zgesdd	Eigen/src/misc/lapacke.h	11373;"	d
LAPACK_zgesv	Eigen/src/misc/lapacke.h	10919;"	d
LAPACK_zgesvd	Eigen/src/misc/lapacke.h	11369;"	d
LAPACK_zgesvx	Eigen/src/misc/lapacke.h	10925;"	d
LAPACK_zgesvxx	Eigen/src/misc/lapacke.h	10928;"	d
LAPACK_zgetf2	Eigen/src/misc/lapacke.h	11487;"	d
LAPACK_zgetrf	Eigen/src/misc/lapacke.h	10615;"	d
LAPACK_zgetri	Eigen/src/misc/lapacke.h	10841;"	d
LAPACK_zgetrs	Eigen/src/misc/lapacke.h	10663;"	d
LAPACK_zggbak	Eigen/src/misc/lapacke.h	11245;"	d
LAPACK_zggbal	Eigen/src/misc/lapacke.h	11241;"	d
LAPACK_zgges	Eigen/src/misc/lapacke.h	11421;"	d
LAPACK_zggesx	Eigen/src/misc/lapacke.h	11425;"	d
LAPACK_zggev	Eigen/src/misc/lapacke.h	11429;"	d
LAPACK_zggevx	Eigen/src/misc/lapacke.h	11433;"	d
LAPACK_zggglm	Eigen/src/misc/lapacke.h	11301;"	d
LAPACK_zgghrd	Eigen/src/misc/lapacke.h	11237;"	d
LAPACK_zgglse	Eigen/src/misc/lapacke.h	11297;"	d
LAPACK_zggqrf	Eigen/src/misc/lapacke.h	11085;"	d
LAPACK_zggrqf	Eigen/src/misc/lapacke.h	11089;"	d
LAPACK_zggsvd	Eigen/src/misc/lapacke.h	11381;"	d
LAPACK_zggsvp	Eigen/src/misc/lapacke.h	11273;"	d
LAPACK_zgtcon	Eigen/src/misc/lapacke.h	10727;"	d
LAPACK_zgtrfs	Eigen/src/misc/lapacke.h	10787;"	d
LAPACK_zgtsv	Eigen/src/misc/lapacke.h	10945;"	d
LAPACK_zgtsvx	Eigen/src/misc/lapacke.h	10949;"	d
LAPACK_zgttrf	Eigen/src/misc/lapacke.h	10623;"	d
LAPACK_zgttrs	Eigen/src/misc/lapacke.h	10671;"	d
LAPACK_zhbev	Eigen/src/misc/lapacke.h	11333;"	d
LAPACK_zhbevd	Eigen/src/misc/lapacke.h	11337;"	d
LAPACK_zhbevx	Eigen/src/misc/lapacke.h	11341;"	d
LAPACK_zhbgst	Eigen/src/misc/lapacke.h	11181;"	d
LAPACK_zhbgv	Eigen/src/misc/lapacke.h	11409;"	d
LAPACK_zhbgvd	Eigen/src/misc/lapacke.h	11413;"	d
LAPACK_zhbgvx	Eigen/src/misc/lapacke.h	11417;"	d
LAPACK_zhbtrd	Eigen/src/misc/lapacke.h	11139;"	d
LAPACK_zhecon	Eigen/src/misc/lapacke.h	10749;"	d
LAPACK_zheequb	Eigen/src/misc/lapacke.h	10914;"	d
LAPACK_zheev	Eigen/src/misc/lapacke.h	11305;"	d
LAPACK_zheevd	Eigen/src/misc/lapacke.h	11309;"	d
LAPACK_zheevr	Eigen/src/misc/lapacke.h	11317;"	d
LAPACK_zheevx	Eigen/src/misc/lapacke.h	11313;"	d
LAPACK_zhegst	Eigen/src/misc/lapacke.h	11173;"	d
LAPACK_zhegv	Eigen/src/misc/lapacke.h	11385;"	d
LAPACK_zhegvd	Eigen/src/misc/lapacke.h	11389;"	d
LAPACK_zhegvx	Eigen/src/misc/lapacke.h	11393;"	d
LAPACK_zherfs	Eigen/src/misc/lapacke.h	10817;"	d
LAPACK_zherfsx	Eigen/src/misc/lapacke.h	10818;"	d
LAPACK_zhesv	Eigen/src/misc/lapacke.h	11001;"	d
LAPACK_zhesvx	Eigen/src/misc/lapacke.h	11003;"	d
LAPACK_zhesvxx	Eigen/src/misc/lapacke.h	11004;"	d
LAPACK_zheswapr	Eigen/src/misc/lapacke.h	11598;"	d
LAPACK_zhetrd	Eigen/src/misc/lapacke.h	11119;"	d
LAPACK_zhetrf	Eigen/src/misc/lapacke.h	10653;"	d
LAPACK_zhetri	Eigen/src/misc/lapacke.h	10859;"	d
LAPACK_zhetri2	Eigen/src/misc/lapacke.h	11599;"	d
LAPACK_zhetri2x	Eigen/src/misc/lapacke.h	11600;"	d
LAPACK_zhetrs	Eigen/src/misc/lapacke.h	10697;"	d
LAPACK_zhetrs2	Eigen/src/misc/lapacke.h	11601;"	d
LAPACK_zhfrk	Eigen/src/misc/lapacke.h	11436;"	d
LAPACK_zhgeqz	Eigen/src/misc/lapacke.h	11249;"	d
LAPACK_zhpcon	Eigen/src/misc/lapacke.h	10755;"	d
LAPACK_zhpev	Eigen/src/misc/lapacke.h	11321;"	d
LAPACK_zhpevd	Eigen/src/misc/lapacke.h	11325;"	d
LAPACK_zhpevx	Eigen/src/misc/lapacke.h	11329;"	d
LAPACK_zhpgst	Eigen/src/misc/lapacke.h	11177;"	d
LAPACK_zhpgv	Eigen/src/misc/lapacke.h	11397;"	d
LAPACK_zhpgvd	Eigen/src/misc/lapacke.h	11401;"	d
LAPACK_zhpgvx	Eigen/src/misc/lapacke.h	11405;"	d
LAPACK_zhprfs	Eigen/src/misc/lapacke.h	10825;"	d
LAPACK_zhpsv	Eigen/src/misc/lapacke.h	11015;"	d
LAPACK_zhpsvx	Eigen/src/misc/lapacke.h	11017;"	d
LAPACK_zhptrd	Eigen/src/misc/lapacke.h	11131;"	d
LAPACK_zhptrf	Eigen/src/misc/lapacke.h	10659;"	d
LAPACK_zhptri	Eigen/src/misc/lapacke.h	10865;"	d
LAPACK_zhptrs	Eigen/src/misc/lapacke.h	10703;"	d
LAPACK_zhsein	Eigen/src/misc/lapacke.h	11213;"	d
LAPACK_zhseqr	Eigen/src/misc/lapacke.h	11209;"	d
LAPACK_zlacgv	Eigen/src/misc/lapacke.h	11471;"	d
LAPACK_zlacpy	Eigen/src/misc/lapacke.h	11483;"	d
LAPACK_zlag2c	Eigen/src/misc/lapacke.h	11535;"	d
LAPACK_zlagge	Eigen/src/misc/lapacke.h	11543;"	d
LAPACK_zlaghe	Eigen/src/misc/lapacke.h	11555;"	d
LAPACK_zlagsy	Eigen/src/misc/lapacke.h	11553;"	d
LAPACK_zlange	Eigen/src/misc/lapacke.h	11495;"	d
LAPACK_zlanhe	Eigen/src/misc/lapacke.h	11497;"	d
LAPACK_zlansy	Eigen/src/misc/lapacke.h	11501;"	d
LAPACK_zlantr	Eigen/src/misc/lapacke.h	11505;"	d
LAPACK_zlapmr	Eigen/src/misc/lapacke.h	11559;"	d
LAPACK_zlarfb	Eigen/src/misc/lapacke.h	11515;"	d
LAPACK_zlarfg	Eigen/src/misc/lapacke.h	11519;"	d
LAPACK_zlarft	Eigen/src/misc/lapacke.h	11523;"	d
LAPACK_zlarfx	Eigen/src/misc/lapacke.h	11527;"	d
LAPACK_zlarnv	Eigen/src/misc/lapacke.h	11475;"	d
LAPACK_zlaset	Eigen/src/misc/lapacke.h	11547;"	d
LAPACK_zlaswp	Eigen/src/misc/lapacke.h	11491;"	d
LAPACK_zlatms	Eigen/src/misc/lapacke.h	11531;"	d
LAPACK_zlauum	Eigen/src/misc/lapacke.h	11539;"	d
LAPACK_zpbcon	Eigen/src/misc/lapacke.h	10739;"	d
LAPACK_zpbequ	Eigen/src/misc/lapacke.h	10909;"	d
LAPACK_zpbrfs	Eigen/src/misc/lapacke.h	10803;"	d
LAPACK_zpbstf	Eigen/src/misc/lapacke.h	11185;"	d
LAPACK_zpbsv	Eigen/src/misc/lapacke.h	10975;"	d
LAPACK_zpbsvx	Eigen/src/misc/lapacke.h	10979;"	d
LAPACK_zpbtrf	Eigen/src/misc/lapacke.h	10643;"	d
LAPACK_zpbtrs	Eigen/src/misc/lapacke.h	10687;"	d
LAPACK_zpftrf	Eigen/src/misc/lapacke.h	10634;"	d
LAPACK_zpftri	Eigen/src/misc/lapacke.h	10848;"	d
LAPACK_zpftrs	Eigen/src/misc/lapacke.h	10678;"	d
LAPACK_zpocon	Eigen/src/misc/lapacke.h	10731;"	d
LAPACK_zpoequ	Eigen/src/misc/lapacke.h	10897;"	d
LAPACK_zpoequb	Eigen/src/misc/lapacke.h	10900;"	d
LAPACK_zporfs	Eigen/src/misc/lapacke.h	10791;"	d
LAPACK_zporfsx	Eigen/src/misc/lapacke.h	10794;"	d
LAPACK_zposv	Eigen/src/misc/lapacke.h	10953;"	d
LAPACK_zposvx	Eigen/src/misc/lapacke.h	10959;"	d
LAPACK_zposvxx	Eigen/src/misc/lapacke.h	10962;"	d
LAPACK_zpotrf	Eigen/src/misc/lapacke.h	10627;"	d
LAPACK_zpotri	Eigen/src/misc/lapacke.h	10845;"	d
LAPACK_zpotrs	Eigen/src/misc/lapacke.h	10675;"	d
LAPACK_zppcon	Eigen/src/misc/lapacke.h	10735;"	d
LAPACK_zppequ	Eigen/src/misc/lapacke.h	10905;"	d
LAPACK_zpprfs	Eigen/src/misc/lapacke.h	10799;"	d
LAPACK_zppsv	Eigen/src/misc/lapacke.h	10967;"	d
LAPACK_zppsvx	Eigen/src/misc/lapacke.h	10971;"	d
LAPACK_zpptrf	Eigen/src/misc/lapacke.h	10639;"	d
LAPACK_zpptri	Eigen/src/misc/lapacke.h	10853;"	d
LAPACK_zpptrs	Eigen/src/misc/lapacke.h	10683;"	d
LAPACK_zpstrf	Eigen/src/misc/lapacke.h	10630;"	d
LAPACK_zptcon	Eigen/src/misc/lapacke.h	10743;"	d
LAPACK_zpteqr	Eigen/src/misc/lapacke.h	11161;"	d
LAPACK_zptrfs	Eigen/src/misc/lapacke.h	10807;"	d
LAPACK_zptsv	Eigen/src/misc/lapacke.h	10983;"	d
LAPACK_zptsvx	Eigen/src/misc/lapacke.h	10987;"	d
LAPACK_zpttrf	Eigen/src/misc/lapacke.h	10647;"	d
LAPACK_zpttrs	Eigen/src/misc/lapacke.h	10691;"	d
LAPACK_zspcon	Eigen/src/misc/lapacke.h	10753;"	d
LAPACK_zsprfs	Eigen/src/misc/lapacke.h	10823;"	d
LAPACK_zspsv	Eigen/src/misc/lapacke.h	11009;"	d
LAPACK_zspsvx	Eigen/src/misc/lapacke.h	11013;"	d
LAPACK_zsptrf	Eigen/src/misc/lapacke.h	10657;"	d
LAPACK_zsptri	Eigen/src/misc/lapacke.h	10863;"	d
LAPACK_zsptrs	Eigen/src/misc/lapacke.h	10701;"	d
LAPACK_zstedc	Eigen/src/misc/lapacke.h	11153;"	d
LAPACK_zstegr	Eigen/src/misc/lapacke.h	11157;"	d
LAPACK_zstein	Eigen/src/misc/lapacke.h	11167;"	d
LAPACK_zstemr	Eigen/src/misc/lapacke.h	11149;"	d
LAPACK_zsteqr	Eigen/src/misc/lapacke.h	11145;"	d
LAPACK_zsycon	Eigen/src/misc/lapacke.h	10747;"	d
LAPACK_zsyconv	Eigen/src/misc/lapacke.h	11602;"	d
LAPACK_zsyequb	Eigen/src/misc/lapacke.h	10912;"	d
LAPACK_zsyr	Eigen/src/misc/lapacke.h	11643;"	d
LAPACK_zsyrfs	Eigen/src/misc/lapacke.h	10811;"	d
LAPACK_zsyrfsx	Eigen/src/misc/lapacke.h	10814;"	d
LAPACK_zsysv	Eigen/src/misc/lapacke.h	10991;"	d
LAPACK_zsysvx	Eigen/src/misc/lapacke.h	10995;"	d
LAPACK_zsysvxx	Eigen/src/misc/lapacke.h	10998;"	d
LAPACK_zsyswapr	Eigen/src/misc/lapacke.h	11603;"	d
LAPACK_zsytrf	Eigen/src/misc/lapacke.h	10651;"	d
LAPACK_zsytri	Eigen/src/misc/lapacke.h	10857;"	d
LAPACK_zsytri2	Eigen/src/misc/lapacke.h	11604;"	d
LAPACK_zsytri2x	Eigen/src/misc/lapacke.h	11605;"	d
LAPACK_zsytrs	Eigen/src/misc/lapacke.h	10695;"	d
LAPACK_zsytrs2	Eigen/src/misc/lapacke.h	11606;"	d
LAPACK_ztbcon	Eigen/src/misc/lapacke.h	10767;"	d
LAPACK_ztbrfs	Eigen/src/misc/lapacke.h	10837;"	d
LAPACK_ztbtrs	Eigen/src/misc/lapacke.h	10715;"	d
LAPACK_ztfsm	Eigen/src/misc/lapacke.h	11440;"	d
LAPACK_ztftri	Eigen/src/misc/lapacke.h	10872;"	d
LAPACK_ztfttp	Eigen/src/misc/lapacke.h	11444;"	d
LAPACK_ztfttr	Eigen/src/misc/lapacke.h	11448;"	d
LAPACK_ztgevc	Eigen/src/misc/lapacke.h	11253;"	d
LAPACK_ztgexc	Eigen/src/misc/lapacke.h	11257;"	d
LAPACK_ztgsen	Eigen/src/misc/lapacke.h	11261;"	d
LAPACK_ztgsja	Eigen/src/misc/lapacke.h	11277;"	d
LAPACK_ztgsna	Eigen/src/misc/lapacke.h	11269;"	d
LAPACK_ztgsyl	Eigen/src/misc/lapacke.h	11265;"	d
LAPACK_ztpcon	Eigen/src/misc/lapacke.h	10763;"	d
LAPACK_ztpmqrt	Eigen/src/misc/lapacke.h	11629;"	d
LAPACK_ztpqrt	Eigen/src/misc/lapacke.h	11632;"	d
LAPACK_ztpqrt2	Eigen/src/misc/lapacke.h	11636;"	d
LAPACK_ztprfb	Eigen/src/misc/lapacke.h	11640;"	d
LAPACK_ztprfs	Eigen/src/misc/lapacke.h	10833;"	d
LAPACK_ztptri	Eigen/src/misc/lapacke.h	10877;"	d
LAPACK_ztptrs	Eigen/src/misc/lapacke.h	10711;"	d
LAPACK_ztpttf	Eigen/src/misc/lapacke.h	11452;"	d
LAPACK_ztpttr	Eigen/src/misc/lapacke.h	11456;"	d
LAPACK_ztrcon	Eigen/src/misc/lapacke.h	10759;"	d
LAPACK_ztrevc	Eigen/src/misc/lapacke.h	11217;"	d
LAPACK_ztrexc	Eigen/src/misc/lapacke.h	11225;"	d
LAPACK_ztrrfs	Eigen/src/misc/lapacke.h	10829;"	d
LAPACK_ztrsen	Eigen/src/misc/lapacke.h	11229;"	d
LAPACK_ztrsna	Eigen/src/misc/lapacke.h	11221;"	d
LAPACK_ztrsyl	Eigen/src/misc/lapacke.h	11233;"	d
LAPACK_ztrtri	Eigen/src/misc/lapacke.h	10869;"	d
LAPACK_ztrtrs	Eigen/src/misc/lapacke.h	10707;"	d
LAPACK_ztrttf	Eigen/src/misc/lapacke.h	11460;"	d
LAPACK_ztrttp	Eigen/src/misc/lapacke.h	11464;"	d
LAPACK_ztzrzf	Eigen/src/misc/lapacke.h	11077;"	d
LAPACK_zunbdb	Eigen/src/misc/lapacke.h	11607;"	d
LAPACK_zuncsd	Eigen/src/misc/lapacke.h	11608;"	d
LAPACK_zungbr	Eigen/src/misc/lapacke.h	11103;"	d
LAPACK_zunghr	Eigen/src/misc/lapacke.h	11195;"	d
LAPACK_zunglq	Eigen/src/misc/lapacke.h	11047;"	d
LAPACK_zungql	Eigen/src/misc/lapacke.h	11057;"	d
LAPACK_zungqr	Eigen/src/misc/lapacke.h	11035;"	d
LAPACK_zungrq	Eigen/src/misc/lapacke.h	11069;"	d
LAPACK_zungtr	Eigen/src/misc/lapacke.h	11121;"	d
LAPACK_zunmbr	Eigen/src/misc/lapacke.h	11105;"	d
LAPACK_zunmhr	Eigen/src/misc/lapacke.h	11197;"	d
LAPACK_zunmlq	Eigen/src/misc/lapacke.h	11049;"	d
LAPACK_zunmql	Eigen/src/misc/lapacke.h	11061;"	d
LAPACK_zunmqr	Eigen/src/misc/lapacke.h	11037;"	d
LAPACK_zunmrq	Eigen/src/misc/lapacke.h	11073;"	d
LAPACK_zunmrz	Eigen/src/misc/lapacke.h	11081;"	d
LAPACK_zunmtr	Eigen/src/misc/lapacke.h	11123;"	d
LAPACK_zupgtr	Eigen/src/misc/lapacke.h	11133;"	d
LAPACK_zupmtr	Eigen/src/misc/lapacke.h	11135;"	d
LAUNCH_CUDA_KERNEL	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	317;"	d
LCE	blas/testing/cblat2.f	/^      LOGICAL            LCE$/;"	v	program:CBLAT2
LCE	blas/testing/cblat2.f	/^      LOGICAL FUNCTION LCE(/;"	f
LCE	blas/testing/cblat3.f	/^      LOGICAL            LCE$/;"	v	program:CBLAT3
LCE	blas/testing/cblat3.f	/^      LOGICAL FUNCTION LCE(/;"	f
LCERES	blas/testing/cblat2.f	/^      LOGICAL FUNCTION LCERES(/;"	f
LCERES	blas/testing/cblat3.f	/^      LOGICAL FUNCTION LCERES(/;"	f
LDE	blas/testing/dblat2.f	/^      LOGICAL            LDE$/;"	v	program:DBLAT2
LDE	blas/testing/dblat2.f	/^      LOGICAL FUNCTION LDE(/;"	f
LDE	blas/testing/dblat3.f	/^      LOGICAL            LDE$/;"	v	program:DBLAT3
LDE	blas/testing/dblat3.f	/^      LOGICAL FUNCTION LDE(/;"	f
LDERES	blas/testing/dblat2.f	/^      LOGICAL FUNCTION LDERES(/;"	f
LDERES	blas/testing/dblat3.f	/^      LOGICAL FUNCTION LDERES(/;"	f
LDLT	Eigen/src/Cholesky/LDLT.h	/^    LDLT()$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(Index size)$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^    explicit LDLT(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
LDLTTraits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LDLT_Traits	Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int LDims =$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
LDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int LDims =$/;"	m	struct:Eigen::TensorEvaluator
LDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  static const int LDims =$/;"	m	struct:Eigen::TensorEvaluator
LDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static const int LDims =$/;"	m	struct:Eigen::TensorEvaluator
LEFT	blas/common.h	28;"	d
LERR	blas/testing/cblat2.f	/^      LOGICAL            LERR,/;"	v	program:CBLAT2
LERR	blas/testing/cblat3.f	/^      LOGICAL            LERR,/;"	v	program:CBLAT3
LERR	blas/testing/dblat2.f	/^      LOGICAL            LERR,/;"	v	program:DBLAT2
LERR	blas/testing/dblat3.f	/^      LOGICAL            LERR,/;"	v	program:DBLAT3
LERR	blas/testing/sblat2.f	/^      LOGICAL            LERR,/;"	v	program:SBLAT2
LERR	blas/testing/sblat3.f	/^      LOGICAL            LERR,/;"	v	program:SBLAT3
LERR	blas/testing/zblat2.f	/^      LOGICAL            LERR,/;"	v	program:ZBLAT2
LERR	blas/testing/zblat3.f	/^      LOGICAL            LERR,/;"	v	program:ZBLAT3
LIToSecs	bench/btl/generic_bench/timers/portable_timer.hh	/^   double LIToSecs(LARGE_INTEGER& L) {$/;"	f	class:Portable_Timer
LLT	Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^    explicit LLT(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^    explicit LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^    explicit LLT(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
LLTTraits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LLT_Traits	Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLVL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
LM_EVAL_COUNT_TOL	unsupported/test/NonLinearOptimization.cpp	16;"	d	file:
LM_EVAL_COUNT_TOL	unsupported/test/levenberg_marquardt.cpp	27;"	d	file:
LMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU
LO	blas/common.h	32;"	d
LSE	blas/testing/sblat2.f	/^      LOGICAL            LSE$/;"	v	program:SBLAT2
LSE	blas/testing/sblat2.f	/^      LOGICAL FUNCTION LSE(/;"	f
LSE	blas/testing/sblat3.f	/^      LOGICAL            LSE$/;"	v	program:SBLAT3
LSE	blas/testing/sblat3.f	/^      LOGICAL FUNCTION LSE(/;"	f
LSERES	blas/testing/sblat2.f	/^      LOGICAL FUNCTION LSERES(/;"	f
LSERES	blas/testing/sblat3.f	/^      LOGICAL FUNCTION LSERES(/;"	f
LSUB	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
LTEST	blas/testing/cblat2.f	/^      LOGICAL            LTEST(/;"	v	program:CBLAT2
LTEST	blas/testing/cblat3.f	/^      LOGICAL            LTEST(/;"	v	program:CBLAT3
LTEST	blas/testing/dblat2.f	/^      LOGICAL            LTEST(/;"	v	program:DBLAT2
LTEST	blas/testing/dblat3.f	/^      LOGICAL            LTEST(/;"	v	program:DBLAT3
LTEST	blas/testing/sblat2.f	/^      LOGICAL            LTEST(/;"	v	program:SBLAT2
LTEST	blas/testing/sblat3.f	/^      LOGICAL            LTEST(/;"	v	program:SBLAT3
LTEST	blas/testing/zblat2.f	/^      LOGICAL            LTEST(/;"	v	program:ZBLAT2
LTEST	blas/testing/zblat3.f	/^      LOGICAL            LTEST(/;"	v	program:ZBLAT3
LTESTT	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:CBLAT2
LTESTT	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:CBLAT3
LTESTT	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:DBLAT2
LTESTT	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:DBLAT3
LTESTT	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:SBLAT2
LTESTT	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:SBLAT3
LTESTT	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:ZBLAT2
LTESTT	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT,/;"	v	program:ZBLAT3
LUMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase
LUMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU
LUMatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU
LUNoMarker	Eigen/src/SparseLU/SparseLU_Memory.h	/^enum { LUNoMarker = 3 };$/;"	e	enum:Eigen::internal::__anon877
LUSUP	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
LUTempSpace	Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUTempSpace(Index&m, Index& w)$/;"	f	namespace:Eigen::internal
LU_GlobalLU_t	Eigen/src/SparseLU/SparseLU_Structs.h	/^struct LU_GlobalLU_t {$/;"	s	namespace:Eigen::internal
LU_factor	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  inline static void LU_factor(gene_matrix & LU, Pivot_Vector & pivot, int N)$/;"	f	class:blitz_LU_solve_interface
LU_factor	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  inline static void LU_factor(gene_matrix & LU, Pivot_Vector & pivot, int N)$/;"	f	class:blitz_LU_solve_interface
LU_factor	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  inline static void LU_factor(gene_matrix & LU, Pivot_Vector & pivot, int N)$/;"	f	class:blitz_LU_solve_interface
LU_kernel_bmod	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <> struct LU_kernel_bmod<1>$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <int SegSizeAtCompileTime> struct LU_kernel_bmod$/;"	s	namespace:Eigen::internal
LU_solve	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  inline static void LU_solve(const gene_matrix & LU, const Pivot_Vector pivot, gene_vector &B, gene_vector X, int N)$/;"	f	class:blitz_LU_solve_interface
LU_solve	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  inline static void LU_solve(const gene_matrix & LU, const Pivot_Vector pivot, gene_vector &B, gene_vector X, int N)$/;"	f	class:blitz_LU_solve_interface
LU_solve	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  inline static void LU_solve(const gene_matrix & LU, const Pivot_Vector pivot, gene_vector &B, gene_vector X, int N)$/;"	f	class:blitz_LU_solve_interface
LUnumTempV	Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUnumTempV(Index& m, Index& w, Index& t, Index& b)$/;"	f	namespace:Eigen::internal
LZE	blas/testing/zblat2.f	/^      LOGICAL            LZE$/;"	v	program:ZBLAT2
LZE	blas/testing/zblat2.f	/^      LOGICAL FUNCTION LZE(/;"	f
LZE	blas/testing/zblat3.f	/^      LOGICAL            LZE$/;"	v	program:ZBLAT3
LZE	blas/testing/zblat3.f	/^      LOGICAL FUNCTION LZE(/;"	f
LZERES	blas/testing/zblat2.f	/^      LOGICAL FUNCTION LZERES(/;"	f
LZERES	blas/testing/zblat3.f	/^      LOGICAL FUNCTION LZERES(/;"	f
L_stl	bench/btl/actions/action_trisolve.hh	/^  typename Interface::stl_matrix L_stl;$/;"	m	class:Action_trisolve
Large	Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon287
LargeEnough	Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
LaunchKernels	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  template <typename Index, typename LhsMapper, typename RhsMapper, typename OutputMapper> struct LaunchKernels<float, float, Index, LhsMapper, RhsMapper, OutputMapper> {$/;"	s	struct:Eigen::TensorEvaluator
LaunchKernels	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  template <typename LhsScalar, typename RhsScalar, typename Index, typename LhsMapper, typename RhsMapper, typename OutputMapper> struct LaunchKernels {$/;"	s	struct:Eigen::TensorEvaluator
Layout	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      Layout = Options_ & RowMajor ? RowMajor : ColMajor,$/;"	e	enum:Eigen::Tensor::__anon122
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon99
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    Layout = TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon100
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon120
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  static const int Layout = internal::traits<LhsXprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon126
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon124
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon97
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon98
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  static const int Layout = traits<LhsXprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout$/;"	e	enum:Eigen::TensorEvaluator::__anon166
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorContractionEvaluatorBase::__anon165
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int Layout = traits<LhsXprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon121
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon182
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon108
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  static const int Layout = traits<XprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    Layout = TensorEvaluator<InputArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon145
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    Layout = TensorEvaluator<InputArgType, GpuDevice>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon146
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int Layout = traits<InputXprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    Layout = TensorEvaluator<LhsXprType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon138
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    Layout = TensorEvaluator<XprType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon137
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int Layout = traits<LhsXprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int Layout = traits<XprType>::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon141
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = Derived::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon109
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = Derived::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon111
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = TensorEvaluator<Arg1Type, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon115
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon112
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon113
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = TensorEvaluator<IfArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon116
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    Layout = TensorEvaluator<LeftArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon114
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon148
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^      Layout = Options_ & RowMajor ? RowMajor : ColMajor,$/;"	e	enum:Eigen::TensorFixedSize::__anon87
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon118
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon142
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon130
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon136
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    Layout = (static_cast<int>(TensorEvaluator<ArgType, Device>::Layout) == static_cast<int>(ColMajor)) ? RowMajor : ColMajor,$/;"	e	enum:Eigen::TensorEvaluator::__anon85
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    Layout = (static_cast<int>(TensorEvaluator<ArgType, Device>::Layout) == static_cast<int>(ColMajor)) ? RowMajor : ColMajor,$/;"	e	enum:Eigen::TensorEvaluator::__anon86
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  static const int Layout = (traits<XprType>::Layout == ColMajor) ? RowMajor : ColMajor;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^      Layout = PlainObjectType::Layout,$/;"	e	enum:Eigen::TensorMap::__anon127
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon89
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon90
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon92
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon93
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon94
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon95
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon147
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon88
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon128
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^      Layout = PlainObjectType::Layout,$/;"	e	enum:Eigen::TensorRef::__anon152
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    Layout = TensorRef<Derived>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon153
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon183
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon184
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon129
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon150
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon185
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon186
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  static const int Layout = BaseTraits::Layout;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  static const int Layout = Options_ & RowMajor ? RowMajor : ColMajor;$/;"	m	struct:Eigen::internal::traits
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    Layout = TensorEvaluator<ArgType, Device>::Layout,$/;"	e	enum:Eigen::TensorEvaluator::__anon143
Layout	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  static const int Layout = XprTraits::Layout;$/;"	m	struct:Eigen::internal::traits
LazyCoeffBasedProductMode	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
LazyEval	bench/basicbenchmark.h	/^enum {LazyEval, EarlyEval, OmpEval};$/;"	e	enum:__anon4
LazyProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<CategoryExpr<OP, RHSExpr...> > :LeafCount<const CategoryExpr<OP, RHSExpr...> >{};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorAssignOp<LHSExpr, RHSExpr> > :LeafCount<const TensorAssignOp<LHSExpr, RHSExpr> >{};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorEvalToOp<Expr> >: LeafCount<const TensorEvalToOp<Expr> >{};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorForcedEvalOp<Expr> >: LeafCount<const TensorForcedEvalOp<Expr> > {};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorMap<PlainObjectType, Options_, MakePointer_> > :LeafCount<const TensorMap<PlainObjectType, Options_, MakePointer_> >{};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorReductionOp<OP, Dim, Expr> >: LeafCount<const TensorReductionOp<OP, Dim, Expr> >{};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<TensorSelectOp<IfExpr, ThenExpr, ElseExpr> >: LeafCount<const TensorSelectOp<IfExpr, ThenExpr, ElseExpr> > {};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const CategoryExpr<OP, RHSExpr...> >: CategoryCount<RHSExpr...> {};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorAssignOp<LHSExpr, RHSExpr> >: CategoryCount<LHSExpr,RHSExpr> {};$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorEvalToOp<Expr> > {$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorForcedEvalOp<Expr> > {$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorMap<PlainObjectType, Options_, MakePointer_> > {$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorReductionOp<OP, Dim, Expr> > {$/;"	s	namespace:Eigen::TensorSycl::internal
LeafCount	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^struct LeafCount<const TensorSelectOp<IfExpr, ThenExpr, ElseExpr> > : CategoryCount<IfExpr, ThenExpr, ElseExpr> {};$/;"	s	namespace:Eigen::TensorSycl::internal
LeastSquareDiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner() : Base() {}$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
LeastSquareDiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    explicit LeastSquareDiagonalPreconditioner(const MatType& mat) : Base()$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
LeastSquareDiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class LeastSquareDiagonalPreconditioner : public DiagonalPreconditioner<_Scalar>$/;"	c	namespace:Eigen
LeastSquaresConjugateGradient	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  LeastSquaresConjugateGradient() : Base() {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
LeastSquaresConjugateGradient	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  explicit LeastSquaresConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
LeastSquaresConjugateGradient	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^class LeastSquaresConjugateGradient : public IterativeSolverBase<LeastSquaresConjugateGradient<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
LeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef LeftArgType_ LeftArgType;$/;"	t	struct:Eigen::internal::traits
LeftArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::traits<Derived>::LeftArgType LeftArgType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
LeftBlock	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, _Deg, Deg_1 >          LeftBlock;$/;"	t	class:Eigen::internal::companion
LeftBlockFirstRow	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, 1, Deg_1 >             LeftBlockFirstRow;$/;"	t	class:Eigen::internal::companion
LeftDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename LeftEvaluator::Dimensions LeftDimensions;$/;"	t	struct:Eigen::TensorEvaluator
LeftEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;$/;"	t	struct:Eigen::TensorEvaluator
LeftEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef TensorEvaluator<EvalLeftArgType, Device> LeftEvaluator;$/;"	t	struct:Eigen::TensorEvaluator
LeftScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd& LeftScaling()$/;"	f	class:Eigen::IterScaling
LerpEulerAngles	demos/opengl/quaternion_demo.h	/^      LerpEulerAngles$/;"	e	enum:RenderingWidget::LerpMode
LerpMode	demos/opengl/quaternion_demo.h	/^    enum LerpMode {$/;"	g	class:RenderingWidget
LerpQuaternion	demos/opengl/quaternion_demo.h	/^      LerpQuaternion,$/;"	e	enum:RenderingWidget::LerpMode
LevenbergMarquardt	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    LevenbergMarquardt(FunctorType& functor) $/;"	f	class:Eigen::LevenbergMarquardt
LevenbergMarquardt	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^class LevenbergMarquardt : internal::no_assignment_operator$/;"	c	namespace:Eigen
LevenbergMarquardt	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    LevenbergMarquardt(FunctorType &_functor)$/;"	f	class:Eigen::LevenbergMarquardt
LevenbergMarquardt	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^class LevenbergMarquardt$/;"	c	namespace:Eigen
LevenbergMarquardtSpace	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^namespace LevenbergMarquardtSpace {$/;"	n	namespace:Eigen
LevenbergMarquardtSpace	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^namespace LevenbergMarquardtSpace {$/;"	n	namespace:Eigen
LgammaReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_lgamma_op<Scalar>, const Derived> LgammaReturnType;$/;"	t
Lhs	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<LhsType>::type Lhs;$/;"	t	class:Eigen::CwiseBinaryOp
Lhs	Eigen/src/Core/Product.h	/^    typedef _Lhs Lhs;$/;"	t	class:Eigen::Product
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Lhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  Lhs = 1$/;"	e	enum:Eigen::internal::__anon131
Lhs	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef typename Traits::Lhs Lhs;$/;"	t	class:Eigen::KroneckerProductBase
Lhs	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits
Lhs1	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename conditional<NeedToTranspose,RhsT,LhsT>::type Lhs1;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsAlignment	Eigen/src/Core/ProductEvaluators.h	/^    LhsAlignment = EIGEN_PLAIN_ENUM_MIN(LhsEtorType::Alignment,LhsVecPacketSize*int(sizeof(typename LhsNestedCleaned::Scalar))),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsArg	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Lhs LhsArg;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsArg	Eigen/src/SparseCore/SparseDenseProduct.h	/^            Lhs1 const&, SparseView<Lhs1> >::type LhsArg;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsBlasTraits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsBlasTraits	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
LhsBlasTraits	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef internal::blas_traits<Lhs> LhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
LhsCleaned	Eigen/src/Core/Product.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::traits
LhsCleaned	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
LhsCoeffReadCost	Eigen/src/Core/ProductEvaluators.h	/^    LhsCoeffReadCost = LhsEtorType::CoeffReadCost,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsCoeffReadCost	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon40
LhsEtorType	Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<LhsNestedCleaned> LhsEtorType;$/;"	t	struct:Eigen::internal::product_evaluator
LhsEval	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<ActualLhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsEval	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<Lhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsEval	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef evaluator<Lhs> LhsEval;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
LhsEvaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef evaluator<LhsArg> LhsEvaluator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsFlags	Eigen/src/Core/CoreEvaluators.h	/^    LhsFlags = evaluator<Lhs>::Flags,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
LhsFlags	Eigen/src/Core/ProductEvaluators.h	/^    LhsFlags = LhsEtorType::Flags,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsFlags	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    LhsFlags = Lhs::Flags,$/;"	e	enum:Eigen::internal::traits::__anon29
LhsFlags	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon40
LhsInnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename evaluator<Lhs>::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsIsSelfAdjoint	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon623
LhsIsUpper	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon623
LhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<Lhs>::InnerIterator  LhsIterator;$/;"	t	struct:Eigen::internal::binary_evaluator
LhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<LhsArg>::InnerIterator  LhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<LhsArg>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
LhsIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename evaluator<ActualLhs>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
LhsIterator	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename evaluator<Lhs>::InnerIterator LhsIterator;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
LhsMap	blas/BandTriangularSolver.h	/^  typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,ColMajor>, 0, OuterStride<> > LhsMap;$/;"	t	struct:internal::band_solve_triangular_selector
LhsMap	blas/BandTriangularSolver.h	/^  typedef Map<const Matrix<LhsScalar,Dynamic,Dynamic,RowMajor>, 0, OuterStride<> > LhsMap;$/;"	t	struct:internal::band_solve_triangular_selector
LhsMatrixType	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits
LhsMatrixType	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
LhsMatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::ref_selector<LhsType>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	Eigen/src/Core/Product.h	/^    typedef typename internal::ref_selector<Lhs>::type LhsNested;$/;"	t	class:Eigen::Product
LhsNested	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;$/;"	t	struct:Eigen::internal::product_evaluator
LhsNested	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<Lhs,1>::type LhsNested;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename LhsXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename LhsXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename LhsXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename InputXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename LhsXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename LhsXprType::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef const typename internal::nested_eval<Lhs, Rhs::RowsAtCompileTime>::type LhsNested;$/;"	t	struct:Eigen::SkylineProductReturnType
LhsNestedCleaned	Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	class:Eigen::Product
LhsNestedCleaned	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	struct:Eigen::internal::product_evaluator
LhsOuterStrideBytes	Eigen/src/Core/ProductEvaluators.h	/^    LhsOuterStrideBytes = int(LhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename LhsNestedCleaned::Scalar)),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
LhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon624
LhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon625
LhsProductTraits	Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon633
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
LhsRowMajor	Eigen/src/Core/ProductEvaluators.h	/^    LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsScalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::generic_product_impl
LhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  typedef typename LhsMapper::Scalar LhsScalar;$/;"	t	class:Eigen::internal::TensorContractionBlocking
LhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename internal::remove_const<typename EvalLeftArgType::Scalar>::type LhsScalar;$/;"	t	struct:Eigen::TensorEvaluator
LhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename internal::remove_const<typename EvalLeftArgType::Scalar>::type LhsScalar;$/;"	t	struct:Eigen::TensorEvaluator
LhsTraits	Eigen/src/Core/Product.h	/^  typedef traits<LhsCleaned> LhsTraits;$/;"	t	struct:Eigen::internal::traits
LhsUpLo	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  enum { LhsUpLo = LhsMode&(Upper|Lower) };$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon620
LhsVecPacketSize	Eigen/src/Core/ProductEvaluators.h	/^    LhsVecPacketSize = unpacket_traits<LhsVecPacketType>::size,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
LhsVecPacketType	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename find_best_packet<Scalar,RowsAtCompileTime>::type LhsVecPacketType;$/;"	t	struct:Eigen::internal::product_evaluator
Lib_Mean	bench/btl/data/mean.cxx	/^  Lib_Mean( void ):_lib_name(),_mean_in_cache(),_mean_out_of_cache(){$/;"	f	class:Lib_Mean
Lib_Mean	bench/btl/data/mean.cxx	/^  Lib_Mean(const Lib_Mean & lm):_lib_name(lm._lib_name),_mean_in_cache(lm._mean_in_cache),_mean_out_of_cache(lm._mean_out_of_cache){$/;"	f	class:Lib_Mean
Lib_Mean	bench/btl/data/mean.cxx	/^  Lib_Mean(const string & name, const double & mic, const double & moc):_lib_name(name),_mean_in_cache(mic),_mean_out_of_cache(moc){$/;"	f	class:Lib_Mean
Lib_Mean	bench/btl/data/mean.cxx	/^class Lib_Mean{$/;"	c	file:
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinearAccess	Eigen/src/Core/CoreEvaluators.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(Flags0)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
LinearAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearAccessMask	Eigen/src/Core/CoreEvaluators.h	/^    LinearAccessMask = XprType::IsVectorAtCompileTime ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon765
LinearAccessMask	Eigen/src/Core/CoreEvaluators.h	/^    LinearAccessMask = bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime) ? ~int(0) : ~int(LinearAccessBit),$/;"	e	enum:Eigen::internal::evaluator::__anon759
LinearBlock	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_const<LinearBlockConst>::type                 LinearBlock;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearBlock	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_const<LinearBlockConst>::type                 LinearBlock;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearBlockConst	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Lhs::template ConstNColsBlockXpr<Dim>::Type          LinearBlockConst;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearBlockConst	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename Rhs::template ConstNRowsBlockXpr<Dim>::Type          LinearBlockConst;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearMapper	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gebp_kernel
LinearMapper	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gemm_pack_lhs
LinearMapper	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename DataMapper::LinearMapper LinearMapper;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
LinearMapper	Eigen/src/Core/util/BlasUtil.h	/^  typedef BlasLinearMapper<Scalar, Index, AlignmentType> LinearMapper;$/;"	t	class:Eigen::internal::blas_data_mapper
LinearMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef Self LinearMapper;$/;"	t	class:Eigen::internal::TensorContractionSubMapper
LinearMatrixType	Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearPacketSize	Eigen/src/Core/AssignEvaluator.h	/^    LinearPacketSize = unpacket_traits<LinearPacketType>::size,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon505
LinearPacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename find_best_packet<DstScalar,Dst::SizeAtCompileTime>::type LinearPacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
LinearPart	Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;$/;"	t	class:Eigen::Transform
LinearProduct	Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<Lhs,LinearBlock,LazyProduct>                          LinearProduct;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
LinearProduct	Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<LinearBlock,Rhs,LazyProduct>                          LinearProduct;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
LinearRequiredAlignment	Eigen/src/Core/AssignEvaluator.h	/^    LinearRequiredAlignment = unpacket_traits<LinearPacketType>::alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon506
LinearTraversal	Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::TraversalType
LinearVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
ListEl	Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector
Literal	Eigen/src/SVD/BDCSVD.h	/^  typedef typename NumTraits<RealScalar>::Literal Literal;$/;"	t	class:Eigen::BDCSVD
Literal	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename NumTraits<typename DerTypeCleaned::Scalar>::Literal Literal;$/;"	t	struct:Eigen::NumTraits
Local	demos/opengl/trackball.h	/^    enum Mode {Around, Local};$/;"	e	enum:Trackball::Mode
Log10ReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log10_op<Scalar>, const Derived> Log10ReturnType;$/;"	t
Log1pReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log1p_op<Scalar>, const Derived> Log1pReturnType;$/;"	t
LogReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_log_op<Scalar>, const Derived> LogReturnType;$/;"	t
Lower	Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::UpLoType
LpNormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    template<int p> struct LpNormReturnType {$/;"	s	class:Eigen::VectorwiseOp
LuType	Eigen/src/LU/FullPivLU.h	/^  typedef FullPivLU<MatrixType> LuType;$/;"	t	struct:Eigen::internal::Assignment
LuType	Eigen/src/LU/PartialPivLU.h	/^  typedef PartialPivLU<MatrixType> LuType;$/;"	t	struct:Eigen::internal::Assignment
LvalueBit	Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
LvalueBitFlag	Eigen/src/Core/ArrayWrapper.h	/^    LvalueBitFlag = is_lvalue<ExpressionType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon441
LvalueBitFlag	Eigen/src/Core/ArrayWrapper.h	/^    LvalueBitFlag = is_lvalue<ExpressionType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon442
M	bench/bench_gemm.cpp	/^typedef Matrix<RealScalar,Dynamic,Dynamic> M;$/;"	t	file:
M	bench/geometry.cpp	/^typedef Matrix<RealScalar,Dynamic,Dynamic> M;$/;"	t	file:
M	doc/snippets/DirectionWise_hnormalized.cpp	/^Matrix4Xd M = Matrix4Xd::Random(4,5);$/;"	v
M	doc/snippets/MatrixBase_eval.cpp	/^Matrix2f M = Matrix2f::Random();$/;"	v
M	doc/snippets/VectorwiseOp_homogeneous.cpp	/^Matrix3Xd M = Matrix3Xd::Random(3,5);$/;"	v
M1	doc/snippets/Tutorial_SlicingCol.cpp	/^MatrixXf M1 = MatrixXf::Random(3,8);$/;"	v
M1	doc/snippets/Tutorial_SlicingCol.cpp	/^cout << "Column major input:" << endl << M1 << "\\n";$/;"	v
M2	doc/snippets/Tutorial_SlicingCol.cpp	/^cout << "1 column over 3:" << endl << M2 << "\\n";$/;"	v
M3	doc/snippets/Tutorial_SlicingCol.cpp	/^cout << "Row major input:" << endl << M3 << "\\n";$/;"	v
M4	doc/snippets/Tutorial_SlicingCol.cpp	/^cout << "1 column over 3:" << endl << M4 << "\\n";/;"	v
MAKE_STRING	bench/btl/libs/BLAS/blas_interface.hh	48;"	d
MAKE_STRING2	bench/btl/libs/BLAS/blas_interface.hh	47;"	d
MANDELBROT_H	demos/mandelbrot/mandelbrot.h	11;"	d
MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
MATSIZE	bench/benchmark.cpp	8;"	d	file:
MATSIZE	bench/benchmarkX.cpp	15;"	d	file:
MATTYPE	bench/benchmarkX.cpp	11;"	d	file:
MAX_AXPY	bench/btl/generic_bench/bench_parameter.hh	32;"	d
MAX_LU	bench/btl/generic_bench/bench_parameter.hh	44;"	d
MAX_MM	bench/btl/generic_bench/bench_parameter.hh	40;"	d
MAX_MV	bench/btl/generic_bench/bench_parameter.hh	36;"	d
MESSAGE	bench/btl/generic_bench/utils/utilities.h	59;"	d
MESSAGE	bench/btl/generic_bench/utils/utilities.h	76;"	d
METIS_SUPPORT_H	Eigen/src/MetisSupport/MetisSupport.h	10;"	d
MGH09_functor	unsupported/test/NonLinearOptimization.cpp	/^    MGH09_functor(void) : Functor<double>(4,11) {}$/;"	f	struct:MGH09_functor
MGH09_functor	unsupported/test/NonLinearOptimization.cpp	/^struct MGH09_functor : Functor<double>$/;"	s	file:
MGH09_functor	unsupported/test/levenberg_marquardt.cpp	/^    MGH09_functor(void) : DenseFunctor<double>(4,11) {}$/;"	f	struct:MGH09_functor
MGH09_functor	unsupported/test/levenberg_marquardt.cpp	/^struct MGH09_functor : DenseFunctor<double>$/;"	s	file:
MGH10_functor	unsupported/test/NonLinearOptimization.cpp	/^    MGH10_functor(void) : Functor<double>(3,16) {}$/;"	f	struct:MGH10_functor
MGH10_functor	unsupported/test/NonLinearOptimization.cpp	/^struct MGH10_functor : Functor<double>$/;"	s	file:
MGH10_functor	unsupported/test/levenberg_marquardt.cpp	/^    MGH10_functor(void) : DenseFunctor<double>(3,16) {}$/;"	f	struct:MGH10_functor
MGH10_functor	unsupported/test/levenberg_marquardt.cpp	/^struct MGH10_functor : DenseFunctor<double>$/;"	s	file:
MGH17_functor	unsupported/test/NonLinearOptimization.cpp	/^    MGH17_functor(void) : Functor<double>(5,33) {}$/;"	f	struct:MGH17_functor
MGH17_functor	unsupported/test/NonLinearOptimization.cpp	/^struct MGH17_functor : Functor<double>$/;"	s	file:
MGH17_functor	unsupported/test/levenberg_marquardt.cpp	/^    MGH17_functor(void) : DenseFunctor<double>(5,33) {}$/;"	f	struct:MGH17_functor
MGH17_functor	unsupported/test/levenberg_marquardt.cpp	/^struct MGH17_functor : DenseFunctor<double>$/;"	s	file:
MINDENSITY	bench/sparse_cholesky.cpp	26;"	d	file:
MINDENSITY	bench/sparse_dense_product.cpp	21;"	d	file:
MINDENSITY	bench/sparse_lu.cpp	26;"	d	file:
MINDENSITY	bench/sparse_randomsetter.cpp	25;"	d	file:
MINDENSITY	bench/sparse_transpose.cpp	21;"	d	file:
MINDENSITY	bench/sparse_trisolver.cpp	22;"	d	file:
MINRES	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        MINRES() : Base() {}$/;"	f	class:Eigen::MINRES
MINRES	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        explicit MINRES(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::MINRES
MINRES	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^    class MINRES : public IterativeSolverBase<MINRES<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen
MIN_AXPY	bench/btl/generic_bench/bench_parameter.hh	30;"	d
MIN_LU	bench/btl/generic_bench/bench_parameter.hh	42;"	d
MIN_MM	bench/btl/generic_bench/bench_parameter.hh	38;"	d
MIN_MV	bench/btl/generic_bench/bench_parameter.hh	34;"	d
MIN_TIME	bench/btl/generic_bench/bench_parameter.hh	26;"	d
MODE	blas/testing/cblat1.f	/^      INTEGER          ICASE, INCX, INCY, MODE,/;"	v	program:CBLAT1
MODE	blas/testing/zblat1.f	/^      INTEGER          ICASE, INCX, INCY, MODE,/;"	v	program:ZBLAT1
MODES	bench/basicbenchmark.cpp	12;"	d	file:
MPFR_USE_INTMAX_T	unsupported/test/mpreal/mpreal.h	108;"	d
MPREAL_DOUBLE_BITS_OVERFLOW	unsupported/test/mpreal/mpreal.h	125;"	d
MPREAL_HAVE_DYNAMIC_STD_NUMERIC_LIMITS	unsupported/test/mpreal/mpreal.h	64;"	d
MPREAL_HAVE_EXPLICIT_CONVERTERS	unsupported/test/mpreal/mpreal.h	105;"	d
MPREAL_HAVE_MOVE_SUPPORT	unsupported/test/mpreal/mpreal.h	93;"	d
MPREAL_HAVE_MSVC_DEBUGVIEW	unsupported/test/mpreal/mpreal.h	63;"	d
MPREAL_MSVC_DEBUGVIEW_CODE	unsupported/test/mpreal/mpreal.h	111;"	d
MPREAL_MSVC_DEBUGVIEW_CODE	unsupported/test/mpreal/mpreal.h	114;"	d
MPREAL_MSVC_DEBUGVIEW_DATA	unsupported/test/mpreal/mpreal.h	112;"	d
MPREAL_MSVC_DEBUGVIEW_DATA	unsupported/test/mpreal/mpreal.h	115;"	d
MPREAL_PERMISSIVE_EXPR	unsupported/test/mpreal/mpreal.h	135;"	d
MPREAL_PERMISSIVE_EXPR	unsupported/test/mpreal/mpreal.h	137;"	d
MPREAL_UNARY_MATH_FUNCTION_BODY	unsupported/test/mpreal/mpreal.h	2159;"	d
MPREAL_VERSION_MAJOR	unsupported/test/mpreal/mpreal.h	69;"	d
MPREAL_VERSION_MINOR	unsupported/test/mpreal/mpreal.h	70;"	d
MPREAL_VERSION_PATCHLEVEL	unsupported/test/mpreal/mpreal.h	71;"	d
MPREAL_VERSION_STRING	unsupported/test/mpreal/mpreal.h	72;"	d
MTL4_INTERFACE_HH	bench/btl/libs/mtl4/mtl4_interface.hh	19;"	d
MYVERIFY	bench/benchBlasGemm.cpp	171;"	d	file:
M_PI	test/main.h	76;"	d
M_PI	test/main.h	78;"	d
MakeAutoDiffScalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<NewDerType> MakeAutoDiffScalar(const typename NewDerType::Scalar& value, const NewDerType &der) {$/;"	f	namespace:Eigen
MakeComplex	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <> struct MakeComplex<false> {$/;"	s	namespace:Eigen
MakeComplex	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <> struct MakeComplex<true> {$/;"	s	namespace:Eigen
MakeComplex	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <bool NeedUprade> struct MakeComplex {$/;"	s	namespace:Eigen
MakeComplexOp	doc/examples/class_CwiseBinaryOp.cpp	/^template<typename Scalar> struct MakeComplexOp {$/;"	s	file:
MakeGlobalPointer	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^struct MakeGlobalPointer {$/;"	s
MakeLocalPointer	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^struct MakeLocalPointer {$/;"	s
MakeLowerTriangular	test/sparse.h	/^  MakeLowerTriangular = 2,$/;"	e	enum:__anon193
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  struct MakePointer {$/;"	s	struct:Eigen::internal::traits
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  template <class T> struct MakePointer {$/;"	s	struct:Eigen::internal::traits
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^template<typename T> struct MakePointer {$/;"	s	namespace:Eigen
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  template <class T> struct MakePointer {$/;"	s	struct:Eigen::internal::traits
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  template <class T> struct MakePointer {$/;"	s	struct:Eigen::internal::traits
MakePointer	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  template <typename T> struct MakePointer {$/;"	s	struct:Eigen::internal::traits
MakePointerT	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    typedef MakePointer_<T> MakePointerT;$/;"	t	struct:Eigen::internal::traits::MakePointer
MakePointerT	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    typedef MakePointer_<T> MakePointerT;$/;"	t	struct:Eigen::internal::traits::MakePointer
MakePointerT	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef MakePointer_<T> MakePointerT;$/;"	t	struct:Eigen::internal::traits::MakePointer
MakePointerT	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    typedef MakePointer_<T> MakePointerT;$/;"	t	struct:Eigen::internal::traits::MakePointer
MakeUpperTriangular	test/sparse.h	/^  MakeUpperTriangular = 4,$/;"	e	enum:__anon193
MandelbrotThread	demos/mandelbrot/mandelbrot.h	/^    MandelbrotThread(MandelbrotWidget *w, int i) : widget(w), id(i) {}$/;"	f	class:MandelbrotThread
MandelbrotThread	demos/mandelbrot/mandelbrot.h	/^class MandelbrotThread : public QThread$/;"	c
MandelbrotWidget	demos/mandelbrot/mandelbrot.h	/^    MandelbrotWidget() : QWidget(), center(0,0), xradius(2),$/;"	f	class:MandelbrotWidget
MandelbrotWidget	demos/mandelbrot/mandelbrot.h	/^class MandelbrotWidget : public QWidget$/;"	c
Map	Eigen/src/Core/Map.h	/^    explicit inline Map(PointerArgType dataPtr, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index rows, Index cols, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index size, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen
Map	Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const StorageIndex* indicesPtr)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const StorageIndex* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex>,_PacketAccess>$/;"	c	namespace:Eigen
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/Transpositions.h	/^    explicit inline Map(const StorageIndex* indicesPtr)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Transpositions.h	/^    inline Map(const StorageIndex* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,PacketAccess>$/;"	c	namespace:Eigen
Map	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC explicit EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC explicit EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	Eigen/src/SparseCore/SparseMap.h	/^    inline Map(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr,$/;"	f	class:Eigen::Map
Map	Eigen/src/SparseCore/SparseMap.h	/^    inline Map(Index rows, Index cols, Index nnz, const StorageIndex* outerIndexPtr,$/;"	f	class:Eigen::Map
Map	Eigen/src/SparseCore/SparseMap.h	/^class Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Map	Eigen/src/SparseCore/SparseMap.h	/^class Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Map	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix
Map	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix
Map	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& a_mat)$/;"	f	struct:Eigen::SluMatrix
Map	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    static SkylineStorage Map(Index* upperProfile, Index* lowerProfile, Scalar* diag, Scalar* upper, Scalar* lower, Index size, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
Map	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::DynamicSparseMatrix
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapBase	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index rows, Index cols) : Base(dataPtr, rows, cols) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index rows, Index cols)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
MapBase	Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen
MapLU	Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl
MapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase
MapType	doc/snippets/Tutorial_Map_using.cpp	/^typedef Map<MatrixType> MapType;$/;"	t	file:
MapTypeConst	doc/snippets/Tutorial_Map_using.cpp	/^typedef Map<const MatrixType> MapTypeConst;   \/\/ a read-only map$/;"	t	file:
Map_MatrixXd_add	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_add(const C_Map_MatrixXd *m1, const C_Map_MatrixXd *m2, C_Map_MatrixXd *result)$/;"	f
Map_MatrixXd_copy	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_copy(C_Map_MatrixXd *dst, const C_Map_MatrixXd *src)$/;"	f
Map_MatrixXd_copy_matrix	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_copy_matrix(C_Map_MatrixXd *dst, const C_MatrixXd *src)$/;"	f
Map_MatrixXd_delete	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_delete(C_Map_MatrixXd *m)$/;"	f
Map_MatrixXd_get_coeff	demos/mix_eigen_and_c/binary_library.cpp	/^double Map_MatrixXd_get_coeff(const C_Map_MatrixXd *m, int i, int j)$/;"	f
Map_MatrixXd_multiply	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_multiply(const C_Map_MatrixXd *m1, const C_Map_MatrixXd *m2, C_Map_MatrixXd *result)$/;"	f
Map_MatrixXd_new	demos/mix_eigen_and_c/binary_library.cpp	/^C_Map_MatrixXd* Map_MatrixXd_new(double *array, int rows, int cols)$/;"	f
Map_MatrixXd_print	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_print(const C_Map_MatrixXd *m)$/;"	f
Map_MatrixXd_set_coeff	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_set_coeff(C_Map_MatrixXd *m, int i, int j, double coeff)$/;"	f
Map_MatrixXd_set_zero	demos/mix_eigen_and_c/binary_library.cpp	/^void Map_MatrixXd_set_zero(C_Map_MatrixXd *m)$/;"	f
MappedMatrixBlock	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Map<ScalarMatrix, 0,  OuterStride<> > MappedMatrixBlock;$/;"	t	class:Eigen::internal::SparseLUImpl
MappedRhs	Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector
MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr, StorageIndex* innerIndexPtr, Scalar* valuePtr, StorageIndex* innerNonZeroPtr = 0)$/;"	f	class:Eigen::MappedSparseMatrix
MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix(Index m, Index n,  ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind,$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix$/;"	c	namespace:Eigen::internal
MaskLvalueBit	Eigen/src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon500
MaskPacketAccessBit	Eigen/src/Core/CoreEvaluators.h	/^    MaskPacketAccessBit = (InnerStrideAtCompileTime == 1 || HasSameStorageOrderAsArgType) ? PacketAccessBit : 0,$/;"	e	enum:Eigen::internal::evaluator::__anon761
Mat	bench/perf_monitoring/gemm/gemm.cpp	/^typedef Matrix<Scalar,Dynamic,Dynamic> Mat;$/;"	t	file:
Mat1	failtest/sparse_storage_mismatch.cpp	/^typedef SparseMatrix<double,ColMajor> Mat1;$/;"	t	file:
Mat2	failtest/sparse_storage_mismatch.cpp	/^typedef SparseMatrix<double,ColMajor> Mat2;$/;"	t	file:
Mat2	failtest/sparse_storage_mismatch.cpp	/^typedef SparseMatrix<double,RowMajor> Mat2;$/;"	t	file:
MatchAtCompileTime	Eigen/src/Core/Ref.h	/^      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch$/;"	e	enum:Eigen::internal::traits::match::__anon474
MatchAtCompileTime	Eigen/src/SparseCore/SparseRef.h	/^      MatchAtCompileTime = (Derived::Flags&CompressedAccessBit) && Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon800
MatchAtCompileTime	Eigen/src/SparseCore/SparseRef.h	/^      MatchAtCompileTime = (Derived::Flags&CompressedAccessBit) && StorageOrderMatch$/;"	e	enum:Eigen::internal::traits::match::__anon797
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix() : Base()$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(const T& x)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    explicit Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen
Matrix	Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix2	Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix2s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,2> Matrix2s;$/;"	t	class:Eigen::RealQZ
Matrix3	Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase
Matrix3	demos/opengl/quaternion_demo.cpp	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:EulerAngles	file:
Matrix3	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef Matrix<Scalar,3,3> Matrix3; \/*!< the equivalent rotation matrix type *\/$/;"	t	class:Eigen::EulerAngles
Matrix3Xd	doc/snippets/VectorwiseOp_homogeneous.cpp	/^typedef Matrix<double,3,Dynamic> Matrix3Xd;$/;"	t	file:
Matrix3dRowMajor	unsupported/test/matrix_power.cpp	/^typedef Matrix<double,3,3,RowMajor>         Matrix3dRowMajor;$/;"	t	file:
Matrix3e	unsupported/test/matrix_power.cpp	/^typedef Matrix<long double,3,3>             Matrix3e;$/;"	t	file:
Matrix3x3	doc/snippets/HouseholderQR_solve.cpp	/^typedef Matrix<float,3,3> Matrix3x3;$/;"	t	file:
Matrix4Xd	doc/snippets/DirectionWise_hnormalized.cpp	/^typedef Matrix<double,4,Dynamic> Matrix4Xd;$/;"	t	file:
Matrix5x3	doc/snippets/class_FullPivLU.cpp	/^typedef Matrix<double, 5, 3> Matrix5x3;$/;"	t	file:
Matrix5x5	doc/snippets/class_FullPivLU.cpp	/^typedef Matrix<double, 5, 5> Matrix5x5;$/;"	t	file:
MatrixAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = traits<MatrixType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon230
MatrixAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = traits<MatrixType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon231
MatrixBase	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase
MatrixBase	Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen
MatrixCols	Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon464
MatrixComplexPowerReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    MatrixComplexPowerReturnValue(const Derived& A, const ComplexScalar& p) : m_A(A), m_p(p)$/;"	f	class:Eigen::MatrixComplexPowerReturnValue
MatrixComplexPowerReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^class MatrixComplexPowerReturnValue : public ReturnByValue< MatrixComplexPowerReturnValue<Derived> >$/;"	c	namespace:Eigen
MatrixConjugateReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::SelfAdjointView
MatrixConjugateReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView
MatrixExponentialReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixExponentialReturnValue(const Derived& src) : m_src(src) { }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
MatrixExponentialReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<typename Derived> struct MatrixExponentialReturnValue$/;"	s	namespace:Eigen
MatrixExponentialScalingOp	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  MatrixExponentialScalingOp(int squarings) : m_squarings(squarings) { }$/;"	f	struct:Eigen::internal::MatrixExponentialScalingOp
MatrixExponentialScalingOp	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct MatrixExponentialScalingOp$/;"	s	namespace:Eigen::internal
MatrixFlags	Eigen/src/Core/ProductEvaluators.h	/^    MatrixFlags = evaluator<MatrixType>::Flags,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
MatrixFree	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MatrixFree = false$/;"	e	enum:Eigen::internal::generic_matrix_wrapper::__anon235
MatrixFree	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MatrixFree = true$/;"	e	enum:Eigen::internal::generic_matrix_wrapper::__anon236
MatrixFunctionAtomic	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixFunctionAtomic(StemFunction f) : m_f(f) { }$/;"	f	class:Eigen::internal::MatrixFunctionAtomic
MatrixFunctionAtomic	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^class MatrixFunctionAtomic $/;"	c	namespace:Eigen::internal
MatrixFunctionReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixFunctionReturnValue(const Derived& A, StemFunction f) : m_A(A), m_f(f) { }$/;"	f	class:Eigen::MatrixFunctionReturnValue
MatrixFunctionReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^template<typename Derived> class MatrixFunctionReturnValue$/;"	c	namespace:Eigen
MatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixL	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixLogarithmAtomic	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^class MatrixLogarithmAtomic$/;"	c	namespace:Eigen::internal
MatrixLogarithmReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  explicit MatrixLogarithmReturnValue(const Derived& A) : m_A(A) { }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
MatrixLogarithmReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^template<typename Derived> class MatrixLogarithmReturnValue$/;"	c	namespace:Eigen
MatrixMarketIterator	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    MatrixMarketIterator(const std::string &folder)$/;"	f	class:Eigen::MatrixMarketIterator
MatrixMarketIterator	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^class MatrixMarketIterator $/;"	c	namespace:Eigen
MatrixOptions	Eigen/src/SVD/BDCSVD.h	/^    MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::BDCSVD::__anon777
MatrixOptions	Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon784
MatrixOptions	Eigen/src/SVD/SVDBase.h	/^    MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::SVDBase::__anon786
MatrixPower	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    explicit MatrixPower(const MatrixType& A) :$/;"	f	class:Eigen::MatrixPower
MatrixPower	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^class MatrixPower : internal::noncopyable$/;"	c	namespace:Eigen
MatrixPowerAtomic	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^MatrixPowerAtomic<MatrixType>::MatrixPowerAtomic(const MatrixType& T, RealScalar p) :$/;"	f	class:Eigen::MatrixPowerAtomic
MatrixPowerAtomic	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^class MatrixPowerAtomic : internal::noncopyable$/;"	c	namespace:Eigen
MatrixPowerParenthesesReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    MatrixPowerParenthesesReturnValue(MatrixPower<MatrixType>& pow, RealScalar p) : m_pow(pow), m_p(p)$/;"	f	class:Eigen::MatrixPowerParenthesesReturnValue
MatrixPowerParenthesesReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^class MatrixPowerParenthesesReturnValue : public ReturnByValue< MatrixPowerParenthesesReturnValue<MatrixType> >$/;"	c	namespace:Eigen
MatrixPowerReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    MatrixPowerReturnValue(const Derived& A, RealScalar p) : m_A(A), m_p(p)$/;"	f	class:Eigen::MatrixPowerReturnValue
MatrixPowerReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^class MatrixPowerReturnValue : public ReturnByValue< MatrixPowerReturnValue<Derived> >$/;"	c	namespace:Eigen
MatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixQType	Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR
MatrixReplacement	doc/examples/matrixfree_cg.cpp	/^  MatrixReplacement() : mp_mat(0) {}$/;"	f	class:MatrixReplacement
MatrixReplacement	doc/examples/matrixfree_cg.cpp	/^class MatrixReplacement : public Eigen::EigenBase<MatrixReplacement> {$/;"	c	file:
MatrixRows	Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon464
MatrixSquareRootReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    explicit MatrixSquareRootReturnValue(const Derived& src) : m_src(src) { }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
MatrixSquareRootReturnValue	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^template<typename Derived> class MatrixSquareRootReturnValue$/;"	c	namespace:Eigen
MatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT
MatrixType	Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT
MatrixType	Eigen/src/Core/ProductEvaluators.h	/^    typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixType	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<typename internal::conditional<int(Side)==OnTheRight,LhsNested,RhsNested>::type>::type MatrixType;$/;"	t	struct:Eigen::internal::generic_product_impl
MatrixType	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::transposition_matrix_product
MatrixType	Eigen/src/Core/SelfAdjointView.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointView
MatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView
MatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularViewImpl
MatrixType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver
MatrixType	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur
MatrixType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver
MatrixType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedEigenSolver
MatrixType	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
MatrixType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealQZ
MatrixType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur
MatrixType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
MatrixType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
MatrixType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB
MatrixType	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient
MatrixType	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase
MatrixType	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
MatrixType	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU
MatrixType	Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU
MatrixType	Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits
MatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits
MatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl
MatrixType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
MatrixType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixType	Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR
MatrixType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor, StorageIndex> MatrixType;$/;"	t	class:Eigen::SPQR
MatrixType	Eigen/src/SVD/BDCSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BDCSVD
MatrixType	Eigen/src/SVD/BDCSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD
MatrixType	Eigen/src/SVD/JacobiSVD.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SVD/SVDBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SVDBase
MatrixType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _StorageIndex> MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename nested_eval<ExpressionType, 1>::type MatrixType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixType	Eigen/src/SparseLU/SparseLU.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::SparseLU
MatrixType	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> MatrixType; $/;"	t	class:Eigen::internal::SparseLUImpl
MatrixType	Eigen/src/SparseQR/SparseQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SparseQR
MatrixType	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::evaluator_traits
MatrixType	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::QRMatrixType MatrixType;$/;"	t	struct:Eigen::SparseQR_QProduct
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU
MatrixType	Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base
MatrixType	Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	bench/benchmark-blocking-sizes.cpp	/^typedef MatrixXf MatrixType;$/;"	t	file:
MatrixType	blas/common.h	/^typedef Map<Matrix<Scalar,Dynamic,Dynamic,ColMajor>, 0, OuterStride<> > MatrixType;$/;"	t
MatrixType	doc/examples/make_circulant2.cpp	/^                 ArgType::MaxSizeAtCompileTime> MatrixType;$/;"	t	struct:circulant_helper	file:
MatrixType	doc/examples/nullary_indexing.cpp	/^                 ColIndexType::MaxSizeAtCompileTime> MatrixType;$/;"	t	class:indexing_functor	file:
MatrixType	doc/snippets/Tutorial_Map_using.cpp	/^typedef Matrix<float,1,Dynamic> MatrixType;$/;"	t	file:
MatrixType	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::DGMRES
MatrixType	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GMRES
MatrixType	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLU
MatrixType	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^            typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        typedef _MatrixType MatrixType;$/;"	t	class:Eigen::MINRES
MatrixType	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::IterScaling
MatrixType	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    typedef SparseMatrix<Scalar,ColMajor> MatrixType; $/;"	t	class:Eigen::MatrixMarketIterator
MatrixTypeCleaned	Eigen/src/Core/ProductEvaluators.h	/^    typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixTypeCleaned	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product
MatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeCleaned	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::permutation_matrix_product
MatrixTypeInnerStride	Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon460
MatrixTypeNested	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryView
MatrixTypeNested	Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Diagonal.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate
MatrixTypeNested	Eigen/src/Core/Replicate.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Reverse.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNested	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Transpose.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::Transpose
MatrixTypeNested	Eigen/src/Core/Transpose.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView
MatrixTypeNested	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
MatrixTypeNested	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNested	Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView
MatrixTypeNestedCleaned	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNestedCleaned	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNestedNonRef	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedNonRef	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedNonRef	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularViewImpl
MatrixTypeNestedPlain	Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits
MatrixTypeOuterStride	Eigen/src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon500
MatrixTypeRealView	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization
MatrixU	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixUType	Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::MatrixUType MatrixUType;$/;"	t	class:Eigen::BDCSVD
MatrixUType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::MatrixUType MatrixUType;$/;"	t	class:Eigen::JacobiSVD
MatrixUType	Eigen/src/SVD/SVDBase.h	/^  typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, MatrixOptions, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixUType;$/;"	t	class:Eigen::SVDBase
MatrixVType	Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::MatrixVType MatrixVType;$/;"	t	class:Eigen::BDCSVD
MatrixVType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::MatrixVType MatrixVType;$/;"	t	class:Eigen::JacobiSVD
MatrixVType	Eigen/src/SVD/SVDBase.h	/^  typedef Matrix<Scalar, ColsAtCompileTime, ColsAtCompileTime, MatrixOptions, MaxColsAtCompileTime, MaxColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVDBase
MatrixWrapper	Eigen/src/Core/ArrayWrapper.h	/^    explicit inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::MatrixWrapper
MatrixWrapper	Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen
MatrixWrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef internal::generic_matrix_wrapper<MatrixType> MatrixWrapper;$/;"	t	class:Eigen::IterativeSolverBase
MatrixX	Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<Scalar, Dynamic, Dynamic, ColMajor> MatrixX;$/;"	t	class:Eigen::BDCSVD
MatrixXd_add	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_add(const C_MatrixXd *m1, const C_MatrixXd *m2, C_MatrixXd *result)$/;"	f
MatrixXd_copy	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_copy(C_MatrixXd *dst, const C_MatrixXd *src)$/;"	f
MatrixXd_copy_map	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_copy_map(C_MatrixXd *dst, const C_Map_MatrixXd *src)$/;"	f
MatrixXd_data	demos/mix_eigen_and_c/binary_library.cpp	/^double* MatrixXd_data(C_MatrixXd *m)$/;"	f
MatrixXd_delete	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_delete(C_MatrixXd *m)$/;"	f
MatrixXd_get_coeff	demos/mix_eigen_and_c/binary_library.cpp	/^double MatrixXd_get_coeff(const C_MatrixXd *m, int i, int j)$/;"	f
MatrixXd_multiply	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_multiply(const C_MatrixXd *m1, const C_MatrixXd *m2, C_MatrixXd *result)$/;"	f
MatrixXd_new	demos/mix_eigen_and_c/binary_library.cpp	/^C_MatrixXd* MatrixXd_new(int rows, int cols)$/;"	f
MatrixXd_print	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_print(const C_MatrixXd *m)$/;"	f
MatrixXd_resize	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_resize(C_MatrixXd *m, int rows, int cols)$/;"	f
MatrixXd_set_coeff	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_set_coeff(C_MatrixXd *m, int i, int j, double coeff)$/;"	f
MatrixXd_set_zero	demos/mix_eigen_and_c/binary_library.cpp	/^void MatrixXd_set_zero(C_MatrixXd *m)$/;"	f
MatrixXe	unsupported/test/matrix_power.cpp	/^typedef Matrix<long double,Dynamic,Dynamic> MatrixXe;$/;"	t	file:
MatrixXpr	Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
MatrixXr	Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<RealScalar, Dynamic, Dynamic, ColMajor> MatrixXr;$/;"	t	class:Eigen::BDCSVD
Max	Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MaxCoeffReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_maxCoeff>::Type MaxCoeffReturnType;$/;"	t	class:Eigen::VectorwiseOp
MaxCols	Eigen/src/Core/GeneralProduct.h	/^    MaxCols = traits<_Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
MaxCols	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    MaxCols = size_at_compile_time<traits<Lhs>::MaxColsAtCompileTime, traits<Rhs>::MaxColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::traits::__anon28
MaxColsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon242
MaxColsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon243
MaxColsAtCompileTime	Eigen/src/CholmodSupport/CholmodSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::CholmodBase::__anon281
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon478
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon479
MaxColsAtCompileTime	Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon464
MaxColsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    MaxColsAtCompileTime = traits<XprType>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon761
MaxColsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon446
MaxColsAtCompileTime	Eigen/src/Core/CwiseTernaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon514
MaxColsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
MaxColsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon500
MaxColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon282
MaxColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon284
MaxColsAtCompileTime	Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon439
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = PermTraits::MaxColsAtCompileTime$/;"	e	enum:Eigen::InverseImpl::__anon468
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon466
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon467
MaxColsAtCompileTime	Eigen/src/Core/Product.h	/^    MaxColsAtCompileTime = RhsTraits::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
MaxColsAtCompileTime	Eigen/src/Core/ProductEvaluators.h	/^    MaxColsAtCompileTime = RhsNestedCleaned::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::product_evaluator::__anon427
MaxColsAtCompileTime	Eigen/src/Core/Redux.h	/^    MaxColsAtCompileTime = XprType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
MaxColsAtCompileTime	Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon772
MaxColsAtCompileTime	Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon433
MaxColsAtCompileTime	Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
MaxColsAtCompileTime	Eigen/src/Core/SolverBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
MaxColsAtCompileTime	Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon443
MaxColsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
MaxColsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon637
MaxColsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon861
MaxColsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon862
MaxColsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon864
MaxColsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon860
MaxColsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealQZ::__anon859
MaxColsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon855
MaxColsAtCompileTime	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon863
MaxColsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon258
MaxColsAtCompileTime	Eigen/src/Geometry/Transform.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon264
MaxColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon278
MaxColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon277
MaxColsAtCompileTime	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::DiagonalPreconditioner::__anon232
MaxColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::IncompleteCholesky::__anon240
MaxColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::IncompleteLUT::__anon241
MaxColsAtCompileTime	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::IterativeSolverBase::__anon237
MaxColsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon225
MaxColsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon229
MaxColsAtCompileTime	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PastixBase::__anon213
MaxColsAtCompileTime	Eigen/src/PardisoSupport/PardisoSupport.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::PardisoImpl::__anon787
MaxColsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon212
MaxColsAtCompileTime	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon210
MaxColsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon208
MaxColsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon206
MaxColsAtCompileTime	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      MaxColsAtCompileTime = Dynamic$/;"	e	enum:Eigen::SPQR::__anon790
MaxColsAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon777
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon784
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon781
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon782
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon783
MaxColsAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon786
MaxColsAtCompileTime	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon217
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon837
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon836
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon845
MaxColsAtCompileTime	Eigen/src/SparseLU/SparseLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SparseLU::__anon874
MaxColsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SparseQR::__anon775
MaxColsAtCompileTime	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SuperLUBase::__anon867
MaxColsAtCompileTime	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::UmfPackLU::__anon791
MaxColsAtCompileTime	doc/examples/matrixfree_cg.cpp	/^    MaxColsAtCompileTime = Eigen::Dynamic,$/;"	e	enum:MatrixReplacement::__anon191	file:
MaxColsAtCompileTime	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    MaxColsAtCompileTime = size_at_compile_time<traits<Lhs>::MaxColsAtCompileTime, traits<Rhs>::MaxColsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon29
MaxColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon41
MaxColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
MaxColsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon40
MaxColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      MaxColsAtCompileTime = BlockSparseMatrixT::MaxColsAtCompileTime,$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
MaxColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
MaxColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon72
MaxColsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon76
MaxColsAtCompileTime	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon63
MaxDepth	Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(traits<_Lhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
MaxDepthAtCompileTime	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::internal::generic_product_impl::__anon617
MaxDiagSizeAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime, MaxColsAtCompileTime), $/;"	e	enum:Eigen::BDCSVD::__anon777
MaxDiagSizeAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon784
MaxDiagSizeAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::SVDBase::__anon786
MaxReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct MaxReducer$/;"	s	namespace:Eigen::internal
MaxRows	Eigen/src/Core/GeneralProduct.h	/^    MaxRows = traits<_Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
MaxRows	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    MaxRows = size_at_compile_time<traits<Lhs>::MaxRowsAtCompileTime, traits<Rhs>::MaxRowsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon28
MaxRowsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon242
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon478
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon479
MaxRowsAtCompileTime	Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon464
MaxRowsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    MaxRowsAtCompileTime = traits<XprType>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon761
MaxRowsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon446
MaxRowsAtCompileTime	Eigen/src/Core/CwiseTernaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon514
MaxRowsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
MaxRowsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon500
MaxRowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon282
MaxRowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon284
MaxRowsAtCompileTime	Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon439
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = PermTraits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon468
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon466
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon467
MaxRowsAtCompileTime	Eigen/src/Core/Product.h	/^    MaxRowsAtCompileTime = LhsTraits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
MaxRowsAtCompileTime	Eigen/src/Core/ProductEvaluators.h	/^    MaxRowsAtCompileTime = LhsNestedCleaned::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon427
MaxRowsAtCompileTime	Eigen/src/Core/Redux.h	/^    MaxRowsAtCompileTime = XprType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
MaxRowsAtCompileTime	Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon772
MaxRowsAtCompileTime	Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon433
MaxRowsAtCompileTime	Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
MaxRowsAtCompileTime	Eigen/src/Core/SolverBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
MaxRowsAtCompileTime	Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon443
MaxRowsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
MaxRowsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon637
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon861
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon862
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon864
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon860
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon859
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon855
MaxRowsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon258
MaxRowsAtCompileTime	Eigen/src/Geometry/Transform.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon264
MaxRowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon278
MaxRowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon277
MaxRowsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon225
MaxRowsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon229
MaxRowsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon212
MaxRowsAtCompileTime	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon210
MaxRowsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon208
MaxRowsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon206
MaxRowsAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon777
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon784
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon780
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon781
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon782
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon783
MaxRowsAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon786
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon836
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon837
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon845
MaxRowsAtCompileTime	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    MaxRowsAtCompileTime = size_at_compile_time<traits<Lhs>::MaxRowsAtCompileTime, traits<Rhs>::MaxRowsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon29
MaxRowsAtCompileTime	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::MatrixPowerAtomic::__anon30
MaxRowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon41
MaxRowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
MaxRowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon40
MaxRowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      MaxRowsAtCompileTime = BlockSparseMatrixT::MaxRowsAtCompileTime$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
MaxRowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
MaxRowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon72
MaxRowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon76
MaxRowsAtCompileTime	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon63
MaxSize	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon858
MaxSize	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon857
MaxSizeAtCompileTime	Eigen/src/Core/AssignEvaluator.h	/^    MaxSizeAtCompileTime = Dst::SizeAtCompileTime$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon504
MaxSizeAtCompileTime	Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
MaxSizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
MaxSizeAtCompileTime	Eigen/src/Core/SolverBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
MaxSizeAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
MaxSizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
MaxSizeAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
MaxSizeMinusOne	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon858
MaxSizeMinusOne	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon857
MaxSizeVector	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  MaxSizeVector(size_t n, const T& init)$/;"	f	class:Eigen::MaxSizeVector
MaxSizeVector	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  explicit MaxSizeVector(size_t n)$/;"	f	class:Eigen::MaxSizeVector
MaxSizeVector	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^class MaxSizeVector {$/;"	c	namespace:Eigen
MaxSmallDimAtCompileTime	Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon227
MaxSmallDimAtCompileTime	Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon226
MaximumIters	bench/spbench/spbenchsolver.h	/^int MaximumIters; \/\/ Maximum number of iterations$/;"	v
MayInnerVectorize	Eigen/src/Core/AssignEvaluator.h	/^    MayInnerVectorize  = MightVectorize$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
MayLinearVectorize	Eigen/src/Core/AssignEvaluator.h	/^    MayLinearVectorize = bool(MightVectorize) && bool(MayLinearize) && bool(DstHasDirectAccess)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
MayLinearVectorize	Eigen/src/Core/Redux.h	/^    MayLinearVectorize = bool(MightVectorize) && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon483
MayLinearize	Eigen/src/Core/AssignEvaluator.h	/^    MayLinearize = bool(StorageOrdersAgree) && (int(DstFlags) & int(SrcFlags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
MaySliceVectorize	Eigen/src/Core/AssignEvaluator.h	/^    MaySliceVectorize  = bool(MightVectorize) && bool(DstHasDirectAccess)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
MaySliceVectorize	Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = bool(MightVectorize) && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon483
MayUnrollCompletely	Eigen/src/Core/AssignEvaluator.h	/^    MayUnrollCompletely = int(Dst::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon509
MayUnrollInner	Eigen/src/Core/AssignEvaluator.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon509
MeanReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  MeanReducer() : scalarCount_(0), packetCount_(0) { }$/;"	f	struct:Eigen::internal::MeanReducer
MeanReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct MeanReducer$/;"	s	namespace:Eigen::internal
MeanReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_mean>::Type MeanReturnType;$/;"	t	class:Eigen::VectorwiseOp
MemType	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	t	namespace:Eigen::internal	typeref:enum:Eigen::internal::__anon875
MemcpyTriggerForSlicing	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC MemcpyTriggerForSlicing(const Device& device) : threshold_(2 * device.numThreads()) { }$/;"	f	struct:Eigen::__anon91::MemcpyTriggerForSlicing
MemcpyTriggerForSlicing	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC MemcpyTriggerForSlicing(const GpuDevice&) { }$/;"	f	struct:Eigen::__anon91::MemcpyTriggerForSlicing
MemcpyTriggerForSlicing	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^template <typename Index, typename Device> struct MemcpyTriggerForSlicing {$/;"	s	namespace:Eigen::__anon91
MemcpyTriggerForSlicing	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^template <typename Index> struct MemcpyTriggerForSlicing<Index, GpuDevice>  {$/;"	s	namespace:Eigen::__anon91
MetisOrdering	Eigen/src/MetisSupport/MetisSupport.h	/^class MetisOrdering$/;"	c	namespace:Eigen
MightEnableVml	Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml = StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess && Src::InnerStrideAtCompileTime==1 && Dst::InnerStrideAtCompileTime==1,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
MightLinearize	Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
MightVectorize	Eigen/src/Core/AssignEvaluator.h	/^    MightVectorize = bool(StorageOrdersAgree)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
MightVectorize	Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon483
Min	Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
MinCoeffReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_minCoeff>::Type MinCoeffReturnType;$/;"	t	class:Eigen::VectorwiseOp
MinMaxBottomValue	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct MinMaxBottomValue {$/;"	s	namespace:Eigen::internal
MinMaxBottomValue	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct MinMaxBottomValue<T, false, false> {$/;"	s	namespace:Eigen::internal
MinMaxBottomValue	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct MinMaxBottomValue<T, false, true> {$/;"	s	namespace:Eigen::internal
MinMaxBottomValue	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct MinMaxBottomValue<T, true, false> {$/;"	s	namespace:Eigen::internal
MinReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct MinReducer$/;"	s	namespace:Eigen::internal
MinRowsAtCompileTime	Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon246
MinSize	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  static const std::size_t MinSize = max_n_1<Size>::size;$/;"	m	class:Eigen::TensorStorage
Mixed_Perf_Analyzer	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  Mixed_Perf_Analyzer( const Mixed_Perf_Analyzer & ){$/;"	f	class:Mixed_Perf_Analyzer
Mixed_Perf_Analyzer	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  Mixed_Perf_Analyzer( void ):_x86pa(),_ppa(),_use_ppa(true)$/;"	f	class:Mixed_Perf_Analyzer
Mixed_Perf_Analyzer	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^class Mixed_Perf_Analyzer{$/;"	c
ModCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int ModCost() {$/;"	f	class:Eigen::TensorOpCost
Mode	Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode,$/;"	e	enum:Eigen::SelfAdjointView::__anon481
Mode	Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon480
Mode	Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon454
Mode	Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularViewImpl::__anon455
Mode	Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon452
Mode	Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon453
Mode	Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon263
Mode	Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon265
Mode	Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon267
Mode	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon834
Mode	demos/opengl/trackball.h	/^    enum Mode {Around, Local};$/;"	g	class:Trackball
MoveOuter	Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permutation_matrix_product::__anon792
MtlSparse	bench/BenchSparseUtil.h	/^typedef mtl::compressed2D<Scalar, mtl::matrix::parameters<mtl::tag::col_major> > MtlSparse;$/;"	t
MtlSparseRowMajor	bench/BenchSparseUtil.h	/^typedef mtl::compressed2D<Scalar, mtl::matrix::parameters<mtl::tag::row_major> > MtlSparseRowMajor;$/;"	t
MulCost	Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon435
MulCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int MulCost() {$/;"	f	class:Eigen::TensorOpCost
MulCost	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^    MulCost = 1$/;"	e	enum:Eigen::NumTraits::__anon123
MyClassA	test/dynalloc.cpp	/^class MyClassA$/;"	c	file:
MyGenerator	unsupported/test/cxx11_tensor_random.cpp	/^  MyGenerator() { }$/;"	f	struct:MyGenerator
MyGenerator	unsupported/test/cxx11_tensor_random.cpp	/^  MyGenerator(const MyGenerator&) { }$/;"	f	struct:MyGenerator
MyGenerator	unsupported/test/cxx11_tensor_random.cpp	/^struct MyGenerator {$/;"	s	file:
MyMatrix	bench/benchBlasGemm.cpp	/^typedef Eigen::Matrix<Scalar,Eigen::Dynamic,Eigen::Dynamic> MyMatrix;$/;"	t	file:
MyStruct	test/dynalloc.cpp	/^struct MyStruct$/;"	s	file:
MyVectorType	doc/examples/CustomizingEigen_Inheritance.cpp	/^    MyVectorType(const Eigen::MatrixBase<OtherDerived>& other)$/;"	f	class:MyVectorType
MyVectorType	doc/examples/CustomizingEigen_Inheritance.cpp	/^    MyVectorType(void):Eigen::VectorXd() {}$/;"	f	class:MyVectorType
MyVectorType	doc/examples/CustomizingEigen_Inheritance.cpp	/^class MyVectorType : public Eigen::VectorXd$/;"	c	file:
N	blas/testing/cblat1.f	/^      INT/;"	v	program:CBLAT1
N	blas/testing/cblat2.f	/^      INT/;"	v	program:CBLAT2
N	blas/testing/cblat3.f	/^      INT/;"	v	program:CBLAT3
N	blas/testing/dblat1.f	/^      INT/;"	v	program:DBLAT1
N	blas/testing/dblat2.f	/^      INT/;"	v	program:DBLAT2
N	blas/testing/dblat3.f	/^      INT/;"	v	program:DBLAT3
N	blas/testing/sblat1.f	/^      INT/;"	v	program:SBLAT1
N	blas/testing/sblat2.f	/^      INT/;"	v	program:SBLAT2
N	blas/testing/sblat3.f	/^      INT/;"	v	program:SBLAT3
N	blas/testing/zblat1.f	/^      INT/;"	v	program:ZBLAT1
N	blas/testing/zblat2.f	/^      INT/;"	v	program:ZBLAT2
N	blas/testing/zblat3.f	/^      INT/;"	v	program:ZBLAT3
N	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^    static const int N = sizeof(T) * 8;$/;"	m	struct:Eigen::internal::__anon139::DividerTraits
N	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  constexpr static std::size_t N = sizeof...(nn);$/;"	m	struct:Eigen::internal::tensor_static_symgroup_permutate
NALF	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:CBLAT2
NALF	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:CBLAT3
NALF	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:DBLAT2
NALF	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:DBLAT3
NALF	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:SBLAT2
NALF	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:SBLAT3
NALF	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:ZBLAT2
NALF	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF,/;"	v	program:ZBLAT3
NALMAX	blas/testing/cblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX,/;"	v	program:CBLAT2
NALMAX	blas/testing/cblat3.f	/^      INTEGER            NIDMAX, NALMAX,/;"	v	program:CBLAT3
NALMAX	blas/testing/dblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX,/;"	v	program:DBLAT2
NALMAX	blas/testing/dblat3.f	/^      INTEGER            NIDMAX, NALMAX,/;"	v	program:DBLAT3
NALMAX	blas/testing/sblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX,/;"	v	program:SBLAT2
NALMAX	blas/testing/sblat3.f	/^      INTEGER            NIDMAX, NALMAX,/;"	v	program:SBLAT3
NALMAX	blas/testing/zblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX,/;"	v	program:ZBLAT2
NALMAX	blas/testing/zblat3.f	/^      INTEGER            NIDMAX, NALMAX,/;"	v	program:ZBLAT3
NBEMAX	blas/testing/cblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX, NBEMAX$/;"	v	program:CBLAT2
NBEMAX	blas/testing/cblat3.f	/^      INTEGER            NIDMAX, NALMAX, NBEMAX$/;"	v	program:CBLAT3
NBEMAX	blas/testing/dblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX, NBEMAX$/;"	v	program:DBLAT2
NBEMAX	blas/testing/dblat3.f	/^      INTEGER            NIDMAX, NALMAX, NBEMAX$/;"	v	program:DBLAT3
NBEMAX	blas/testing/sblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX, NBEMAX$/;"	v	program:SBLAT2
NBEMAX	blas/testing/sblat3.f	/^      INTEGER            NIDMAX, NALMAX, NBEMAX$/;"	v	program:SBLAT3
NBEMAX	blas/testing/zblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX, NALMAX, NBEMAX$/;"	v	program:ZBLAT2
NBEMAX	blas/testing/zblat3.f	/^      INTEGER            NIDMAX, NALMAX, NBEMAX$/;"	v	program:ZBLAT3
NBET	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:CBLAT2
NBET	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:CBLAT3
NBET	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:DBLAT2
NBET	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:DBLAT3
NBET	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:SBLAT2
NBET	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:SBLAT3
NBET	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:ZBLAT2
NBET	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET,/;"	v	program:ZBLAT3
NBPERROW	bench/sparse_setter.cpp	11;"	d	file:
NBTRIES	bench/sparse_cholesky.cpp	30;"	d	file:
NBTRIES	bench/sparse_dense_product.cpp	25;"	d	file:
NBTRIES	bench/sparse_lu.cpp	30;"	d	file:
NBTRIES	bench/sparse_product.cpp	27;"	d	file:
NBTRIES	bench/sparse_randomsetter.cpp	29;"	d	file:
NBTRIES	bench/sparse_setter.cpp	19;"	d	file:
NBTRIES	bench/sparse_transpose.cpp	25;"	d	file:
NBTRIES	bench/sparse_trisolver.cpp	26;"	d	file:
NB_POINT	bench/btl/generic_bench/bench_parameter.hh	28;"	d
NCMatrix	Eigen/src/SparseLU/SparseLU.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> NCMatrix;$/;"	t	class:Eigen::SparseLU
NColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NDATA	bench/benchFFT.cpp	38;"	d	file:
NDEBUG	test/main.h	119;"	d
NEON	Eigen/src/Core/util/Constants.h	/^    NEON = 0x4,$/;"	e	enum:Eigen::Architecture::Type
NFFT	bench/benchFFT.cpp	35;"	d	file:
NIDIM	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:CBLAT2
NIDIM	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:CBLAT3
NIDIM	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:DBLAT2
NIDIM	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:DBLAT3
NIDIM	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:SBLAT2
NIDIM	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:SBLAT3
NIDIM	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:ZBLAT2
NIDIM	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM,/;"	v	program:ZBLAT3
NIDMAX	blas/testing/cblat2.f	/^      INTEGER            NINMAX, NIDMAX,/;"	v	program:CBLAT2
NIDMAX	blas/testing/cblat3.f	/^      INTEGER            NIDMAX,/;"	v	program:CBLAT3
NIDMAX	blas/testing/dblat2.f	/^      INTEGER            NINMAX, NIDMAX,/;"	v	program:DBLAT2
NIDMAX	blas/testing/dblat3.f	/^      INTEGER            NIDMAX,/;"	v	program:DBLAT3
NIDMAX	blas/testing/sblat2.f	/^      INTEGER            NINMAX, NIDMAX,/;"	v	program:SBLAT2
NIDMAX	blas/testing/sblat3.f	/^      INTEGER            NIDMAX,/;"	v	program:SBLAT3
NIDMAX	blas/testing/zblat2.f	/^      INTEGER            NINMAX, NIDMAX,/;"	v	program:ZBLAT2
NIDMAX	blas/testing/zblat3.f	/^      INTEGER            NIDMAX,/;"	v	program:ZBLAT3
NIN	blas/testing/cblat2.f	/^      INTEGER            NIN$/;"	v	program:CBLAT2
NIN	blas/testing/cblat3.f	/^      INTEGER            NIN$/;"	v	program:CBLAT3
NIN	blas/testing/dblat2.f	/^      INTEGER            NIN$/;"	v	program:DBLAT2
NIN	blas/testing/dblat3.f	/^      INTEGER            NIN$/;"	v	program:DBLAT3
NIN	blas/testing/sblat2.f	/^      INTEGER            NIN$/;"	v	program:SBLAT2
NIN	blas/testing/sblat3.f	/^      INTEGER            NIN$/;"	v	program:SBLAT3
NIN	blas/testing/zblat2.f	/^      INTEGER            NIN$/;"	v	program:ZBLAT2
NIN	blas/testing/zblat3.f	/^      INTEGER            NIN$/;"	v	program:ZBLAT3
NINC	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC,/;"	v	program:CBLAT2
NINC	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC,/;"	v	program:DBLAT2
NINC	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC,/;"	v	program:SBLAT2
NINC	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC,/;"	v	program:ZBLAT2
NINMAX	blas/testing/cblat2.f	/^      INTEGER            NINMAX,/;"	v	program:CBLAT2
NINMAX	blas/testing/dblat2.f	/^      INTEGER            NINMAX,/;"	v	program:DBLAT2
NINMAX	blas/testing/sblat2.f	/^      INTEGER            NINMAX,/;"	v	program:SBLAT2
NINMAX	blas/testing/zblat2.f	/^      INTEGER            NINMAX,/;"	v	program:ZBLAT2
NKB	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,/;"	v	program:CBLAT2
NKB	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,/;"	v	program:DBLAT2
NKB	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,/;"	v	program:SBLAT2
NKB	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,/;"	v	program:ZBLAT2
NKBMAX	blas/testing/cblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX,/;"	v	program:CBLAT2
NKBMAX	blas/testing/dblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX,/;"	v	program:DBLAT2
NKBMAX	blas/testing/sblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX,/;"	v	program:SBLAT2
NKBMAX	blas/testing/zblat2.f	/^      INTEGER            NINMAX, NIDMAX, NKBMAX,/;"	v	program:ZBLAT2
NMAX	blas/testing/cblat2.f	/^      INTEGER            NMAX,/;"	v	program:CBLAT2
NMAX	blas/testing/cblat3.f	/^      INTEGER            NMAX$/;"	v	program:CBLAT3
NMAX	blas/testing/dblat2.f	/^      INTEGER            NMAX,/;"	v	program:DBLAT2
NMAX	blas/testing/dblat3.f	/^      INTEGER            NMAX$/;"	v	program:DBLAT3
NMAX	blas/testing/sblat2.f	/^      INTEGER            NMAX,/;"	v	program:SBLAT2
NMAX	blas/testing/sblat3.f	/^      INTEGER            NMAX$/;"	v	program:SBLAT3
NMAX	blas/testing/zblat2.f	/^      INTEGER            NMAX,/;"	v	program:ZBLAT2
NMAX	blas/testing/zblat3.f	/^      INTEGER            NMAX$/;"	v	program:ZBLAT3
NNZPERCOL	bench/sparse_product.cpp	14;"	d	file:
NOGMM	bench/sparse_cholesky.cpp	8;"	d	file:
NOGMM	bench/sparse_lu.cpp	8;"	d	file:
NOGMM	bench/sparse_randomsetter.cpp	2;"	d	file:
NOMINMAX	bench/BenchTimer.h	16;"	d
NOMINMAX	bench/BenchTimer.h	187;"	d
NOMINMAX	bench/btl/generic_bench/timers/portable_timer.hh	39;"	d
NOMTL	bench/sparse_cholesky.cpp	9;"	d	file:
NOMTL	bench/sparse_lu.cpp	9;"	d	file:
NOMTL	bench/sparse_randomsetter.cpp	3;"	d	file:
NOTR	blas/common.h	24;"	d
NOUT	blas/testing/cblat1.f	/^      INTEGER          NOUT$/;"	v	program:CBLAT1
NOUT	blas/testing/cblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,$/;"	v	program:CBLAT2
NOUT	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT,/;"	v	program:CBLAT3
NOUT	blas/testing/dblat1.f	/^      INTEGER          NOUT$/;"	v	program:DBLAT1
NOUT	blas/testing/dblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,$/;"	v	program:DBLAT2
NOUT	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT,/;"	v	program:DBLAT3
NOUT	blas/testing/sblat1.f	/^      INTEGER          NOUT$/;"	v	program:SBLAT1
NOUT	blas/testing/sblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,$/;"	v	program:SBLAT2
NOUT	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT,/;"	v	program:SBLAT3
NOUT	blas/testing/zblat1.f	/^      INTEGER          NOUT$/;"	v	program:ZBLAT1
NOUT	blas/testing/zblat2.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NINC, NKB,$/;"	v	program:ZBLAT2
NOUT	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT,/;"	v	program:ZBLAT3
NOUTC	blas/testing/cblat2.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:CBLAT2
NOUTC	blas/testing/cblat3.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:CBLAT3
NOUTC	blas/testing/dblat2.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:DBLAT2
NOUTC	blas/testing/dblat3.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:DBLAT3
NOUTC	blas/testing/sblat2.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:SBLAT2
NOUTC	blas/testing/sblat3.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:SBLAT3
NOUTC	blas/testing/zblat2.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:ZBLAT2
NOUTC	blas/testing/zblat3.f	/^      INTEGER            INFOT, NOUTC$/;"	v	program:ZBLAT3
NRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NSUBS	blas/testing/cblat2.f	/^      INTEGER            NSUBS$/;"	v	program:CBLAT2
NSUBS	blas/testing/cblat3.f	/^      INTEGER            NSUBS$/;"	v	program:CBLAT3
NSUBS	blas/testing/dblat2.f	/^      INTEGER            NSUBS$/;"	v	program:DBLAT2
NSUBS	blas/testing/dblat3.f	/^      INTEGER            NSUBS$/;"	v	program:DBLAT3
NSUBS	blas/testing/sblat2.f	/^      INTEGER            NSUBS$/;"	v	program:SBLAT2
NSUBS	blas/testing/sblat3.f	/^      INTEGER            NSUBS$/;"	v	program:SBLAT3
NSUBS	blas/testing/zblat2.f	/^      INTEGER            NSUBS$/;"	v	program:ZBLAT2
NSUBS	blas/testing/zblat3.f	/^      INTEGER            NSUBS$/;"	v	program:ZBLAT3
NTRA	blas/testing/cblat2.f	/^     $                   NOUT, NTRA$/;"	v	program:CBLAT2
NTRA	blas/testing/cblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT, NTRA$/;"	v	program:CBLAT3
NTRA	blas/testing/dblat2.f	/^     $                   NOUT, NTRA$/;"	v	program:DBLAT2
NTRA	blas/testing/dblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT, NTRA$/;"	v	program:DBLAT3
NTRA	blas/testing/sblat2.f	/^     $                   NOUT, NTRA$/;"	v	program:SBLAT2
NTRA	blas/testing/sblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT, NTRA$/;"	v	program:SBLAT3
NTRA	blas/testing/zblat2.f	/^     $                   NOUT, NTRA$/;"	v	program:ZBLAT2
NTRA	blas/testing/zblat3.f	/^      INTEGER            I, ISNUM, J, N, NALF, NBET, NIDIM, NOUT, NTRA$/;"	v	program:ZBLAT3
NUMBER_DIRECTIONS	unsupported/test/forward_adolc.cpp	13;"	d	file:
NUMBER_SAMPLE	unsupported/bench/bench_svd.cpp	30;"	d	file:
NUMERIC_TYPE_MUST_BE_REAL	Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
NUNIT	blas/common.h	34;"	d
Name	bench/tensors/benchmark_main.cc	/^const char* Benchmark::Name() {$/;"	f	class:testing::Benchmark
NanoTime	bench/tensors/benchmark_main.cc	/^static int64_t NanoTime() {$/;"	f	file:
NaturalOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class NaturalOrdering$/;"	c	namespace:Eigen
NavFly	demos/opengl/quaternion_demo.h	/^      NavFly$/;"	e	enum:RenderingWidget::NavMode
NavMode	demos/opengl/quaternion_demo.h	/^    enum NavMode {$/;"	g	class:RenderingWidget
NavTurnAround	demos/opengl/quaternion_demo.h	/^      NavTurnAround,$/;"	e	enum:RenderingWidget::NavMode
NeedToConjugate	Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon610
NeedToConjugate	Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon609
NeedsAlignment	Eigen/src/Geometry/Quaternion.h	/^  enum { NeedsAlignment = internal::traits<Quaternion>::Alignment>0 };$/;"	e	enum:Eigen::Quaternion::__anon251
NeedsToAlign	Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0) };$/;"	e	enum:Eigen::PlainObjectBase::__anon462
NegationFlag	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  NegationFlag           = 0x01,$/;"	e	enum:Eigen::__anon189
NegativeReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_opposite_op<Scalar>, const Derived> NegativeReturnType;$/;"	t
NegativeSemiDef	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
NestByRefBit	Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
NestByValue	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC explicit inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue
NestByValue	Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen
Nested	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper
Nested	Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix
Nested	Eigen/src/Core/Inverse.h	/^  typedef typename internal::ref_selector<Inverse>::type Nested;$/;"	t	class:Eigen::Inverse
Nested	Eigen/src/Core/PermutationMatrix.h	/^    typedef const PermutationMatrix& Nested;$/;"	t	class:Eigen::PermutationMatrix
Nested	Eigen/src/Core/TriangularMatrix.h	/^    typedef Derived const& Nested;$/;"	t	class:Eigen::TriangularBase
Nested	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::ref_selector<SolveWithGuess>::type Nested;$/;"	t	class:Eigen::SolveWithGuess
Nested	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef typename Eigen::internal::nested<Self>::type Nested;$/;"	t	class:Eigen::Tensor
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::nested<TensorIndexTupleOp>::type Nested;$/;"	t	class:Eigen::TensorIndexTupleOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::nested<TensorTupleReducerOp>::type Nested;$/;"	t	class:Eigen::TensorTupleReducerOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename Eigen::internal::nested<TensorAssignOp>::type Nested;$/;"	t	class:Eigen::TensorAssignOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename Eigen::internal::nested<TensorBroadcastingOp>::type Nested;$/;"	t	class:Eigen::TensorBroadcastingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename Eigen::internal::nested<TensorChippingOp>::type Nested;$/;"	t	class:Eigen::TensorChippingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typedef typename internal::nested<TensorConcatenationOp>::type Nested;$/;"	t	class:Eigen::TensorConcatenationOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename Eigen::internal::nested<TensorContractionOp>::type Nested;$/;"	t	class:Eigen::TensorContractionOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef typename internal::nested<TensorConversionOp>::type Nested;$/;"	t	class:Eigen::TensorConversionOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename Eigen::internal::nested<TensorConvolutionOp>::type Nested;$/;"	t	class:Eigen::TensorConvolutionOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::nested<TensorCustomBinaryOp>::type Nested;$/;"	t	class:Eigen::TensorCustomBinaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::nested<TensorCustomUnaryOp>::type Nested;$/;"	t	class:Eigen::TensorCustomUnaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename Eigen::internal::nested<TensorEvalToOp>::type Nested;$/;"	t	class:Eigen::TensorEvalToOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef TensorCwiseNullaryOp<NullaryOp, XprType> Nested;$/;"	t	class:Eigen::TensorCwiseNullaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::nested<TensorCwiseBinaryOp>::type Nested;$/;"	t	class:Eigen::TensorCwiseBinaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::nested<TensorCwiseTernaryOp>::type Nested;$/;"	t	class:Eigen::TensorCwiseTernaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::nested<TensorCwiseUnaryOp>::type Nested;$/;"	t	class:Eigen::TensorCwiseUnaryOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::nested<TensorSelectOp>::type Nested;$/;"	t	class:Eigen::TensorSelectOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::internal::nested<TensorFFTOp>::type Nested;$/;"	t	class:Eigen::TensorFFTOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef typename Eigen::internal::nested<Self>::type Nested;$/;"	t	class:Eigen::TensorFixedSize
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename Eigen::internal::nested<TensorForcedEvalOp>::type Nested;$/;"	t	class:Eigen::TensorForcedEvalOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename Eigen::internal::nested<TensorGeneratorOp>::type Nested;$/;"	t	class:Eigen::TensorGeneratorOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename Eigen::internal::nested<TensorImagePatchOp>::type Nested;$/;"	t	class:Eigen::TensorImagePatchOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename Eigen::internal::nested<TensorInflationOp>::type Nested;$/;"	t	class:Eigen::TensorInflationOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename Eigen::internal::nested<TensorLayoutSwapOp>::type Nested;$/;"	t	class:Eigen::TensorLayoutSwapOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename Eigen::internal::nested<Self>::type Nested;$/;"	t	class:Eigen::TensorMap
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::nested<TensorReshapingOp>::type Nested;$/;"	t	class:Eigen::TensorReshapingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::nested<TensorSlicingOp>::type Nested;$/;"	t	class:Eigen::TensorSlicingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::nested<TensorStridingSlicingOp>::type Nested;$/;"	t	class:Eigen::TensorStridingSlicingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename Eigen::internal::nested<TensorPaddingOp>::type Nested;$/;"	t	class:Eigen::TensorPaddingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename Eigen::internal::nested<TensorPatchOp>::type Nested;$/;"	t	class:Eigen::TensorPatchOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename Eigen::internal::nested<TensorReductionOp>::type Nested;$/;"	t	class:Eigen::TensorReductionOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename Eigen::internal::nested<Self>::type Nested;$/;"	t	class:Eigen::TensorRef
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename Eigen::internal::nested<TensorReverseOp>::type Nested;$/;"	t	class:Eigen::TensorReverseOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename Eigen::internal::nested<TensorScanOp>::type Nested;$/;"	t	class:Eigen::TensorScanOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename Eigen::internal::nested<TensorShufflingOp>::type Nested;$/;"	t	class:Eigen::TensorShufflingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename Eigen::internal::nested<TensorStridingOp>::type Nested;$/;"	t	class:Eigen::TensorStridingOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename Eigen::internal::nested<TensorVolumePatchOp>::type Nested;$/;"	t	class:Eigen::TensorVolumePatchOp
Nested	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprType::Nested Nested;$/;"	t	struct:Eigen::internal::traits
Nested	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<DerType> Nested;$/;"	t	struct:Eigen::NumTraits
Nested	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef  BlockSparseMatrixT Nested;$/;"	t	class:Eigen::BlockSparseMatrixView
Nested	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename internal::ref_selector<BlockSparseMatrix<_Scalar, _BlockAtCompileTime, _Options, _StorageIndex> >::type Nested;$/;"	t	class:Eigen::BlockSparseMatrix
NestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::remove_all<ExpressionType>::type NestedExpression;$/;"	t	class:Eigen::ArrayWrapper
NestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::remove_all<ExpressionType>::type NestedExpression;$/;"	t	class:Eigen::MatrixWrapper
NestedExpression	Eigen/src/Core/Block.h	/^    typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::Block
NestedExpression	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::CwiseUnaryOp
NestedExpression	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::CwiseUnaryView
NestedExpression	Eigen/src/Core/Inverse.h	/^  typedef typename internal::remove_all<XprType>::type NestedExpression;$/;"	t	class:Eigen::Inverse
NestedExpression	Eigen/src/Core/Replicate.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Replicate
NestedExpression	Eigen/src/Core/Reverse.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Reverse
NestedExpression	Eigen/src/Core/SelfAdjointView.h	/^    typedef MatrixTypeNestedCleaned NestedExpression;$/;"	t	class:Eigen::SelfAdjointView
NestedExpression	Eigen/src/Core/Transpose.h	/^    typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::Transpose
NestedExpression	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned NestedExpression;$/;"	t	class:Eigen::TriangularView
NestedExpression	Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixType NestedExpression;$/;"	t	class:Eigen::Homogeneous
NestedExpression	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type NestedExpression;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
NestedExpression	Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixType>::type NestedExpression;$/;"	t	class:Eigen::SparseView
NestedExpressionType	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper
NestedExpressionType	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper
NewInf	Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewSup	Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NoAlias	Eigen/src/Core/NoAlias.h	/^    explicit NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias
NoAlias	Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
NoChange	Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoConvergence	Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NoPivoting	Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoPreferredStorageOrderBit	Eigen/src/Core/util/Constants.h	/^const unsigned int NoPreferredStorageOrderBit = 0x200;$/;"	m	namespace:Eigen
NoQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
NoUnrolling	Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::UnrollingType
NonBlockingThreadPool	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^typedef NonBlockingThreadPoolTempl<StlThreadEnvironment> NonBlockingThreadPool;$/;"	t	namespace:Eigen
NonBlockingThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  NonBlockingThreadPoolTempl(int num_threads, Environment env = Environment())$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
NonBlockingThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^class NonBlockingThreadPoolTempl : public Eigen::ThreadPoolInterface {$/;"	c	namespace:Eigen
NonConstCoeffReturnType	Eigen/src/Geometry/Quaternion.h	/^                                        Scalar&, CoeffReturnType>::type NonConstCoeffReturnType;$/;"	t	class:Eigen::QuaternionBase
NonConstImagReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
NonEmptyQueueIndex	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  int NonEmptyQueueIndex() {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
NonInteger	Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger         NonInteger;$/;"	t	class:Eigen::AlignedBox
NonInteger	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<DerType> NonInteger;$/;"	t	struct:Eigen::NumTraits
NonOpConversion	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^struct NonOpConversion{$/;"	s	namespace:Eigen::TensorSycl::internal
NonSymmetric	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^  NonSymmetric = 0x0$/;"	e	enum:Eigen::__anon66
NormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_norm,RealScalar>::Type NormReturnType;$/;"	t	class:Eigen::VectorwiseOp
NormalRandomGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE NormalRandomGenerator($/;"	f	class:Eigen::internal::NormalRandomGenerator
NormalRandomGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE NormalRandomGenerator(uint64_t seed = 0) {$/;"	f	class:Eigen::internal::NormalRandomGenerator
NormalRandomGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^template <typename T> class NormalRandomGenerator {$/;"	c	namespace:Eigen::internal
NormalReturnType	Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
NotMakingProgressIterations	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        NotMakingProgressIterations = 5,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
NotMakingProgressJacobian	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        NotMakingProgressJacobian = 4,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
NotStarted	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        NotStarted = -2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
NotStarted	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        NotStarted = -2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Notification	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  Notification() : Barrier(1) {};$/;"	f	struct:Eigen::Notification
Notification	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^struct Notification : Barrier {$/;"	s	namespace:Eigen
Notify	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  void Notify() {$/;"	f	class:Eigen::Barrier
Notify	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void Notify(bool all) {$/;"	f	class:Eigen::EventCount
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NumCoords	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  static const int NumCoords = internal::traits<Derived>::NumDimensions > 0 ?$/;"	m	struct:Eigen::TensorEvaluator
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  static const int NumDimensions = XprTraits::NumDimensions - array_size<Dims>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  static const std::size_t NumDimensions = internal::traits<LhsXprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    static const int NumDimensions = DerivedTraits::NumDimensions;$/;"	m	class:Eigen::TensorBase
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  static const int NumDimensions = XprTraits::NumDimensions - 1;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  static const int NumDimensions = traits<LhsXprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int NumDimensions = traits<LeftArgType_>::NumDimensions + traits<RightArgType_>::NumDimensions - 2 * array_size<Indices_>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int NumDimensions = traits<RhsXprType>::NumDimensions + traits<RhsXprType>::NumDimensions - 2 * array_size<Dimensions>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  static const int NumDimensions = traits<XprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int NumDimensions = traits<InputXprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int NumDimensions = traits<LhsXprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int NumDimensions = traits<XprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  static const int NumDimensions = XprTraits::NumDimensions + 1;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  static const int NumDimensions = traits<XprType>::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static const int NumDimensions = array_size<NewDimensions>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static const int NumDimensions = array_size<StartIndices>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  static const int NumDimensions = XprTraits::NumDimensions + 1;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int NumDimensions = XprTraits::NumDimensions - array_size<Dims>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  static const int NumDimensions = XprTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  static const int NumDimensions = BaseTraits::NumDimensions;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  static const int NumDimensions = NumIndices_;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  static const int NumDimensions = array_size<Dimensions>::value;$/;"	m	struct:Eigen::internal::traits
NumDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  static const int NumDimensions = XprTraits::NumDimensions + 1;$/;"	m	struct:Eigen::internal::traits
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  static const int NumDims = internal::array_size<Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  static const int NumDims = internal::array_size<InputDimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  static const int NumDims = NumInputDims-1;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<LeftArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int NumDims = LDims + RDims - 2 * ContractDims;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int NumDims = LDims + RDims - 2 * ContractDims;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  static const int NumDims = LDims + RDims - 2 * ContractDims;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static const int NumDims = LDims + RDims - 2 * ContractDims;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int NumDims =  internal::array_size<typename TensorEvaluator<InputArgType, GpuDevice>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int NumDims = internal::array_size<InputDims>::value;$/;"	m	class:Eigen::internal::IndexMapper
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<InputArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int NumDims = internal::traits<ArgType>::NumDimensions;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int NumDims = internal::traits<XprType>::NumDimensions;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  static const int NumDims = internal::array_size<Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  static const int NumDims = NumInputDims + 1;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static const int NumDims = internal::array_size<Sizes>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static const int NumDims = internal::array_size<Strides>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  static const int NumDims = internal::array_size<PaddingDimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value + 1;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  static const int NumDims = internal::array_size<ReverseDimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  static const int NumDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumDims	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  static const int NumDims = NumInputDims + 1;$/;"	m	struct:Eigen::TensorEvaluator
NumIndices	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    static const int NumIndices = NumIndices_;$/;"	m	class:Eigen::Tensor
NumIndices	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^  static const std::size_t NumIndices = Dimensions::count;$/;"	m	class:Eigen::TensorFixedSize
NumIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    static const Index NumIndices = PlainObjectType::NumIndices;$/;"	m	class:Eigen::TensorMap
NumIndices	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    static const Index NumIndices = PlainObjectType::NumIndices;$/;"	m	class:Eigen::TensorRef
NumIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static std::size_t NumIndices = internal::tensor_symmetry_num_indices<Gen...>::value;$/;"	m	class:Eigen::StaticSGroup
NumIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    constexpr static std::size_t NumIndices = Tensor_::NumIndices;$/;"	m	class:Eigen::internal::tensor_symmetry_value_setter
NumIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    constexpr static std::size_t NumIndices = internal::tensor_symmetry_num_indices<Gen...>::value;$/;"	m	class:Eigen::SGroup
NumIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t NumIndices = Tensor_::NumIndices;$/;"	m	struct:Eigen::internal::tensor_symmetry_assign_value
NumIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t NumIndices = Tensor_::NumIndices;$/;"	m	struct:Eigen::internal::tensor_symmetry_calculate_flags
NumInputDims	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumInputDims	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumInputDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int NumInputDims = internal::array_size<InputDimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumInputDims	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  static const int NumInputDims = internal::array_size<typename TensorEvaluator<ArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumKernelDims	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int NumKernelDims = internal::array_size<Indices>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumOfDerivativesAtCompileTime	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { NumOfDerivativesAtCompileTime = OrderAtCompileTime \/*!< The number of derivatives defined for the current spline. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon58
NumOfDerivativesAtCompileTime	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { NumOfDerivativesAtCompileTime = _DerivativeOrder==Dynamic ? Dynamic : _DerivativeOrder+1 \/*!< The number of derivatives defined for the current spline. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon61
NumOutputDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int NumOutputDims = NumInputDims - NumReducedDims;$/;"	m	struct:Eigen::TensorEvaluator
NumPreservedStrides	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int NumPreservedStrides = max_n_1<NumOutputDims>::size;$/;"	m	struct:Eigen::TensorEvaluator
NumReducedDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int NumReducedDims = internal::array_size<Dims>::value;$/;"	m	struct:Eigen::TensorEvaluator
NumTraits	Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct NumTraits<Eigen::half>$/;"	s	namespace:Eigen
NumTraits	test/boostmultiprec.cpp	/^  struct NumTraits<boost::multiprecision::detail::expression<T1,T2,T3,T4,T5> > : NumTraits<Real> {};$/;"	s	namespace:Eigen	file:
NumTraits	test/boostmultiprec.cpp	/^  template<> struct NumTraits<Real> : GenericNumTraits<Real> {$/;"	s	namespace:Eigen	file:
NumTraits	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<DenseIndex n> struct NumTraits<type2index<n> >$/;"	s	namespace:Eigen
NumTraits	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^template<typename DerType> struct NumTraits<AutoDiffScalar<DerType> >$/;"	s	namespace:Eigen
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0) : Functor(a0), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0, const T1& a1) : Functor(a0, a1), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0, const T1& a1, const T2& a2) : Functor(a0, a1, a2), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    NumericalDiff(Scalar _epsfcn=0.) : Functor(), epsfcn(_epsfcn) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    NumericalDiff(const Functor& f, Scalar _epsfcn=0.) : Functor(f), epsfcn(_epsfcn) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^class NumericalDiff : public _Functor$/;"	c	namespace:Eigen
NumericalDiffMode	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^enum NumericalDiffMode {$/;"	g	namespace:Eigen
NumericalIssue	Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG	Eigen/src/Core/util/StaticAssert.h	/^        OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
OK	blas/testing/cblat2.f	/^      LOGICAL            LERR, OK$/;"	v	program:CBLAT2
OK	blas/testing/cblat3.f	/^      LOGICAL            LERR, OK$/;"	v	program:CBLAT3
OK	blas/testing/dblat2.f	/^      LOGICAL            LERR, OK$/;"	v	program:DBLAT2
OK	blas/testing/dblat3.f	/^      LOGICAL            LERR, OK$/;"	v	program:DBLAT3
OK	blas/testing/sblat2.f	/^      LOGICAL            LERR, OK$/;"	v	program:SBLAT2
OK	blas/testing/sblat3.f	/^      LOGICAL            LERR, OK$/;"	v	program:SBLAT3
OK	blas/testing/zblat2.f	/^      LOGICAL            LERR, OK$/;"	v	program:ZBLAT2
OK	blas/testing/zblat3.f	/^      LOGICAL            LERR, OK$/;"	v	program:ZBLAT3
ONE	blas/testing/cblat2.f	/^      COMPLEX            ZERO, ONE$/;"	v	program:CBLAT2
ONE	blas/testing/cblat3.f	/^      COMPLEX            ZERO, ONE$/;"	v	program:CBLAT3
ONE	blas/testing/dblat2.f	/^      DOUBLE PRECISION   ZERO, ONE$/;"	v	program:DBLAT2
ONE	blas/testing/dblat3.f	/^      DOUBLE PRECISION   ZERO, ONE$/;"	v	program:DBLAT3
ONE	blas/testing/sblat2.f	/^      REAL               ZERO, ONE$/;"	v	program:SBLAT2
ONE	blas/testing/sblat3.f	/^      REAL               ZERO, ONE$/;"	v	program:SBLAT3
ONE	blas/testing/zblat2.f	/^      COMPLEX*16         ZERO, ONE$/;"	v	program:ZBLAT2
ONE	blas/testing/zblat3.f	/^      COMPLEX*16         ZERO, ONE$/;"	v	program:ZBLAT3
ONES_COMPLEMENT	Eigen/src/OrderingMethods/Eigen_Colamd.h	101;"	d
OP	blas/common.h	39;"	d
OP	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^struct OP$/;"	s	namespace:Eigen::internal
OP	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^struct OP<MatrixSolver, MatrixType, Scalar, false>$/;"	s	namespace:Eigen::internal
OP	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^struct OP<MatrixSolver, MatrixType, Scalar, true>$/;"	s	namespace:Eigen::internal
OPEXPRCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	88;"	d
OPEXPRCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	96;"	d
OUT_OF_RANGE_ACCESS	Eigen/src/Core/util/StaticAssert.h	/^        OUT_OF_RANGE_ACCESS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
Object	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef _Object Object;$/;"	t	class:Eigen::KdBVH
ObjectIterator	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef const Object *ObjectIterator;$/;"	t	class:Eigen::KdBVH
ObjectList	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<Object, aligned_allocator<Object> > ObjectList;$/;"	t	class:Eigen::KdBVH
OffsetCol	Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon434
OffsetRow	Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon434
OmpEval	bench/basicbenchmark.h	/^enum {LazyEval, EarlyEval, OmpEval};$/;"	e	enum:__anon4
OnTheLeft	Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::SideType
OnTheRight	Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::SideType
One	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int One = One_;$/;"	m	struct:Eigen::AntiHermiticity
One	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int One = One_;$/;"	m	struct:Eigen::AntiSymmetry
One	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int One = One_;$/;"	m	struct:Eigen::Hermiticity
One	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int One = One_;$/;"	m	struct:Eigen::Symmetry
One	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t One = static_cast<std::size_t>(One_);$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index newSize)$/;"	f	class:Eigen::DenseBase
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
OppositeExtendedType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct OppositeExtendedType {$/;"	s	class:Eigen::VectorwiseOp
Options	Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon773
Options	Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
Options	Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon478
Options	Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon479
Options	Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon749
Options	Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon439
Options	Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon440
Options	Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon461
Options	Eigen/src/Core/Ref.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon473
Options	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon861
Options	Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon862
Options	Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon864
Options	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon860
Options	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon858
Options	Eigen/src/Eigenvalues/RealQZ.h	/^        Options = MatrixType::Options,$/;"	e	enum:Eigen::RealQZ::__anon859
Options	Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon855
Options	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon863
Options	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon857
Options	Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon248
Options	Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon245
Options	Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon265
Options	Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon783
Options	Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon839
Options	Eigen/src/SparseCore/SparseRef.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon796
Options	Eigen/src/SparseCore/SparseRef.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon799
Options	Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon848
Options	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    static const int Options = Options_;$/;"	m	class:Eigen::Tensor
Options	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    static const int Options = Options_;$/;"	m	class:Eigen::TensorFixedSize
Options	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    static const int Options = Options_;$/;"	m	class:Eigen::TensorMap
Options	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Options = BaseTraits::Options,$/;"	e	enum:Eigen::internal::traits::__anon162
Options	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Options = Options_,$/;"	e	enum:Eigen::internal::traits::__anon159
Options	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Options = Options_,$/;"	e	enum:Eigen::internal::traits::__anon160
Options	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    Options = Options_,$/;"	e	enum:Eigen::internal::traits::__anon161
Options	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Options = BlockSparseMatrixT::Options,$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
Options	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      Options = _Options,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
Options	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::DynamicSparseMatrix::__anon64
OrReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct OrReducer {$/;"	s	namespace:Eigen::internal
OrderAtCompileTime	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { OrderAtCompileTime = _Degree==Dynamic ? Dynamic : _Degree+1 \/*!< The spline curve's order at compile-time. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon57
OrderAtCompileTime	unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { OrderAtCompileTime = _Degree==Dynamic ? Dynamic : _Degree+1 \/*!< The spline curve's order at compile-time. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon60
OrderingType	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::IncompleteCholesky
OrderingType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::OrderingType OrderingType;$/;"	t	class:Eigen::SimplicialCholeskyBase
OrderingType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _Ordering OrderingType;$/;"	t	struct:Eigen::internal::traits
OrderingType	Eigen/src/SparseLU/SparseLU.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseLU
OrderingType	Eigen/src/SparseQR/SparseQR.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseQR
Other	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  typedef IndexTuple<O...> Other;$/;"	t	struct:Eigen::internal::IndexTuple
OtherCols	Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon268
OtherCols	Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon269
OtherRows	Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon268
OtherRows	Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon269
OtherRows	Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon270
OuterPacketMask	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    static const int OuterPacketMask = (1 << OuterPacketBits) - 1;$/;"	m	class:Eigen::RandomSetter
OuterProduct	Eigen/src/Core/util/Constants.h	/^{ DefaultProduct=0, LazyProduct, AliasFreeProduct, CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
OuterRandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
OuterReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct OuterReducer {$/;"	s	namespace:Eigen::internal
OuterReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^struct OuterReducer<Self, Op, GpuDevice> {$/;"	s	namespace:Eigen::internal
OuterReductionKernel	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void OuterReductionKernel(Reducer reducer, const Self input, Index num_coeffs_to_reduce, Index num_preserved_coeffs,$/;"	f	namespace:Eigen::internal
OuterSize	Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon803
OuterSize	Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::internal::sparse_matrix_block_impl::__anon805
OuterStride	Eigen/src/Core/AssignEvaluator.h	/^    OuterStride = int(outer_stride_at_compile_time<Dst>::ret),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon504
OuterStride	Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride
OuterStride	Eigen/src/Core/Stride.h	/^    EIGEN_DEVICE_FUNC OuterStride(Index v) : Base(v,0) {} \/\/ FIXME making this explicit could break valid code$/;"	f	class:Eigen::OuterStride
OuterStride	Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen
OuterStrideAtCompileTime	Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon464
OuterStrideAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsArgType$/;"	e	enum:Eigen::internal::evaluator::__anon761
OuterStrideAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::evaluator::__anon759
OuterStrideAtCompileTime	Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon460
OuterStrideAtCompileTime	Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon285
OuterStrideAtCompileTime	Eigen/src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon500
OuterStrideAtCompileTime	Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon748
OuterStrideAtCompileTime	Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon439
OuterStrideAtCompileTime	Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon471
OuterStrideAtCompileTime	Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon443
OuterStrideMatch	Eigen/src/Core/Ref.h	/^      OuterStrideMatch = Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon474
OuterType	Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef internal::variable_if_dynamic<Index,Derived::IsVectorAtCompileTime?0:Dynamic> OuterType;$/;"	t	class:Eigen::SparseCompressedBase::InnerIterator
OuterType	Eigen/src/SparseCore/SparseCompressedBase.h	/^    typedef internal::variable_if_dynamic<Index,Derived::IsVectorAtCompileTime?0:Dynamic> OuterType;$/;"	t	class:Eigen::SparseCompressedBase::ReverseInnerIterator
OuterVector	Eigen/src/SparseCore/SparseBlock.h	/^      OuterVector =  (BlockCols==1 && ArgType::IsRowMajor)$/;"	e	enum:Eigen::internal::unary_evaluator::__anon807
OuterVectorInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^  EIGEN_STRONG_INLINE OuterVectorInnerIterator(const unary_evaluator& aEval, Index outer)$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
OuterVectorInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::OuterVectorInnerIterator$/;"	c	class:Eigen::internal::unary_evaluator
OutputScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename conditional<FFTResultType == RealPart || FFTResultType == ImagPart, RealScalar, ComplexScalar>::type OutputScalar;$/;"	t	struct:Eigen::internal::traits
OutputScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename internal::conditional<FFTResultType == RealPart || FFTResultType == ImagPart, RealScalar, ComplexScalar>::type OutputScalar;$/;"	t	class:Eigen::TensorFFTOp
OutputScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename internal::conditional<FFTResultType == RealPart || FFTResultType == ImagPart, RealScalar, ComplexScalar>::type OutputScalar;$/;"	t	struct:Eigen::TensorEvaluator
P	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    static const Index P = 3;$/;"	m	class:Eigen::TensorEvaluator::Context
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
PACK_OUTPUT	Eigen/src/Core/arch/AVX512/PacketMath.h	1046;"	d
PACK_OUTPUT_2	Eigen/src/Core/arch/AVX512/PacketMath.h	1160;"	d
PACK_OUTPUT_D	Eigen/src/Core/arch/AVX512/PacketMath.h	1202;"	d
PACK_OUTPUT_SQ_D	Eigen/src/Core/arch/AVX512/PacketMath.h	1198;"	d
PADDING_SAME	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  PADDING_SAME = 2$/;"	e	enum:Eigen::__anon163
PADDING_VALID	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  PADDING_VALID = 1,$/;"	e	enum:Eigen::__anon163
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	512;"	d
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	532;"	d
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	731;"	d
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	744;"	d
PASS	blas/testing/cblat1.f	/^      LOGICAL          PASS$/;"	v	program:CBLAT1
PASS	blas/testing/dblat1.f	/^      LOGICAL          PASS$/;"	v	program:DBLAT1
PASS	blas/testing/sblat1.f	/^      LOGICAL          PASS$/;"	v	program:SBLAT1
PASS	blas/testing/zblat1.f	/^      LOGICAL          PASS$/;"	v	program:ZBLAT1
PASTIX_COMPLEX	Eigen/src/PaStiXSupport/PaStiXSupport.h	16;"	d
PASTIX_DCOMPLEX	Eigen/src/PaStiXSupport/PaStiXSupport.h	17;"	d
PCG_XSH_RS_generator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE unsigned PCG_XSH_RS_generator(uint64_t* state) {$/;"	f	namespace:Eigen::internal::__anon101
PCG_XSH_RS_state	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE uint64_t PCG_XSH_RS_state(uint64_t seed) {$/;"	f	namespace:Eigen::internal::__anon101
PM_Normalized	demos/opengl/gpuhelper.h	/^    enum ProjectionMode2D { PM_Normalized = 1, PM_Viewport = 2 };$/;"	e	enum:GpuHelper::ProjectionMode2D
PM_Viewport	demos/opengl/gpuhelper.h	/^    enum ProjectionMode2D { PM_Normalized = 1, PM_Viewport = 2 };$/;"	e	enum:GpuHelper::ProjectionMode2D
PS_Base	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef PolynomialSolverBase<_Scalar,1>    PS_Base;$/;"	t	class:Eigen::PolynomialSolver
PS_Base	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef PolynomialSolverBase<_Scalar,_Deg>    PS_Base;$/;"	t	class:Eigen::PolynomialSolver
PYSCRIPT	bench/btl/generic_bench/utils/utilities.h	23;"	d
Packet	Eigen/src/Core/arch/ZVector/PacketMath.h	/^} Packet;$/;"	t	namespace:Eigen::internal	typeref:union:Eigen::internal::__anon720
Packet	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
Packet	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::internal::BlasLinearMapper
Packet	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::internal::blas_data_mapper
Packet	bench/benchmark-blocking-sizes.cpp	/^typedef internal::packet_traits<Scalar>::type Packet;$/;"	t	file:
Packet	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef typename Tensor::PacketReturnType Packet;$/;"	t	class:Eigen::internal::BaseTensorContractionMapper
Packet	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef typename Tensor::PacketReturnType Packet;$/;"	t	class:Eigen::internal::TensorContractionSubMapper
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_polygamma_op
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_zeta_op
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_digamma_op
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_erf_op
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_erfc_op
Packet	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_lgamma_op
Packet16f	Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512 Packet16f;$/;"	t	namespace:Eigen::internal
Packet16i	Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512i Packet16i;$/;"	t	namespace:Eigen::internal
Packet16uc	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet16uc	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned char       Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1cd	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/ZVector/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet1d	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float64x1_t Packet1d;$/;"	t	namespace:Eigen::internal
Packet2bl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef Packet2ul                    Packet2bl;$/;"	t	namespace:Eigen::internal
Packet2bl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool long         Packet2bl;$/;"	t	namespace:Eigen::internal
Packet2cd	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd() {}$/;"	f	struct:Eigen::internal::Packet2cd
Packet2cd	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cd(const __m256d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cd
Packet2cd	Eigen/src/Core/arch/AVX/Complex.h	/^struct Packet2cd$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf() : v(p4f_ZERO) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/ZVector/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector double              Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float64x2_t Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128d> Packet2d;$/;"	t	namespace:Eigen::internal
Packet2d	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector double              Packet2d;$/;"	t	namespace:Eigen::internal
Packet2f	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef eigen_packet_wrapper<float32x2_t,0> Packet2f;$/;"	t	namespace:Eigen::internal
Packet2i	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef eigen_packet_wrapper<int32x2_t  ,3> Packet2i;$/;"	t	namespace:Eigen::internal
Packet2l	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector long long           Packet2l;$/;"	t	namespace:Eigen::internal
Packet2l	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector long long           Packet2l;$/;"	t	namespace:Eigen::internal
Packet2ul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned long long  Packet2ul;$/;"	t	namespace:Eigen::internal
Packet2ul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned long long  Packet2ul;$/;"	t	namespace:Eigen::internal
Packet4bi	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4bi	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector __bool int          Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4cf	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf() {}$/;"	f	struct:Eigen::internal::Packet4cf
Packet4cf	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet4cf(const __m256& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet4cf
Packet4cf	Eigen/src/Core/arch/AVX/Complex.h	/^struct Packet4cf$/;"	s	namespace:Eigen::internal
Packet4d	Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256d Packet4d;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef eigen_packet_wrapper<float32x4_t,1> Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128>  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/ZVector/PacketMath.h	/^} Packet4f;$/;"	t	namespace:Eigen::internal	typeref:struct:Eigen::internal::__anon719
Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef eigen_packet_wrapper<int32x4_t  ,2> Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef eigen_packet_wrapper<__m128i> Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector int                 Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef eigen_packet_wrapper<uint32x4_t ,4> Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector unsigned int        Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8d	Eigen/src/Core/arch/AVX512/PacketMath.h	/^typedef __m512d Packet8d;$/;"	t	namespace:Eigen::internal
Packet8f	Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256  Packet8f;$/;"	t	namespace:Eigen::internal
Packet8i	Eigen/src/Core/arch/AVX/PacketMath.h	/^typedef __m256i Packet8i;$/;"	t	namespace:Eigen::internal
Packet8i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
Packet8i	Eigen/src/Core/arch/ZVector/PacketMath.h	/^typedef __vector short int           Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccess	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon516
PacketAccess	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon672
PacketAccess	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon673
PacketAccess	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^{ enum { Cost = NumTraits<float>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon674
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon393
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasDiv$/;"	e	enum:Eigen::internal::functor_traits::__anon396
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon395
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon394
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::Vectorizable && packet_traits<SrcScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon392
PacketAccess	Eigen/src/Core/functors/AssignmentFunctors.h	/^    PacketAccess = packet_traits<Scalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon397
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon384
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon385
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon389
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon390
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon391
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon383
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon382
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon381
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasAdd && packet_traits<RhsScalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon378
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasDiv && packet_traits<RhsScalar>::HasDiv,$/;"	e	enum:Eigen::internal::functor_traits::__anon388
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon379
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasSub && packet_traits<RhsScalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon387
PacketAccess	Eigen/src/Core/functors/BinaryFunctors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon386
PacketAccess	Eigen/src/Core/functors/NullaryFunctors.h	/^         PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon362
PacketAccess	Eigen/src/Core/functors/NullaryFunctors.h	/^    PacketAccess =   (!NumTraits<Scalar>::IsInteger) && packet_traits<Scalar>::HasSetLinear && packet_traits<Scalar>::HasBlend,$/;"	e	enum:Eigen::internal::functor_traits::__anon364
PacketAccess	Eigen/src/Core/functors/NullaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon363
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon416
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon417
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon418
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon419
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon414
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon415
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon403
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon404
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon405
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon406
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon407
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon408
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon409
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon410
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon411
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon400
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon401
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon402
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon398
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon399
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon421
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon420
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon412
PacketAccess	Eigen/src/Core/functors/StlFunctors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon413
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon357
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon358
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon359
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon360
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon345
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon346
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasATan$/;"	e	enum:Eigen::internal::functor_traits::__anon347
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon327
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasArg$/;"	e	enum:Eigen::internal::functor_traits::__anon330
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCeil$/;"	e	enum:Eigen::internal::functor_traits::__anon356
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon329
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon342
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasCosh$/;"	e	enum:Eigen::internal::functor_traits::__anon350
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasExp,$/;"	e	enum:Eigen::internal::functor_traits::__anon336
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasFloor$/;"	e	enum:Eigen::internal::functor_traits::__anon355
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasLog,$/;"	e	enum:Eigen::internal::functor_traits::__anon337
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasLog1p,$/;"	e	enum:Eigen::internal::functor_traits::__anon338
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon326
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasRound$/;"	e	enum:Eigen::internal::functor_traits::__anon354
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasRsqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon341
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSign$/;"	e	enum:Eigen::internal::functor_traits::__anon361
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon343
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSinh$/;"	e	enum:Eigen::internal::functor_traits::__anon349
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon340
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon344
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasTanh,$/;"	e	enum:Eigen::internal::functor_traits::__anon348
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon332
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon333
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon334
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon335
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon353
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon339
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon328
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon351
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon352
PacketAccess	Eigen/src/Core/functors/UnaryFunctors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon331
PacketAccess	blas/level1_cplx_impl.h	/^      enum { Cost = 3 * NumTraits<Scalar>::AddCost, PacketAccess = 0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon205
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    PacketAccess = \/*TensorEvaluator<ArgType, Device>::PacketAccess*\/ false,$/;"	e	enum:Eigen::TensorEvaluator::__anon100
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    PacketAccess = \/*TensorEvaluator<ArgType, Device>::PacketAccess*\/ false,$/;"	e	enum:Eigen::TensorEvaluator::__anon99
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon120
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon126
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon124
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon125
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon97
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon98
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    PacketAccess = (internal::unpacket_traits<PacketReturnType>::size > 1),$/;"	e	enum:Eigen::TensorContractionEvaluatorBase::__anon165
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    PacketAccess = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon108
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    PacketAccess = TensorEvaluator<InputArgType, Device>::PacketAccess & TensorEvaluator<KernelArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon145
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    PacketAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon146
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    PacketAccess = (internal::packet_traits<Scalar>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon137
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    PacketAccess = (internal::packet_traits<Scalar>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon138
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon141
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = (internal::unpacket_traits<PacketReturnType>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon109
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = (internal::unpacket_traits<PacketReturnType>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon111
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = TensorEvaluator<Arg1Type, Device>::PacketAccess & TensorEvaluator<Arg2Type, Device>::PacketAccess & TensorEvaluator<Arg3Type, Device>::PacketAccess &$/;"	e	enum:Eigen::TensorEvaluator::__anon115
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess & internal::functor_traits<UnaryOp>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon113
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = TensorEvaluator<LeftArgType, Device>::PacketAccess & TensorEvaluator<RightArgType, Device>::PacketAccess &$/;"	e	enum:Eigen::TensorEvaluator::__anon114
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = TensorEvaluator<ThenArgType, Device>::PacketAccess & TensorEvaluator<ElseArgType, Device>::PacketAccess &$/;"	e	enum:Eigen::TensorEvaluator::__anon116
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    PacketAccess = internal::functor_traits<NullaryOp>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon112
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    PacketAccess = true,$/;"	e	enum:Eigen::TensorEvaluator::__anon148
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    PacketAccess = (PacketSize > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon118
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^         PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon169
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = GaussianGenerator<T, Index, NumDims>::PacketAccess$/;"	e	enum:Eigen::internal::functor_traits::__anon181
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = PacketType<T, Device>::HasAdd$/;"	e	enum:Eigen::internal::reducer_traits::__anon172
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = PacketType<T, Device>::HasAdd$/;"	e	enum:Eigen::internal::reducer_traits::__anon173
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = PacketType<T, Device>::HasMax$/;"	e	enum:Eigen::internal::reducer_traits::__anon174
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = PacketType<T, Device>::HasMin$/;"	e	enum:Eigen::internal::reducer_traits::__anon175
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = PacketType<T, Device>::HasMul$/;"	e	enum:Eigen::internal::reducer_traits::__anon176
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::reducer_traits::__anon171
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::reducer_traits::__anon177
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::reducer_traits::__anon178
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::reducer_traits::__anon179
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::reducer_traits::__anon180
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    PacketAccess = packet_traits<T>::HasAdd && packet_traits<T>::HasDiv &&$/;"	e	enum:Eigen::internal::functor_traits::__anon170
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = false;$/;"	m	class:Eigen::internal::GaussianGenerator
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = false;$/;"	m	struct:Eigen::internal::AndReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = false;$/;"	m	struct:Eigen::internal::ArgMaxTupleReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = false;$/;"	m	struct:Eigen::internal::ArgMinTupleReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = false;$/;"	m	struct:Eigen::internal::OrReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = packet_traits<T>::HasAdd && !NumTraits<T>::IsInteger;$/;"	m	struct:Eigen::internal::MeanReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = packet_traits<T>::HasAdd;$/;"	m	struct:Eigen::internal::SumReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = packet_traits<T>::HasMax;$/;"	m	struct:Eigen::internal::MaxReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = packet_traits<T>::HasMin;$/;"	m	struct:Eigen::internal::MinReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  static const bool PacketAccess = packet_traits<T>::HasMul;$/;"	m	struct:Eigen::internal::ProdReducer
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^{ enum { Cost = scalar_div_cost<Scalar,false>::value, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon167
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^{ enum { Cost = scalar_div_cost<Scalar,false>::value, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon168
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    PacketAccess = (internal::unpacket_traits<PacketReturnType>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon142
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon130
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon136
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon85
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon86
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon89
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon90
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon92
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon93
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon94
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    PacketAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon95
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon147
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon88
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^    PacketAccess = NormalRandomGenerator<Scalar>::PacketAccess$/;"	e	enum:Eigen::internal::functor_traits::__anon103
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^    PacketAccess = UniformRandomGenerator<Scalar>::PacketAccess$/;"	e	enum:Eigen::internal::functor_traits::__anon102
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  static const bool PacketAccess = true;$/;"	m	class:Eigen::internal::NormalRandomGenerator
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  static const bool PacketAccess = true;$/;"	m	class:Eigen::internal::UniformRandomGenerator
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    PacketAccess = Self::InputPacketAccess && Op::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon128
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^      PacketAccess = false,$/;"	e	enum:Eigen::TensorRef::__anon152
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    PacketAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon153
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    PacketAccess = false,$/;"	e	enum:Eigen::TensorEvaluator::__anon154
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon183
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon184
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    PacketAccess = (internal::unpacket_traits<PacketReturnType>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon129
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    PacketAccess = (internal::packet_traits<Scalar>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon150
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    PacketAccess = (internal::packet_traits<Scalar>::size > 1),$/;"	e	enum:Eigen::TensorEvaluator::__anon151
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon185
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon186
PacketAccess	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    PacketAccess = TensorEvaluator<ArgType, Device>::PacketAccess,$/;"	e	enum:Eigen::TensorEvaluator::__anon143
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^        PacketAccess = packet_traits<Scalar>::HasPolygamma$/;"	e	enum:Eigen::internal::functor_traits::__anon37
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^        PacketAccess = packet_traits<Scalar>::HasZeta$/;"	e	enum:Eigen::internal::functor_traits::__anon36
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasBetaInc$/;"	e	enum:Eigen::internal::functor_traits::__anon33
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasDiGamma$/;"	e	enum:Eigen::internal::functor_traits::__anon35
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasErf$/;"	e	enum:Eigen::internal::functor_traits::__anon38
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasErfc$/;"	e	enum:Eigen::internal::functor_traits::__anon39
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasIGamma$/;"	e	enum:Eigen::internal::functor_traits::__anon31
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasIGammac$/;"	e	enum:Eigen::internal::functor_traits::__anon32
PacketAccess	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    PacketAccess = packet_traits<Scalar>::HasLGamma$/;"	e	enum:Eigen::internal::functor_traits::__anon34
PacketAccess	unsupported/test/cxx11_tensor_reduction.cpp	/^  static const bool PacketAccess = false;$/;"	m	struct:UserReducer	file:
PacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketAccessMask	Eigen/src/Core/CoreEvaluators.h	/^    PacketAccessMask = bool(HasNoInnerStride) ? ~int(0) : ~int(PacketAccessBit),$/;"	e	enum:Eigen::internal::evaluator::__anon759
PacketAlignment	Eigen/src/Core/CoreEvaluators.h	/^    PacketAlignment = unpacket_traits<PacketScalar>::alignment,$/;"	e	enum:Eigen::internal::evaluator::__anon761
PacketBlock	Eigen/src/Core/GenericPacketMath.h	/^template <typename Packet,int N=unpacket_traits<Packet>::size> struct PacketBlock {$/;"	s	namespace:Eigen::internal
PacketConv	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  struct PacketConv {$/;"	s	struct:Eigen::TensorEvaluator
PacketConv	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  struct PacketConv<LoadMode, true> {$/;"	s	struct:Eigen::TensorEvaluator
PacketConverter	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  PacketConverter(const TensorEvaluator& impl)$/;"	f	struct:Eigen::PacketConverter
PacketConverter	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct PacketConverter {$/;"	s	namespace:Eigen
PacketConverter	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 1, 2> {$/;"	s	namespace:Eigen
PacketConverter	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 2, 1> {$/;"	s	namespace:Eigen
PacketConverter	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct PacketConverter<TensorEvaluator, SrcPacket, TgtPacket, 4, 1> {$/;"	s	namespace:Eigen
PacketReturnType	Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
PacketReturnType	Eigen/src/Core/Redux.h	/^  typedef typename XprType::PacketReturnType PacketReturnType;$/;"	t	class:Eigen::internal::redux_evaluator
PacketReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename PacketType<CoeffReturnType, GpuDevice>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename PacketType<CoeffReturnType, GpuDevice>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename PacketType<OutputScalar, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketReturnType	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename PacketType<CoeffReturnType, Device>::type PacketReturnType;$/;"	t	struct:Eigen::TensorEvaluator
PacketScalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase
PacketScalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::evaluator
PacketScalar	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;$/;"	t	class:Eigen::DenseBase
PacketScalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase
PacketScalar	Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	Eigen/src/Core/Matrix.h	/^  typedef typename find_best_packet<_Scalar,size>::type PacketScalar;$/;"	t	struct:Eigen::internal::traits
PacketScalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase
PacketScalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase
PacketScalar	Eigen/src/Core/Redux.h	/^  typedef typename XprType::PacketScalar PacketScalar;$/;"	t	class:Eigen::internal::redux_evaluator
PacketScalar	Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl
PacketScalar	Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
PacketScalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase
PacketSize	Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon244
PacketSize	Eigen/src/Core/GeneralProduct.h	/^    PacketSize      = internal::packet_traits<Scalar>::size$/;"	e	enum:Eigen::internal::gemv_static_vector_if::__anon316
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_impl::__anon491
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon489
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = unpacket_traits<PacketType>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon482
PacketSize	Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon434
PacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon634
PacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon635
PacketSize	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon622
PacketSize	test/vectorization_logic.cpp	/^    PacketSize = internal::unpacket_traits<PacketType>::size$/;"	e	enum:vectorization_logic_half::__anon195	file:
PacketSize	test/vectorization_logic.cpp	/^    PacketSize = internal::unpacket_traits<PacketType>::size,$/;"	e	enum:vectorization_logic::__anon194	file:
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static const int PacketSize = unpacket_traits<typename Evaluator::PacketReturnType>::size;$/;"	m	struct:Eigen::internal::EvalRange
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const int PacketSize =$/;"	m	struct:Eigen::internal::FullReducer
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSize	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  static const int PacketSize = internal::unpacket_traits<PacketReturnType>::size;$/;"	m	struct:Eigen::TensorEvaluator
PacketSourceType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename PacketType<SrcType, Device>::type PacketSourceType;$/;"	t	struct:Eigen::TensorEvaluator
PacketTraits	test/vectorization_logic.cpp	/^  typedef internal::packet_traits<Scalar> PacketTraits;$/;"	t	struct:vectorization_logic	file:
PacketTraits	test/vectorization_logic.cpp	/^  typedef internal::packet_traits<Scalar> PacketTraits;$/;"	t	struct:vectorization_logic_half	file:
PacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename AssignmentTraits::PacketType PacketType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
PacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
PacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
PacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename Kernel::PacketType PacketType;$/;"	t	struct:Eigen::internal::dense_assignment_loop
PacketType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename conditional<int(Traversal)==LinearVectorizedTraversal, LinearPacketType, InnerPacketType>::type PacketType;$/;"	t	struct:Eigen::internal::copy_using_evaluator_traits
PacketType	Eigen/src/Core/Redux.h	/^    typedef typename find_best_packet<typename Derived::Scalar,Derived::SizeAtCompileTime>::type PacketType;$/;"	t	struct:Eigen::internal::redux_traits
PacketType	Eigen/src/Core/Redux.h	/^  typedef typename redux_traits<Func, Derived>::PacketType PacketType;$/;"	t	struct:Eigen::internal::redux_impl
PacketType	test/vectorization_logic.cpp	/^  typedef typename internal::packet_traits<Scalar>::type PacketType;$/;"	t	struct:vectorization_logic	file:
PacketType	test/vectorization_logic.cpp	/^  typedef typename internal::unpacket_traits<typename internal::packet_traits<Scalar>::type>::half PacketType;$/;"	t	struct:vectorization_logic_half	file:
PacketType	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  struct PacketType<T, SyclDevice> {$/;"	s	namespace:Eigen
PacketType	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^struct PacketType : internal::packet_traits<Scalar> {$/;"	s	namespace:Eigen
PacketType	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^struct PacketType<half, GpuDevice> {$/;"	s	namespace:Eigen
PaddingType	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^} PaddingType;$/;"	t	namespace:Eigen	typeref:enum:Eigen::__anon163
ParameterType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Array<StorageIndex,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl
ParameterVectorType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::ParameterVectorType ParameterVectorType;$/;"	t	class:Eigen::Spline
ParameterVectorType	unsupported/Eigen/src/Splines/SplineFitting.h	/^    typedef typename SplineType::ParameterVectorType ParameterVectorType;$/;"	t	struct:Eigen::SplineFitting
ParameterVectorType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,1,Dynamic> ParameterVectorType;$/;"	t	struct:Eigen::SplineTraits
Parameters	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Parameters()$/;"	f	struct:Eigen::HybridNonLinearSolver::Parameters
Parameters	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    struct Parameters {$/;"	s	class:Eigen::HybridNonLinearSolver
Parameters	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Parameters()$/;"	f	struct:Eigen::LevenbergMarquardt::Parameters
Parameters	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    struct Parameters {$/;"	s	class:Eigen::LevenbergMarquardt
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^    explicit PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen
ParentMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef BaseTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> ParentMapper;$/;"	t	class:Eigen::internal::TensorContractionSubMapper
ParentMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, 1, inner_dim_contiguous, Alignment> ParentMapper;$/;"	t	class:Eigen::internal::BaseTensorContractionMapper
ParentMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef SimpleTensorContractionMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, Alignment> ParentMapper;$/;"	t	class:Eigen::internal::BaseTensorContractionMapper
Park	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void Park(Waiter* w) {$/;"	f	class:Eigen::EventCount
PartOf	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <> struct PartOf<ImagPart> {$/;"	s	namespace:Eigen
PartOf	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <> struct PartOf<RealPart> {$/;"	s	namespace:Eigen
PartOf	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^template <int ResultType> struct PartOf {$/;"	s	namespace:Eigen
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(EigenBase<InputType>& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	Eigen/src/Core/VectorwiseOp.h	/^    explicit PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr
PartialReduxExpr	Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : public internal::dense_xpr_base< PartialReduxExpr<MatrixType, MemberOp, Direction> >::type,$/;"	c	namespace:Eigen
PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase
PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    explicit PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen
PerThread	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^    constexpr PerThread() : pool(NULL), rand(0), thread_id(-1) { }$/;"	f	struct:Eigen::NonBlockingThreadPoolTempl::PerThread
PerThread	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  struct PerThread {$/;"	s	class:Eigen::NonBlockingThreadPoolTempl
PerThread	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    constexpr PerThread() : pool(NULL), thread_id(-1) { }$/;"	f	struct:Eigen::SimpleThreadPoolTempl::PerThread
PerThread	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  struct PerThread {$/;"	s	class:Eigen::SimpleThreadPoolTempl
Perm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,StorageIndex> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
PermIndex	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef typename QRSolver::StorageIndex PermIndex;$/;"	t	class:Eigen::LevenbergMarquardt
PermIndexType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename PermutationType::StorageIndex PermIndexType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermIndexType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename PermutationType::Index PermIndexType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PermPermProduct	Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermTraits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> PermTraits;$/;"	t	class:Eigen::InverseImpl
PermutationBase	Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
PermutationMap	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Map<PermutationMatrix<Dynamic,Dynamic,int> > PermutationMap;$/;"	t	class:Eigen::SuperLUBase
PermutationMap	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::PermutationMap PermutationMap;$/;"	t	class:Eigen::SuperLU
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const InverseImpl<Other,PermutationStorage>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(Index size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex> >$/;"	c	namespace:Eigen
PermutationPType	Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU
PermutationQType	Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU
PermutationShape	Eigen/src/Core/util/Constants.h	/^struct PermutationShape       { static std::string debugName() { return "PermutationShape"; } };$/;"	s	namespace:Eigen
PermutationStorage	Eigen/src/Core/util/Constants.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT
PermutationType	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename OrderingType::PermutationType PermutationType;$/;"	t	class:Eigen::IncompleteCholesky
PermutationType	Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU
PermutationType	Eigen/src/MetisSupport/MetisSupport.h	/^  typedef PermutationMatrix<Dynamic,Dynamic,StorageIndex> PermutationType;$/;"	t	class:Eigen::MetisOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType; $/;"	t	class:Eigen::COLAMDOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::AMDOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::NaturalOrdering
PermutationType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermutationType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      PermutationType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PermutationType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR
PermutationType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef Map<PermutationMatrix<Dynamic, Dynamic, StorageIndex> > PermutationType;$/;"	t	class:Eigen::SPQR
PermutationType	Eigen/src/SparseLU/SparseLU.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::SparseLU
PermutationType	Eigen/src/SparseQR/SparseQR.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, StorageIndex> PermutationType;$/;"	t	class:Eigen::SparseQR
PermutationType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef PermutationMatrix<Dynamic,Dynamic> PermutationType;$/;"	t	class:Eigen::LevenbergMarquardt
PermutationWrapper	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& indices)$/;"	f	class:Eigen::PermutationWrapper
PermutationWrapper	Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen
Pivot_Vector	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  typedef blitz::Array<int,1> Pivot_Vector;$/;"	t	class:blitz_LU_solve_interface
Pivot_Vector	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  typedef blitz::Array<int,1> Pivot_Vector;$/;"	t	class:blitz_LU_solve_interface
Pivot_Vector	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  typedef blitz::Array<int,1> Pivot_Vector;$/;"	t	class:blitz_LU_solve_interface
Pivoting	Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
PivotsType	lapack/lapack_common.h	/^typedef Eigen::Map<Eigen::Transpositions<Eigen::Dynamic,Eigen::Dynamic,int> > PivotsType;$/;"	t
PlaceHolder	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct PlaceHolder {$/;"	s	namespace:Eigen::TensorSycl::internal
PlainArray	Eigen/src/Core/DenseBase.h	/^          > PlainArray;$/;"	t	class:Eigen::DenseBase
PlainMatrix	Eigen/src/Core/DenseBase.h	/^          > PlainMatrix;$/;"	t	class:Eigen::DenseBase
PlainMatrixType	blas/common.h	/^typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> PlainMatrixType;$/;"	t
PlainObject	Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array
PlainObject	Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ArrayBase
PlainObject	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::PlainObject         PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	Eigen/src/Core/DenseBase.h	/^                                 PlainMatrix, PlainArray>::type PlainObject;$/;"	t	class:Eigen::DenseBase
PlainObject	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase
PlainObject	Eigen/src/Core/Inverse.h	/^  typedef typename InverseType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	Eigen/src/Core/Inverse.h	/^  typedef typename XprType::PlainObject                       PlainObject;$/;"	t	class:Eigen::Inverse
PlainObject	Eigen/src/Core/Inverse.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix
PlainObject	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::MatrixBase
PlainObject	Eigen/src/Core/PermutationMatrix.h	/^    typedef PlainPermutationType PlainObject;$/;"	t	class:Eigen::PermutationBase
PlainObject	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	Eigen/src/Core/ReturnByValue.h	/^  typedef typename internal::traits<Derived>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView
PlainObject	Eigen/src/Core/Solve.h	/^                 RhsType::MaxColsAtCompileTime>::type PlainObject;$/;"	t	struct:Eigen::internal::solve_traits
PlainObject	Eigen/src/Core/Solve.h	/^  typedef typename SolveType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	Eigen/src/Core/Solve.h	/^  typedef typename internal::traits<Solve>::PlainObject PlainObject;$/;"	t	class:Eigen::Solve
PlainObject	Eigen/src/Core/Solve.h	/^  typedef typename solve_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularViewImpl
PlainObject	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename SolveType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::evaluator
PlainObject	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::traits<SolveWithGuess>::PlainObject PlainObject;$/;"	t	class:Eigen::SolveWithGuess
PlainObject	Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::FullPivLU
PlainObject	Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::PartialPivLU
PlainObject	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::ColPivHouseholderQR
PlainObject	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
PlainObject	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::FullPivHouseholderQR
PlainObject	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor, StorageIndex> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase
PlainObject	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename permutation_matrix_product<Lhs,OnTheRight,false,SparseShape>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename permutation_matrix_product<Rhs,OnTheLeft,false,SparseShape>::ReturnType PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::unary_evaluator
PlainObject	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename XprType::PlainObject PlainObject;$/;"	t	struct:Eigen::internal::product_evaluator
PlainObject	Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename sparse_eval<RhsType, RhsType::RowsAtCompileTime, RhsType::ColsAtCompileTime,traits<RhsType>::Flags>::type PlainObject;$/;"	t	struct:Eigen::internal::solve_traits
PlainObject	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename Derived::PlainObject PlainObject;$/;"	t	class:Eigen::MatrixComplexPowerReturnValue
PlainObject	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename Derived::PlainObject PlainObject;$/;"	t	class:Eigen::MatrixPowerReturnValue
PlainObject	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef BlockSparseMatrix<Scalar, BlockSize, IsColMajor ? ColMajor : RowMajor, StorageIndex> PlainObject;$/;"	t	class:Eigen::BlockSparseMatrix
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>$/;"	c	namespace:Eigen
PlainObjectType	Eigen/src/Core/CoreEvaluators.h	/^  typedef PlainObjectBase<Derived> PlainObjectType;$/;"	t	struct:Eigen::internal::evaluator
PlainObjectType	Eigen/src/Core/Ref.h	/^  typedef _PlainObjectType PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;$/;"	t	class:Eigen::RefBase
PlainObjectType	Eigen/src/SparseCore/SparseMap.h	/^  typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	class:Eigen::Ref
PlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseVector<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	class:Eigen::Ref
PlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseMatrix<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^  typedef SparseVector<MatScalar,MatOptions,MatIndex> PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectTypeCleaned	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;$/;"	t	struct:Eigen::internal::evaluator
PlainObjectTypeInnerSize	Eigen/src/Core/Map.h	/^    PlainObjectTypeInnerSize = ((traits<PlainObjectType>::Flags&RowMajorBit)==RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon748
PlainPermutationType	Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase
PlainPermutationType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::InverseImpl
PlanData	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftw_plan<Scalar> PlanData;$/;"	t	struct:Eigen::internal::fftw_impl
PlanData	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef kiss_cpx_fft<Scalar> PlanData;$/;"	t	struct:Eigen::internal::kissfft_impl
PlanKey	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    int PlanKey(int nfft, bool isinverse) const { return (nfft<<1) | int(isinverse); }$/;"	f	struct:Eigen::internal::kissfft_impl
PlanMap	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef std::map<int64_t,PlanData> PlanMap;$/;"	t	struct:Eigen::internal::fftw_impl
PlanMap	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::map<int,PlanData> PlanMap;$/;"	t	struct:Eigen::internal::kissfft_impl
PointPointMinimizer	unsupported/doc/examples/BVH_Example.cpp	/^  PointPointMinimizer() : calls(0) {}$/;"	f	struct:PointPointMinimizer
PointPointMinimizer	unsupported/doc/examples/BVH_Example.cpp	/^struct PointPointMinimizer \/\/how to compute squared distances between points and rectangles$/;"	s	file:
PointType	unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::PointType PointType;$/;"	t	class:Eigen::Spline
PointType	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,1> PointType;$/;"	t	struct:Eigen::SplineTraits
PointerArgType	Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map
PointerArgType	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::TensorMap
PointerArgType	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::TensorRef
PointerType	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::PointerType PointerType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
PointerType	Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map
PointerType	Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase
PointerType	Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase
PointerType	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename MakePointer_<CoeffReturnType>::Type PointerType;$/;"	t	class:Eigen::TensorEvalToOp
PointerType	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename MakePointer_<Scalar>::Type PointerType;$/;"	t	class:Eigen::TensorMap
PointerType	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef Scalar* PointerType;$/;"	t	class:Eigen::TensorRef
PolynomialSolver	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolver( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolver
PolynomialSolver	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolver(){}$/;"	f	class:Eigen::PolynomialSolver
PolynomialSolver	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolver : public PolynomialSolverBase<_Scalar,_Deg>$/;"	c	namespace:Eigen
PolynomialSolver	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolver<_Scalar,1> : public PolynomialSolverBase<_Scalar,1>$/;"	c	namespace:Eigen
PolynomialSolverBase	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolverBase( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolverBase
PolynomialSolverBase	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolverBase(){}$/;"	f	class:Eigen::PolynomialSolverBase
PolynomialSolverBase	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolverBase$/;"	c	namespace:Eigen
Pop	unsupported/test/cxx11_eventcount.cpp	/^  bool Pop() {$/;"	f	struct:TestQueue
PopBack	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  Work PopBack() {$/;"	f	class:Eigen::RunQueue
PopBackHalf	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  unsigned PopBackHalf(std::vector<Work>* result) {$/;"	f	class:Eigen::RunQueue
PopFront	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  Work PopFront() {$/;"	f	class:Eigen::RunQueue
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  Portable_Perf_Analyzer( ):_nb_calc(0), m_time_action(0), _chronos(){$/;"	f	class:Portable_Perf_Analyzer
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  Portable_Perf_Analyzer( const Portable_Perf_Analyzer & ){$/;"	f	class:Portable_Perf_Analyzer
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^class Portable_Perf_Analyzer{$/;"	c
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  Portable_Perf_Analyzer( const Portable_Perf_Analyzer & ){$/;"	f	class:Portable_Perf_Analyzer
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  Portable_Perf_Analyzer( void ):_nb_calc(1),_nb_init(1),_chronos(){$/;"	f	class:Portable_Perf_Analyzer
Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^class Portable_Perf_Analyzer{$/;"	c
Portable_Timer	bench/btl/generic_bench/timers/portable_timer.hh	/^   Portable_Timer()$/;"	f	class:Portable_Timer
Portable_Timer	bench/btl/generic_bench/timers/portable_timer.hh	/^  Portable_Timer()$/;"	f	class:Portable_Timer
Portable_Timer	bench/btl/generic_bench/timers/portable_timer.hh	/^  Portable_Timer(int clkid) : m_clkid(clkid)$/;"	f	class:Portable_Timer
Portable_Timer	bench/btl/generic_bench/timers/portable_timer.hh	/^ class Portable_Timer$/;"	c
Portable_Timer	bench/btl/generic_bench/timers/portable_timer.hh	/^class Portable_Timer$/;"	c
PositiveSemiDef	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
PreconditionIfMoreColsThanRows	Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon778
PreconditionIfMoreRowsThanCols	Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon778
Preconditioner	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB
Preconditioner	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient
Preconditioner	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase
Preconditioner	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Preconditioner	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::DGMRES
Preconditioner	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::GMRES
Preconditioner	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^            typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::MINRES
PreservingInnerMostDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool PreservingInnerMostDims = internal::preserve_inner_most_dims<Dims, NumInputDims, Layout>::value;$/;"	m	struct:Eigen::TensorEvaluator
Prewait	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void Prewait(Waiter* w) {$/;"	f	class:Eigen::EventCount
PrivateType	Eigen/src/Core/Array.h	/^    struct PrivateType {};$/;"	s	class:Eigen::Array
ProdReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct ProdReducer$/;"	s	namespace:Eigen::internal
ProdReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_prod>::Type ProdReturnType;$/;"	t	class:Eigen::VectorwiseOp
ProdXprType	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Product<LhsT,RhsT,DefaultProduct> ProdXprType;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
Product	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)$/;"	f	class:Eigen::Product
Product	Eigen/src/Core/Product.h	/^class Product : public ProductImpl<_Lhs,_Rhs,Option,$/;"	c	namespace:Eigen
ProductImpl	Eigen/src/Core/Product.h	/^class ProductImpl : public internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type$/;"	c	namespace:Eigen
ProductImpl	Eigen/src/Core/Product.h	/^class ProductImpl<Lhs,Rhs,Option,Dense>$/;"	c	namespace:Eigen
ProductImplType	Eigen/src/Core/util/Constants.h	/^enum ProductImplType$/;"	g	namespace:Eigen
ProductType	Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ProductXpr	Eigen/src/Core/Product.h	/^  typedef Product<Lhs,Rhs,Option> ProductXpr;$/;"	t	class:Eigen::internal::dense_product_base
ProjectionMode2D	demos/opengl/gpuhelper.h	/^    enum ProjectionMode2D { PM_Normalized = 1, PM_Viewport = 2 };$/;"	g	class:GpuHelper
Projective	Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Projective2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
Push	unsupported/test/cxx11_eventcount.cpp	/^  bool Push() {$/;"	f	struct:TestQueue
PushBack	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  Work PushBack(Work w) {$/;"	f	class:Eigen::RunQueue
PushFront	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  Work PushFront(Work w) {$/;"	f	class:Eigen::RunQueue
PutMatrixElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void PutMatrixElt(Scalar value, int row, int col, std::ofstream& out)$/;"	f	namespace:Eigen::internal
PutMatrixElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void PutMatrixElt(std::complex<Scalar> value, int row, int col, std::ofstream& out)$/;"	f	namespace:Eigen::internal
Q	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^MatrixXf Q = hessOfA.matrixQ();$/;"	v
Q	doc/snippets/HouseholderQR_householderQ.cpp	/^std::cout << "The complete unitary matrix Q is:\\n" << Q << "\\n\\n";$/;"	v
Q	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^MatrixXd Q = triOfA.matrixQ();$/;"	v
QRMatrixType	Eigen/src/SparseQR/SparseQR.h	/^    typedef SparseMatrix<Scalar,ColMajor,StorageIndex> QRMatrixType;$/;"	t	class:Eigen::SparseQR
QRPreconditioners	Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
QRSolver	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef typename FunctorType::QRSolver QRSolver;$/;"	t	class:Eigen::LevenbergMarquardt
QRSolver	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef ColPivHouseholderQR<JacobianType> QRSolver;$/;"	t	struct:Eigen::DenseFunctor
QRSolver	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef SparseQR<JacobianType, COLAMDOrdering<int> > QRSolver;$/;"	t	struct:Eigen::SparseFunctor
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QrType	Eigen/src/QR/ColPivHouseholderQR.h	/^  typedef ColPivHouseholderQR<MatrixType> QrType;$/;"	t	struct:Eigen::internal::Assignment
QrType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef FullPivHouseholderQR<MatrixType> QrType;$/;"	t	struct:Eigen::internal::Assignment
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC explicit inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen
QuaternionBase	Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen
QuaternionDemo	demos/opengl/quaternion_demo.cpp	/^QuaternionDemo::QuaternionDemo()$/;"	f	class:QuaternionDemo
QuaternionDemo	demos/opengl/quaternion_demo.h	/^class QuaternionDemo : public QMainWindow$/;"	c
QuaternionMapAlignedd	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionType	Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
QuaternionType	demos/opengl/quaternion_demo.cpp	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:EulerAngles	file:
QuaternionType	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef Quaternion<Scalar> QuaternionType; \/*!< the equivalent quaternion type *\/$/;"	t	class:Eigen::EulerAngles
Quaterniond	Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaternionf	Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Queue	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  typedef RunQueue<Task, 1024> Queue;$/;"	t	class:Eigen::NonBlockingThreadPoolTempl
QuickSplit	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)$/;"	f	namespace:Eigen::internal
R	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    UpperTriangularType R;$/;"	m	class:Eigen::HybridNonLinearSolver
RDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int RDims =$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
RDims	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  static const int RDims =$/;"	m	struct:Eigen::TensorEvaluator
RDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  static const int RDims =$/;"	m	struct:Eigen::TensorEvaluator
RDims	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static const int RDims =$/;"	m	struct:Eigen::TensorEvaluator
REAL_SCALAR_SUFFIX	blas/complex_double.cpp	13;"	d	file:
REAL_SCALAR_SUFFIX	blas/complex_single.cpp	13;"	d	file:
REAL_SCALAR_SUFFIX	lapack/complex_double.cpp	13;"	d	file:
REAL_SCALAR_SUFFIX	lapack/complex_single.cpp	13;"	d	file:
REAL_TIMER	bench/BenchTimer.h	/^  REAL_TIMER = 1$/;"	e	enum:Eigen::__anon13
REAL_TYPE	bench/btl/generic_bench/bench_parameter.hh	24;"	d
RECURSIVE_TUPLE_GET	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	104;"	d
RECURSIVE_TUPLE_GET	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	112;"	d
REF_ADD	test/packetmath.cpp	107;"	d	file:
REF_DIV	test/packetmath.cpp	110;"	d	file:
REF_MUL	test/packetmath.cpp	109;"	d	file:
REF_SUB	test/packetmath.cpp	108;"	d	file:
REPEAT	bench/benchCholesky.cpp	19;"	d	file:
REPEAT	bench/benchEigenSolver.cpp	20;"	d	file:
REPEAT	bench/benchGeometry.cpp	11;"	d	file:
REPEAT	bench/benchVecAdd.cpp	12;"	d	file:
REPEAT	bench/bench_reverse.cpp	8;"	d	file:
REPEAT	bench/benchmark.cpp	15;"	d	file:
REPEAT	bench/benchmarkSlice.cpp	11;"	d	file:
REPEAT	bench/benchmarkX.cpp	19;"	d	file:
REPEAT	bench/benchmarkXcwise.cpp	18;"	d	file:
REPEAT	bench/sparse_cholesky.cpp	20;"	d	file:
REPEAT	bench/sparse_dense_product.cpp	15;"	d	file:
REPEAT	bench/sparse_lu.cpp	20;"	d	file:
REPEAT	bench/sparse_product.cpp	18;"	d	file:
REPEAT	bench/sparse_randomsetter.cpp	19;"	d	file:
REPEAT	bench/sparse_setter.cpp	15;"	d	file:
REPEAT	bench/sparse_transpose.cpp	15;"	d	file:
REPEAT	bench/sparse_trisolver.cpp	16;"	d	file:
REPEAT	bench/vdw_new.cpp	15;"	d	file:
REPEAT	unsupported/bench/bench_svd.cpp	25;"	d	file:
REPERE	bench/btl/generic_bench/utils/utilities.h	66;"	d
REPERE	bench/btl/generic_bench/utils/utilities.h	83;"	d
REWI	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:CBLAT2
REWI	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:CBLAT3
REWI	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:DBLAT2
REWI	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:DBLAT3
REWI	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:SBLAT2
REWI	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:SBLAT3
REWI	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:ZBLAT2
REWI	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI,/;"	v	program:ZBLAT3
RIGHT	blas/common.h	29;"	d
ROW_IS_ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	118;"	d
ROW_IS_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	116;"	d
ROW_IS_MARKED_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	117;"	d
RZERO	blas/testing/cblat2.f	/^      REAL               RZERO$/;"	v	program:CBLAT2
RZERO	blas/testing/cblat3.f	/^      REAL               RZERO$/;"	v	program:CBLAT3
RZERO	blas/testing/zblat2.f	/^      DOUBLE PRECISION   RZERO$/;"	v	program:ZBLAT2
RZERO	blas/testing/zblat3.f	/^      DOUBLE PRECISION   RZERO$/;"	v	program:ZBLAT3
Rand	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  static EIGEN_STRONG_INLINE unsigned Rand(uint64_t* state) {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase
RandomAccessLinSpacedReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
RandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
RandomCpx	unsupported/test/FFTW.cpp	/^std::complex<T> RandomCpx() { return std::complex<T>( (T)(rand()\/(T)RAND_MAX - .5), (T)(rand()\/(T)RAND_MAX - .5) ); }$/;"	f
RandomFill	unsupported/doc/examples/FFT.cpp	/^void RandomFill(std::vector<T> & vec)$/;"	f
RandomFill	unsupported/doc/examples/FFT.cpp	/^void RandomFill(std::vector<std::complex<T> > & vec)$/;"	f
RandomReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;$/;"	t	class:Eigen::DenseBase
RandomSetter	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    inline RandomSetter(SparseMatrixType& target)$/;"	f	class:Eigen::RandomSetter
RandomSetter	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^class RandomSetter$/;"	c	namespace:Eigen
RandomToTypeNormal	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^T RandomToTypeNormal(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeNormal	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^std::complex<double> RandomToTypeNormal<std::complex<double> >(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeNormal	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^std::complex<float> RandomToTypeNormal<std::complex<float> >(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^Eigen::half RandomToTypeUniform<Eigen::half>(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^T RandomToTypeUniform(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^double RandomToTypeUniform<double>(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^float RandomToTypeUniform<float>(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^std::complex<double> RandomToTypeUniform<std::complex<double> >(uint64_t* state) {$/;"	f	namespace:Eigen::internal
RandomToTypeUniform	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^std::complex<float> RandomToTypeUniform<std::complex<float> >(uint64_t* state) {$/;"	f	namespace:Eigen::internal
Range	bench/tensors/benchmark_main.cc	/^Benchmark* Benchmark::Range(int lo, int hi) {$/;"	f	class:testing::Benchmark
RangeBuilder	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct RangeBuilder : public RangeBuilder<MIN, N - 1, N - 1, Is...> {};$/;"	s	namespace:utility::tuple
RangeBuilder	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct RangeBuilder<MIN, MIN, Is...> {$/;"	s	namespace:utility::tuple
RawAccess	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      RawAccess = true$/;"	e	enum:Eigen::Tensor::__anon122
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon100
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon99
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    RawAccess = TensorEvaluator<LeftArgType, Device>::RawAccess$/;"	e	enum:Eigen::TensorEvaluator::__anon120
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon126
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon124
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon125
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon97
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon98
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorContractionEvaluatorBase::__anon165
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon108
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon145
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon146
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon137
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon138
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorEvaluator::__anon141
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon112
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon113
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon114
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon115
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon116
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorEvaluator::__anon109
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorEvaluator::__anon111
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon148
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^      RawAccess = true$/;"	e	enum:Eigen::TensorFixedSize::__anon87
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorEvaluator::__anon118
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon142
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon130
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon136
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess$/;"	e	enum:Eigen::TensorEvaluator::__anon85
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^      RawAccess = true$/;"	e	enum:Eigen::TensorMap::__anon127
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess$/;"	e	enum:Eigen::TensorEvaluator::__anon89
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = TensorEvaluator<ArgType, Device>::RawAccess$/;"	e	enum:Eigen::TensorEvaluator::__anon90
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon92
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon93
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon94
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon95
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon147
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon88
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon128
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^      RawAccess = false$/;"	e	enum:Eigen::TensorRef::__anon152
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon153
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon154
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon183
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon184
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^    RawAccess = true$/;"	e	enum:Eigen::TensorEvaluator::__anon129
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon150
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon151
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon185
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon186
RawAccess	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    RawAccess = false$/;"	e	enum:Eigen::TensorEvaluator::__anon143
ReadCost	Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
ReadCost	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon123
ReadOnlyAccessors	Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
ReadOnlyMapBase	Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::MapBase
ReadOnlyMapBase	Eigen/src/SparseCore/SparseMap.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::SparseMapBase
Real	Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits
Real	test/boostmultiprec.cpp	/^typedef mp::number<mp::cpp_dec_float<100>, mp::et_on> Real;$/;"	t	file:
Real	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  typedef DenseIndex Real;$/;"	t	struct:Eigen::NumTraits
Real	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^                                0, DerTypeCleaned::MaxRowsAtCompileTime, DerTypeCleaned::MaxColsAtCompileTime> > Real;$/;"	t	struct:Eigen::NumTraits
Real	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename NumTraits<Scalar>::Real Real;$/;"	t	class:Eigen::AutoDiffScalar
Real	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename NumTraits<Scalar>::Real Real;$/;"	t	struct:Eigen::internal::auto_diff_special_op
RealPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits
RealPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
RealPart	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  RealPart = 0,$/;"	e	enum:Eigen::FFTResultType
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :$/;"	f	class:Eigen::RealQZ
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      explicit RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) :$/;"	f	class:Eigen::RealQZ
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^  template<typename _MatrixType> class RealQZ$/;"	c	namespace:Eigen
RealReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
RealRowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RealRowVectorType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^      RealRowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RealScalar	Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT
RealScalar	Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT
RealScalar	Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace
RealScalar	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase
RealScalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase
RealScalar	Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase
RealScalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase
RealScalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase
RealScalar	Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector
RealScalar	Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase
RealScalar	Eigen/src/Core/MathFunctions.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::arg_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef T RealScalar;$/;"	t	struct:Eigen::internal::imag_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef T RealScalar;$/;"	t	struct:Eigen::internal::real_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl_default
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl
RealScalar	Eigen/src/Core/MathFunctionsImpl.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl
RealScalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase
RealScalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase
RealScalar	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView
RealScalar	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp
RealScalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver
RealScalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur
RealScalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver
RealScalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
RealScalar	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition
RealScalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RealScalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization
RealScalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
RealScalar	Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
RealScalar	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase
RealScalar	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
RealScalar	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB
RealScalar	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient
RealScalar	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar; $/;"	t	class:Eigen::IncompleteCholesky
RealScalar	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT
RealScalar	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase
RealScalar	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
RealScalar	Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation
RealScalar	Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl
RealScalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase
RealScalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits
RealScalar	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RealScalar	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR
RealScalar	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR
RealScalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SPQR
RealScalar	Eigen/src/SVD/BDCSVD.h	/^  typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::BDCSVD
RealScalar	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD
RealScalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
RealScalar	Eigen/src/SVD/SVDBase.h	/^  typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVDBase
RealScalar	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT
RealScalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector
RealScalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
RealScalar	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage
RealScalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase
RealScalar	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
RealScalar	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::RealScalar RealScalar; $/;"	t	class:Eigen::SparseLU
RealScalar	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef typename ScalarVector::RealScalar RealScalar; $/;"	t	class:Eigen::internal::SparseLUImpl
RealScalar	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SparseQR
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase
RealScalar	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU
RealScalar	bench/bench_gemm.cpp	/^typedef NumTraits<Scalar>::Real RealScalar;$/;"	t	file:
RealScalar	bench/geometry.cpp	/^typedef NumTraits<Scalar>::Real RealScalar;$/;"	t	file:
RealScalar	blas/PackedSelfadjointProduct.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:internal::selfadjoint_packed_rank1_update
RealScalar	blas/common.h	/^typedef NumTraits<Scalar>::Real RealScalar;$/;"	t
RealScalar	doc/examples/matrixfree_cg.cpp	/^  typedef double RealScalar;$/;"	t	class:MatrixReplacement	file:
RealScalar	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tensor
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorIndexTupleOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorTupleReducerOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorAssignOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorBroadcastingOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorChippingOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorConcatenationOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorConversionOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorConvolutionOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCustomBinaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCustomUnaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorEvalToOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCwiseBinaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCwiseNullaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCwiseTernaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorCwiseUnaryOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorSelectOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorFFTOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::TensorEvaluator
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename NumTraits<typename XprTraits::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::traits
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorFixedSize
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorForcedEvalOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorGeneratorOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorImagePatchOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorInflationOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorLayoutSwapOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorMap
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorPaddingOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorPatchOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorReductionOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorRef
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorReverseOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorScanOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorShufflingOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorStridingOp
RealScalar	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename Eigen::NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::TensorVolumePatchOp
RealScalar	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
RealScalar	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::DGMRES
RealScalar	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::GMRES
RealScalar	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::MINRES
RealScalar	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef typename JacobianType::RealScalar RealScalar; $/;"	t	class:Eigen::LevenbergMarquardt
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  typedef typename NumTraits<typename traits<MatrixType>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::matrix_exp_computeUV
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::matrix_log_max_pade_degree
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename Derived::RealScalar RealScalar;$/;"	t	class:Eigen::MatrixPowerReturnValue
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::MatrixPower
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::MatrixPowerAtomic
RealScalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::MatrixPowerParenthesesReturnValue
RealScalar	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef typename NumTraits<Scalar>::Real       RealScalar;$/;"	t	class:Eigen::internal::companion
RealScalar	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef typename NumTraits<Scalar>::Real    RealScalar;$/;"	t	class:Eigen::PolynomialSolverBase
RealScalar	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineInplaceLU
RealScalar	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineMatrixBase
RealScalar	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineStorage
RealScalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Ref<typename BlockSparseMatrixT::BlockRealScalar> RealScalar;$/;"	t	class:Eigen::BlockSparseMatrixView
RealScalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::BlockSparseMatrix
RealScalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef Ref<Matrix<typename BlockSparseMatrixT::RealScalar, BlockSparseMatrixT::BlockSize, BlockSparseMatrixT::BlockSize> > RealScalar;$/;"	t	struct:Eigen::internal::traits
RealScalar	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixMarketIterator
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^    explicit RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^    explicit RealSchur(const EigenBase<InputType>& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RealVectorType	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
ReducingInnerMostDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool ReducingInnerMostDims = internal::are_inner_most_dims<Dims, NumInputDims, Layout>::value;$/;"	m	struct:Eigen::TensorEvaluator
ReductionCleanupKernelHalfFloat	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void ReductionCleanupKernelHalfFloat(Op& reducer, half* output, half2* scratch) {$/;"	f	namespace:Eigen::internal
ReductionInitFullReduxKernelHalfFloat	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void ReductionInitFullReduxKernelHalfFloat(Reducer reducer, const Self input, Index num_coeffs, half2* scratch) {$/;"	f	namespace:Eigen::internal
ReductionInitKernel	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void ReductionInitKernel(const CoeffType val, Index num_preserved_coeffs, CoeffType* output) {$/;"	f	namespace:Eigen::internal
ReductionInitKernelHalfFloat	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__global__ void ReductionInitKernelHalfFloat(Reducer reducer, const Self input, Index num_coeffs, half* output) {$/;"	f	namespace:Eigen::internal
ReduxReturnType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp
Ref	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(PlainObjectBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const Ref& other) : Base(other) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC inline Ref(const RefBase<OtherRef>& other) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^template<typename PlainObjectType, int Options, typename StrideType> class Ref$/;"	c	namespace:Eigen
Ref	Eigen/src/Core/Ref.h	/^template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>$/;"	c	namespace:Eigen
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(MappedSparseMatrix<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(SparseMatrix<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(SparseVector<MatScalar,OtherOptions,MatIndex>& expr)$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const Ref& other) : Base(other), m_hasCopy(false) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const RefBase<OtherRef>& other) : m_hasCopy(false) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const SparseCompressedBase<Derived>& expr)$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^    inline Ref(const SparseMatrixBase<Derived>& expr) : m_hasCopy(false)$/;"	f	class:Eigen::Ref
Ref	Eigen/src/SparseCore/SparseRef.h	/^class Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType >$/;"	c	namespace:Eigen
Ref	Eigen/src/SparseCore/SparseRef.h	/^class Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType >$/;"	c	namespace:Eigen
Ref	Eigen/src/SparseCore/SparseRef.h	/^class Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
Ref	Eigen/src/SparseCore/SparseRef.h	/^class Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType>$/;"	c	namespace:Eigen
RefBase	Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC RefBase()$/;"	f	class:Eigen::RefBase
RefBase	Eigen/src/Core/Ref.h	/^template<typename Derived> class RefBase$/;"	c	namespace:Eigen
RefactoredXpr	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename helper::Xpr RefactoredXpr;$/;"	t	struct:Eigen::internal::product_evaluator
Register	bench/tensors/benchmark_main.cc	/^void Benchmark::Register(const char* name, void (*fn)(int), void (*fn_range)(int, int)) {$/;"	f	class:testing::Benchmark
RelErr	bench/spbench/spbenchsolver.h	/^double RelErr; \/\/ Relative error of the computed solution$/;"	v
RelativeErrorAndReductionTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        RelativeErrorAndReductionTooSmall = 3,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeErrorAndReductionTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeErrorAndReductionTooSmall = 3,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeErrorTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        RelativeErrorTooSmall = 2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeErrorTooSmall	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        RelativeErrorTooSmall = 1,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
RelativeErrorTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeErrorTooSmall = 2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeReductionTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        RelativeReductionTooSmall = 1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeReductionTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeReductionTooSmall = 1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RemovedBits	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon29
RemovedBits	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RemovedBits = ~((EvalToRowMajor ? 0 : RowMajorBit) | (ResultIsSkyline ? 0 : SkylineBit)),$/;"	e	enum:Eigen::internal::traits::__anon40
RenderingWidget	demos/opengl/quaternion_demo.cpp	/^RenderingWidget::RenderingWidget()$/;"	f	class:RenderingWidget
RenderingWidget	demos/opengl/quaternion_demo.h	/^class RenderingWidget : public QGLWidget$/;"	c
Replicate	Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate
Replicate	Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& matrix)$/;"	f	class:Eigen::Replicate
Replicate	Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen
ReplicateReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,(isVertical?Dynamic:1),(isHorizontal?Dynamic:1)> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp
RequireInitialization	Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon435
RequireInitialization	Eigen/src/Core/arch/CUDA/Half.h	/^    RequireInitialization = false$/;"	e	enum:Eigen::NumTraits::__anon671
RequireInitialization	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^    RequireInitialization = false,$/;"	e	enum:Eigen::NumTraits::__anon123
RequireInitialization	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    RequireInitialization = 1$/;"	e	enum:Eigen::NumTraits::__anon80
Res	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Res	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^  static const size_t Res =X;$/;"	m	struct:Eigen::TensorSycl::internal::ValueCondition
Res	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^  static const size_t Res =Y;$/;"	m	struct:Eigen::TensorSycl::internal::ValueCondition
ResAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    ResAlignment = traits<Quaternion<double> >::Alignment$/;"	e	enum:Eigen::internal::quat_conj::__anon276
ResAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    ResAlignment = traits<Quaternion<double> >::Alignment$/;"	e	enum:Eigen::internal::quat_product::__anon275
ResAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    ResAlignment = traits<Quaternion<float> >::Alignment$/;"	e	enum:Eigen::internal::quat_conj::__anon273
ResAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    ResAlignment = traits<Quaternion<float> >::Alignment$/;"	e	enum:Eigen::internal::quat_product::__anon272
ResAlignment	Eigen/src/Geometry/arch/Geometry_SSE.h	/^    ResAlignment = traits<typename plain_matrix_type<VectorLhs>::type>::Alignment$/;"	e	enum:Eigen::internal::cross3_impl::__anon274
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon633
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
ResPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon624
ResPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon625
ResScalar	Eigen/src/Core/Dot.h	/^  typedef typename conj_prod::result_type ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel
ResScalar	Eigen/src/Core/products/GeneralMatrixVector.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product
ResScalar	blas/PackedTriangularMatrixVector.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:internal::packed_triangular_matrix_vector_product
ResultAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = traits<ResultType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon230
ResultAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = traits<ResultType>::Alignment,$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon231
ResultIsSkyline	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        ResultIsSkyline = ProductMode == SkylineTimeSkylineProduct,$/;"	e	enum:Eigen::internal::traits::__anon40
ResultMode	Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon271
ResultScalar	Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
ResultType	Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl
ResultType	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef Block<MatrixType,Dynamic,Dynamic> ResultType;$/;"	t	class:Eigen::MatrixPowerAtomic
ReturnByValue	Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen
ReturnOpposite	Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon477
ReturnType	Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue
ReturnType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar_=Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp
ReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType; \/\/ FIXME shall it be a BandMatrix?$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename SPQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,StorageIndex> >::type ReturnType;$/;"	t	struct:Eigen::internal::permutation_matrix_product
ReturnType	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename SparseQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<DerType> ReturnType;$/;"	t	struct:Eigen::ScalarBinaryOpTraits
ReturnType	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef Matrix<Scalar,Rows,Cols> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef SparseMatrix<Scalar, 0, StorageIndex> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^{ typedef typename Derived::PlainObject ReturnType; };$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^{ typedef typename MatrixPowerType::PlainObject ReturnType; };$/;"	t	struct:Eigen::internal::traits
ReturnType	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
Reverse	Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC explicit inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse
Reverse	Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen
ReverseCol	Eigen/src/Core/CoreEvaluators.h	/^    ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
ReverseCol	Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon434
ReverseInnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    ReverseInnerIterator(const SparseCompressedBase& mat, Index outer)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit ReverseInnerIterator(const SparseCompressedBase& mat)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^    explicit ReverseInnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase<Derived>::ReverseInnerIterator$/;"	c	class:Eigen::SparseCompressedBase
ReverseInnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::ReverseInnerIterator ReverseInnerIterator;$/;"	t	class:Eigen::SparseMatrix
ReverseInnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    typedef typename Base::ReverseInnerIterator ReverseInnerIterator;$/;"	t	class:Eigen::SparseVector
ReverseInnerIterator	Eigen/src/SparseCore/SparseVector.h	/^  typedef typename SparseVectorType::ReverseInnerIterator ReverseInnerIterator;$/;"	t	struct:Eigen::internal::evaluator
ReverseInnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    ReverseInnerIterator(const DynamicSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
ReverseInnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef typename SparseMatrixType::ReverseInnerIterator ReverseInnerIterator;$/;"	t	struct:Eigen::internal::evaluator
ReverseInnerIterator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^class DynamicSparseMatrix<Scalar,_Options,_StorageIndex>::ReverseInnerIterator : public SparseVector<Scalar,_Options,_StorageIndex>::ReverseInnerIterator$/;"	c	class:Eigen::DynamicSparseMatrix
ReversePacket	Eigen/src/Core/CoreEvaluators.h	/^    ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
ReversePacket	Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon434
ReverseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase
ReverseReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef Reverse<ExpressionType, Direction> ReverseReturnType;$/;"	t	class:Eigen::VectorwiseOp
ReverseRow	Eigen/src/Core/CoreEvaluators.h	/^    ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::internal::unary_evaluator::__anon769
ReverseRow	Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon434
Rhs	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_all<RhsType>::type Rhs;$/;"	t	class:Eigen::CwiseBinaryOp
Rhs	Eigen/src/Core/Product.h	/^    typedef _Rhs Rhs;$/;"	t	class:Eigen::Product
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Rhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  Rhs = 0,$/;"	e	enum:Eigen::internal::__anon131
Rhs	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef typename Traits::Rhs Rhs;$/;"	t	class:Eigen::KroneckerProductBase
Rhs	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits
RhsAlignment	Eigen/src/Core/ProductEvaluators.h	/^    RhsAlignment = EIGEN_PLAIN_ENUM_MIN(RhsEtorType::Alignment,RhsVecPacketSize*int(sizeof(typename RhsNestedCleaned::Scalar))),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsArg	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::Rhs RhsArg;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsBlasTraits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsBlasTraits	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
RhsBlasTraits	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef internal::blas_traits<Rhs> RhsBlasTraits;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
RhsCleaned	Eigen/src/Core/Product.h	/^  typedef typename remove_all<Rhs>::type RhsCleaned;$/;"	t	struct:Eigen::internal::traits
RhsCoeffReadCost	Eigen/src/Core/ProductEvaluators.h	/^    RhsCoeffReadCost = RhsEtorType::CoeffReadCost,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsCoeffReadCost	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon40
RhsEtorType	Eigen/src/Core/ProductEvaluators.h	/^  typedef evaluator<RhsNestedCleaned> RhsEtorType;$/;"	t	struct:Eigen::internal::product_evaluator
RhsEval	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef evaluator<ActualRhs> RhsEval;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
RhsEvaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef evaluator<RhsArg> RhsEvaluator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsFlags	Eigen/src/Core/CoreEvaluators.h	/^    RhsFlags = evaluator<Rhs>::Flags,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
RhsFlags	Eigen/src/Core/ProductEvaluators.h	/^    RhsFlags = RhsEtorType::Flags,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsFlags	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    RhsFlags = Rhs::Flags,$/;"	e	enum:Eigen::internal::traits::__anon29
RhsFlags	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon40
RhsIsSelfAdjoint	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon623
RhsIsUpper	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon623
RhsIsVectorAtCompileTime	Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon517
RhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<Rhs>::InnerIterator  RhsIterator;$/;"	t	struct:Eigen::internal::binary_evaluator
RhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename evaluator<RhsArg>::InnerIterator  RhsIterator;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
RhsMap	blas/BandTriangularSolver.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1> > RhsMap;$/;"	t	struct:internal::band_solve_triangular_selector
RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::ref_selector<RhsType>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	Eigen/src/Core/Product.h	/^    typedef typename internal::ref_selector<Rhs>::type RhsNested;$/;"	t	class:Eigen::Product
RhsNested	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;$/;"	t	struct:Eigen::internal::product_evaluator
RhsNested	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename nested_eval<Rhs,1>::type RhsNested;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename RhsXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename RhsXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename RhsXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename KernelXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename RhsXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename RhsXprType::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef const typename internal::nested_eval<Rhs, Lhs::RowsAtCompileTime>::type RhsNested;$/;"	t	struct:Eigen::SkylineProductReturnType
RhsNestedCleaned	Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	class:Eigen::Product
RhsNestedCleaned	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::product_evaluator
RhsNestedCleaned	Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval
RhsOuterStrideBytes	Eigen/src/Core/ProductEvaluators.h	/^    RhsOuterStrideBytes = int(RhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename RhsNestedCleaned::Scalar)),$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacketType,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
RhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon624
RhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon625
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon633
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
RhsRowMajor	Eigen/src/Core/ProductEvaluators.h	/^    RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsScalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::generic_product_impl
RhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  typedef typename RhsMapper::Scalar RhsScalar;$/;"	t	class:Eigen::internal::TensorContractionBlocking
RhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename internal::remove_const<typename EvalRightArgType::Scalar>::type RhsScalar;$/;"	t	struct:Eigen::TensorEvaluator
RhsScalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename internal::remove_const<typename EvalRightArgType::Scalar>::type RhsScalar;$/;"	t	struct:Eigen::TensorEvaluator
RhsTraits	Eigen/src/Core/Product.h	/^  typedef traits<RhsCleaned> RhsTraits;$/;"	t	struct:Eigen::internal::traits
RhsUpLo	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  enum { RhsUpLo = RhsMode&(Upper|Lower)  };$/;"	e	enum:Eigen::internal::selfadjoint_product_impl::__anon621
RhsVecPacketSize	Eigen/src/Core/ProductEvaluators.h	/^    RhsVecPacketSize = unpacket_traits<RhsVecPacketType>::size,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
RhsVecPacketType	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename find_best_packet<Scalar,ColsAtCompileTime>::type RhsVecPacketType;$/;"	t	struct:Eigen::internal::product_evaluator
RhsVectors	Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon518
RightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef RightArgType_ RightArgType;$/;"	t	struct:Eigen::internal::traits
RightArgType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::traits<Derived>::RightArgType RightArgType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
RightColumn	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg, 1>                 RightColumn;$/;"	t	class:Eigen::internal::companion
RightDimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename RightEvaluator::Dimensions RightDimensions;$/;"	t	struct:Eigen::TensorEvaluator
RightEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;$/;"	t	struct:Eigen::TensorEvaluator
RightEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef TensorEvaluator<EvalRightArgType, Device> RightEvaluator;$/;"	t	struct:Eigen::TensorEvaluator
RightNumDims	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  static const int RightNumDims = internal::array_size<typename TensorEvaluator<RightArgType, Device>::Dimensions>::value;$/;"	m	struct:Eigen::TensorEvaluator
RightScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd& RightScaling()$/;"	f	class:Eigen::IterScaling
RootType	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef std::complex<RealScalar>            RootType;$/;"	t	class:Eigen::PolynomialSolverBase
RootsType	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef Matrix<RootType,_Deg,1>             RootsType;$/;"	t	class:Eigen::PolynomialSolverBase
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Rotation2D() {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC explicit Rotation2D(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC explicit inline Rotation2D(const Scalar& a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2Dd	Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
RotationBase	Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationMatrixType	Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RotationMode	demos/opengl/quaternion_demo.h	/^    enum RotationMode {$/;"	g	class:RenderingWidget
RotationStable	demos/opengl/quaternion_demo.h	/^      RotationStable,$/;"	e	enum:RenderingWidget::RotationMode
RotationStandard	demos/opengl/quaternion_demo.h	/^      RotationStandard$/;"	e	enum:RenderingWidget::RotationMode
Round	bench/tensors/benchmark_main.cc	/^static int Round(int n) {$/;"	f	file:
RoundReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_round_op<Scalar>, const Derived> RoundReturnType;$/;"	t
RowMajor	Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::StorageOptions
RowMajorBit	Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowMajorMatrixXf	doc/snippets/Tutorial_SlicingCol.cpp	/^typedef Matrix<float,Dynamic,Dynamic,RowMajor> RowMajorMatrixXf;$/;"	t	file:
RowMatrixXd	test/ref.cpp	/^typedef Matrix<double,Dynamic,Dynamic,RowMajor> RowMatrixXd;$/;"	t	file:
RowType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD
RowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RowVectorType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
RowVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
RowVectorType	Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR
RowVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RowXpr	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase
RowXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
Rows	Eigen/src/Core/GeneralProduct.h	/^    Rows    = traits<_Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon289
Rows	Eigen/src/Geometry/Homogeneous.h	/^    Rows = Lhs::RowsAtCompileTime$/;"	e	enum:Eigen::internal::homogeneous_right_product_refactoring_helper::__anon260
Rows	Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon265
Rows	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    Rows = size_at_compile_time<traits<Lhs>::RowsAtCompileTime, traits<Rhs>::RowsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon28
RowsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon242
RowsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon243
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon478
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon479
RowsAtCompileTime	Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon464
RowsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = PlainObjectType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon751
RowsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = XprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon762
RowsAtCompileTime	Eigen/src/Core/CoreEvaluators.h	/^    RowsAtCompileTime = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::evaluator::__anon761
RowsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon446
RowsAtCompileTime	Eigen/src/Core/CwiseTernaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon514
RowsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
RowsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == DynamicIndex || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon500
RowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon282
RowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon284
RowsAtCompileTime	Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon436
RowsAtCompileTime	Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon439
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = PermTraits::RowsAtCompileTime,$/;"	e	enum:Eigen::InverseImpl::__anon468
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon466
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon467
RowsAtCompileTime	Eigen/src/Core/Product.h	/^    RowsAtCompileTime    = LhsTraits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
RowsAtCompileTime	Eigen/src/Core/ProductEvaluators.h	/^    RowsAtCompileTime = LhsNestedCleaned::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_evaluator::__anon427
RowsAtCompileTime	Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon772
RowsAtCompileTime	Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon433
RowsAtCompileTime	Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
RowsAtCompileTime	Eigen/src/Core/SolverBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
RowsAtCompileTime	Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon443
RowsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
RowsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon637
RowsAtCompileTime	Eigen/src/Core/Visitor.h	/^    RowsAtCompileTime = XprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_evaluator::__anon643
RowsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon861
RowsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon862
RowsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon864
RowsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon860
RowsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon859
RowsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon855
RowsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon258
RowsAtCompileTime	Eigen/src/Geometry/Transform.h	/^    RowsAtCompileTime = _Mode==Projective ? Dim1 : _Dim,$/;"	e	enum:Eigen::internal::traits::__anon264
RowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon278
RowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon277
RowsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon212
RowsAtCompileTime	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::CompleteOrthogonalDecomposition::__anon210
RowsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon208
RowsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon206
RowsAtCompileTime	Eigen/src/SVD/BDCSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime, $/;"	e	enum:Eigen::BDCSVD::__anon777
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon784
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon780
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon781
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon782
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon783
RowsAtCompileTime	Eigen/src/SVD/SVDBase.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SVDBase::__anon786
RowsAtCompileTime	Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon785
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon836
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon837
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
RowsAtCompileTime	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      RowsAtCompileTime = internal::traits<SparseSelfAdjointView>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon834
RowsAtCompileTime	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      RowsAtCompileTime = internal::traits<SparseSymmetricPermutationProduct>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseSymmetricPermutationProduct::__anon835
RowsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon845
RowsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^      RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon774
RowsAtCompileTime	Eigen/src/SparseQR/SparseQR.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::SparseQRMatrixQReturnType::__anon776
RowsAtCompileTime	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    RowsAtCompileTime = size_at_compile_time<traits<Lhs>::RowsAtCompileTime, traits<Rhs>::RowsAtCompileTime>::ret,$/;"	e	enum:Eigen::internal::traits::__anon29
RowsAtCompileTime	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::MatrixPowerAtomic::__anon30
RowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon41
RowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
RowsAtCompileTime	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon40
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      RowsAtCompileTime = BlockSparseMatrixT::RowsAtCompileTime,$/;"	e	enum:Eigen::BlockSparseMatrixView::__anon73
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::BlockSparseMatrix::__anon77
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      RowsAtCompileTime = VectorType::RowsAtCompileTime,$/;"	e	enum:Eigen::BlockVectorReturn::__anon75
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^      RowsAtCompileTime = VectorType::RowsAtCompileTime,$/;"	e	enum:Eigen::BlockVectorView::__anon74
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon72
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon76
RowsAtCompileTime	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon63
RowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
RowsPlusOne	Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon258
RowwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase
RsqrtReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_rsqrt_op<Scalar>, const Derived> RsqrtReturnType;$/;"	t
Run	bench/tensors/benchmark_main.cc	/^void Benchmark::Run() {$/;"	f	class:testing::Benchmark
Run	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^    static void Run(const LhsMapper& lhs, const RhsMapper& rhs, const OutputMapper& output, Index m, Index n, Index k, const GpuDevice& device) {$/;"	f	struct:Eigen::TensorEvaluator::LaunchKernels
RunQueue	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  RunQueue() : front_(0), back_(0) {$/;"	f	class:Eigen::RunQueue
RunQueue	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^class RunQueue {$/;"	c	namespace:Eigen
RunRepeatedlyWithArg	bench/tensors/benchmark_main.cc	/^void Benchmark::RunRepeatedlyWithArg(int iterations, int arg) {$/;"	f	class:testing::Benchmark
RunWithArg	bench/tensors/benchmark_main.cc	/^void Benchmark::RunWithArg(int arg) {$/;"	f	class:testing::Benchmark
Running	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        Running = -1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Running	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Running = -1,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
Running	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Running = -1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RunningFullReduction	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool RunningFullReduction = (NumOutputDims==0);$/;"	m	struct:Eigen::TensorEvaluator
RunningOnGPU	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool RunningOnGPU = false;$/;"	m	struct:Eigen::TensorEvaluator
RunningOnGPU	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool RunningOnGPU = internal::is_same<Device, Eigen::GpuDevice>::value;$/;"	m	struct:Eigen::TensorEvaluator
RunningOnGPU	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^static const bool RunningOnGPU = false;$/;"	m	struct:Eigen::TensorEvaluator
RunningOnSycl	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool RunningOnSycl = false;$/;"	m	struct:Eigen::TensorEvaluator
RunningOnSycl	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^static const bool RunningOnSycl = internal::is_same<typename internal::remove_all<Device>::type, Eigen::SyclDevice>::value;$/;"	m	struct:Eigen::TensorEvaluator
SAME	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:CBLAT2
SAME	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:CBLAT3
SAME	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:DBLAT2
SAME	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:DBLAT3
SAME	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:SBLAT2
SAME	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:SBLAT3
SAME	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:ZBLAT2
SAME	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME,/;"	v	program:ZBLAT3
SAccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::AccPacket SAccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SBEG	blas/testing/sblat2.f	/^      REAL FUNCTION SBEG(/;"	f
SBEG	blas/testing/sblat3.f	/^      REAL FUNCTION SBEG(/;"	f
SBLAT1	blas/testing/sblat1.f	/^      PROGRAM SBLAT1$/;"	p
SBLAT2	blas/testing/sblat2.f	/^      PROGRAM SBLAT2$/;"	p
SBLAT3	blas/testing/sblat3.f	/^      PROGRAM SBLAT3$/;"	p
SCALAR	bench/BenchSparseUtil.h	19;"	d
SCALAR	bench/benchEigenSolver.cpp	28;"	d	file:
SCALAR	bench/bench_gemm.cpp	22;"	d	file:
SCALAR	bench/benchmark.cpp	19;"	d	file:
SCALAR	bench/benchmarkSlice.cpp	15;"	d	file:
SCALAR	bench/btl/libs/BLAS/blas_interface.hh	67;"	d
SCALAR	bench/btl/libs/BLAS/blas_interface.hh	70;"	d
SCALAR	bench/btl/libs/BLAS/blas_interface.hh	74;"	d
SCALAR	bench/btl/libs/BLAS/blas_interface.hh	77;"	d
SCALAR	bench/geometry.cpp	10;"	d	file:
SCALAR	bench/spmv.cpp	4;"	d	file:
SCALAR	bench/vdw_new.cpp	7;"	d	file:
SCALAR	blas/complex_double.cpp	10;"	d	file:
SCALAR	blas/complex_single.cpp	10;"	d	file:
SCALAR	blas/double.cpp	11;"	d	file:
SCALAR	blas/single.cpp	10;"	d	file:
SCALAR	failtest/bdcsvd_int.cpp	4;"	d	file:
SCALAR	failtest/bdcsvd_int.cpp	6;"	d	file:
SCALAR	failtest/colpivqr_int.cpp	4;"	d	file:
SCALAR	failtest/colpivqr_int.cpp	6;"	d	file:
SCALAR	failtest/eigensolver_cplx.cpp	4;"	d	file:
SCALAR	failtest/eigensolver_cplx.cpp	6;"	d	file:
SCALAR	failtest/eigensolver_int.cpp	4;"	d	file:
SCALAR	failtest/eigensolver_int.cpp	6;"	d	file:
SCALAR	failtest/fullpivlu_int.cpp	4;"	d	file:
SCALAR	failtest/fullpivlu_int.cpp	6;"	d	file:
SCALAR	failtest/fullpivqr_int.cpp	4;"	d	file:
SCALAR	failtest/fullpivqr_int.cpp	6;"	d	file:
SCALAR	failtest/jacobisvd_int.cpp	4;"	d	file:
SCALAR	failtest/jacobisvd_int.cpp	6;"	d	file:
SCALAR	failtest/ldlt_int.cpp	4;"	d	file:
SCALAR	failtest/ldlt_int.cpp	6;"	d	file:
SCALAR	failtest/llt_int.cpp	4;"	d	file:
SCALAR	failtest/llt_int.cpp	6;"	d	file:
SCALAR	failtest/partialpivlu_int.cpp	4;"	d	file:
SCALAR	failtest/partialpivlu_int.cpp	6;"	d	file:
SCALAR	failtest/qr_int.cpp	4;"	d	file:
SCALAR	failtest/qr_int.cpp	6;"	d	file:
SCALAR	lapack/complex_double.cpp	10;"	d	file:
SCALAR	lapack/complex_single.cpp	10;"	d	file:
SCALAR	lapack/double.cpp	10;"	d	file:
SCALAR	lapack/single.cpp	10;"	d	file:
SCALARA	bench/bench_gemm.cpp	26;"	d	file:
SCALARB	bench/bench_gemm.cpp	30;"	d	file:
SCALAR_PREFIX	bench/btl/libs/BLAS/blas_interface.hh	68;"	d
SCALAR_PREFIX	bench/btl/libs/BLAS/blas_interface.hh	71;"	d
SCALAR_PREFIX	bench/btl/libs/BLAS/blas_interface.hh	75;"	d
SCALAR_PREFIX	bench/btl/libs/BLAS/blas_interface.hh	78;"	d
SCALAR_SUFFIX	blas/complex_double.cpp	11;"	d	file:
SCALAR_SUFFIX	blas/complex_single.cpp	11;"	d	file:
SCALAR_SUFFIX	blas/double.cpp	12;"	d	file:
SCALAR_SUFFIX	blas/single.cpp	11;"	d	file:
SCALAR_SUFFIX	lapack/complex_double.cpp	11;"	d	file:
SCALAR_SUFFIX	lapack/complex_single.cpp	11;"	d	file:
SCALAR_SUFFIX	lapack/double.cpp	11;"	d	file:
SCALAR_SUFFIX	lapack/single.cpp	11;"	d	file:
SCALAR_SUFFIX_UP	blas/complex_double.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	blas/complex_single.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	blas/double.cpp	13;"	d	file:
SCALAR_SUFFIX_UP	blas/single.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	lapack/complex_double.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	lapack/complex_single.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	lapack/double.cpp	12;"	d	file:
SCALAR_SUFFIX_UP	lapack/single.cpp	12;"	d	file:
SCHK1	blas/testing/sblat2.f	/^      SUBROUTINE SCHK1(/;"	s
SCHK1	blas/testing/sblat3.f	/^      SUBROUTINE SCHK1(/;"	s
SCHK2	blas/testing/sblat2.f	/^      SUBROUTINE SCHK2(/;"	s
SCHK2	blas/testing/sblat3.f	/^      SUBROUTINE SCHK2(/;"	s
SCHK3	blas/testing/sblat2.f	/^      SUBROUTINE SCHK3(/;"	s
SCHK3	blas/testing/sblat3.f	/^      SUBROUTINE SCHK3(/;"	s
SCHK4	blas/testing/sblat2.f	/^      SUBROUTINE SCHK4(/;"	s
SCHK4	blas/testing/sblat3.f	/^      SUBROUTINE SCHK4(/;"	s
SCHK5	blas/testing/sblat2.f	/^      SUBROUTINE SCHK5(/;"	s
SCHK5	blas/testing/sblat3.f	/^      SUBROUTINE SCHK5(/;"	s
SCHK6	blas/testing/sblat2.f	/^      SUBROUTINE SCHK6(/;"	s
SCHKE	blas/testing/sblat2.f	/^      SUBROUTINE SCHKE(/;"	s
SCHKE	blas/testing/sblat3.f	/^      SUBROUTINE SCHKE(/;"	s
SCMatrix	Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::MappedSuperNodalMatrix<Scalar, StorageIndex> SCMatrix;$/;"	t	class:Eigen::SparseLU
SCRUTE	bench/btl/generic_bench/utils/utilities.h	58;"	d
SCRUTE	bench/btl/generic_bench/utils/utilities.h	75;"	d
SDIFF	blas/testing/cblat1.f	/^      REAL             FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/cblat2.f	/^      REAL               SDIFF$/;"	v	program:CBLAT2
SDIFF	blas/testing/cblat2.f	/^      REAL FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/cblat3.f	/^      REAL               SDIFF$/;"	v	program:CBLAT3
SDIFF	blas/testing/cblat3.f	/^      REAL FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/dblat1.f	/^      DOUBLE PRECISION FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/sblat1.f	/^      REAL             FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/sblat2.f	/^      REAL               SDIFF$/;"	v	program:SBLAT2
SDIFF	blas/testing/sblat2.f	/^      REAL FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/sblat3.f	/^      REAL               SDIFF$/;"	v	program:SBLAT3
SDIFF	blas/testing/sblat3.f	/^      REAL FUNCTION SDIFF(/;"	f
SDIFF	blas/testing/zblat1.f	/^      DOUBLE PRECISION FUNCTION SDIFF(/;"	f
SDP_AsCwiseProduct	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  SDP_AsCwiseProduct$/;"	e	enum:Eigen::internal::__anon810
SDP_AsScalarProduct	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  SDP_AsScalarProduct,$/;"	e	enum:Eigen::internal::__anon810
SECOND	lapack/second_NONE.f	/^      REAL FUNCTION SECOND(/;"	f
SELECTEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	100;"	d
SELECTEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	108;"	d
SELECTOP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	125;"	d
SELECTOP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	143;"	d
SELECTOPCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	74;"	d
SELECTOPCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	80;"	d
SELFADJOINTVIEW_ACCEPTS_UPPER_AND_LOWER_MODE_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        SELFADJOINTVIEW_ACCEPTS_UPPER_AND_LOWER_MODE_ONLY=1$/;"	e	enum:Eigen::internal::static_assertion::__anon608
SFAC	blas/testing/cblat1.f	/^      REAL             SFAC$/;"	v	program:CBLAT1
SFAC	blas/testing/dblat1.f	/^      DOUBLE PRECISION SFAC$/;"	v	program:DBLAT1
SFAC	blas/testing/sblat1.f	/^      REAL             SFAC$/;"	v	program:SBLAT1
SFAC	blas/testing/zblat1.f	/^      DOUBLE PRECISION SFAC$/;"	v	program:ZBLAT1
SFATAL	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:CBLAT2
SFATAL	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:CBLAT3
SFATAL	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:DBLAT2
SFATAL	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:DBLAT3
SFATAL	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:SBLAT2
SFATAL	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:SBLAT3
SFATAL	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:ZBLAT2
SFATAL	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL,/;"	v	program:ZBLAT3
SGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline SGroup() : Base() { }$/;"	f	class:Eigen::SGroup
SGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline SGroup(SGroup<Gen...>&& other) : Base(other) { }$/;"	f	class:Eigen::SGroup
SGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline SGroup(const SGroup<Gen...>& other) : Base(other) { }$/;"	f	class:Eigen::SGroup
SGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^class SGroup : public internal::tensor_symmetry_pre_analysis<internal::tensor_symmetry_num_indices<Gen...>::value, Gen...>::root_type$/;"	c	namespace:Eigen
SIDE	blas/common.h	44;"	d
SIZE	bench/BenchSparseUtil.h	11;"	d
SIZE	bench/benchVecAdd.cpp	8;"	d	file:
SIZE	bench/geometry.cpp	14;"	d	file:
SIZE	bench/sparse_cholesky.cpp	12;"	d	file:
SIZE	bench/sparse_dense_product.cpp	7;"	d	file:
SIZE	bench/sparse_lu.cpp	12;"	d	file:
SIZE	bench/sparse_product.cpp	10;"	d	file:
SIZE	bench/sparse_randomsetter.cpp	11;"	d	file:
SIZE	bench/sparse_setter.cpp	7;"	d	file:
SIZE	bench/sparse_transpose.cpp	7;"	d	file:
SIZE	bench/sparse_trisolver.cpp	8;"	d	file:
SIZE	bench/vdw_new.cpp	11;"	d	file:
SIZE_LIN_LOG	bench/btl/generic_bench/utils/size_lin_log.hh	21;"	d
SIZE_LOG	bench/btl/generic_bench/utils/size_log.hh	21;"	d
SLADIV	lapack/sladiv.f	/^      SUBROUTINE SLADIV(/;"	s
SLAMC3	lapack/slamch.f	/^      REAL             FUNCTION SLAMC3(/;"	f
SLAMCH	lapack/slamch.f	/^      REAL             FUNCTION SLAMCH(/;"	f
SLAPY2	lapack/slapy2.f	/^      REAL             FUNCTION SLAPY2(/;"	f
SLAPY3	lapack/slapy3.f	/^      REAL             FUNCTION SLAPY3(/;"	f
SLARF	lapack/slarf.f	/^      SUBROUTINE SLARF(/;"	s
SLARFB	lapack/slarfb.f	/^      SUBROUTINE SLARFB(/;"	s
SLARFG	lapack/slarfg.f	/^      SUBROUTINE SLARFG(/;"	s
SLARFT	lapack/slarft.f	/^      SUBROUTINE SLARFT(/;"	s
SLhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::LhsPacket SLhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SMAKE	blas/testing/sblat2.f	/^      SUBROUTINE SMAKE(/;"	s
SMAKE	blas/testing/sblat3.f	/^      SUBROUTINE SMAKE(/;"	s
SMMCH	blas/testing/sblat3.f	/^      SUBROUTINE SMMCH(/;"	s
SMVCH	blas/testing/sblat2.f	/^      SUBROUTINE SMVCH(/;"	s
SNAMES	blas/testing/cblat2.f	/^      CHARACTER*6        SNAMES(/;"	v	program:CBLAT2
SNAMES	blas/testing/cblat3.f	/^      CHARACTER*6        SNAMES(/;"	v	program:CBLAT3
SNAMES	blas/testing/dblat2.f	/^      CHARACTER*6        SNAMES(/;"	v	program:DBLAT2
SNAMES	blas/testing/dblat3.f	/^      CHARACTER*6        SNAMES(/;"	v	program:DBLAT3
SNAMES	blas/testing/sblat2.f	/^      CHARACTER*6        SNAMES(/;"	v	program:SBLAT2
SNAMES	blas/testing/sblat3.f	/^      CHARACTER*6        SNAMES(/;"	v	program:SBLAT3
SNAMES	blas/testing/zblat2.f	/^      CHARACTER*6        SNAMES(/;"	v	program:ZBLAT2
SNAMES	blas/testing/zblat3.f	/^      CHARACTER*6        SNAMES(/;"	v	program:ZBLAT3
SNAMET	blas/testing/cblat2.f	/^      CHARACTER*6        SNAMET$/;"	v	program:CBLAT2
SNAMET	blas/testing/cblat3.f	/^      CHARACTER*6        SNAMET$/;"	v	program:CBLAT3
SNAMET	blas/testing/dblat2.f	/^      CHARACTER*6        SNAMET$/;"	v	program:DBLAT2
SNAMET	blas/testing/dblat3.f	/^      CHARACTER*6        SNAMET$/;"	v	program:DBLAT3
SNAMET	blas/testing/sblat2.f	/^      CHARACTER*6        SNAMET$/;"	v	program:SBLAT2
SNAMET	blas/testing/sblat3.f	/^      CHARACTER*6        SNAMET$/;"	v	program:SBLAT3
SNAMET	blas/testing/zblat2.f	/^      CHARACTER*6        SNAMET$/;"	v	program:ZBLAT2
SNAMET	blas/testing/zblat3.f	/^      CHARACTER*6        SNAMET$/;"	v	program:ZBLAT3
SNAPS	blas/testing/cblat2.f	/^      CHARACTER*32       SNAPS,/;"	v	program:CBLAT2
SNAPS	blas/testing/cblat3.f	/^      CHARACTER*32       SNAPS,/;"	v	program:CBLAT3
SNAPS	blas/testing/dblat2.f	/^      CHARACTER*32       SNAPS,/;"	v	program:DBLAT2
SNAPS	blas/testing/dblat3.f	/^      CHARACTER*32       SNAPS,/;"	v	program:DBLAT3
SNAPS	blas/testing/sblat2.f	/^      CHARACTER*32       SNAPS,/;"	v	program:SBLAT2
SNAPS	blas/testing/sblat3.f	/^      CHARACTER*32       SNAPS,/;"	v	program:SBLAT3
SNAPS	blas/testing/zblat2.f	/^      CHARACTER*32       SNAPS,/;"	v	program:ZBLAT2
SNAPS	blas/testing/zblat3.f	/^      CHARACTER*32       SNAPS,/;"	v	program:ZBLAT3
SPARSELU_COLUMN_BMOD_H	Eigen/src/SparseLU/SparseLU_column_bmod.h	32;"	d
SPARSELU_COLUMN_DFS_H	Eigen/src/SparseLU/SparseLU_column_dfs.h	31;"	d
SPARSELU_COPY_TO_UCOL_H	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	30;"	d
SPARSELU_HEAP_RELAX_SNODE_H	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	29;"	d
SPARSELU_IMPL_H	Eigen/src/SparseLU/SparseLUImpl.h	10;"	d
SPARSELU_KERNEL_BMOD_H	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	12;"	d
SPARSELU_PANEL_BMOD_H	Eigen/src/SparseLU/SparseLU_panel_bmod.h	32;"	d
SPARSELU_PANEL_DFS_H	Eigen/src/SparseLU/SparseLU_panel_dfs.h	31;"	d
SPARSELU_PIVOTL_H	Eigen/src/SparseLU/SparseLU_pivotL.h	31;"	d
SPARSELU_PRUNEL_H	Eigen/src/SparseLU/SparseLU_pruneL.h	31;"	d
SPARSELU_RELAX_SNODE_H	Eigen/src/SparseLU/SparseLU_relax_snode.h	29;"	d
SPARSE_COLETREE_H	Eigen/src/SparseCore/SparseColEtree.h	32;"	d
SPBENCHSTYLE_H	bench/spbench/spbenchstyle.h	11;"	d
SPD	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^  SPD = 0x100,$/;"	e	enum:Eigen::__anon66
SPMV_BENCH	bench/spmv.cpp	11;"	d	file:
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR() $/;"	f	class:Eigen::SPQR
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    explicit SPQR(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^class SPQR : public SparseSolverBase<SPQR<_MatrixType> >$/;"	c	namespace:Eigen
SPQRMatrixQReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQReturnType
SPQRMatrixQReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQReturnType{$/;"	s	namespace:Eigen
SPQRMatrixQTransposeReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
SPQRMatrixQTransposeReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQTransposeReturnType{$/;"	s	namespace:Eigen
SPQR_QProduct	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct(const SPQRType& spqr, const Derived& other, bool transpose) : m_spqr(spqr),m_other(other),m_transpose(transpose) {}$/;"	f	struct:Eigen::SPQR_QProduct
SPQR_QProduct	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQR_QProduct : ReturnByValue<SPQR_QProduct<SPQRType,Derived> >$/;"	s	namespace:Eigen
SPQR_free	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void SPQR_free()$/;"	f	class:Eigen::SPQR
SQR	unsupported/test/BVH.cpp	/^inline double SQR(double x) { return x * x; }$/;"	f
SQRT2DIV2	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	457;"	d
SRNAMC	blas/testing/cblat2.f	162;"	c	program:CBLAT2
SRNAMC	blas/testing/cblat2.f	3252;"	c	subroutine:XERBLA
SRNAMC	blas/testing/cblat3.f	141;"	c	program:CBLAT3
SRNAMC	blas/testing/cblat3.f	3465;"	c	subroutine:XERBLA
SRNAMC	blas/testing/dblat2.f	158;"	c	program:DBLAT2
SRNAMC	blas/testing/dblat2.f	3149;"	c	subroutine:XERBLA
SRNAMC	blas/testing/dblat3.f	135;"	c	program:DBLAT3
SRNAMC	blas/testing/dblat3.f	2846;"	c	subroutine:XERBLA
SRNAMC	blas/testing/sblat2.f	158;"	c	program:SBLAT2
SRNAMC	blas/testing/sblat2.f	3149;"	c	subroutine:XERBLA
SRNAMC	blas/testing/sblat3.f	135;"	c	program:SBLAT3
SRNAMC	blas/testing/sblat3.f	2846;"	c	subroutine:XERBLA
SRNAMC	blas/testing/zblat2.f	163;"	c	program:ZBLAT2
SRNAMC	blas/testing/zblat2.f	3260;"	c	subroutine:XERBLA
SRNAMC	blas/testing/zblat3.f	143;"	c	program:ZBLAT3
SRNAMC	blas/testing/zblat3.f	3475;"	c	subroutine:XERBLA
SRNAMT	blas/testing/cblat2.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:CBLAT2
SRNAMT	blas/testing/cblat3.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:CBLAT3
SRNAMT	blas/testing/dblat2.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:DBLAT2
SRNAMT	blas/testing/dblat3.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:DBLAT3
SRNAMT	blas/testing/sblat2.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:SBLAT2
SRNAMT	blas/testing/sblat3.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:SBLAT3
SRNAMT	blas/testing/zblat2.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:ZBLAT2
SRNAMT	blas/testing/zblat3.f	/^      CHARACTER*6        SRNAMT$/;"	v	program:ZBLAT3
SResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::ResPacket SResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::ResScalar SResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
SRhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename SwappedTraits::RhsPacket SRhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
SSE	Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
STEST	blas/testing/cblat1.f	/^      SUBROUTINE STEST(/;"	s
STEST	blas/testing/dblat1.f	/^      SUBROUTINE STEST(/;"	s
STEST	blas/testing/sblat1.f	/^      SUBROUTINE STEST(/;"	s
STEST	blas/testing/zblat1.f	/^      SUBROUTINE STEST(/;"	s
STEST1	blas/testing/cblat1.f	/^      SUBROUTINE STEST1(/;"	s
STEST1	blas/testing/dblat1.f	/^      SUBROUTINE STEST1(/;"	s
STEST1	blas/testing/sblat1.f	/^      SUBROUTINE STEST1(/;"	s
STEST1	blas/testing/zblat1.f	/^      SUBROUTINE STEST1(/;"	s
STL_INTERFACE_HH	bench/btl/libs/STL/STL_interface.hh	21;"	d
STL_Perf_Analyzer	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  STL_Perf_Analyzer( const STL_Perf_Analyzer & ){$/;"	f	class:STL_Perf_Analyzer
STL_Perf_Analyzer	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  STL_Perf_Analyzer(unsigned long long nb_sample=DEFAULT_NB_SAMPLE):_nb_sample(nb_sample),_chronos()$/;"	f	class:STL_Perf_Analyzer
STL_Perf_Analyzer	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^class STL_Perf_Analyzer{$/;"	c
STL_Timer	bench/btl/generic_bench/timers/STL_timer.hh	/^  STL_Timer(){ baseline = false; };  \/\/ Default constructor$/;"	f	class:STL_Timer
STL_Timer	bench/btl/generic_bench/timers/STL_timer.hh	/^class STL_Timer {$/;"	c
STL_interface	bench/btl/libs/STL/STL_interface.hh	/^class STL_interface{$/;"	c
STORAGE_INDEX_MUST_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_INDEX_MUST_MATCH=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
STORAGE_KIND_MUST_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_KIND_MUST_MATCH=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
STORAGE_LAYOUT_DOES_NOT_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_LAYOUT_DOES_NOT_MATCH=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
SUMMRY	blas/testing/cblat2.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:CBLAT2
SUMMRY	blas/testing/cblat3.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:CBLAT3
SUMMRY	blas/testing/dblat2.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:DBLAT2
SUMMRY	blas/testing/dblat3.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:DBLAT3
SUMMRY	blas/testing/sblat2.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:SBLAT2
SUMMRY	blas/testing/sblat3.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:SBLAT3
SUMMRY	blas/testing/zblat2.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:ZBLAT2
SUMMRY	blas/testing/zblat3.f	/^      CHARACTER*32       SNAPS, SUMMRY$/;"	v	program:ZBLAT3
SVA_Inner	Eigen/src/SparseCore/SparseVector.h	/^  SVA_Inner,$/;"	e	enum:Eigen::internal::__anon846
SVA_Outer	Eigen/src/SparseCore/SparseVector.h	/^  SVA_Outer$/;"	e	enum:Eigen::internal::__anon846
SVA_RuntimeSwitch	Eigen/src/SparseCore/SparseVector.h	/^  SVA_RuntimeSwitch,$/;"	e	enum:Eigen::internal::__anon846
SVD	Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
SVDBase	Eigen/src/SVD/SVDBase.h	/^  SVDBase()$/;"	f	class:Eigen::SVDBase
SVDBase	Eigen/src/SVD/SVDBase.h	/^class SVDBase$/;"	c	namespace:Eigen
SVD_DEFAULT	test/bdcsvd.cpp	23;"	d	file:
SVD_DEFAULT	test/jacobisvd.cpp	17;"	d	file:
SVD_DEFAULT	test/svd_common.h	477;"	d
SVD_FOR_MIN_NORM	test/bdcsvd.cpp	24;"	d	file:
SVD_FOR_MIN_NORM	test/jacobisvd.cpp	18;"	d	file:
SVD_FOR_MIN_NORM	test/svd_common.h	478;"	d
SYCLREDUCTION	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	161;"	d
SYCLREDUCTION	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	168;"	d
SYCLREDUCTIONEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	210;"	d
SYCLREDUCTIONEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	225;"	d
SameType	Eigen/src/Core/CoreEvaluators.h	/^    SameType = is_same<typename Arg1::Scalar,typename Arg2::Scalar>::value && is_same<typename Arg1::Scalar,typename Arg3::Scalar>::value,$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
SameType	Eigen/src/Core/CoreEvaluators.h	/^    SameType = is_same<typename Lhs::Scalar,typename Rhs::Scalar>::value,$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
SameType	Eigen/src/Core/ProductEvaluators.h	/^    SameType = is_same<typename LhsNestedCleaned::Scalar,typename RhsNestedCleaned::Scalar>::value,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
Scalar	Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT
Scalar	Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT
Scalar	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase
Scalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase
Scalar	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename DstEvaluatorType::Scalar Scalar;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase
Scalar	Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename ArgType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator_wrapper_base
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::block_evaluator
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::mapbase_evaluator
Scalar	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	Eigen/src/Core/CoreIterators.h	/^  typedef typename internal::traits<XprType>::Scalar Scalar;$/;"	t	class:Eigen::InnerIterator
Scalar	Eigen/src/Core/CoreIterators.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	class:Eigen::internal::inner_iterator_selector
Scalar	Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CwiseTernaryOp.h	/^      const typename Arg3::Scalar&)>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase
Scalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Inverse.h	/^  typedef typename XprType::Scalar                            Scalar;$/;"	t	class:Eigen::Inverse
Scalar	Eigen/src/Core/Inverse.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::InverseImpl
Scalar	Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/MatrixBase.h	/^      typedef typename ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
Scalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase
Scalar	Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias
Scalar	Eigen/src/Core/PermutationMatrix.h	/^    typedef void Scalar;$/;"	t	class:Eigen::PermutationBase
Scalar	Eigen/src/Core/PermutationMatrix.h	/^  typedef void Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase
Scalar	Eigen/src/Core/Product.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::dense_product_base
Scalar	Eigen/src/Core/Product.h	/^  typedef typename ScalarBinaryOpTraits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/ProductEvaluators.h	/^   typedef typename ScalarBinaryOpTraits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::diagonal_product_evaluator_base
Scalar	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	struct:Eigen::internal::product_evaluator
Scalar	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl_base
Scalar	Eigen/src/Core/ProductEvaluators.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::product_evaluator
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::redux_evaluator
Scalar	Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView
Scalar	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Scalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Scalar	Eigen/src/Core/SolverBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SolverBase
Scalar	Eigen/src/Core/Swap.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
Scalar	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase
Scalar	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView
Scalar	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularViewType>::Scalar Scalar;$/;"	t	class:Eigen::TriangularViewImpl
Scalar	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
Scalar	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Kernel::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_loop
Scalar	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp
Scalar	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar; $/;"	t	struct:Eigen::internal::max_coeff_visitor
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::visitor_evaluator
Scalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits
Scalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
Scalar	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::selfadjoint_product_impl
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver
Scalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur
Scalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver
Scalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
Scalar	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition
Scalar	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealQZ
Scalar	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur
Scalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Scalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Scalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization
Scalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Scalar	Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Scalar	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase
Scalar	Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling
Scalar	Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence
Scalar	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner
Scalar	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::LeastSquareDiagonalPreconditioner
Scalar	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB
Scalar	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient
Scalar	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT
Scalar	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase
Scalar	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LeastSquaresConjugateGradient
Scalar	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef typename internal::traits<SolveWithGuess>::Scalar Scalar;$/;"	t	class:Eigen::SolveWithGuess
Scalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase
Scalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits
Scalar	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR
Scalar	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
Scalar	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR
Scalar	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR
Scalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SPQR
Scalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Scalar Scalar;$/;"	t	struct:Eigen::SPQR_QProduct
Scalar	Eigen/src/SVD/BDCSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BDCSVD
Scalar	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD
Scalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Scalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Scalar	Eigen/src/SVD/SVDBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVDBase
Scalar	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector
Scalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
Scalar	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage
Scalar	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MappedSparseMatrix
Scalar	Eigen/src/SparseCore/SparseAssign.h	/^  typedef typename DstXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::Assignment
Scalar	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	Eigen/src/SparseCore/SparseCompressedBase.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::binary_evaluator
Scalar	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
Scalar	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Scalar	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename ProdXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_dense_outer_product_evaluator
Scalar	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Product<Lhs,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl
Scalar	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename SparseXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
Scalar	Eigen/src/SparseCore/SparseMap.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SparseMapBase
Scalar	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase
Scalar	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permutation_matrix_product
Scalar	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView
Scalar	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Scalar	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::SparseTransposeImpl
Scalar	Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseView.h	/^        typedef typename XprType::Scalar Scalar;$/;"	t	class:Eigen::internal::unary_evaluator::InnerIterator
Scalar	Eigen/src/SparseCore/SparseView.h	/^    typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::unary_evaluator
Scalar	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
Scalar	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Scalar	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Scalar Scalar; $/;"	t	class:Eigen::SparseLU
Scalar	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType
Scalar	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType
Scalar	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Scalar Scalar; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
Scalar	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename ScalarVector::Scalar Scalar;$/;"	t	struct:Eigen::internal::column_dfs_traits
Scalar	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseQR
Scalar	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename DstXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::Assignment
Scalar	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
Scalar	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQR_QProduct
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase
Scalar	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU
Scalar	bench/BenchSparseUtil.h	/^typedef SCALAR Scalar;$/;"	t
Scalar	bench/benchBlasGemm.cpp	/^typedef double Scalar;$/;"	t	file:
Scalar	bench/benchBlasGemm.cpp	/^typedef float Scalar;$/;"	t	file:
Scalar	bench/benchCholesky.cpp	/^typedef float Scalar;$/;"	t	file:
Scalar	bench/benchEigenSolver.cpp	/^typedef SCALAR Scalar;$/;"	t	file:
Scalar	bench/benchVecAdd.cpp	/^typedef float Scalar;$/;"	t	file:
Scalar	bench/bench_gemm.cpp	/^typedef SCALAR Scalar;$/;"	t	file:
Scalar	bench/bench_reverse.cpp	/^typedef double Scalar;$/;"	t	file:
Scalar	bench/benchmark-blocking-sizes.cpp	/^typedef MatrixType::Scalar Scalar;$/;"	t	file:
Scalar	bench/geometry.cpp	/^  typedef typename T::Scalar Scalar;$/;"	t	struct:ToRotationMatrixWrapper	file:
Scalar	bench/geometry.cpp	/^typedef SCALAR Scalar;$/;"	t	file:
Scalar	bench/perf_monitoring/gemm/gemm.cpp	/^typedef SCALAR Scalar;$/;"	t	file:
Scalar	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^typedef SCALAR Scalar;$/;"	t	file:
Scalar	blas/common.h	/^typedef SCALAR Scalar;$/;"	t
Scalar	demos/opengl/quaternion_demo.cpp	/^  typedef _Scalar Scalar;$/;"	t	class:EulerAngles	file:
Scalar	doc/examples/matrixfree_cg.cpp	/^    typedef typename Product<MatrixReplacement,Rhs>::Scalar Scalar;$/;"	t	struct:Eigen::internal::generic_product_impl	file:
Scalar	doc/examples/matrixfree_cg.cpp	/^  typedef double Scalar;$/;"	t	class:MatrixReplacement	file:
Scalar	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef Scalar_ Scalar;$/;"	t	class:Eigen::Tensor
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef Index Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef Tuple<Index, typename XprTraits::Scalar> Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorIndexTupleOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorTupleReducerOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename Eigen::internal::traits<TensorAssignOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorAssignOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename LhsXprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef typename DerivedTraits::Scalar Scalar;$/;"	t	class:Eigen::TensorBase
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorBroadcastingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename Eigen::internal::traits<TensorChippingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorChippingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^                                        typename RhsXprType::Scalar>::ret Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typedef typename internal::traits<TensorConcatenationOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorConcatenationOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^                               typename remove_const<typename RhsXprType::Scalar>::type>::ResScalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename Eigen::internal::traits<TensorContractionOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorContractionOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef Scalar_ Scalar;$/;"	t	class:Eigen::internal::TensorContractionInputMapper
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef typename Tensor::Scalar Scalar;$/;"	t	struct:Eigen::internal::CoeffLoader
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef typename internal::traits<TensorConversionOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorConversionOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef TargetType Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef TargetType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^                                        typename KernelXprType::Scalar>::ret Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename Eigen::internal::traits<TensorConvolutionOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorConvolutionOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename InputArgType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^                                                  typename RhsXprType::Scalar>::ret Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::remove_const<typename ArgType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomBinaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCustomBinaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomUnaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCustomUnaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename ArgType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename Eigen::internal::traits<TensorEvalToOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorEvalToOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^                typename Arg3XprType::Scalar)>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^               typename RhsXprType::Scalar)>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCwiseBinaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCwiseNullaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCwiseTernaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorCwiseUnaryOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorSelectOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorSelectOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename result_of<UnaryOp(typename XprType::Scalar)>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename traits<ThenXprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::internal::traits<TensorFFTOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorFFTOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef Scalar_ Scalar;$/;"	t	class:Eigen::TensorFixedSize
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename ArgType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorForcedEvalOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename Eigen::internal::traits<TensorGeneratorOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorGeneratorOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename Eigen::internal::traits<TensorImagePatchOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorImagePatchOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename Eigen::internal::traits<TensorInflationOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorInflationOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorLayoutSwapOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename internal::traits<PlainObjectType>::Scalar Scalar;$/;"	t	class:Eigen::TensorMap
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorReshapingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorReshapingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorSlicingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorSlicingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::traits<TensorStridingSlicingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorStridingSlicingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename Eigen::internal::traits<TensorPaddingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorPaddingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename Eigen::internal::traits<TensorPatchOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorPatchOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename Eigen::internal::traits<TensorReductionOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorReductionOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprTraits::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename internal::traits<PlainObjectType>::Scalar Scalar;$/;"	t	class:Eigen::TensorRef
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::TensorLazyEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::internal::TensorLazyEvaluatorWritable
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  typedef typename TensorEvaluator<Expr, Device>::Scalar Scalar;$/;"	t	class:Eigen::internal::TensorLazyEvaluatorReadOnly
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename Eigen::internal::traits<TensorReverseOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorReverseOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename Eigen::internal::traits<TensorScanOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorScanOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename Eigen::internal::traits<TensorShufflingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorShufflingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename Eigen::internal::traits<TensorStridingOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorStridingOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef Scalar_ Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef typename BaseTraits::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::Scalar Scalar;$/;"	t	class:Eigen::TensorVolumePatchOp
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::TensorEvaluator
Scalar	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename internal::remove_const<typename XprType::Scalar>::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    typedef typename Tensor_::Scalar Scalar;$/;"	t	class:Eigen::internal::tensor_symmetry_value_setter
Scalar	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  typedef typename Tensor_::Scalar Scalar;$/;"	t	struct:Eigen::internal::tensor_symmetry_assign_value
Scalar	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename ValueType::Scalar Scalar;$/;"	t	class:Eigen::AutoDiffJacobian
Scalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename internal::traits<DerType>::Scalar Scalar;$/;"	t	class:Eigen::AutoDiffScalar
Scalar	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename traits<DerType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::auto_diff_special_op
Scalar	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef ActiveScalar Scalar;$/;"	t	class:Eigen::AutoDiffVector
Scalar	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  typedef typename Minimizer::Scalar Scalar;$/;"	t	struct:Eigen::internal::minimizer_helper1
Scalar	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  typedef typename Minimizer::Scalar Scalar;$/;"	t	struct:Eigen::internal::minimizer_helper2
Scalar	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::KdBVH
Scalar	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
Scalar	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef _Scalar Scalar;$/;"	t	class:Eigen::EulerAngles
Scalar	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::fftw_impl
Scalar	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::kiss_cpx_fft
Scalar	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::kissfft_impl
Scalar	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::DGMRES
Scalar	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GMRES
Scalar	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLU
Scalar	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MINRES
Scalar	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterScaling
Scalar	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::KroneckerProductBase
Scalar	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef typename ScalarBinaryOpTraits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    typedef typename JacobianType::Scalar Scalar;$/;"	t	class:Eigen::LevenbergMarquardt
Scalar	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::DenseFunctor
Scalar	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::SparseFunctor
Scalar	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::MatrixFunctionReturnValue
Scalar	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::MatrixFunctionAtomic
Scalar	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::MatrixLogarithmReturnValue
Scalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixPower
Scalar	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixPowerAtomic
Scalar	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::Scalar Scalar;$/;"	t	class:Eigen::NumericalDiff
Scalar	unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef _Scalar                                Scalar;$/;"	t	class:Eigen::internal::companion
Scalar	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef _Scalar                             Scalar;$/;"	t	class:Eigen::PolynomialSolverBase
Scalar	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SkylineInplaceLU
Scalar	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SkylineMatrixBase
Scalar	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::skyline_product_selector
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Ref<Matrix<typename VectorType::Scalar, RowsAtCompileTime, ColsAtCompileTime> > Scalar;$/;"	t	class:Eigen::BlockVectorReturn
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Ref<const Matrix<typename BlockSparseMatrixT::Scalar, (RowsAtCompileTime==1)? 1 : BlockSize, (ColsAtCompileTime==1)? 1 : BlockSize> >Scalar;$/;"	t	class:Eigen::BlockVectorView
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef Ref<typename BlockSparseMatrixT::BlockScalar> Scalar;$/;"	t	class:Eigen::BlockSparseMatrixView
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::BlockSparseMatrix
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef Ref<Matrix<typename BlockSparseMatrixT::Scalar, BlockSparseMatrixT::BlockSize, BlockSparseMatrixT::BlockSize> > Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef typename BlockSparseMatrixT::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::evaluator
Scalar	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename SparseMatrixType::Scalar Scalar;$/;"	t	class:Eigen::RandomSetter
Scalar	unsupported/Eigen/src/Splines/Spline.h	/^    typedef _Scalar Scalar; \/*!< The spline curve's scalar type. *\/$/;"	t	class:Eigen::Spline
Scalar	unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef _Scalar Scalar; \/*!< The spline curve's scalar type. *\/$/;"	t	struct:Eigen::SplineTraits
Scalar	unsupported/doc/examples/BVH_Example.cpp	/^  typedef double Scalar;$/;"	t	struct:PointPointMinimizer	file:
Scalar	unsupported/test/BVH.cpp	/^  typedef double Scalar;$/;"	t	struct:BallPointStuff	file:
Scalar	unsupported/test/NonLinearOptimization.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:Functor	file:
Scalar	unsupported/test/NumericalDiff.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:Functor	file:
Scalar	unsupported/test/autodiff.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:TestFunc1	file:
Scalar	unsupported/test/forward_adolc.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:TestFunc1	file:
ScalarBinaryOpTraits	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct ScalarBinaryOpTraits<AutoDiffScalar<DerType>,typename DerType::Scalar,BinOp>$/;"	s	namespace:Eigen
ScalarBinaryOpTraits	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct ScalarBinaryOpTraits<typename DerType::Scalar,AutoDiffScalar<DerType>, BinOp>$/;"	s	namespace:Eigen
ScalarIsComplex	Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::PardisoImpl::__anon787
ScalarMatrix	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> ScalarMatrix;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarNonConst	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::remove_const<Scalar>::type ScalarNonConst;$/;"	t	struct:Eigen::TensorEvaluator
ScalarPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits
ScalarPointer	Eigen/src/SparseCore/SparseMap.h	/^                         Scalar *, const Scalar *>::type ScalarPointer;$/;"	t	class:Eigen::SparseMapBase
ScalarTraits	Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox
ScalarTypeMatch	Eigen/src/Core/Ref.h	/^      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::match::__anon474
ScalarVector	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef typename Base::ScalarVector ScalarVector;$/;"	t	class:Eigen::SparseMatrix
ScalarVector	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseMatrixBase
ScalarVector	Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseLU
ScalarVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarVector	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
ScalarVector	Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<Scalar, Dynamic, 1> ScalarVector;$/;"	t	class:Eigen::SparseQR
ScalarWithConstIfNotLvalue	Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper
ScalarWithConstIfNotLvalue	Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper
ScalarWithConstIfNotLvalue	Eigen/src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal
ScalarWithConstIfNotLvalue	Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase
ScalarWithConstIfNotLvalue	Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl
ScalarWithExceptions	test/exceptions.cpp	/^    ScalarWithExceptions() { init(); }$/;"	f	class:ScalarWithExceptions
ScalarWithExceptions	test/exceptions.cpp	/^    ScalarWithExceptions(const ScalarWithExceptions& other) { init(); *v = *(other.v); }$/;"	f	class:ScalarWithExceptions
ScalarWithExceptions	test/exceptions.cpp	/^    ScalarWithExceptions(const float& _v) { init(); *v = _v; }$/;"	f	class:ScalarWithExceptions
ScalarWithExceptions	test/exceptions.cpp	/^class ScalarWithExceptions$/;"	c	file:
ScalarWrapper	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      ScalarWrapper() : value(0) {}$/;"	f	struct:Eigen::RandomSetter::ScalarWrapper
ScalarWrapper	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    struct ScalarWrapper$/;"	s	class:Eigen::RandomSetter
Scaling	Eigen/src/Geometry/Scaling.h	/^inline DiagonalMatrix<Scalar,2> Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^inline DiagonalMatrix<Scalar,3> Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen
ScanKernel	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^__global__ void ScanKernel(Self self, Index total_size, typename Self::CoeffReturnType* data) {$/;"	f	namespace:Eigen
ScanLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct ScanLauncher {$/;"	s	namespace:Eigen
ScanLauncher	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct ScanLauncher<Self, Reducer, GpuDevice> {$/;"	s	namespace:Eigen
Schedule	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  void Schedule(std::function<void()> fn) {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
Score_is_abs	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef void Score_is_abs;$/;"	t	struct:Eigen::internal::scalar_score_coeff_op
SegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^typedef VectorBlock<Derived> SegmentReturnType;$/;"	t
Select	Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& a_conditionMatrix,$/;"	f	class:Eigen::Select
Select	Eigen/src/Core/Select.h	/^class Select : public internal::dense_xpr_base< Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >::type,$/;"	c	namespace:Eigen
SelectSolvers	bench/spbench/spbenchsolver.h	/^void SelectSolvers(const SparseMatrix<Scalar>&A, unsigned int sym, Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)$/;"	f
Selector	Eigen/src/Core/GenericPacketMath.h	/^template <size_t N> struct Selector {$/;"	s	namespace:Eigen::internal
Self	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef Tensor<Scalar_, NumIndices_, Options_, IndexType_> Self;$/;"	t	class:Eigen::Tensor
Self	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef TensorContractionSubMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> Self;$/;"	t	class:Eigen::internal::TensorContractionSubMapper
Self	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> Self;$/;"	t	class:Eigen::TensorFixedSize
Self	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^                          Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef TensorMap<PlainObjectType, Options_, MakePointer_> Self;$/;"	t	class:Eigen::TensorMap
Self	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef TensorRef<PlainObjectType> Self;$/;"	t	class:Eigen::TensorRef
Self	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> Self;$/;"	t	struct:Eigen::TensorEvaluator
Self	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    typedef TensorStorage<T, DSizes<IndexType, NumIndices_>, Options_> Self;$/;"	t	class:Eigen::TensorStorage
SelfAdjoint	Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::UpLoType
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    explicit SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjointShape	Eigen/src/Core/util/Constants.h	/^struct SelfAdjointShape       { static std::string debugName() { return "SelfAdjointShape"; } };$/;"	s	namespace:Eigen
SelfAdjointView	Eigen/src/Core/SelfAdjointView.h	/^    explicit inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView
SelfAdjointView	Eigen/src/Core/SelfAdjointView.h	/^template<typename _MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen
SelfAdjointViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
SelfAdjointViewReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SparseSelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::SparseMatrixBase
Sequential	Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
Sequential_t	Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
SetAction	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
SetBenchmarkFlopsProcessed	bench/tensors/benchmark_main.cc	/^void SetBenchmarkFlopsProcessed(int64_t x) {$/;"	f
SetDiag	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon618
SetDiag	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon619
SetterRowMajor	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      SetterRowMajor = SwapStorage ? 1-TargetRowMajor : TargetRowMajor$/;"	e	enum:Eigen::RandomSetter::__anon71
Shape	Eigen/src/Core/BandMatrix.h	/^  typedef BandShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/Core/CoreEvaluators.h	/^  typedef typename storage_kind_to_shape<typename traits<T>::StorageKind>::Shape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits_base
Shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<Dense>                  { typedef DenseShape Shape;           };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<PermutationStorage>     { typedef PermutationShape Shape;     };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<SolverStorage>          { typedef SolverShape Shape;           };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<TranspositionsStorage>  { typedef TranspositionsShape Shape;  };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/Core/DiagonalMatrix.h	/^template<> struct storage_kind_to_shape<DiagonalShape> { typedef DiagonalShape Shape; };$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/Core/SelfAdjointView.h	/^  typedef SelfAdjointShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename glue_shapes<typename evaluator_traits<MatrixType>::Shape, TriangularShape>::type Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/Geometry/Homogeneous.h	/^  typedef HomogeneousShape Shape;  $/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequenceShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/SparseCore/SparseAssign.h	/^  typedef SparseShape Shape;$/;"	t	struct:Eigen::internal::storage_kind_to_shape
Shape	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef SparseSelfAdjointShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
Shape	Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseShape Shape;$/;"	t	struct:Eigen::internal::evaluator_traits
ShardByCol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  ShardByCol = 1$/;"	e	enum:Eigen::internal::__anon149
ShardByRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  ShardByRow = 0,$/;"	e	enum:Eigen::internal::__anon149
ShouldRun	bench/tensors/benchmark_main.cc	/^bool Benchmark::ShouldRun(int argc, char* argv[]) {$/;"	f	class:testing::Benchmark
Side	Eigen/src/Core/ProductEvaluators.h	/^  enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::internal::generic_product_impl::__anon426
SideType	Eigen/src/Core/util/Constants.h	/^enum SideType {$/;"	g	namespace:Eigen
SignMatrix	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	g	namespace:Eigen::internal
SignReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> SignReturnType;$/;"	t
SimpleTensorContractionMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  SimpleTensorContractionMapper(const Tensor& tensor,$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
SimpleTensorContractionMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^class SimpleTensorContractionMapper {$/;"	c	namespace:Eigen::internal
SimpleThreadPool	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^typedef SimpleThreadPoolTempl<StlThreadEnvironment> SimpleThreadPool;$/;"	t	namespace:Eigen
SimpleThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  explicit SimpleThreadPoolTempl(int num_threads, Environment env = Environment())$/;"	f	class:Eigen::SimpleThreadPoolTempl
SimpleThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^class SimpleThreadPoolTempl : public ThreadPoolInterface {$/;"	c	namespace:Eigen
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
SimplicialCholeskyLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    explicit SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
SinReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sin_op<Scalar>, const Derived> SinReturnType;$/;"	t
SingletonVector	Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector
SingletonVector	Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix
SingularValuesType	Eigen/src/SVD/BDCSVD.h	/^  typedef typename Base::SingularValuesType SingularValuesType;$/;"	t	class:Eigen::BDCSVD
SingularValuesType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename Base::SingularValuesType SingularValuesType;$/;"	t	class:Eigen::JacobiSVD
SingularValuesType	Eigen/src/SVD/SVDBase.h	/^  typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::SVDBase
SinhReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sinh_op<Scalar>, const Derived> SinhReturnType;$/;"	t
Size	Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon491
Size	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon858
Size	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon863
Size	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon857
Size	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  static const std::size_t Size = FixedDimensions::total_size;$/;"	m	class:Eigen::TensorStorage
Size	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  unsigned Size() const {$/;"	f	class:Eigen::RunQueue
SizeA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon615
SizeAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon476
SizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon285
SizeAtCompileTime	Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon436
SizeAtCompileTime	Eigen/src/Core/Redux.h	/^    SizeAtCompileTime = XprType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_evaluator::__anon492
SizeAtCompileTime	Eigen/src/Core/SolverBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SolverBase::__anon493
SizeAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon452
SizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
SizeAtCompileTime	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon44
SizeB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon615
SizeMinusOne	Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon470
SizeMinusOne	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon858
SizeMinusOne	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon857
Sizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC Sizes() { }$/;"	f	struct:Eigen::Sizes
Sizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  explicit EIGEN_DEVICE_FUNC Sizes(const array<DenseIndex, Base::count>& \/*indices*\/) {$/;"	f	struct:Eigen::Sizes
Sizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  explicit EIGEN_DEVICE_FUNC Sizes(std::initializer_list<std::ptrdiff_t> \/*l*\/) {$/;"	f	struct:Eigen::Sizes
Sizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  template <typename... DenseIndex> EIGEN_DEVICE_FUNC Sizes(DenseIndex...) { }$/;"	f	struct:Eigen::Sizes
Sizes	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct Sizes : internal::numeric_list<std::ptrdiff_t, Indices...> {$/;"	s	namespace:Eigen
SkipDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::TriangularViewImpl::__anon824
SkipDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^         SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon825
SkipFirst	Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::TriangularViewImpl::__anon824
SkipFirst	Eigen/src/SparseCore/SparseTriangularView.h	/^  enum { SkipFirst = ((Mode&Lower) && !(ArgType::Flags&RowMajorBit))$/;"	e	enum:Eigen::internal::unary_evaluator::__anon825
SkipLast	Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::TriangularViewImpl::__anon824
SkipLast	Eigen/src/SparseCore/SparseTriangularView.h	/^         SkipLast = !SkipFirst,$/;"	e	enum:Eigen::internal::unary_evaluator::__anon825
SkylineBit	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^const unsigned int SkylineBit = 0x1200;$/;"	m	namespace:Eigen
SkylineInplaceLU	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    SkylineInplaceLU(MatrixType& matrix, int flags = 0)$/;"	f	class:Eigen::SkylineInplaceLU
SkylineInplaceLU	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^class SkylineInplaceLU {$/;"	c	namespace:Eigen
SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix()$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(const SkylineMatrix & other)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(const SkylineMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(size_t rows, size_t cols)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix$/;"	c	namespace:Eigen
SkylineMatrixBase	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    SkylineMatrixBase() : m_isRValue(false) {$/;"	f	class:Eigen::SkylineMatrixBase
SkylineMatrixBase	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^template<typename Derived> class SkylineMatrixBase : public EigenBase<Derived> {$/;"	c	namespace:Eigen
SkylineProduct	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE SkylineProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::internal::SkylineProduct
SkylineProduct	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^class SkylineProduct : no_assignment_operator,$/;"	c	namespace:Eigen::internal
SkylineProductReturnType	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct SkylineProductReturnType {$/;"	s	namespace:Eigen
SkylineStorage	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage()$/;"	f	class:Eigen::SkylineStorage
SkylineStorage	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage(const SkylineStorage& other)$/;"	f	class:Eigen::SkylineStorage
SkylineStorage	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^class SkylineStorage {$/;"	c	namespace:Eigen
SkylineTimeDenseProduct	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
SkylineTimeSkylineProduct	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
SliceVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen
SluMatrixMapHelper	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon287
SmallPanelWidth	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon618
SmallPanelWidth	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon619
Solve	Eigen/src/Core/Solve.h	/^  Solve(const Decomposition &dec, const RhsType &rhs)$/;"	f	class:Eigen::Solve
Solve	Eigen/src/Core/Solve.h	/^class Solve : public SolveImpl<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>$/;"	c	namespace:Eigen
SolveImpl	Eigen/src/Core/Solve.h	/^class SolveImpl : public internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type$/;"	c	namespace:Eigen
SolveImpl	Eigen/src/Core/Solve.h	/^class SolveImpl<Decomposition,RhsType,Dense>$/;"	c	namespace:Eigen
SolveType	Eigen/src/Core/Solve.h	/^  typedef Solve<Decomposition,RhsType> SolveType;$/;"	t	struct:Eigen::internal::evaluator
SolveType	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef SolveWithGuess<Decomposition,RhsType,GuessType> SolveType;$/;"	t	struct:Eigen::internal::evaluator
SolveWithGuess	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  SolveWithGuess(const Decomposition &dec, const RhsType &rhs, const GuessType &guess)$/;"	f	class:Eigen::SolveWithGuess
SolveWithGuess	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^class SolveWithGuess : public internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type$/;"	c	namespace:Eigen
SolverBase	Eigen/src/Core/SolverBase.h	/^    SolverBase()$/;"	f	class:Eigen::SolverBase
SolverBase	Eigen/src/Core/SolverBase.h	/^class SolverBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
SolverShape	Eigen/src/Core/util/Constants.h	/^struct SolverShape            { static std::string debugName() { return "SolverShape"; } };$/;"	s	namespace:Eigen
SolverStorage	Eigen/src/Core/util/Constants.h	/^struct SolverStorage {};$/;"	s	namespace:Eigen
SpMat	doc/special_examples/Tutorial_sparse_example.cpp	/^typedef Eigen::SparseMatrix<double> SpMat; \/\/ declares a column-major sparse matrix type of double$/;"	t	file:
SpMat	doc/special_examples/Tutorial_sparse_example_details.cpp	/^typedef Eigen::SparseMatrix<double> SpMat; \/\/ declares a column-major sparse matrix type of double$/;"	t	file:
Span	unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::Span($/;"	f	class:Eigen::Spline
Sparse	Eigen/src/Core/util/Constants.h	/^struct Sparse {};$/;"	s	namespace:Eigen
Sparse2Dense	Eigen/src/SparseCore/SparseAssign.h	/^struct Sparse2Dense  {};$/;"	s	namespace:Eigen::internal
Sparse2Sparse	Eigen/src/SparseCore/SparseAssign.h	/^struct Sparse2Sparse {};$/;"	s	namespace:Eigen::internal
SparseCompressedBase	Eigen/src/SparseCore/SparseCompressedBase.h	/^    SparseCompressedBase() {}$/;"	f	class:Eigen::SparseCompressedBase
SparseCompressedBase	Eigen/src/SparseCore/SparseCompressedBase.h	/^class SparseCompressedBase$/;"	c	namespace:Eigen
SparseFunctor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  SparseFunctor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Eigen::SparseFunctor
SparseFunctor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^struct SparseFunctor$/;"	s	namespace:Eigen
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    SparseLU():m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    explicit SparseLU(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^class SparseLU : public SparseSolverBase<SparseLU<_MatrixType,_OrderingType> >, public internal::SparseLUImpl<typename _MatrixType::Scalar, typename _MatrixType::StorageIndex>$/;"	c	namespace:Eigen
SparseLUImpl	Eigen/src/SparseLU/SparseLUImpl.h	/^class SparseLUImpl$/;"	c	namespace:Eigen::internal
SparseLUMatrixLReturnType	Eigen/src/SparseLU/SparseLU.h	/^  explicit SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
SparseLUMatrixLReturnType	Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixLReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseLUMatrixUReturnType	Eigen/src/SparseLU/SparseLU.h	/^  SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
SparseLUMatrixUReturnType	Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixUReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase() {}$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index rows, Index cols, Index nnz, IndexPointer outerIndexPtr, IndexPointer innerIndexPtr,$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index rows, Index cols, Index nnz, StorageIndex* outerIndexPtr, StorageIndex* innerIndexPtr,$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index size, Index nnz, IndexPointer innerIndexPtr, ScalarPointer valuePtr)$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline SparseMapBase(Index size, Index nnz, StorageIndex* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::SparseMapBase
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^class SparseMapBase<Derived,ReadOnlyAccessors>$/;"	c	namespace:Eigen
SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^class SparseMapBase<Derived,WriteAccessors>$/;"	c	namespace:Eigen
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    explicit SparseMatrix(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen
SparseMatrixBase	Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase
SparseMatrixBase	Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase$/;"	c	namespace:Eigen
SparseMatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl
SparseMatrixType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef SparseMatrix<_Scalar, _Options, _StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl
SparseMatrixType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef const SparseMatrix<_Scalar, _Options, _StorageIndex> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl
SparseMatrixType	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar,_Options,_StorageIndex> SparseMatrixType;$/;"	t	struct:Eigen::internal::evaluator
SparseMatrixType	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef DynamicSparseMatrix<_Scalar,_Options,_StorageIndex> SparseMatrixType;$/;"	t	struct:Eigen::internal::evaluator
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^    SparseQR () :  m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^    explicit SparseQR(const MatrixType& mat) : m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^class SparseQR : public SparseSolverBase<SparseQR<_MatrixType,_OrderingType> >$/;"	c	namespace:Eigen
SparseQRMatrixQReturnType	Eigen/src/SparseQR/SparseQR.h	/^  explicit SparseQRMatrixQReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
SparseQRMatrixQReturnType	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQReturnType : public EigenBase<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen
SparseQRMatrixQTransposeReturnType	Eigen/src/SparseQR/SparseQR.h	/^  explicit SparseQRMatrixQTransposeReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
SparseQRMatrixQTransposeReturnType	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQTransposeReturnType$/;"	s	namespace:Eigen
SparseQR_QProduct	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct(const SparseQRType& qr, const Derived& other, bool transpose) : $/;"	f	struct:Eigen::SparseQR_QProduct
SparseQR_QProduct	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQR_QProduct : ReturnByValue<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen
SparseRefBase	Eigen/src/SparseCore/SparseRef.h	/^  SparseRefBase()$/;"	f	class:Eigen::internal::SparseRefBase
SparseRefBase	Eigen/src/SparseCore/SparseRef.h	/^template<typename Derived> class SparseRefBase$/;"	c	namespace:Eigen::internal
SparseSelfAdjoint2Sparse	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct SparseSelfAdjoint2Sparse {};$/;"	s	namespace:Eigen::internal
SparseSelfAdjointShape	Eigen/src/SparseCore/SparseUtil.h	/^struct SparseSelfAdjointShape { static std::string debugName() { return "SparseSelfAdjointShape"; } };$/;"	s	namespace:Eigen::internal
SparseSelfAdjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    explicit inline SparseSelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView
SparseSelfAdjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int _Mode> class SparseSelfAdjointView$/;"	c	namespace:Eigen
SparseShape	Eigen/src/Core/util/Constants.h	/^struct SparseShape            { static std::string debugName() { return "SparseShape"; } };$/;"	s	namespace:Eigen
SparseSolverBase	Eigen/src/SparseCore/SparseSolverBase.h	/^    SparseSolverBase()$/;"	f	class:Eigen::SparseSolverBase
SparseSolverBase	Eigen/src/SparseCore/SparseSolverBase.h	/^class SparseSolverBase : internal::noncopyable$/;"	c	namespace:Eigen
SparseSymmetricPermutationProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
SparseSymmetricPermutationProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen
SparseTransposeImpl	Eigen/src/SparseCore/SparseTranspose.h	/^  class SparseTransposeImpl$/;"	c	namespace:Eigen::internal
SparseTransposeImpl	Eigen/src/SparseCore/SparseTranspose.h	/^  class SparseTransposeImpl<MatrixType,CompressedAccessBit>$/;"	c	namespace:Eigen::internal
SparseTriangularShape	Eigen/src/SparseCore/SparseUtil.h	/^struct SparseTriangularShape  { static std::string debugName() { return "SparseTriangularShape"; } };$/;"	s	namespace:Eigen::internal
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    explicit inline SparseVector(Index size) : m_size(0) { check_template_parameters(); resize(size); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { check_template_parameters(); resize(0); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { check_template_parameters(); resize(rows,cols); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen
SparseVectorType	Eigen/src/SparseCore/SparseVector.h	/^  typedef SparseVector<_Scalar,_Options,_Index> SparseVectorType;$/;"	t	struct:Eigen::internal::evaluator
SparseView	Eigen/src/SparseCore/SparseView.h	/^  explicit SparseView(const MatrixType& mat, const Scalar& reference = Scalar(0),$/;"	f	class:Eigen::SparseView
SparseView	Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen
SparseXprInnerIterator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename evaluator<SparseXprType>::InnerIterator SparseXprInnerIterator;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
SparseXprIter	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename evaluator<SparseXprType>::InnerIterator SparseXprIter;$/;"	t	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
Specialized	Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::SpecializedType
SpecializedType	Eigen/src/Core/util/Constants.h	/^enum SpecializedType {$/;"	g	namespace:Eigen
Spline	unsupported/Eigen/src/Splines/Spline.h	/^    Spline() $/;"	f	class:Eigen::Spline
Spline	unsupported/Eigen/src/Splines/Spline.h	/^    Spline(const OtherVectorType& knots, const OtherArrayType& ctrls) : m_knots(knots), m_ctrls(ctrls) {}$/;"	f	class:Eigen::Spline
Spline	unsupported/Eigen/src/Splines/Spline.h	/^    Spline(const Spline<Scalar, Dimension, OtherDegree>& spline) : $/;"	f	class:Eigen::Spline
Spline	unsupported/Eigen/src/Splines/Spline.h	/^  class Spline$/;"	c	namespace:Eigen
Spline2d	unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<double,2> Spline2d;$/;"	t	namespace:Eigen
Spline2f	unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<float,2> Spline2f;$/;"	t	namespace:Eigen
Spline3d	unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<double,3> Spline3d;$/;"	t	namespace:Eigen
Spline3f	unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<float,3> Spline3f;$/;"	t	namespace:Eigen
SplineFitting	unsupported/Eigen/src/Splines/SplineFitting.h	/^  struct SplineFitting$/;"	s	namespace:Eigen
SplineTraits	unsupported/Eigen/src/Splines/SplineFwd.h	/^    struct SplineTraits< Spline<_Scalar, _Dim, _Degree>, Dynamic >$/;"	s	namespace:Eigen
SplineTraits	unsupported/Eigen/src/Splines/SplineFwd.h	/^    struct SplineTraits< Spline<_Scalar, _Dim, _Degree>, _DerivativeOrder > : public SplineTraits< Spline<_Scalar, _Dim, _Degree> >$/;"	s	namespace:Eigen
SplineTraits	unsupported/Eigen/src/Splines/SplineFwd.h	/^    template < typename SplineType, int DerivativeOrder = Dynamic > struct SplineTraits {};$/;"	s	namespace:Eigen
SqrtReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> SqrtReturnType;$/;"	t
SquareMatrixType	Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase
SquareMatrixType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
SquareMatrixType	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^                           EIGEN_SIZE_MAX(RowsAtCompileTime, ColsAtCompileTime) > SquareMatrixType;$/;"	t	class:Eigen::SkylineMatrixBase
SquareReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_square_op<Scalar>, const Derived> SquareReturnType;$/;"	t
SquaredNormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_squaredNorm,RealScalar>::Type SquaredNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
SrcAlignment	Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon512
SrcAlignment	Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,$/;"	e	enum:Eigen::internal::dense_assignment_loop::__anon513
SrcAlignment	Eigen/src/Core/AssignEvaluator.h	/^    SrcAlignment = SrcEvaluator::Alignment,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon503
SrcCoeffRatio	Eigen/src/Core/GenericPacketMath.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon499
SrcCoeffRatio	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon646
SrcCoeffRatio	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon647
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon676
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon677
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon678
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon679
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon680
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon681
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon682
SrcCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    SrcCoeffRatio = 2,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon675
SrcCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon727
SrcCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon728
SrcCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon730
SrcCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    SrcCoeffRatio = 2,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon729
SrcEvaluatorType	Eigen/src/Core/AssignEvaluator.h	/^  typedef SrcEvaluatorTypeT SrcEvaluatorType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
SrcEvaluatorType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::SrcEvaluatorType SrcEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcEvaluatorType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::SrcEvaluatorType SrcEvaluatorType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcFlags	Eigen/src/Core/AssignEvaluator.h	/^    SrcFlags = SrcEvaluator::Flags$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon502
SrcHasDirectAccess	Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
SrcIsRowMajor	Eigen/src/Core/AssignEvaluator.h	/^    SrcIsRowMajor = SrcFlags&RowMajorBit,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
SrcStorageOrder	Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permutation_matrix_product::__anon792
SrcType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename internal::remove_all<typename internal::traits<ArgType>::Scalar>::type SrcType;$/;"	t	struct:Eigen::TensorEvaluator
SrcXprType	Eigen/src/Core/AssignEvaluator.h	/^  typedef typename SrcEvaluatorTypeT::XprType SrcXprType;$/;"	t	class:Eigen::internal::generic_dense_assignment_kernel
SrcXprType	Eigen/src/Core/ProductEvaluators.h	/^                        const Product<Lhs,Rhs,DefaultProduct> > SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs,Rhs,Options> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Base::SrcXprType SrcXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcXprType	Eigen/src/Core/Solve.h	/^  typedef Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/Solve.h	/^  typedef Solve<DecType,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/Solve.h	/^  typedef Solve<Transpose<const DecType>,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/TriangularMatrix.h	/^  typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Base::SrcXprType SrcXprType;$/;"	t	class:Eigen::internal::triangular_dense_assignment_kernel
SrcXprType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Horizontal> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Vertical> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  typedef SolveWithGuess<DecType,RhsType,GuessType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/LU/FullPivLU.h	/^  typedef Inverse<LuType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/LU/InverseImpl.h	/^  typedef Inverse<XprType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/LU/PartialPivLU.h	/^  typedef Inverse<LuType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/QR/ColPivHouseholderQR.h	/^  typedef Inverse<QrType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef Inverse<CodType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef Inverse<QrType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/SparseCore/SparseAssign.h	/^  typedef Solve<DecType,RhsType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/SparseCore/SparseProduct.h	/^  typedef Product<Lhs,Rhs,AliasFreeProduct> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef SparseSymmetricPermutationProduct<MatrixType,Mode> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SrcXprType	Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseQRMatrixQReturnType<SparseQRType> SrcXprType;$/;"	t	struct:Eigen::internal::Assignment
SsePrefetchPtrType	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef const char * SsePrefetchPtrType;$/;"	t	namespace:Eigen::internal
SsePrefetchPtrType	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef const void * SsePrefetchPtrType;$/;"	t	namespace:Eigen::internal
StableNormReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_stableNorm,RealScalar>::Type StableNormReturnType;$/;"	t	class:Eigen::VectorwiseOp
StandardCompressedFormat	Eigen/src/SparseCore/SparseRef.h	/^  StandardCompressedFormat = 2 \/**< used by Ref<SparseMatrix> to specify whether the input storage must be in standard compressed form *\/$/;"	e	enum:Eigen::__anon795
StartBenchmarkTiming	bench/tensors/benchmark_main.cc	/^void StartBenchmarkTiming() {$/;"	f
StartIndex	Eigen/src/Core/SolveTriangular.h	/^    StartIndex = IsLower ? 0         : DiagIndex+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon519
StaticIf	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct StaticIf<true, T> {$/;"	s	namespace:utility::tuple
StaticSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr inline StaticSGroup() {}$/;"	f	class:Eigen::StaticSGroup
StaticSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr inline StaticSGroup(StaticSGroup<Gen...>&&) {}$/;"	f	class:Eigen::StaticSGroup
StaticSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr inline StaticSGroup(const StaticSGroup<Gen...>&) {}$/;"	f	class:Eigen::StaticSGroup
StaticSGroup	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^class StaticSGroup$/;"	c	namespace:Eigen
Status	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    enum Status {$/;"	g	namespace:Eigen::LevenbergMarquardtSpace
Status	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    enum Status {$/;"	g	namespace:Eigen::HybridNonLinearSolverSpace
Status	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    enum Status {$/;"	g	namespace:Eigen::LevenbergMarquardtSpace
StdMapTraits	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct StdMapTraits$/;"	s	namespace:Eigen
StdUnorderedMapTraits	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct StdUnorderedMapTraits$/;"	s	namespace:Eigen
StdVectorContainer	unsupported/test/FFTW.cpp	/^enum { StdVectorContainer, EigenVectorContainer };$/;"	e	enum:__anon21	file:
Steal	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  Task Steal() {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
StemFunction	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase
StemFunction	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixFunctionReturnValue
StemFunction	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::internal::MatrixFunctionAtomic
StlThreadEnvironment	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^struct StlThreadEnvironment {$/;"	s	namespace:Eigen
StopBenchmarkTiming	bench/tensors/benchmark_main.cc	/^void StopBenchmarkTiming() {$/;"	f
Storage	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,StorageIndex> Storage;$/;"	t	class:Eigen::SparseMatrix
Storage	Eigen/src/SparseCore/SparseVector.h	/^    typedef internal::CompressedStorage<Scalar,StorageIndex> Storage;$/;"	t	class:Eigen::SparseVector
StorageBaseType	Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase
StorageBaseType	Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase
StorageBaseType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase
StorageIndex	Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::LDLT
StorageIndex	Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::LLT
StorageIndex	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::CholmodBase
StorageIndex	Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::TridiagonalMatrix
StorageIndex	Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrixBase
StorageIndex	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrix
StorageIndex	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::BandMatrixWrapper
StorageIndex	Eigen/src/Core/BandMatrix.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/Block.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	class:Eigen::BlockImpl
StorageIndex	Eigen/src/Core/CwiseBinaryOp.h	/^                                      typename traits<Rhs>::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::traits<Arg1>::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DenseBase
StorageIndex	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalBase
StorageIndex	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalMatrix
StorageIndex	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/Inverse.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	class:Eigen::Inverse
StorageIndex	Eigen/src/Core/MapBase.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::MapBase
StorageIndex	Eigen/src/Core/Matrix.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::MatrixBase
StorageIndex	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Map
StorageIndex	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PermutationBase
StorageIndex	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PermutationMatrix
StorageIndex	Eigen/src/Core/PermutationMatrix.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/Product.h	/^                                      typename RhsTraits::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SelfAdjointView
StorageIndex	Eigen/src/Core/Solve.h	/^  typedef typename internal::traits<Solve>::StorageIndex StorageIndex;$/;"	t	class:Eigen::Solve
StorageIndex	Eigen/src/Core/Solve.h	/^  typedef typename promote_index_type<typename Decomposition::StorageIndex, typename RhsType::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Map
StorageIndex	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::Transpositions
StorageIndex	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::TranspositionsBase
StorageIndex	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar StorageIndex;$/;"	t	class:Eigen::TranspositionsWrapper
StorageIndex	Eigen/src/Core/Transpositions.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::TriangularBase
StorageIndex	Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	class:Eigen::Transform
StorageIndex	Eigen/src/Geometry/Transform.h	/^  typedef Eigen::Index StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::StorageIndex StorageIndex;$/;"	t	class:Eigen::DiagonalPreconditioner
StorageIndex	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef typename PermutationType::StorageIndex StorageIndex; $/;"	t	class:Eigen::IncompleteCholesky
StorageIndex	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::IncompleteLUT
StorageIndex	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::IterativeSolverBase
StorageIndex	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::PastixBase
StorageIndex	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::PastixLU
StorageIndex	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::pastix_traits
StorageIndex	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoLDLT
StorageIndex	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoLLT
StorageIndex	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::StorageIndex StorageIndex;$/;"	t	class:Eigen::PardisoImpl
StorageIndex	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;    $/;"	t	struct:Eigen::internal::pardiso_traits
StorageIndex	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::pardiso_traits
StorageIndex	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::ColPivHouseholderQR
StorageIndex	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::CompleteOrthogonalDecomposition
StorageIndex	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::FullPivHouseholderQR
StorageIndex	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::HouseholderQR
StorageIndex	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SuiteSparse_long StorageIndex ;$/;"	t	class:Eigen::SPQR
StorageIndex	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::SPQR_QProduct
StorageIndex	Eigen/src/SVD/SVDBase.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SVDBase
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialCholesky
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialCholeskyBase
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialLDLT
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SimplicialLLT
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::StorageIndex                       StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::StorageIndex                   StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::AmbiVector
StorageIndex	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::CompressedStorage
StorageIndex	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::MappedSparseMatrix
StorageIndex	Eigen/src/SparseCore/SparseAssign.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	Eigen/src/SparseCore/SparseBlock.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::BlockImpl
StorageIndex	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::binary_evaluator
StorageIndex	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::sparse_conjunction_evaluator
StorageIndex	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename SparseXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::sparse_diagonal_product_evaluator
StorageIndex	Eigen/src/SparseCore/SparseMap.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseMapBase
StorageIndex	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseMatrixBase
StorageIndex	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeCleaned::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::permutation_matrix_product
StorageIndex	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseSelfAdjointView
StorageIndex	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
StorageIndex	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::SparseTransposeImpl
StorageIndex	Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	Eigen/src/SparseCore/SparseVector.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseCore/SparseView.h	/^    typedef typename XprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::unary_evaluator
StorageIndex	Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseCore/TriangularSolver.h	/^                                      typename traits<Rhs>::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
StorageIndex	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseLU
StorageIndex	Eigen/src/SparseLU/SparseLU_Structs.h	/^  typedef typename IndexVector::Scalar StorageIndex; $/;"	t	struct:Eigen::internal::LU_GlobalLU_t
StorageIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
StorageIndex	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename IndexVector::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::column_dfs_traits
StorageIndex	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  typedef typename IndexVector::Scalar StorageIndex;$/;"	t	struct:Eigen::internal::panel_dfs_traits
StorageIndex	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SparseQR
StorageIndex	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename DstXprType::StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::Assignment
StorageIndex	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::StorageIndex StorageIndex;$/;"	t	class:Eigen::SuperLU
StorageIndex	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::SuperLUBase
StorageIndex	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::UmfPackLU
StorageIndex	doc/examples/matrixfree_cg.cpp	/^  typedef int StorageIndex;$/;"	t	class:MatrixReplacement	file:
StorageIndex	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    typedef typename MatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::DGMRES
StorageIndex	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef typename promote_index_type<typename Lhs::StorageIndex, typename Rhs::StorageIndex>::type StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    typedef _StorageIndex StorageIndex;$/;"	t	class:Eigen::BlockSparseMatrix
StorageIndex	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef _StorageIndex StorageIndex;$/;"	t	struct:Eigen::internal::traits
StorageIndex	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename SparseMatrixType::StorageIndex StorageIndex;$/;"	t	class:Eigen::RandomSetter
StorageKind	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase
StorageKind	Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/CwiseBinaryOp.h	/^                                              BinaryOp>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::traits<Arg1>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase
StorageKind	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase
StorageKind	Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^  typedef DiagonalShape StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase
StorageKind	Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase
StorageKind	Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase
StorageKind	Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase
StorageKind	Eigen/src/Core/Product.h	/^                                                internal::product_type<Lhs,Rhs>::ret>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Transpositions.h	/^  typedef TranspositionsStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase
StorageKind	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView
StorageKind	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularViewType>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularViewImpl
StorageKind	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Geometry/Transform.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/LU/FullPivLU.h	/^  typedef SolverStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/LU/PartialPivLU.h	/^  typedef SolverStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    typedef typename internal::traits<Self>::StorageKind StorageKind;$/;"	t	class:Eigen::Tensor
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorIndexTupleOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorIndexTupleOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename Eigen::internal::traits<TensorTupleReducerOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorTupleReducerOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename Eigen::internal::traits<TensorAssignOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorAssignOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename traits<LhsXprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename Eigen::internal::traits<TensorBroadcastingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorBroadcastingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename Eigen::internal::traits<TensorChippingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorChippingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^                                        typename traits<RhsXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typedef typename internal::traits<TensorConcatenationOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorConcatenationOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^                                        typename traits<RhsXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename Eigen::internal::traits<TensorContractionOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorContractionOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typedef typename internal::traits<TensorConversionOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorConversionOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^                                        typename traits<KernelXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename Eigen::internal::traits<TensorConvolutionOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorConvolutionOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^                                        typename traits<RhsXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename XprType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomBinaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCustomBinaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename internal::traits<TensorCustomUnaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCustomUnaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename Eigen::internal::traits<TensorEvalToOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorEvalToOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^                                        typename traits<ElseXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^      typename traits<RhsXprType>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseBinaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCwiseBinaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseNullaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCwiseNullaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseTernaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCwiseTernaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorCwiseUnaryOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorCwiseUnaryOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typedef typename Eigen::internal::traits<TensorSelectOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorSelectOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename traits<Arg1XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename Eigen::internal::traits<TensorFFTOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorFFTOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    typedef typename internal::traits<Self>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorFixedSize
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename Eigen::internal::traits<TensorForcedEvalOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorForcedEvalOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename Eigen::internal::traits<TensorGeneratorOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorGeneratorOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename Eigen::internal::traits<TensorImagePatchOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorImagePatchOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename Eigen::internal::traits<TensorInflationOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorInflationOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename Eigen::internal::traits<TensorLayoutSwapOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorLayoutSwapOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typedef typename internal::traits<PlainObjectType>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorMap
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorReshapingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorReshapingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename Eigen::internal::traits<TensorSlicingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorSlicingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename internal::traits<TensorStridingSlicingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorStridingSlicingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename Eigen::internal::traits<TensorPaddingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorPaddingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename Eigen::internal::traits<TensorPatchOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorPatchOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename Eigen::internal::traits<TensorReductionOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorReductionOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    typedef typename internal::traits<PlainObjectType>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorRef
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^                                                                    StorageKind;$/;"	t	class:Eigen::TensorReverseOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename Eigen::internal::traits<TensorScanOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorScanOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename Eigen::internal::traits<TensorShufflingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorShufflingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename Eigen::internal::traits<TensorStridingOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorStridingOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef typename BaseTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename Eigen::internal::traits<TensorVolumePatchOp>::StorageKind StorageKind;$/;"	t	class:Eigen::TensorVolumePatchOp
StorageKind	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename XprTraits::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef typename cwise_promote_storage_type<typename traits<Lhs>::StorageKind, typename traits<Rhs>::StorageKind, scalar_product_op<typename Lhs::Scalar, typename Rhs::Scalar> >::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SkylineMatrixBase
StorageKind	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef Sparse StorageKind; \/\/ FIXME Where is it used ??$/;"	t	struct:Eigen::internal::traits
StorageKind	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageOptions	Eigen/src/Core/util/Constants.h	/^enum StorageOptions {$/;"	g	namespace:Eigen
StorageOrder	Eigen/src/Core/ProductEvaluators.h	/^    StorageOrder = int(Rhs::Flags) & RowMajorBit ? RowMajor : ColMajor$/;"	e	enum:Eigen::internal::product_evaluator::__anon431
StorageOrder	Eigen/src/Core/ProductEvaluators.h	/^  enum { StorageOrder = int(Lhs::Flags) & RowMajorBit ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::product_evaluator::__anon432
StorageOrderMatch	Eigen/src/Core/Ref.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon474
StorageOrderMatch	Eigen/src/SparseCore/SparseRef.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon797
StorageOrdersAgree	Eigen/src/Core/AssignEvaluator.h	/^    StorageOrdersAgree = (int(DstIsRowMajor) == int(SrcIsRowMajor)),$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon507
StorageOrdersAgree	Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
StorageOrdersAgree	Eigen/src/Core/CoreEvaluators.h	/^    StorageOrdersAgree = (int(Arg1Flags)&RowMajorBit)==(int(Arg2Flags)&RowMajorBit) && (int(Arg1Flags)&RowMajorBit)==(int(Arg3Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::ternary_evaluator::__anon755
StorageOrdersAgree	Eigen/src/Core/CoreEvaluators.h	/^    StorageOrdersAgree = (int(LhsFlags)&RowMajorBit)==(int(RhsFlags)&RowMajorBit),$/;"	e	enum:Eigen::internal::binary_evaluator::__anon756
StorageOrdersMatch	Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon230
StorageOrdersMatch	Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon231
StreamInterface	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^class StreamInterface {$/;"	c	namespace:Eigen
StreamPrecision	Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon423
StrictlyLower	Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::UpLoType
StrictlyUpper	Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::UpLoType
Stride	Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
StrideBase	Eigen/src/Core/Ref.h	/^  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;$/;"	t	class:Eigen::RefBase
StrideDims	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef array<Index, NumDims> StrideDims;$/;"	t	struct:Eigen::TensorEvaluator
StrideType	Eigen/src/Core/Ref.h	/^  typedef _StrideType StrideType;$/;"	t	struct:Eigen::internal::traits
StrideType	Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::StrideType StrideType;$/;"	t	class:Eigen::RefBase
StridedAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedVectorType	blas/common.h	/^typedef Map<Matrix<Scalar,Dynamic,1>, 0, InnerStride<Dynamic> > StridedVectorType;$/;"	t
SubDiagonalReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
SubDiagonalType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename TridiagonalizationType::SubDiagonalType SubDiagonalType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
SubDiagonalType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization
SubMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef TensorContractionSubMapper<Scalar, Index, side, Tensor, nocontract_t, contract_t, packet_size, inner_dim_contiguous, inner_dim_reordered, Alignment> SubMapper;$/;"	t	class:Eigen::internal::TensorContractionInputMapper
SubVector	Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp
Subs	Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
Subs	Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon478
Subs	Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon479
Success	Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
SumReducer	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^template <typename T> struct SumReducer$/;"	s	namespace:Eigen::internal
SumReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ReturnType<internal::member_sum>::Type SumReturnType;$/;"	t	class:Eigen::VectorwiseOp
SuperDiagVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    explicit SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : public SparseSolverBase<Derived>$/;"	c	namespace:Eigen
Supers	Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon475
Supers	Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon478
Supers	Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon479
SupportedAccessPatterns	Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon836
SupportedAccessPatterns	Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon845
SupportedAccessPatterns	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon72
SupportedAccessPatterns	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    SupportedAccessPatterns = OuterRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon63
SwapStorage	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      SwapStorage = 1 - MapTraits<ScalarWrapper>::IsSorted,$/;"	e	enum:Eigen::RandomSetter::__anon71
SwappedTraits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<RhsScalar,LhsScalar,ConjugateRhs,ConjugateLhs> SwappedTraits;$/;"	t	struct:Eigen::internal::gebp_kernel
SyclDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template<typename dev_Selector> SyclDevice(dev_Selector s)$/;"	f	struct:Eigen::SyclDevice
SyclDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^struct SyclDevice {$/;"	s	namespace:Eigen
Symmetric	Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::UpLoType
Symmetry	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct Symmetry$/;"	s	namespace:Eigen
System	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef _System System;$/;"	t	class:Eigen::EulerAngles
T	doc/snippets/RealSchur_RealSchur_MatrixType.cpp	/^MatrixXd T = schur.matrixT();$/;"	v
T	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^MatrixXd T = triOfA.matrixT();$/;"	v
T	doc/snippets/Tridiagonalization_diagonal.cpp	/^MatrixXd T = triOfA.matrixT();$/;"	v
T	doc/special_examples/Tutorial_sparse_example.cpp	/^typedef Eigen::Triplet<double> T;$/;"	t	file:
T	doc/special_examples/Tutorial_sparse_example_details.cpp	/^typedef Eigen::Triplet<double> T;$/;"	t	file:
TENSORMAP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	47;"	d
TENSORMAP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	61;"	d
TENSORMAPCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	50;"	d
TENSORMAPCONVERT	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	58;"	d
TENSORMAPEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	140;"	d
TENSORMAPEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	150;"	d
TENSORMAPEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	124;"	d
TENSORMAPEXPR	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	132;"	d
TENSOR_INTERFACE_HH	bench/btl/libs/tensors/tensor_interface.hh	10;"	d
TERMINATE_CONDS_TUPLE_GET	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	86;"	d
TERMINATE_CONDS_TUPLE_GET	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	96;"	d
TERNARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	102;"	d
TERNARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	121;"	d
TESTDSDOT	blas/testing/dblat1.f	/^      SUBROUTINE TESTDSDOT(/;"	s
TEST_CHECK_STATIC_ASSERTIONS	test/ref.cpp	16;"	d	file:
TEST_CHECK_STATIC_ASSERTIONS	test/selfadjoint.cpp	10;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/cholesky.cpp	14;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/constructor.cpp	11;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/nesting_ops.cpp	11;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/permutationmatrices.cpp	10;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/product_notemporary.cpp	10;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/redux.cpp	11;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/ref.cpp	15;"	d	file:
TEST_ENABLE_TEMPORARY_TRACKING	test/vectorwiseop.cpp	11;"	d	file:
TEST_OP	unsupported/test/cxx11_tensor_sugar.cpp	23;"	d	file:
TEST_OP	unsupported/test/cxx11_tensor_sugar.cpp	31;"	d	file:
TEST_SET_BUT_UNUSED_VARIABLE	test/main.h	91;"	d
TEST_TENSOR_EQUAL	unsupported/test/cxx11_tensor_sugar.cpp	19;"	d	file:
TEST_TENSOR_EQUAL	unsupported/test/cxx11_tensor_sugar.cpp	32;"	d	file:
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIRD_PARTY_EIGEN3_EIGEN_SRC_CORE_ARCH_AVX512_MATHFUNCTIONS_H_	Eigen/src/Core/arch/AVX512/MathFunctions.h	11;"	d
THIRD_PARTY_EIGEN3_TENSOR_BENCHMARKS_H_	bench/tensors/tensor_benchmarks.h	2;"	d
THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THIS_TYPE_IS_NOT_SUPPORTED	Eigen/src/Core/util/StaticAssert.h	/^        THIS_TYPE_IS_NOT_SUPPORTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
THRESH	blas/testing/cblat2.f	/^      REAL               EPS, ERR, THRESH$/;"	v	program:CBLAT2
THRESH	blas/testing/cblat3.f	/^      REAL               EPS, ERR, THRESH$/;"	v	program:CBLAT3
THRESH	blas/testing/dblat2.f	/^      DOUBLE PRECISION   EPS, ERR, THRESH$/;"	v	program:DBLAT2
THRESH	blas/testing/dblat3.f	/^      DOUBLE PRECISION   EPS, ERR, THRESH$/;"	v	program:DBLAT3
THRESH	blas/testing/sblat2.f	/^      REAL               EPS, ERR, THRESH$/;"	v	program:SBLAT2
THRESH	blas/testing/sblat3.f	/^      REAL               EPS, ERR, THRESH$/;"	v	program:SBLAT3
THRESH	blas/testing/zblat2.f	/^      DOUBLE PRECISION   EPS, ERR, THRESH$/;"	v	program:ZBLAT2
THRESH	blas/testing/zblat3.f	/^      DOUBLE PRECISION   EPS, ERR, THRESH$/;"	v	program:ZBLAT3
TINY_BLITZ_INTERFACE_HH	bench/btl/libs/blitz/tiny_blitz_interface.hh	21;"	d
TINY_MV_MAX_SIZE	bench/btl/generic_bench/bench_parameter.hh	46;"	d
TMATV	bench/benchGeometry.cpp	/^    TMATV,$/;"	e	enum:func_opt	file:
TMATVMAT	bench/benchGeometry.cpp	/^    TMATVMAT,$/;"	e	enum:func_opt	file:
TM_FLY_PAN	demos/opengl/quaternion_demo.h	/^      TM_LOCAL_ROTATE, TM_FLY_Z, TM_FLY_PAN$/;"	e	enum:RenderingWidget::TrackMode
TM_FLY_Z	demos/opengl/quaternion_demo.h	/^      TM_LOCAL_ROTATE, TM_FLY_Z, TM_FLY_PAN$/;"	e	enum:RenderingWidget::TrackMode
TM_LOCAL_ROTATE	demos/opengl/quaternion_demo.h	/^      TM_LOCAL_ROTATE, TM_FLY_Z, TM_FLY_PAN$/;"	e	enum:RenderingWidget::TrackMode
TM_NO_TRACK	demos/opengl/quaternion_demo.h	/^      TM_NO_TRACK=0, TM_ROTATE_AROUND, TM_ZOOM,$/;"	e	enum:RenderingWidget::TrackMode
TM_ROTATE_AROUND	demos/opengl/quaternion_demo.h	/^      TM_NO_TRACK=0, TM_ROTATE_AROUND, TM_ZOOM,$/;"	e	enum:RenderingWidget::TrackMode
TM_ZOOM	demos/opengl/quaternion_demo.h	/^      TM_NO_TRACK=0, TM_ROTATE_AROUND, TM_ZOOM,$/;"	e	enum:RenderingWidget::TrackMode
TPlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseMatrix<MatScalar,MatOptions,MatIndex> TPlainObjectType;$/;"	t	class:Eigen::Ref
TPlainObjectType	Eigen/src/SparseCore/SparseRef.h	/^    typedef SparseVector<MatScalar,MatOptions,MatIndex> TPlainObjectType;$/;"	t	class:Eigen::Ref
TR	blas/common.h	25;"	d
TRACE	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:CBLAT2
TRACE	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:CBLAT3
TRACE	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:DBLAT2
TRACE	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:DBLAT3
TRACE	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:SBLAT2
TRACE	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:SBLAT3
TRACE	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:ZBLAT2
TRACE	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,/;"	v	program:ZBLAT3
TRACK	test/main.h	149;"	d
TRANS	blas/testing/cblat2.f	/^      CHARACTER*1        TRANS$/;"	v	program:CBLAT2
TRANS	blas/testing/dblat2.f	/^      CHARACTER*1        TRANS$/;"	v	program:DBLAT2
TRANS	blas/testing/sblat2.f	/^      CHARACTER*1        TRANS$/;"	v	program:SBLAT2
TRANS	blas/testing/zblat2.f	/^      CHARACTER*1        TRANS$/;"	v	program:ZBLAT2
TRANSA	blas/testing/cblat3.f	/^      CHARACTER*1        TRANSA,/;"	v	program:CBLAT3
TRANSA	blas/testing/dblat3.f	/^      CHARACTER*1        TRANSA,/;"	v	program:DBLAT3
TRANSA	blas/testing/sblat3.f	/^      CHARACTER*1        TRANSA,/;"	v	program:SBLAT3
TRANSA	blas/testing/zblat3.f	/^      CHARACTER*1        TRANSA,/;"	v	program:ZBLAT3
TRANSB	blas/testing/cblat3.f	/^      CHARACTER*1        TRANSA, TRANSB$/;"	v	program:CBLAT3
TRANSB	blas/testing/dblat3.f	/^      CHARACTER*1        TRANSA, TRANSB$/;"	v	program:DBLAT3
TRANSB	blas/testing/sblat3.f	/^      CHARACTER*1        TRANSA, TRANSB$/;"	v	program:SBLAT3
TRANSB	blas/testing/zblat3.f	/^      CHARACTER*1        TRANSA, TRANSB$/;"	v	program:ZBLAT3
TRIES	bench/benchCholesky.cpp	23;"	d	file:
TRIES	bench/benchEigenSolver.cpp	24;"	d	file:
TRIES	bench/bench_reverse.cpp	12;"	d	file:
TSTERR	blas/testing/cblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:CBLAT2
TSTERR	blas/testing/cblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:CBLAT3
TSTERR	blas/testing/dblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:DBLAT2
TSTERR	blas/testing/dblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:DBLAT3
TSTERR	blas/testing/sblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:SBLAT2
TSTERR	blas/testing/sblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:SBLAT3
TSTERR	blas/testing/zblat2.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:ZBLAT2
TSTERR	blas/testing/zblat3.f	/^      LOGICAL            FATAL, LTESTT, REWI, SAME, SFATAL, TRACE,$/;"	v	program:ZBLAT3
TV	bench/benchGeometry.cpp	/^    TV,$/;"	e	enum:func_opt	file:
TVMET_INTERFACE_HH	bench/btl/libs/tvmet/tvmet_interface.hh	21;"	d
TYPE	bench/benchFFT.cpp	31;"	d	file:
TailType	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef Tail TailType;$/;"	t	struct:Eigen::internal::type_list
TanReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_tan_op<Scalar>, const Derived> TanReturnType;$/;"	t
TanhReturnType	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_tanh_op<Scalar>, const Derived> TanhReturnType;$/;"	t
Target	Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
TargetRowMajor	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      TargetRowMajor = (SparseMatrixType::Flags & RowMajorBit) ? 1 : 0,$/;"	e	enum:Eigen::RandomSetter::__anon71
Task	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  typedef typename Environment::Task Task;$/;"	t	class:Eigen::NonBlockingThreadPoolTempl
Task	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  typedef typename Environment::Task Task;$/;"	t	class:Eigen::SimpleThreadPoolTempl
Task	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^  struct Task {$/;"	s	struct:Eigen::StlThreadEnvironment
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index dim1, Index dim2, Index dim3, Index dim4, Index dim5)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Tensor(Index firstDimension, IndexTypes... otherDimensions)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit Tensor(Index dim1)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit Tensor(const array<Index, NumIndices>& dimensions)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor()$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor(const Self& other)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor(const TensorBase<OtherDerived, ReadOnlyAccessors>& other)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor(const TensorBase<OtherDerived, WriteAccessors>& other)$/;"	f	class:Eigen::Tensor
Tensor	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^class Tensor : public TensorBase<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >$/;"	c	namespace:Eigen
TensorAssignOp	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorAssignOp(LhsXprType& lhs, const RhsXprType& rhs)$/;"	f	class:Eigen::TensorAssignOp
TensorAssignOp	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^class TensorAssignOp : public TensorBase<TensorAssignOp<LhsXprType, RhsXprType> >$/;"	c	namespace:Eigen
TensorBase	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^class TensorBase : public TensorBase<Derived, ReadOnlyAccessors> {$/;"	c	namespace:Eigen
TensorBase	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^class TensorBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorBroadcastingOp	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorBroadcastingOp(const XprType& expr, const Broadcast& broadcast)$/;"	f	class:Eigen::TensorBroadcastingOp
TensorBroadcastingOp	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^class TensorBroadcastingOp : public TensorBase<TensorBroadcastingOp<Broadcast, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorChippingOp	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorChippingOp(const XprType& expr, const Index offset, const Index dim)$/;"	f	class:Eigen::TensorChippingOp
TensorChippingOp	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^class TensorChippingOp : public TensorBase<TensorChippingOp<DimId, XprType> >$/;"	c	namespace:Eigen
TensorConcatenationOp	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConcatenationOp(const LhsXprType& lhs, const RhsXprType& rhs, Axis axis)$/;"	f	class:Eigen::TensorConcatenationOp
TensorConcatenationOp	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^class TensorConcatenationOp : public TensorBase<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, WriteAccessors>$/;"	c	namespace:Eigen
TensorContractionBlocking	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  EIGEN_DEVICE_FUNC TensorContractionBlocking(Index k, Index m, Index n, Index num_threads = 1) :$/;"	f	class:Eigen::internal::TensorContractionBlocking
TensorContractionBlocking	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^class TensorContractionBlocking {$/;"	c	namespace:Eigen::internal
TensorContractionEvaluatorBase	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  TensorContractionEvaluatorBase(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
TensorContractionEvaluatorBase	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct TensorContractionEvaluatorBase$/;"	s	namespace:Eigen
TensorContractionInputMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC TensorContractionInputMapper(const Tensor& tensor,$/;"	f	class:Eigen::internal::TensorContractionInputMapper
TensorContractionInputMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^class TensorContractionInputMapper$/;"	c	namespace:Eigen::internal
TensorContractionOp	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorContractionOp($/;"	f	class:Eigen::TensorContractionOp
TensorContractionOp	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^class TensorContractionOp : public TensorBase<TensorContractionOp<Indices, LhsXprType, RhsXprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorContractionSubMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC TensorContractionSubMapper(const ParentMapper& base_mapper, Index vert_offset, Index horiz_offset)$/;"	f	class:Eigen::internal::TensorContractionSubMapper
TensorContractionSubMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^class TensorContractionSubMapper {$/;"	c	namespace:Eigen::internal
TensorConversionOp	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConversionOp(const XprType& xpr)$/;"	f	class:Eigen::TensorConversionOp
TensorConversionOp	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^class TensorConversionOp : public TensorBase<TensorConversionOp<TargetType, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorConvolutionOp	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorConvolutionOp(const InputXprType& input, const KernelXprType& kernel, const Indices& dims)$/;"	f	class:Eigen::TensorConvolutionOp
TensorConvolutionOp	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^class TensorConvolutionOp : public TensorBase<TensorConvolutionOp<Indices, InputXprType, KernelXprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCostModel	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^class TensorCostModel {$/;"	c	namespace:Eigen
TensorCustomBinaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCustomBinaryOp(const LhsXprType& lhs, const RhsXprType& rhs, const CustomBinaryFunc& func)$/;"	f	class:Eigen::TensorCustomBinaryOp
TensorCustomBinaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^class TensorCustomBinaryOp : public TensorBase<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCustomUnaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCustomUnaryOp(const XprType& expr, const CustomUnaryFunc& func)$/;"	f	class:Eigen::TensorCustomUnaryOp
TensorCustomUnaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^class TensorCustomUnaryOp : public TensorBase<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCwiseBinaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseBinaryOp(const LhsXprType& lhs, const RhsXprType& rhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::TensorCwiseBinaryOp
TensorCwiseBinaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^class TensorCwiseBinaryOp : public TensorBase<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCwiseNullaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseNullaryOp(const XprType& xpr, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::TensorCwiseNullaryOp
TensorCwiseNullaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^class TensorCwiseNullaryOp : public TensorBase<TensorCwiseNullaryOp<NullaryOp, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCwiseTernaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseTernaryOp(const Arg1XprType& arg1, const Arg2XprType& arg2, const Arg3XprType& arg3, const TernaryOp& func = TernaryOp())$/;"	f	class:Eigen::TensorCwiseTernaryOp
TensorCwiseTernaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^class TensorCwiseTernaryOp : public TensorBase<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorCwiseUnaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorCwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::TensorCwiseUnaryOp
TensorCwiseUnaryOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^class TensorCwiseUnaryOp : public TensorBase<TensorCwiseUnaryOp<UnaryOp, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    TensorDevice(const DeviceType& device, ExpressionType& expression) : m_device(device), m_expression(expression) {}$/;"	f	class:Eigen::TensorDevice
TensorDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^template <typename ExpressionType, typename DeviceType> class TensorDevice {$/;"	c	namespace:Eigen
TensorEvalToOp	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvalToOp(PointerType buffer, const XprType& expr)$/;"	f	class:Eigen::TensorEvalToOp
TensorEvalToOp	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^class TensorEvalToOp : public TensorBase<TensorEvalToOp<XprType, MakePointer_>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct TensorEvaluator<const TensorIndexTupleOp<ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct TensorEvaluator<const TensorTupleReducerOp<ReduceOp, Dims, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^struct TensorEvaluator<const TensorAssignOp<LeftArgType, RightArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct TensorEvaluator<const TensorBroadcastingOp<Broadcast, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct TensorEvaluator<TensorChippingOp<DimId, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  struct TensorEvaluator<TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^struct TensorEvaluator<const TensorConcatenationOp<Axis, LeftArgType, RightArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, Device> :$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device) :$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, GpuDevice> :$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  TensorEvaluator(const XprType& op, const Device& device) :$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^struct TensorEvaluator<const TensorContractionOp<Indices, LeftArgType, RightArgType>, ThreadPoolDevice> :$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct TensorEvaluator<const TensorConversionOp<TargetType, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const GpuDevice& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct TensorEvaluator<const TensorConvolutionOp<Indices, InputArgType, KernelArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct TensorEvaluator<const TensorConvolutionOp<Indices, InputArgType, KernelArgType>, GpuDevice>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const ArgType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct TensorEvaluator<const TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct TensorEvaluator<const TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^struct TensorEvaluator<const TensorEvalToOp<ArgType, MakePointer_>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const Derived& m, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const Derived, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const TensorCwiseBinaryOp<BinaryOp, LeftArgType, RightArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const TensorCwiseNullaryOp<NullaryOp, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const TensorCwiseTernaryOp<TernaryOp, Arg1Type, Arg2Type, Arg3Type>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const TensorCwiseUnaryOp<UnaryOp, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^struct TensorEvaluator<const TensorSelectOp<IfArgType, ThenArgType, ElseArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device) : m_fft(op.fft()), m_impl(op.expression(), device), m_data(NULL), m_device(device) {$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^struct TensorEvaluator<const TensorFFTOp<FFT, ArgType, FFTResultType, FFTDir>, Device> {$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^struct TensorEvaluator<const TensorForcedEvalOp<ArgType, MakePointer_>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^struct TensorEvaluator<const TensorGeneratorOp<Generator, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^struct TensorEvaluator<const TensorImagePatchOp<Rows, Cols, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^struct TensorEvaluator<const TensorInflationOp<Strides, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  struct TensorEvaluator<TensorLayoutSwapOp<ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^struct TensorEvaluator<const TensorLayoutSwapOp<ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  struct TensorEvaluator<TensorReshapingOp<NewDimensions, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct TensorEvaluator<TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct TensorEvaluator<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct TensorEvaluator<const TensorReshapingOp<NewDimensions, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct TensorEvaluator<const TensorSlicingOp<StartIndices, Sizes, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct TensorEvaluator<const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^struct TensorEvaluator<const TensorPaddingOp<PaddingDimensions, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^struct TensorEvaluator<const TensorPatchOp<PatchDim, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct TensorEvaluator<const TensorReductionOp<Op, Dims, ArgType, MakePointer_>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(TensorRef<Derived>& m, const Device& d) : Base(m, d)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const TensorRef<Derived>& m, const Device&)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^struct TensorEvaluator<TensorRef<Derived>, Device> : public TensorEvaluator<const TensorRef<Derived>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^struct TensorEvaluator<const TensorRef<Derived>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^struct TensorEvaluator<TensorReverseOp<ReverseDimensions, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^struct TensorEvaluator<const TensorReverseOp<ReverseDimensions, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op,$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct TensorEvaluator<const TensorScanOp<Op, ArgType>, Device> {$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^struct TensorEvaluator<TensorShufflingOp<Shuffle, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^struct TensorEvaluator<const TensorShufflingOp<Shuffle, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^struct TensorEvaluator<TensorStridingOp<Strides, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^struct TensorEvaluator<const TensorStridingOp<Strides, ArgType>, Device>$/;"	s	namespace:Eigen
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorEvaluator(const XprType& op, const Device& device)$/;"	f	struct:Eigen::TensorEvaluator
TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^struct TensorEvaluator<const TensorVolumePatchOp<Planes, Rows, Cols, ArgType>, Device>$/;"	s	namespace:Eigen
TensorExecutor	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^class TensorExecutor$/;"	c	namespace:Eigen::internal
TensorExecutor	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^class TensorExecutor<Expression, DefaultDevice, true>$/;"	c	namespace:Eigen::internal
TensorExecutor	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^class TensorExecutor<Expression, GpuDevice, Vectorizable> {$/;"	c	namespace:Eigen::internal
TensorExecutor	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^class TensorExecutor<Expression, SyclDevice, Vectorizable> {$/;"	c	namespace:Eigen::internal
TensorExecutor	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^class TensorExecutor<Expression, ThreadPoolDevice, Vectorizable> {$/;"	c	namespace:Eigen::internal
TensorFFTOp	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorFFTOp(const XprType& expr, const FFT& fft)$/;"	f	class:Eigen::TensorFFTOp
TensorFFTOp	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^class TensorFFTOp : public TensorBase<TensorFFTOp<FFT, XprType, FFTResultType, FFTDir>, ReadOnlyAccessors> {$/;"	c	namespace:Eigen
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorFixedSize(Self&& other)$/;"	f	class:Eigen::TensorFixedSize
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize()$/;"	f	class:Eigen::TensorFixedSize
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize(const Self& other)$/;"	f	class:Eigen::TensorFixedSize
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize(const TensorBase<OtherDerived, ReadOnlyAccessors>& other)$/;"	f	class:Eigen::TensorFixedSize
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize(const TensorBase<OtherDerived, WriteAccessors>& other)$/;"	f	class:Eigen::TensorFixedSize
TensorFixedSize	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^class TensorFixedSize : public TensorBase<TensorFixedSize<Scalar_, Dimensions_, Options_, IndexType> >$/;"	c	namespace:Eigen
TensorForcedEvalOp	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorForcedEvalOp(const XprType& expr)$/;"	f	class:Eigen::TensorForcedEvalOp
TensorForcedEvalOp	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^class TensorForcedEvalOp : public TensorBase<TensorForcedEvalOp<XprType, MakePointer_>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorGeneratorOp	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorGeneratorOp(const XprType& expr, const Generator& generator)$/;"	f	class:Eigen::TensorGeneratorOp
TensorGeneratorOp	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^class TensorGeneratorOp : public TensorBase<TensorGeneratorOp<Generator, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorImagePatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorImagePatchOp(const XprType& expr, DenseIndex patch_rows, DenseIndex patch_cols,$/;"	f	class:Eigen::TensorImagePatchOp
TensorImagePatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^class TensorImagePatchOp : public TensorBase<TensorImagePatchOp<Rows, Cols, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorIndex	bench/tensors/tensor_benchmarks.h	/^typedef int TensorIndex;$/;"	t
TensorIndexTupleOp	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIndexTupleOp(const XprType& expr)$/;"	f	class:Eigen::TensorIndexTupleOp
TensorIndexTupleOp	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^class TensorIndexTupleOp : public TensorBase<TensorIndexTupleOp<XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorInflationOp	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorInflationOp(const XprType& expr, const Strides& strides)$/;"	f	class:Eigen::TensorInflationOp
TensorInflationOp	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^class TensorInflationOp : public TensorBase<TensorInflationOp<Strides, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor() {$/;"	f	class:Eigen::internal::TensorIntDivisor
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor() {$/;"	f	struct:Eigen::internal::TensorIntDivisor
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorIntDivisor(const T divider) {$/;"	f	struct:Eigen::internal::TensorIntDivisor
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC TensorIntDivisor(int32_t divider)  {$/;"	f	class:Eigen::internal::TensorIntDivisor
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^class TensorIntDivisor<int32_t, true> {$/;"	c	namespace:Eigen::internal
TensorIntDivisor	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^struct TensorIntDivisor {$/;"	s	namespace:Eigen::internal
TensorLayoutSwapOp	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorLayoutSwapOp(const XprType& expr)$/;"	f	class:Eigen::TensorLayoutSwapOp
TensorLayoutSwapOp	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^class TensorLayoutSwapOp : public TensorBase<TensorLayoutSwapOp<XprType>, WriteAccessors>$/;"	c	namespace:Eigen
TensorLazyBaseEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorLazyBaseEvaluator() : m_refcount(0) { }$/;"	f	class:Eigen::internal::TensorLazyBaseEvaluator
TensorLazyBaseEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^class TensorLazyBaseEvaluator {$/;"	c	namespace:Eigen::internal
TensorLazyEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorLazyEvaluator(const Expr& expr, const Device& device) : Base(expr, device) {$/;"	f	class:Eigen::internal::TensorLazyEvaluator
TensorLazyEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^class TensorLazyEvaluator : public internal::conditional<bool(internal::is_lvalue<Expr>::value),$/;"	c	namespace:Eigen::internal
TensorLazyEvaluatorReadOnly	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorLazyEvaluatorReadOnly(const Expr& expr, const Device& device) : m_impl(expr, device), m_dummy(Scalar(0)) {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
TensorLazyEvaluatorReadOnly	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^class TensorLazyEvaluatorReadOnly : public TensorLazyBaseEvaluator<Dimensions, typename TensorEvaluator<Expr, Device>::Scalar> {$/;"	c	namespace:Eigen::internal
TensorLazyEvaluatorWritable	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorLazyEvaluatorWritable(const Expr& expr, const Device& device) : Base(expr, device) {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorWritable
TensorLazyEvaluatorWritable	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^class TensorLazyEvaluatorWritable : public TensorLazyEvaluatorReadOnly<Dimensions, Expr, Device> {$/;"	c	namespace:Eigen::internal
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PlainObjectType& tensor)$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, const Dimensions& dimensions)$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr) : m_data(dataPtr), m_dimensions() {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2) : m_data(dataPtr), m_dimensions(dim1, dim2) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3, dim4) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index dim1, Index dim2, Index dim3, Index dim4, Index dim5) : m_data(dataPtr), m_dimensions(dim1, dim2, dim3, dim4, dim5) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension) : m_data(dataPtr), m_dimensions(firstDimension) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, Index firstDimension, IndexTypes... otherDimensions) : m_data(dataPtr), m_dimensions(firstDimension, otherDimensions...) {$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorMap(PointerArgType dataPtr, const array<Index, NumIndices>& dimensions)$/;"	f	class:Eigen::TensorMap
TensorMap	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^template<typename PlainObjectType, int Options_, template <class> class MakePointer_> class TensorMap : public TensorBase<TensorMap<PlainObjectType, Options_, MakePointer_> >$/;"	c	namespace:Eigen
TensorOpCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  TensorOpCost() : bytes_loaded_(0), bytes_stored_(0), compute_cycles_(0) {}$/;"	f	class:Eigen::TensorOpCost
TensorOpCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  TensorOpCost(double bytes_loaded, double bytes_stored, double compute_cycles)$/;"	f	class:Eigen::TensorOpCost
TensorOpCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  TensorOpCost(double bytes_loaded, double bytes_stored, double compute_cycles,$/;"	f	class:Eigen::TensorOpCost
TensorOpCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^class TensorOpCost {$/;"	c	namespace:Eigen
TensorPaddingOp	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorPaddingOp(const XprType& expr, const PaddingDimensions& padding_dims, const Scalar padding_value)$/;"	f	class:Eigen::TensorPaddingOp
TensorPaddingOp	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^class TensorPaddingOp : public TensorBase<TensorPaddingOp<PaddingDimensions, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorPatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorPatchOp(const XprType& expr, const PatchDim& patch_dims)$/;"	f	class:Eigen::TensorPatchOp
TensorPatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^class TensorPatchOp : public TensorBase<TensorPatchOp<PatchDim, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorPrinter	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^struct TensorPrinter {$/;"	s	namespace:Eigen::internal
TensorPrinter	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^struct TensorPrinter<Tensor, 0> {$/;"	s	namespace:Eigen::internal
TensorPrinter	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^struct TensorPrinter<Tensor, 1> {$/;"	s	namespace:Eigen::internal
TensorReductionOp	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    TensorReductionOp(const XprType& expr, const Dims& dims) : m_expr(expr), m_dims(dims)$/;"	f	class:Eigen::TensorReductionOp
TensorReductionOp	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    TensorReductionOp(const XprType& expr, const Dims& dims, const Op& reducer) : m_expr(expr), m_dims(dims), m_reducer(reducer)$/;"	f	class:Eigen::TensorReductionOp
TensorReductionOp	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^class TensorReductionOp : public TensorBase<TensorReductionOp<Op, Dims, XprType, MakePointer_>, ReadOnlyAccessors> {$/;"	c	namespace:Eigen
TensorRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE TensorRef() : m_evaluator(NULL) {$/;"	f	class:Eigen::TensorRef
TensorRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE TensorRef(const Expression& expr) : m_evaluator(new internal::TensorLazyEvaluator<Dimensions, Expression, DefaultDevice>(expr, DefaultDevice())) {$/;"	f	class:Eigen::TensorRef
TensorRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    TensorRef(const TensorRef& other) : m_evaluator(other.m_evaluator) {$/;"	f	class:Eigen::TensorRef
TensorRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^template<typename PlainObjectType> class TensorRef : public TensorBase<TensorRef<PlainObjectType> >$/;"	c	namespace:Eigen
TensorReshapingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorReshapingOp(const XprType& expr, const NewDimensions& dims)$/;"	f	class:Eigen::TensorReshapingOp
TensorReshapingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^class TensorReshapingOp : public TensorBase<TensorReshapingOp<NewDimensions, XprType>, WriteAccessors>$/;"	c	namespace:Eigen
TensorReverseOp	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorReverseOp($/;"	f	class:Eigen::TensorReverseOp
TensorReverseOp	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^class TensorReverseOp : public TensorBase<TensorReverseOp<ReverseDimensions,$/;"	c	namespace:Eigen
TensorScanOp	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorScanOp($/;"	f	class:Eigen::TensorScanOp
TensorScanOp	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^class TensorScanOp$/;"	c	namespace:Eigen
TensorScanProdOp	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef TensorScanOp<internal::ProdReducer<CoeffReturnType>, const Derived> TensorScanProdOp;$/;"	t	class:Eigen::TensorBase
TensorScanSumOp	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    typedef TensorScanOp<internal::SumReducer<CoeffReturnType>, const Derived> TensorScanSumOp;$/;"	t	class:Eigen::TensorBase
TensorSelectOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    TensorSelectOp(const IfXprType& a_condition,$/;"	f	class:Eigen::TensorSelectOp
TensorSelectOp	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^class TensorSelectOp : public TensorBase<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorShufflingOp	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorShufflingOp(const XprType& expr, const Shuffle& shuffle)$/;"	f	class:Eigen::TensorShufflingOp
TensorShufflingOp	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^class TensorShufflingOp : public TensorBase<TensorShufflingOp<Shuffle, XprType> >$/;"	c	namespace:Eigen
TensorSlicingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorSlicingOp(const XprType& expr, const StartIndices& indices, const Sizes& sizes)$/;"	f	class:Eigen::TensorSlicingOp
TensorSlicingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^class TensorSlicingOp : public TensorBase<TensorSlicingOp<StartIndices, Sizes, XprType> >$/;"	c	namespace:Eigen
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC TensorStorage() : m_data(0), m_dimensions() {$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC TensorStorage(DenseIndex... indices) : m_dimensions(indices...) {$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC TensorStorage(Index size, const array<Index, NumIndices_>& dimensions)$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC TensorStorage(const Self& other)$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC TensorStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_STRONG_INLINE TensorStorage() {$/;"	f	class:Eigen::TensorStorage
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^class TensorStorage$/;"	c	namespace:Eigen
TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^class TensorStorage<T, DSizes<IndexType, NumIndices_>, Options_>$/;"	c	namespace:Eigen
TensorStridingOp	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorStridingOp(const XprType& expr, const Strides& dims)$/;"	f	class:Eigen::TensorStridingOp
TensorStridingOp	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^class TensorStridingOp : public TensorBase<TensorStridingOp<Strides, XprType> >$/;"	c	namespace:Eigen
TensorStridingSlicingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorStridingSlicingOp($/;"	f	class:Eigen::TensorStridingSlicingOp
TensorStridingSlicingOp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^class TensorStridingSlicingOp : public TensorBase<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >$/;"	c	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorSycl	unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h	/^namespace TensorSycl {$/;"	n	namespace:Eigen
TensorTupleReducerOp	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorTupleReducerOp(const XprType& expr,$/;"	f	class:Eigen::TensorTupleReducerOp
TensorTupleReducerOp	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^class TensorTupleReducerOp : public TensorBase<TensorTupleReducerOp<ReduceOp, Dims, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TensorUInt128	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  TensorUInt128(HIGH y, LOW x) : high(y), low(x) { }$/;"	f	struct:Eigen::internal::TensorUInt128
TensorUInt128	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  TensorUInt128(const TensorUInt128<OTHER_HIGH, OTHER_LOW>& other) : high(other.high), low(other.low) {$/;"	f	struct:Eigen::internal::TensorUInt128
TensorUInt128	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  explicit TensorUInt128(const T& x) : high(0), low(x) {$/;"	f	struct:Eigen::internal::TensorUInt128
TensorUInt128	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^struct TensorUInt128$/;"	s	namespace:Eigen::internal
TensorVolumePatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorVolumePatchOp(const XprType& expr, DenseIndex patch_planes, DenseIndex patch_rows, DenseIndex patch_cols,$/;"	f	class:Eigen::TensorVolumePatchOp
TensorVolumePatchOp	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^class TensorVolumePatchOp : public TensorBase<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, ReadOnlyAccessors>$/;"	c	namespace:Eigen
TestFunc1	unsupported/test/autodiff.cpp	/^  TestFunc1() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:TestFunc1
TestFunc1	unsupported/test/autodiff.cpp	/^  TestFunc1(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:TestFunc1
TestFunc1	unsupported/test/autodiff.cpp	/^struct TestFunc1$/;"	s	file:
TestFunc1	unsupported/test/forward_adolc.cpp	/^  TestFunc1() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:TestFunc1
TestFunc1	unsupported/test/forward_adolc.cpp	/^  TestFunc1(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:TestFunc1
TestFunc1	unsupported/test/forward_adolc.cpp	/^struct TestFunc1$/;"	s	file:
TestNew1	test/unalignedassert.cpp	/^  TestNew1() : m(20,20) {}$/;"	f	struct:TestNew1
TestNew1	test/unalignedassert.cpp	/^struct TestNew1$/;"	s	file:
TestNew2	test/unalignedassert.cpp	/^struct TestNew2$/;"	s	file:
TestNew3	test/unalignedassert.cpp	/^struct TestNew3$/;"	s	file:
TestNew4	test/unalignedassert.cpp	/^struct TestNew4$/;"	s	file:
TestNew5	test/unalignedassert.cpp	/^struct TestNew5$/;"	s	file:
TestNew6	test/unalignedassert.cpp	/^struct TestNew6$/;"	s	file:
TestQueue	unsupported/test/cxx11_eventcount.cpp	/^  TestQueue() : val_() {}$/;"	f	struct:TestQueue
TestQueue	unsupported/test/cxx11_eventcount.cpp	/^struct TestQueue {$/;"	s	file:
TgtCoeffRatio	Eigen/src/Core/GenericPacketMath.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon499
TgtCoeffRatio	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon646
TgtCoeffRatio	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon647
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon675
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon677
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon678
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon679
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon680
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon681
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon682
TgtCoeffRatio	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    TgtCoeffRatio = 2$/;"	e	enum:Eigen::internal::type_casting_traits::__anon676
TgtCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon727
TgtCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon728
TgtCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 1$/;"	e	enum:Eigen::internal::type_casting_traits::__anon729
TgtCoeffRatio	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    TgtCoeffRatio = 2$/;"	e	enum:Eigen::internal::type_casting_traits::__anon730
ThenMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits
ThenNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename ThenXprType::Nested ThenNested;$/;"	t	struct:Eigen::internal::traits
Thread	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  typedef typename Environment::EnvThread Thread;$/;"	t	class:Eigen::NonBlockingThreadPoolTempl
Thread	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  typedef typename Environment::EnvThread Thread;$/;"	t	class:Eigen::SimpleThreadPoolTempl
ThreadPool	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^typedef NonBlockingThreadPool ThreadPool;$/;"	t	namespace:Eigen
ThreadPoolDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  ThreadPoolDevice(ThreadPoolInterface* pool, int num_cores) : pool_(pool), num_threads_(num_cores) { }$/;"	f	struct:Eigen::ThreadPoolDevice
ThreadPoolDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^struct ThreadPoolDevice {$/;"	s	namespace:Eigen
ThreadPoolInterface	unsupported/Eigen/CXX11/src/ThreadPool/ThreadPoolInterface.h	/^class ThreadPoolInterface {$/;"	c	namespace:Eigen
Three	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t Three = tensor_symmetry_num_indices<Sym...>::value;$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
Through	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
TimeLine	demos/opengl/quaternion_demo.h	/^    typedef std::map<float,Frame> TimeLine;$/;"	t	class:RenderingWidget
TmpFlags	Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon258
TmpMatrixType	Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, 0, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT
ToRotationMatrixWrapper	bench/geometry.cpp	/^  ToRotationMatrixWrapper(const T& o) : object(o) {}$/;"	f	struct:ToRotationMatrixWrapper
ToRotationMatrixWrapper	bench/geometry.cpp	/^template<typename T> struct ToRotationMatrixWrapper$/;"	s	file:
TolTooSmall	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        TolTooSmall = 3,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
TooManyFunctionEvaluation	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        TooManyFunctionEvaluation = 5,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
TooManyFunctionEvaluation	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        TooManyFunctionEvaluation = 2,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
TooManyFunctionEvaluation	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        TooManyFunctionEvaluation = 5,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
TopLeft	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftCeil	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftFloor	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightFloor	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TotalLeaves	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  static const size_t TotalLeaves = LeafCount<Expr>::Count;$/;"	m	struct:Eigen::TensorSycl::internal::createPlaceHolderExpression
TotalSize	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DenseIndex TotalSize() const {$/;"	f	struct:Eigen::DSizes
TotalSize	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t TotalSize() {$/;"	f	struct:Eigen::Sizes
TrOptions	Eigen/src/SVD/JacobiSVD.h	/^    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon781
TrOptions	Eigen/src/SVD/JacobiSVD.h	/^    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon782
TrackMode	demos/opengl/quaternion_demo.h	/^    enum TrackMode {$/;"	g	class:RenderingWidget
Trackball	demos/opengl/trackball.h	/^    Trackball() : mpCamera(0) {}$/;"	f	class:Trackball
Trackball	demos/opengl/trackball.h	/^class Trackball$/;"	c
Traits	Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT
Traits	Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT
Traits	Eigen/src/Core/BooleanRedux.h	/^  typedef typename Derived::ExpressionTraits Traits;$/;"	t	struct:Eigen::internal::all_unroller
Traits	Eigen/src/Core/BooleanRedux.h	/^  typedef typename Derived::ExpressionTraits Traits;$/;"	t	struct:Eigen::internal::any_unroller
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper
Traits	Eigen/src/Core/Ref.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper
Traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel
Traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space
Traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef gebp_traits<RhsScalar,LhsScalar> Traits;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
Traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename Gemm::Traits Traits;$/;"	t	struct:Eigen::internal::gemm_functor
Traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
Traits	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel
Traits	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix
Traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT
Traits	Eigen/src/SparseCore/SparseRef.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref
Traits	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef typename internal::gebp_traits<LhsScalar, RhsScalar> Traits;$/;"	t	struct:Eigen::TensorEvaluator
Traits	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typedef typename internal::traits<Derived> Traits;$/;"	t	class:Eigen::KroneckerProductBase
TraitsBase	Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> > TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	Eigen/src/SparseCore/SparseMap.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform()$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
TransformMatrix	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType TransformMatrix;$/;"	t	struct:Eigen::internal::transform_right_product_impl
TransformTimeDiagonalMode	Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon266
TransformTimeDiagonalReturnType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform
TransformTraits	Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
TransformType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::generic_product_impl
TransformType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
TransformType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
Translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC Translation() {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation2d	Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
TranslationPart	Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationType	Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
Transpose	Eigen/src/Core/Transpose.h	/^    explicit inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Transpose
Transpose	Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen
Transpose	Eigen/src/Core/Transpositions.h	/^    explicit Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose
Transpose	Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Transpose	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon616
Transpose	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon614
TransposeImpl	Eigen/src/Core/Transpose.h	/^class TransposeImpl$/;"	c	namespace:Eigen
TransposeImpl	Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen
TransposeImpl	Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen
TransposeImpl_base	Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl_base	Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeMode	Eigen/src/Core/SelfAdjointView.h	/^      TransposeMode = ((Mode & Upper) ? Lower : 0) | ((Mode & Lower) ? Upper : 0)$/;"	e	enum:Eigen::SelfAdjointView::__anon481
TransposeMode	Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon454
TransposeMode	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^      TransposeMode = ((Mode & Upper) ? Lower : 0) | ((Mode & Lower) ? Upper : 0),$/;"	e	enum:Eigen::SparseSelfAdjointView::__anon834
TransposeReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Transpose<Derived> TransposeReturnType;$/;"	t	class:Eigen::DenseBase
TransposeReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef SelfAdjointView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;$/;"	t	class:Eigen::SelfAdjointView
TransposeReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;$/;"	t	class:Eigen::TriangularView
TransposeReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Transpose<Derived> TransposeReturnType;$/;"	t	class:Eigen::SparseMatrixBase
TransposeTypeWithSameStorageOrder	Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
TransposedSkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef SkylineMatrix<Scalar, (Flags&~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0) > TransposedSkylineMatrix;$/;"	t	class:Eigen::SkylineMatrix
TransposedSparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix
TransposedSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef DynamicSparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0), StorageIndex> TransposedSparseMatrix;$/;"	t	class:Eigen::DynamicSparseMatrix
TranspositionType	Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT
TranspositionType	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose
TranspositionType	Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU
Transpositions	Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex> >$/;"	c	namespace:Eigen
TranspositionsBase	Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
TranspositionsShape	Eigen/src/Core/util/Constants.h	/^struct TranspositionsShape    { static std::string debugName() { return "TranspositionsShape"; } };$/;"	s	namespace:Eigen
TranspositionsStorage	Eigen/src/Core/util/Constants.h	/^struct TranspositionsStorage {};$/;"	s	namespace:Eigen
TranspositionsWrapper	Eigen/src/Core/Transpositions.h	/^    explicit inline TranspositionsWrapper(IndicesType& indices)$/;"	f	class:Eigen::TranspositionsWrapper
TranspositionsWrapper	Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen
Traversal	Eigen/src/Core/AssignEvaluator.h	/^    Traversal = int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon508
Traversal	Eigen/src/Core/Assign_MKL.h	/^      Traversal = MightLinearize ? LinearTraversal : DefaultTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon747
Traversal	Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon484
TraversalSize	Eigen/src/Core/CoreEvaluators.h	/^    TraversalSize = Direction==int(Vertical) ? int(ArgType::RowsAtCompileTime) :  int(ArgType::ColsAtCompileTime)$/;"	e	enum:Eigen::internal::evaluator::__anon766
TraversalSize	Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? MatrixType::RowsAtCompileTime :  MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon637
TraversalType	Eigen/src/Core/util/Constants.h	/^enum TraversalType {$/;"	g	namespace:Eigen
TreeTest	unsupported/test/BVH.cpp	/^struct TreeTest$/;"	s	file:
Triangular2Dense	Eigen/src/Core/TriangularMatrix.h	/^struct Triangular2Dense         {};$/;"	s	namespace:Eigen::internal
Triangular2Triangular	Eigen/src/Core/TriangularMatrix.h	/^struct Triangular2Triangular    {};$/;"	s	namespace:Eigen::internal
TriangularBase	Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase
TriangularBase	Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
TriangularShape	Eigen/src/Core/util/Constants.h	/^struct TriangularShape        { static std::string debugName() { return "TriangularShape"; } };$/;"	s	namespace:Eigen
TriangularView	Eigen/src/Core/TriangularMatrix.h	/^    explicit inline TriangularView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView
TriangularView	Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen
TriangularViewImpl	Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularViewImpl<_MatrixType,_Mode,Dense>$/;"	c	namespace:Eigen
TriangularViewImpl	Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, unsigned int Mode> class TriangularViewImpl<MatrixType,Mode,Sparse>$/;"	c	namespace:Eigen
TriangularViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
TriangularViewType	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularView<_MatrixType, _Mode> TriangularViewType;$/;"	t	class:Eigen::TriangularViewImpl
TriangularViewType	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef TriangularView<MatrixType,Mode> TriangularViewType;$/;"	t	class:Eigen::TriangularViewImpl
TridiagonalMatrix	Eigen/src/Core/BandMatrix.h	/^    explicit TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix
TridiagonalMatrix	Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    explicit Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    explicit Tridiagonalization(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
TridiagonalizationMatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
TridiagonalizationMatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal
TridiagonalizationType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const StorageIndex& i, const StorageIndex& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Triplet	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef typename Iterator::value_type Triplet;$/;"	t	struct:Eigen::internal::TripletComp
TripletComp	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^struct TripletComp$/;"	s	namespace:Eigen::internal
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  Tuple() : first(), second() {}$/;"	f	struct:Eigen::Tuple
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  Tuple(const U& f, const V& s) : first(f), second(s) {}$/;"	f	struct:Eigen::Tuple
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^template <typename U, typename V> struct Tuple {$/;"	s	namespace:Eigen
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  Tuple(T t, Ts... ts) : head(t), tail(ts...) {}$/;"	f	struct:utility::tuple::Tuple
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct Tuple {};$/;"	s	namespace:utility::tuple
Tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^struct Tuple<T, Ts...> {$/;"	s	namespace:utility::tuple
TupleType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename TensorIndexTupleOp<ArgType>::CoeffReturnType TupleType;$/;"	t	struct:Eigen::TensorEvaluator
Two	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Two = Two_;$/;"	m	struct:Eigen::AntiHermiticity
Two	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Two = Two_;$/;"	m	struct:Eigen::AntiSymmetry
Two	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Two = Two_;$/;"	m	struct:Eigen::Hermiticity
Two	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static int Two = Two_;$/;"	m	struct:Eigen::Symmetry
Two	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t Two = static_cast<std::size_t>(Two_);$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
Type	Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                        isHorizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType
Type	Eigen/src/Core/VectorwiseOp.h	/^                        isVertical   ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::OppositeExtendedType
Type	Eigen/src/Core/VectorwiseOp.h	/^      typedef PartialReduxExpr<ExpressionType, internal::member_lpnorm<p,RealScalar>,Direction> Type;$/;"	t	struct:Eigen::VectorwiseOp::LpNormReturnType
Type	Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Type	Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
Type	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    typedef ActualMatrixType Type;$/;"	t	struct:Eigen::internal::generic_matrix_wrapper::ConstSelfAdjointViewReturnType
Type	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^    typedef typename ActualMatrixType::template ConstSelfAdjointViewReturnType<UpLo>::Type Type;$/;"	t	struct:Eigen::internal::generic_matrix_wrapper::ConstSelfAdjointViewReturnType
Type	Eigen/src/SparseCore/SparseMatrixBase.h	/^                          > Type;$/;"	t	struct:Eigen::SparseMatrixBase::CwiseProductDenseReturnType
Type	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SparseSelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::SparseMatrixBase::ConstSelfAdjointViewReturnType
Type	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SparseSelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::SparseMatrixBase::SelfAdjointViewReturnType
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct ConstFixedBlockXpr { typedef Block<const Derived,Rows,Cols> Type; };$/;"	t	struct:ConstFixedBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Rows, int Cols> struct FixedBlockXpr { typedef Block<Derived,Rows,Cols> Type; };$/;"	t	struct:FixedBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:ConstFixedSegmentReturnType
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:FixedSegmentReturnType
Type	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^template<class NewType> struct CastXpr { typedef typename internal::cast_return_type<Derived,const CwiseUnaryOp<internal::scalar_cast_op<Scalar, NewType>, const Derived> >::type Type; };$/;"	t	struct:CastXpr
Type	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    typedef typename MakePointerT::Type Type;$/;"	t	struct:Eigen::internal::traits::MakePointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    typedef typename MakePointerT::Type Type;$/;"	t	struct:Eigen::internal::traits::MakePointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  typedef T* Type;$/;"	t	struct:Eigen::MakePointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typedef typename MakePointerT::Type Type;$/;"	t	struct:Eigen::internal::traits::MakePointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^  typedef T Type;$/;"	t	struct:Eigen::TensorSycl::internal::GetType
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^  typedef const T Type;$/;"	t	struct:Eigen::TensorSycl::internal::GetType
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^  typedef typename cl::sycl::global_ptr<T>::pointer_t Type;$/;"	t	struct:MakeGlobalPointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^  typedef typename cl::sycl::local_ptr<T>::pointer_t Type;$/;"	t	struct:MakeLocalPointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^  typedef typename GetType<IsConst, NonOpCategory<typename ConvertToDeviceExpression<Args>::Type, MakeGlobalPointer> >::Type Type;$/;"	t	struct:Eigen::TensorSycl::internal::DeviceConvertor
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^  typedef typename GetType<IsConst, NonOpCategory<typename ConvertToDeviceExpression<Args>::Type...> >::Type Type;$/;"	t	struct:Eigen::TensorSycl::internal::NonOpConversion
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef Category<OP, T... > Type;$/;"	t	struct:Eigen::TensorSycl::internal::CategoryHelper
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef Category<T... > Type;$/;"	t	struct:Eigen::TensorSycl::internal::CategoryHelper
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef Scalar Type;$/;"	t	struct:Eigen::TensorSycl::internal::PlaceHolder
Type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^  typedef typename PlaceHolderExpression<Expr, TotalLeaves - 1>::Type Type;$/;"	t	struct:Eigen::TensorSycl::internal::createPlaceHolderExpression
Type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    typedef T* Type;$/;"	t	struct:Eigen::internal::traits::MakePointer
Type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    typedef typename MakePointerT::Type Type;$/;"	t	struct:Eigen::internal::traits::MakePointer
Type	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef SkylineProduct<LhsNested, RhsNested, ProductMode> Type;$/;"	t	struct:Eigen::SkylineProductReturnType
Type	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef google::dense_hash_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::GoogleDenseHashMapTraits
Type	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef google::sparse_hash_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::GoogleSparseHashMapTraits
Type	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef std::map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::StdMapTraits
Type	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef std::unordered_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::StdUnorderedMapTraits
U	doc/snippets/RealSchur_RealSchur_MatrixType.cpp	/^MatrixXd U = schur.matrixU();$/;"	v
UBLAS_INTERFACE_HH	bench/btl/libs/ublas/ublas_interface.hh	21;"	d
UBlasSparse	bench/BenchSparseUtil.h	/^typedef boost::numeric::ublas::compressed_matrix<Scalar,boost::numeric::ublas::column_major> UBlasSparse;$/;"	t
UCOL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
UIntPtr	Eigen/src/Core/util/Meta.h	/^typedef std::uintptr_t UIntPtr;$/;"	t	namespace:Eigen::internal
ULVL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
UMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>          UMatrixType;$/;"	t	class:Eigen::SuperLU
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
UNARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	63;"	d
UNARYCATEGORY	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	77;"	d
UNIT	blas/common.h	35;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_CONVERT_TO_DEVICE_EXPRESSION_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	23;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_EXPR_CONSTRUCTOR_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	23;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_EXTRACT_ACCESSOR_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	33;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_EXTRACT_FUNCTORS_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	23;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_H	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	15;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_LEAF_COUNT_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	23;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_PLACEHOLDER_EXPR_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	23;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_SYCLRUN_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h	24;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSORSYCL_TUPLE_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	22;"	d
UNSUPPORTED_EIGEN_CXX11_SRC_TENSOR_TENSOR_REDUCTION_SYCL_HPP	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	23;"	d
UP	blas/common.h	31;"	d
UPLO	blas/common.h	48;"	d
USEC_IN_SEC	bench/btl/generic_bench/timers/portable_timer.hh	31;"	d
USUB	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon875
UTILITIES_H	bench/btl/generic_bench/utils/utilities.h	13;"	d
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    explicit UmfPackLU(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : public SparseSolverBase<UmfPackLU<_MatrixType> >$/;"	c	namespace:Eigen
UmfpackControl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Array<double, UMFPACK_CONTROL, 1> UmfpackControl;$/;"	t	class:Eigen::UmfPackLU
UmfpackInfo	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Array<double, UMFPACK_INFO, 1> UmfpackInfo;$/;"	t	class:Eigen::UmfPackLU
UmfpackMatrixRef	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Ref<const UmfpackMatrixType, StandardCompressedFormat> UmfpackMatrixRef;$/;"	t	class:Eigen::UmfPackLU
UmfpackMatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU
Unaligned	Eigen/src/Core/util/Constants.h	/^  Unaligned=0,        \/**< Data pointer has no specific alignment. *\/$/;"	e	enum:Eigen::AlignmentType
UniformRandomGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE UniformRandomGenerator($/;"	f	class:Eigen::internal::UniformRandomGenerator
UniformRandomGenerator	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^template <typename T> class UniformRandomGenerator {$/;"	c	namespace:Eigen::internal
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Unit	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase
Unit	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index newSize, Index i)$/;"	f	class:Eigen::MatrixBase
UnitDiag	Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::UpLoType
UnitLower	Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::UpLoType
UnitRandom	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC Quaternion<Scalar,Options> Quaternion<Scalar,Options>::UnitRandom()$/;"	f	class:Eigen::Quaternion
UnitUpper	Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::UpLoType
UnitW	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase
UnitX	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase
UnitY	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase
UnitZ	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase
Unpark	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  void Unpark(Waiter* waiters) {$/;"	f	class:Eigen::EventCount
Unroll	Eigen/src/Core/ProductEvaluators.h	/^    Unroll = CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::internal::product_evaluator::__anon428
Unrolling	Eigen/src/Core/AssignEvaluator.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon510
Unrolling	Eigen/src/Core/Redux.h	/^    Unrolling = Cost <= UnrollingLimit ? CompleteUnrolling : NoUnrolling$/;"	e	enum:Eigen::internal::redux_traits::__anon486
Unrolling	Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon518
UnrollingLimit	Eigen/src/Core/AssignEvaluator.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * ActualPacketSize,$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon509
UnrollingLimit	Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon485
UnrollingType	Eigen/src/Core/util/Constants.h	/^enum UnrollingType {$/;"	g	namespace:Eigen
UnsignedTraits	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  struct UnsignedTraits {$/;"	s	namespace:Eigen::internal::__anon139
UnsignedType	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  typedef typename DividerTraits<T>::type UnsignedType;$/;"	t	struct:Eigen::internal::TensorIntDivisor
Unusable	Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable
Unusable	Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue
Unusable	Eigen/src/Core/ReturnByValue.h	67;"	d
Unusable	Eigen/src/Core/ReturnByValue.h	76;"	d
UpLo	Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon242
UpLo	Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon244
UpLo	Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon280
UpLo	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon238
UpLo	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::IncompleteCholesky::__anon239
UpLo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon215
UpLo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon214
UpLo	Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon789
UpLo	Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon788
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon223
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon222
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon221
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon216
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon218
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon219
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon220
UpLo	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        enum {UpLo = _UpLo};$/;"	e	enum:Eigen::MINRES::__anon79
UpLoType	Eigen/src/Core/util/Constants.h	/^enum UpLoType {$/;"	g	namespace:Eigen
Upper	Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::UpLoType
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^    explicit UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
UpperTriangularType	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > UpperTriangularType;$/;"	t	class:Eigen::HybridNonLinearSolver
UseDirectOffsets	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^    UseDirectOffsets = ParentMapper::DirectOffsets && (side == Lhs) && inner_dim_contiguous && (array_size<contract_t>::value > 0)$/;"	e	enum:Eigen::internal::TensorContractionSubMapper::__anon135
UserAsked	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        UserAsked = 9$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
UserAsked	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        UserAsked = 6$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
UserAsked	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        UserAsked = 9$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
UserReducer	unsupported/test/cxx11_tensor_reduction.cpp	/^  UserReducer(float offset) : offset_(offset) {}$/;"	f	struct:UserReducer
UserReducer	unsupported/test/cxx11_tensor_reduction.cpp	/^struct UserReducer {$/;"	s	file:
V	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^MatrixXcd V = es.eigenvectors();$/;"	v
V	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^MatrixXd V = es.pseudoEigenvectors();$/;"	v
V	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^MatrixXd V = es.eigenvectors();$/;"	v
VECSIZE	bench/benchmarkXcwise.cpp	14;"	d	file:
VECTYPE	bench/benchmarkXcwise.cpp	10;"	d	file:
VERIFY	test/main.h	325;"	d
VERIFY_ALIGNED_UNALIGNED_COUNT	test/unalignedcount.cpp	20;"	d	file:
VERIFY_EQUAL	unsupported/test/cxx11_tensor_uint128.cpp	/^void VERIFY_EQUAL(TensorUInt128<uint64_t, uint64_t> actual, uint128_t expected) {$/;"	f
VERIFY_EVALUATION_COUNT	test/main.h	106;"	d
VERIFY_EVALUATION_COUNT	test/sparse_product.cpp	27;"	d	file:
VERIFY_EVALUATION_COUNT	test/sparse_ref.cpp	27;"	d	file:
VERIFY_GE	test/main.h	327;"	d
VERIFY_IS_APPROX	test/integer_types.cpp	14;"	d	file:
VERIFY_IS_APPROX	test/integer_types.cpp	15;"	d	file:
VERIFY_IS_APPROX	test/main.h	333;"	d
VERIFY_IS_APPROX_ABS	unsupported/test/matrix_function.cpp	15;"	d	file:
VERIFY_IS_APPROX_EVALUATOR	test/evaluators.cpp	101;"	d	file:
VERIFY_IS_APPROX_EVALUATOR2	test/evaluators.cpp	102;"	d	file:
VERIFY_IS_APPROX_OR_LESS_THAN	test/main.h	337;"	d
VERIFY_IS_EQUAL	test/main.h	331;"	d
VERIFY_IS_EQUAL	test/ref.cpp	27;"	d	file:
VERIFY_IS_EQUAL	test/ref.cpp	28;"	d	file:
VERIFY_IS_MUCH_SMALLER_THAN	test/main.h	335;"	d
VERIFY_IS_NOT_APPROX	test/integer_types.cpp	16;"	d	file:
VERIFY_IS_NOT_APPROX	test/integer_types.cpp	17;"	d	file:
VERIFY_IS_NOT_APPROX	test/main.h	334;"	d
VERIFY_IS_NOT_APPROX_OR_LESS_THAN	test/main.h	338;"	d
VERIFY_IS_NOT_EQUAL	test/main.h	332;"	d
VERIFY_IS_NOT_MUCH_SMALLER_THAN	test/main.h	336;"	d
VERIFY_IS_UNITARY	test/main.h	340;"	d
VERIFY_LE	test/main.h	328;"	d
VERIFY_MATRIX	unsupported/test/openglsupport.cpp	20;"	d	file:
VERIFY_META_SQRT	test/meta.cpp	80;"	d	file:
VERIFY_MIX_SCALAR	test/mixingtypes.cpp	47;"	d	file:
VERIFY_RAISES_ASSERT	test/main.h	216;"	d
VERIFY_RAISES_ASSERT	test/main.h	285;"	d
VERIFY_RAISES_STATIC_ASSERT	test/main.h	272;"	d
VERIFY_RAISES_STATIC_ASSERT	test/main.h	289;"	d
VERIFY_THROWS_BADALLOC	test/sizeoverflow.cpp	12;"	d	file:
VERIFY_TRANSPOSITION_COUNT	test/sparse_permutations.cpp	13;"	d	file:
VERIFY_TRSM	test/product_trsolve.cpp	12;"	d	file:
VERIFY_TRSM_ONTHERIGHT	test/product_trsolve.cpp	21;"	d	file:
VERIFY_UNIFORM	unsupported/test/openglsupport.cpp	31;"	d	file:
VERIFY_UNIFORMi	unsupported/test/openglsupport.cpp	44;"	d	file:
VIPair	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef internal::vector_int_pair<Scalar, Dim> VIPair;$/;"	t	class:Eigen::KdBVH
VIPairList	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<VIPair, aligned_allocator<VIPair> > VIPairList;$/;"	t	class:Eigen::KdBVH
VSX	Eigen/src/Core/util/Constants.h	/^    VSX = 0x3,$/;"	e	enum:Eigen::Architecture::Type
ValType	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  typedef T ValType;$/;"	t	struct:Eigen::internal::IndexTupleExtractor
ValType	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  typedef typename IndexTupleExtractor<N-1, O...>::ValType ValType;$/;"	t	struct:Eigen::internal::IndexTupleExtractor
ValueCondition	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^template <bool Conds,  size_t X , size_t Y > struct ValueCondition {$/;"	s	namespace:Eigen::TensorSycl::internal
ValueCondition	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^template<size_t X, size_t Y> struct ValueCondition<false, X , Y> {$/;"	s	namespace:Eigen::TensorSycl::internal
ValueType	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename Functor::ValueType ValueType;$/;"	t	class:Eigen::AutoDiffJacobian
ValueType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef Matrix<Scalar,Dynamic,1> ValueType;$/;"	t	struct:Eigen::SparseFunctor
ValueType	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:Eigen::DenseFunctor
ValueType	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::ValueType ValueType;$/;"	t	class:Eigen::NumericalDiff
ValueType	unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:Functor	file:
ValueType	unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:Functor	file:
ValueType	unsupported/test/autodiff.cpp	/^    typedef Matrix<Scalar, 2, 1> ValueType;$/;"	t	struct:integratorFunctor	file:
ValueType	unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:TestFunc1	file:
ValueType	unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:TestFunc1	file:
Values	bench/sparse_setter.cpp	/^typedef std::vector<float> Values;$/;"	t	file:
ValuesAtCompileTime	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^    ValuesAtCompileTime = ValueType::RowsAtCompileTime$/;"	e	enum:Eigen::AutoDiffJacobian::__anon81
ValuesAtCompileTime	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    ValuesAtCompileTime = Dynamic$/;"	e	enum:Eigen::SparseFunctor::__anon84
ValuesAtCompileTime	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    ValuesAtCompileTime = NY$/;"	e	enum:Eigen::DenseFunctor::__anon83
ValuesAtCompileTime	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        ValuesAtCompileTime = Functor::ValuesAtCompileTime$/;"	e	enum:Eigen::NumericalDiff::__anon82
ValuesAtCompileTime	unsupported/test/NonLinearOptimization.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:Functor::__anon23	file:
ValuesAtCompileTime	unsupported/test/NumericalDiff.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:Functor::__anon20	file:
ValuesAtCompileTime	unsupported/test/autodiff.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:TestFunc1::__anon24	file:
ValuesAtCompileTime	unsupported/test/forward_adolc.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:TestFunc1::__anon22	file:
Vec	bench/vdw_new.cpp	/^typedef Matrix<SCALAR, Eigen::Dynamic, 1> Vec;$/;"	t	file:
Vector	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner
Vector	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT
Vector	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase
Vector	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase
Vector	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU
Vector	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLU
Vector10d	test/unalignedassert.cpp	/^typedef Matrix<double,10,1> Vector10d;$/;"	t	file:
Vector12d	test/unalignedassert.cpp	/^typedef Matrix<double,12,1> Vector12d;$/;"	t	file:
Vector12f	test/unalignedassert.cpp	/^typedef Matrix<float, 12,1> Vector12f;$/;"	t	file:
Vector2	Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Vector2	Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,1> Vector2s;$/;"	t	class:Eigen::RealQZ
Vector3	Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase
Vector3	demos/opengl/quaternion_demo.cpp	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:EulerAngles	file:
Vector3	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      typedef Matrix<Scalar,3,1> Vector3; \/*!< the equivalent 3 dimension vector type *\/$/;"	t	class:Eigen::EulerAngles
Vector3s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealQZ
Vector3s	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur
Vector5d	test/unalignedassert.cpp	/^typedef Matrix<double, 5,1> Vector5d;$/;"	t	file:
Vector6d	test/unalignedassert.cpp	/^typedef Matrix<double, 6,1> Vector6d;$/;"	t	file:
Vector6f	test/unalignedassert.cpp	/^typedef Matrix<float,  6,1> Vector6f;$/;"	t	file:
Vector7d	test/unalignedassert.cpp	/^typedef Matrix<double, 7,1> Vector7d;$/;"	t	file:
Vector8d	test/unalignedassert.cpp	/^typedef Matrix<double, 8,1> Vector8d;$/;"	t	file:
Vector8f	test/dynalloc.cpp	/^typedef Matrix<float,8,1> Vector8f;$/;"	t	file:
Vector8f	test/unalignedassert.cpp	/^typedef Matrix<float,  8,1> Vector8f;$/;"	t	file:
Vector9d	test/unalignedassert.cpp	/^typedef Matrix<double, 9,1> Vector9d;$/;"	t	file:
VectorBlock	Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock
VectorBlock	Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock
VectorBlock	Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen
VectorComparator	unsupported/Eigen/src/BVH/KdBVH.h	/^    VectorComparator(int inDim) : dim(inDim) {}$/;"	f	struct:Eigen::KdBVH::VectorComparator
VectorComparator	unsupported/Eigen/src/BVH/KdBVH.h	/^  struct VectorComparator \/\/compares vectors, or, more specificall, VIPairs along a particular dimension$/;"	s	class:Eigen::KdBVH
VectorI	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::IncompleteLUT
VectorI	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorI	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView
VectorI	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<StorageIndex,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
VectorIx	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<StorageIndex,Dynamic, 1> VectorIx;$/;"	t	class:Eigen::IncompleteCholesky
VectorList	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef std::vector<std::list<StorageIndex> > VectorList; $/;"	t	class:Eigen::IncompleteCholesky
VectorMapper	Eigen/src/Core/util/BlasUtil.h	/^  typedef BlasVectorMapper<Scalar, Index> VectorMapper;$/;"	t	class:Eigen::internal::blas_data_mapper
VectorMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  typedef SubMapper VectorMapper;$/;"	t	class:Eigen::internal::TensorContractionInputMapper
VectorRx	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<RealScalar,Dynamic,1> VectorRx;$/;"	t	class:Eigen::IncompleteCholesky
VectorSx	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorSx;$/;"	t	class:Eigen::IncompleteCholesky
VectorType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
VectorType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition
VectorType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
VectorType	Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
VectorType	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase
VectorType	Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl
VectorType	Eigen/src/SVD/BDCSVD.h	/^  typedef Matrix<RealScalar, Dynamic, 1> VectorType;$/;"	t	class:Eigen::BDCSVD
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT
VectorType	test/denseLM.cpp	/^  typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	struct:DenseLM	file:
VectorType	test/sparseLM.cpp	/^  typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	struct:sparseGaussianTest	file:
VectorType	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef Matrix<Scalar, Dim, 1> VectorType;$/;"	t	class:Eigen::KdBVH
VectorType	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef Matrix<Scalar, Dim, 1> VectorType;$/;"	t	struct:Eigen::internal::vector_int_pair
VectorType	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType; $/;"	t	class:Eigen::MatrixMarketIterator
VectorType	unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:Ball	file:
VectorType	unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:BallPointStuff	file:
VectorType	unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:TreeTest	file:
VectorType	unsupported/test/FFTW.cpp	/^template<typename Scalar> struct VectorType<EigenVectorContainer,Scalar>$/;"	s	file:
VectorType	unsupported/test/FFTW.cpp	/^template<typename Scalar> struct VectorType<StdVectorContainer,Scalar>$/;"	s	file:
VectorTypeList	unsupported/test/BVH.cpp	/^  typedef std::vector<VectorType, aligned_allocator<VectorType> > VectorTypeList;$/;"	t	struct:TreeTest	file:
VectorTypeSum	Eigen/src/Geometry/AlignedBox.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<Scalar>, const VectorType, const VectorType> VectorTypeSum;$/;"	t	class:Eigen::AlignedBox
VectorX	bench/sparse_lu.cpp	/^typedef Matrix<Scalar,Dynamic,1> VectorX;$/;"	t	file:
Vectorizable	Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon497
Vectorizable	Eigen/src/Core/arch/AVX/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
Vectorizable	Eigen/src/Core/arch/AVX/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
Vectorizable	Eigen/src/Core/arch/AVX/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
Vectorizable	Eigen/src/Core/arch/AVX/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
Vectorizable	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
Vectorizable	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
Vectorizable	Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
Vectorizable	Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
Vectorizable	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
Vectorizable	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
Vectorizable	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
Vectorizable	Eigen/src/Core/arch/CUDA/Complex.h	/^    Vectorizable = packet_traits<std::complex<T>>::HasDiv$/;"	e	enum:Eigen::internal::scalar_quotient_op::__anon687
Vectorizable	Eigen/src/Core/arch/CUDA/Complex.h	/^    Vectorizable = packet_traits<std::complex<T>>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon686
Vectorizable	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
Vectorizable	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
Vectorizable	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
Vectorizable	Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
Vectorizable	Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
Vectorizable	Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
Vectorizable	Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon709
Vectorizable	Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
Vectorizable	Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
Vectorizable	Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon740
Vectorizable	Eigen/src/Core/arch/ZVector/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
Vectorizable	Eigen/src/Core/arch/ZVector/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
Vectorizable	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
Vectorizable	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
Vectorizable	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon633
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
Vectorizable	Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon624
Vectorizable	Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon625
Vectorized	Eigen/src/Core/AssignEvaluator.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::copy_using_evaluator_traits::__anon508
VectorizedCast	Eigen/src/Core/GenericPacketMath.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon499
VectorizedCast	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon646
VectorizedCast	Eigen/src/Core/arch/AVX/TypeCasting.h	/^    VectorizedCast = 0,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon647
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon675
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon676
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon677
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon678
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon679
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon680
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon681
VectorizedCast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon682
VectorizedCast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon727
VectorizedCast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon728
VectorizedCast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon729
VectorizedCast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^    VectorizedCast = 1,$/;"	e	enum:Eigen::internal::type_casting_traits::__anon730
VectorizedSize	Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon491
VectorwiseOp	Eigen/src/Core/VectorwiseOp.h	/^    explicit inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp
VectorwiseOp	Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Vertical	Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
VmlSize	Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon746
Volume	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef AlignedBox<Scalar, Dim> Volume;$/;"	t	class:Eigen::KdBVH
VolumeIterator	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef const int *VolumeIterator; \/\/the iterators are just pointers into the tree's vectors$/;"	t	class:Eigen::KdBVH
VolumeList	unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<Volume, aligned_allocator<Volume> > VolumeList;$/;"	t	class:Eigen::KdBVH
W	blas/testing/cblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT( NMAX ),$/;"	v	program:CBLAT3
W	blas/testing/dblat3.f	/^     $                   G( NMAX ), W(/;"	v	program:DBLAT3
W	blas/testing/sblat3.f	/^     $                   G( NMAX ), W(/;"	v	program:SBLAT3
W	blas/testing/zblat3.f	/^     $                   CC( NMAX*NMAX ), CS( NMAX*NMAX ), CT( NMAX ),$/;"	v	program:ZBLAT3
WIN32_LEAN_AND_MEAN	bench/BenchTimer.h	192;"	d
WIN32_LEAN_AND_MEAN	bench/BenchTimer.h	20;"	d
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	108;"	d
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	149;"	d
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	206;"	d
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	246;"	d
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
Wait	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  void Wait() {$/;"	f	class:Eigen::Barrier
WaitAndAdd	unsupported/test/cxx11_tensor_notification.cpp	/^void WaitAndAdd(Eigen::Notification* n, int* counter) {$/;"	f	namespace:__anon26
WaitForWork	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  bool WaitForWork(EventCount::Waiter* waiter, Task* t) {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
Waiter	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  class Waiter {$/;"	c	class:Eigen::EventCount
Waiter	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  struct Waiter {$/;"	s	class:Eigen::SimpleThreadPoolTempl
WithFormat	Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat
WithFormat	Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WorkMatrixType	Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD
WorkVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
WorkerLoop	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  void WorkerLoop(int thread_id) {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
WorkerLoop	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  void WorkerLoop(int thread_id) {$/;"	f	class:Eigen::SimpleThreadPoolTempl
WorkingRows	Eigen/src/Geometry/Transform.h	/^    WorkingRows = EIGEN_PLAIN_ENUM_MIN(TransformMatrix::RowsAtCompileTime,HDim)$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon270
WorkspaceType	Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Wrapper	test/constructor.cpp	/^  inline Wrapper(const MatrixType &x) : m_mat(x) {}$/;"	f	struct:Wrapper
Wrapper	test/constructor.cpp	/^template<typename MatrixType> struct Wrapper$/;"	s	file:
WriteAccessors	Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
X	bench/btl/actions/action_aat_product.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_aat_product
X	bench/btl/actions/action_ata_product.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_ata_product
X	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_atv_product
X	bench/btl/actions/action_axpby.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_axpby
X	bench/btl/actions/action_axpy.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_axpy
X	bench/btl/actions/action_cholesky.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_cholesky
X	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_ger
X	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_hessenberg
X	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_tridiagonalization
X	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_lu_decomp
X	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_matrix_matrix_product
X	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_matrix_vector_product
X	bench/btl/actions/action_partial_lu.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_partial_lu
X	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_symv
X	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_syr2
X	bench/btl/actions/action_trisolve.hh	/^  typename Interface::gene_vector X;$/;"	m	class:Action_trisolve
X	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_trisolve_matrix
X	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix X;$/;"	m	class:Action_trmm
X	blas/testing/cblat2.f	/^     $                   ALF( NALMAX /;"	v	program:CBLAT2
X	blas/testing/dblat2.f	/^     $                   G( NMAX /;"	v	program:DBLAT2
X	blas/testing/sblat2.f	/^     $                   G( NMAX /;"	v	program:SBLAT2
X	blas/testing/zblat2.f	/^     $                   ALF( NALMAX /;"	v	program:ZBLAT2
X	demos/opengl/icosphere.cpp	20;"	d	file:
X	doc/snippets/PartialPivLU_solve.cpp	/^MatrixXd X = A.lu().solve(B);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver.cpp	/^Matrix4f X = Matrix4f::Random(4,4);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^MatrixXd X = MatrixXd::Random(5,5);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^MatrixXd X = MatrixXd::Random(5,5);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_compute_MatrixType.cpp	/^MatrixXf X = MatrixXf::Random(4,4);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_compute_MatrixType2.cpp	/^MatrixXd X = MatrixXd::Random(5,5);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp	/^MatrixXd X = MatrixXd::Random(4,4);$/;"	v
X	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^MatrixXd X = MatrixXd::Random(4,4);$/;"	v
X	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^MatrixXd X = MatrixXd::Random(5,5);$/;"	v
X	doc/snippets/Tridiagonalization_compute.cpp	/^MatrixXf X = MatrixXf::Random(4,4);$/;"	v
X	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^MatrixXd X = MatrixXd::Random(5,5);$/;"	v
X	doc/snippets/Tridiagonalization_diagonal.cpp	/^MatrixXcd X = MatrixXcd::Random(4,4);$/;"	v
X	doc/snippets/Tridiagonalization_householderCoefficients.cpp	/^Matrix4d X = Matrix4d::Random(4,4);$/;"	v
X	doc/snippets/Tridiagonalization_packedMatrix.cpp	/^Matrix4d X = Matrix4d::Random(4,4);$/;"	v
X	doc/snippets/Tutorial_solve_multiple_rhs.cpp	/^Matrix<float,3,2> X;$/;"	v
X86_Perf_Analyzer	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  X86_Perf_Analyzer( const X86_Perf_Analyzer & ){$/;"	f	class:X86_Perf_Analyzer
X86_Perf_Analyzer	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  X86_Perf_Analyzer( unsigned long long nb_sample=DEFAULT_NB_SAMPLE):_nb_sample(nb_sample),_chronos()$/;"	f	class:X86_Perf_Analyzer
X86_Perf_Analyzer	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^class X86_Perf_Analyzer{$/;"	c
X86_Timer	bench/btl/generic_bench/timers/x86_timer.hh	/^  X86_Timer( void ):_frequency(FREQUENCY),_nb_sample(0)$/;"	f	class:X86_Timer
X86_Timer	bench/btl/generic_bench/timers/x86_timer.hh	/^class X86_Timer {$/;"	c
XERBLA	blas/testing/cblat2.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/cblat3.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/dblat2.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/dblat3.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/sblat2.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/sblat3.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/zblat2.f	/^      SUBROUTINE XERBLA(/;"	s
XERBLA	blas/testing/zblat3.f	/^      SUBROUTINE XERBLA(/;"	s
XS	blas/testing/cblat2.f	/^     $                   X( NMAX ), XS(/;"	v	program:CBLAT2
XS	blas/testing/dblat2.f	/^     $                   G( NMAX ), X( NMAX ), XS(/;"	v	program:DBLAT2
XS	blas/testing/sblat2.f	/^     $                   G( NMAX ), X( NMAX ), XS(/;"	v	program:SBLAT2
XS	blas/testing/zblat2.f	/^     $                   X( NMAX ), XS(/;"	v	program:ZBLAT2
XX	blas/testing/cblat2.f	/^     $                   X( NMAX ), XS( NMAX*INCMAX ),$/;"	v	program:CBLAT2
XX	blas/testing/dblat2.f	/^     $                   G( NMAX ), X( NMAX ), XS( NMAX*INCMAX ),$/;"	v	program:DBLAT2
XX	blas/testing/sblat2.f	/^     $                   G( NMAX ), X( NMAX ), XS( NMAX*INCMAX ),$/;"	v	program:SBLAT2
XX	blas/testing/zblat2.f	/^     $                   X( NMAX ), XS( NMAX*INCMAX ),$/;"	v	program:ZBLAT2
XY_FILE_HH	bench/btl/generic_bench/utils/xy_file.hh	21;"	d
X_ref	bench/btl/actions/action_aat_product.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_aat_product
X_ref	bench/btl/actions/action_ata_product.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_ata_product
X_ref	bench/btl/actions/action_atv_product.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_atv_product
X_ref	bench/btl/actions/action_axpby.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_axpby
X_ref	bench/btl/actions/action_axpy.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_axpy
X_ref	bench/btl/actions/action_cholesky.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_cholesky
X_ref	bench/btl/actions/action_ger.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_ger
X_ref	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_hessenberg
X_ref	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_tridiagonalization
X_ref	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_lu_decomp
X_ref	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_matrix_matrix_product
X_ref	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_matrix_vector_product
X_ref	bench/btl/actions/action_partial_lu.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_partial_lu
X_ref	bench/btl/actions/action_symv.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_symv
X_ref	bench/btl/actions/action_syr2.hh	/^  typename Interface::gene_vector X_ref;$/;"	m	class:Action_syr2
X_ref	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_trisolve_matrix
X_ref	bench/btl/actions/action_trmm.hh	/^  typename Interface::gene_matrix X_ref;$/;"	m	class:Action_trmm
X_stl	bench/btl/actions/action_aat_product.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_aat_product
X_stl	bench/btl/actions/action_ata_product.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_ata_product
X_stl	bench/btl/actions/action_atv_product.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_atv_product
X_stl	bench/btl/actions/action_axpby.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_axpby
X_stl	bench/btl/actions/action_axpy.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_axpy
X_stl	bench/btl/actions/action_cholesky.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_cholesky
X_stl	bench/btl/actions/action_ger.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_ger
X_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_hessenberg
X_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_tridiagonalization
X_stl	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_lu_decomp
X_stl	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_matrix_matrix_product
X_stl	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_matrix_vector_product
X_stl	bench/btl/actions/action_partial_lu.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_partial_lu
X_stl	bench/btl/actions/action_symv.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_symv
X_stl	bench/btl/actions/action_syr2.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_syr2
X_stl	bench/btl/actions/action_trisolve.hh	/^  typename Interface::stl_vector X_stl;$/;"	m	class:Action_trisolve
X_stl	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_trisolve_matrix
X_stl	bench/btl/actions/action_trmm.hh	/^  typename Interface::stl_matrix X_stl;$/;"	m	class:Action_trmm
Xpr	Eigen/src/Geometry/Homogeneous.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<typename Lhs::Scalar,typename Rhs::Scalar>, const LinearProduct, const ConstantBlock> Xpr;$/;"	t	struct:Eigen::internal::homogeneous_left_product_refactoring_helper
Xpr	Eigen/src/Geometry/Homogeneous.h	/^  typedef CwiseBinaryOp<internal::scalar_sum_op<typename Lhs::Scalar,typename Rhs::Scalar>, const LinearProduct, const ConstantBlock> Xpr;$/;"	t	struct:Eigen::internal::homogeneous_right_product_refactoring_helper
XprBase	Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename traits<DiagonalVectorType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Product.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/LU/FullPivLU.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/LU/PartialPivLU.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef traits<Arg1XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef traits<LhsXprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef traits<ThenXprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef internal::traits<XprType> XprTraits;$/;"	t	struct:Eigen::TensorEvaluator
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprTraits	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef traits<XprType> XprTraits;$/;"	t	struct:Eigen::internal::traits
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef ArrayWrapper<TArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::block_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;$/;"	t	struct:Eigen::internal::ternary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef CwiseUnaryView<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Derived  XprType;$/;"	t	struct:Eigen::internal::mapbase_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Diagonal<ArgType, DiagIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef EvalToTemp<ArgType>                   XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Map<PlainObjectType, MapOptions, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef MatrixWrapper<TArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Ref<PlainObjectType, RefOptions, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Replicate<ArgType, RowFactor, ColFactor> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Reverse<ArgType, Direction> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/CoreEvaluators.h	/^  typedef Transpose<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^                               const Product<Lhs, Rhs, DefaultProduct> > XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, LazyProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, Options> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, Options> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/Core/ProductEvaluators.h	/^  typedef Product<Lhs, Rhs, ProductKind> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/Core/Redux.h	/^  typedef _XprType XprType;$/;"	t	class:Eigen::internal::redux_evaluator
XprType	Eigen/src/Core/ReturnByValue.h	/^  typedef ReturnByValue<Derived> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType,Mode> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Homogeneous<ArgType,Direction> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Product<Lhs, Rhs, LazyProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/MappedSparseMatrix.h	/^  typedef MappedSparseMatrix<_Scalar,_Options,_StorageIndex> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<ArgType,BlockRows,BlockCols,InnerPanel> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  typedef CwiseBinaryOp<scalar_quotient_op<T1,T2>, Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::binary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Product<Lhs, Rhs> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Product<Lhs, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/SparseMap.h	/^  typedef Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseMap.h	/^  typedef Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef Product<Lhs, Rhs, AliasFreeProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseView<Product<Lhs, Rhs, Options> > XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;  $/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseRef.h	/^  typedef Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> XprType;$/;"	t	struct:Eigen::internal::evaluator
XprType	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Product<Lhs, RhsView, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Product<LhsView, Rhs, DefaultProduct> XprType;$/;"	t	struct:Eigen::internal::product_evaluator
XprType	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef Transpose<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseTriangularView.h	/^  typedef TriangularView<ArgType,Mode> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	Eigen/src/SparseCore/SparseView.h	/^    typedef SparseView<ArgType> XprType;$/;"	t	struct:Eigen::internal::unary_evaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef TensorIndexTupleOp<ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef TensorTupleReducerOp<ReduceOp, Dims, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef TensorAssignOp<LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef TensorBroadcastingOp<Broadcast, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef TensorChippingOp<DimId, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef TensorConcatenationOp<Axis, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef TensorContractionOp<Indices, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef TensorConversionOp<TargetType, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef TensorConvolutionOp<Indices, InputArgType, KernelArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef TensorEvalToOp<ArgType, MakePointer_> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef TensorCwiseBinaryOp<BinaryOp, LeftArgType, RightArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef TensorCwiseNullaryOp<NullaryOp, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef TensorCwiseTernaryOp<TernaryOp, Arg1Type, Arg2Type, Arg3Type> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef TensorCwiseUnaryOp<UnaryOp, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typedef TensorSelectOp<IfArgType, ThenArgType, ElseArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef TensorFFTOp<FFT, ArgType, FFTResultType, FFTDir> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef TensorForcedEvalOp<ArgType, MakePointer_> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef TensorGeneratorOp<Generator, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef TensorImagePatchOp<Rows, Cols, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef TensorInflationOp<Strides, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef TensorLayoutSwapOp<ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorReshapingOp<NewDimensions, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorSlicingOp<StartIndices, Sizes, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorStridingSlicingOp<StartIndices, StopIndices, Strides, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef TensorPaddingOp<PaddingDimensions, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef TensorPatchOp<PatchDim, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef TensorReductionOp<Op, Dims, ArgType, MakePointer_> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef TensorReverseOp<ReverseDimensions, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef TensorScanOp<Op, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef TensorShufflingOp<Shuffle, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef TensorStridingOp<Strides, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprType	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef TensorVolumePatchOp<Planes, Rows, Cols, ArgType> XprType;$/;"	t	struct:Eigen::TensorEvaluator
XprTypeIsRowMajor	Eigen/src/Core/Block.h	/^      XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0$/;"	e	enum:Eigen::internal::BlockImpl_dense::__anon465
XprTypeIsRowMajor	Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon464
XprTypeNested	Eigen/src/Core/Block.h	/^    typedef typename internal::ref_selector<XprType>::non_const_type XprTypeNested;$/;"	t	class:Eigen::internal::BlockImpl_dense
XprTypeNested	Eigen/src/Core/Block.h	/^  typedef typename ref_selector<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::ref_selector<XprType>::type XprTypeNested;$/;"	t	class:Eigen::CwiseUnaryOp
XprTypeNested	Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	Eigen/src/Core/Inverse.h	/^  typedef typename internal::ref_selector<XprType>::type      XprTypeNested;$/;"	t	class:Eigen::Inverse
XprTypeNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNestedCleaned	Eigen/src/Core/Inverse.h	/^  typedef typename internal::remove_all<XprTypeNested>::type  XprTypeNestedCleaned;$/;"	t	class:Eigen::Inverse
XtolTooSmall	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^        XtolTooSmall = 7,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
XtolTooSmall	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        XtolTooSmall = 7,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Y	bench/btl/actions/action_axpby.hh	/^  typename Interface::gene_vector Y;$/;"	m	class:Action_axpby
Y	bench/btl/actions/action_axpy.hh	/^  typename Interface::gene_vector Y;$/;"	m	class:Action_axpy
Y	blas/testing/cblat2.f	/^     $                   XX( NMAX*INCMAX ), Y(/;"	v	program:CBLAT2
Y	blas/testing/dblat2.f	/^     $                   XX( NMAX*INCMAX ), Y(/;"	v	program:DBLAT2
Y	blas/testing/sblat2.f	/^     $                   XX( NMAX*INCMAX ), Y(/;"	v	program:SBLAT2
Y	blas/testing/zblat2.f	/^     $                   XX( NMAX*INCMAX ), Y(/;"	v	program:ZBLAT2
YOU_ALREADY_SPECIFIED_THIS_STRIDE	Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_MADE_A_PROGRAMMING_MISTAKE	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX=1,$/;"	e	enum:Eigen::internal::static_assertion::__anon608
YS	blas/testing/cblat2.f	/^     $                   XX( NMAX*INCMAX ), Y( NMAX ),$/;"	v	program:CBLAT2
YS	blas/testing/dblat2.f	/^     $                   XX( NMAX*INCMAX ), Y( NMAX ),$/;"	v	program:DBLAT2
YS	blas/testing/sblat2.f	/^     $                   XX( NMAX*INCMAX ), Y( NMAX ),$/;"	v	program:SBLAT2
YS	blas/testing/zblat2.f	/^     $                   XX( NMAX*INCMAX ), Y( NMAX ),$/;"	v	program:ZBLAT2
YT	blas/testing/cblat2.f	/^     $                   YS( NMAX*INCMAX ), YT(/;"	v	program:CBLAT2
YT	blas/testing/dblat2.f	/^     $                   YS( NMAX*INCMAX ), YT(/;"	v	program:DBLAT2
YT	blas/testing/sblat2.f	/^     $                   YS( NMAX*INCMAX ), YT(/;"	v	program:SBLAT2
YT	blas/testing/zblat2.f	/^     $                   YS( NMAX*INCMAX ), YT(/;"	v	program:ZBLAT2
YY	blas/testing/cblat2.f	/^     $                   YS( NMAX*INCMAX ), YT( NMAX ),$/;"	v	program:CBLAT2
YY	blas/testing/dblat2.f	/^     $                   YS( NMAX*INCMAX ), YT( NMAX ),$/;"	v	program:DBLAT2
YY	blas/testing/sblat2.f	/^     $                   YS( NMAX*INCMAX ), YT( NMAX ),$/;"	v	program:SBLAT2
YY	blas/testing/zblat2.f	/^     $                   YS( NMAX*INCMAX ), YT( NMAX ),$/;"	v	program:ZBLAT2
Y_ref	bench/btl/actions/action_axpby.hh	/^  typename Interface::gene_vector Y_ref;$/;"	m	class:Action_axpby
Y_ref	bench/btl/actions/action_axpy.hh	/^  typename Interface::gene_vector Y_ref;$/;"	m	class:Action_axpy
Y_stl	bench/btl/actions/action_axpby.hh	/^  typename Interface::stl_vector Y_stl;$/;"	m	class:Action_axpby
Y_stl	bench/btl/actions/action_axpy.hh	/^  typename Interface::stl_vector Y_stl;$/;"	m	class:Action_axpy
Z	blas/testing/cblat2.f	/^     $                   YY( NMAX*INCMAX ), Z(/;"	v	program:CBLAT2
Z	blas/testing/dblat2.f	/^     $                   YY( NMAX*INCMAX ), Z(/;"	v	program:DBLAT2
Z	blas/testing/sblat2.f	/^     $                   YY( NMAX*INCMAX ), Z(/;"	v	program:SBLAT2
Z	blas/testing/zblat2.f	/^     $                   YY( NMAX*INCMAX ), Z(/;"	v	program:ZBLAT2
Z	demos/opengl/icosphere.cpp	21;"	d	file:
ZBEG	blas/testing/zblat2.f	/^      COMPLEX*16 FUNCTION ZBEG(/;"	f
ZBEG	blas/testing/zblat3.f	/^      COMPLEX*16     FUNCTION ZBEG(/;"	f
ZBLAT1	blas/testing/zblat1.f	/^      PROGRAM ZBLAT1$/;"	p
ZBLAT2	blas/testing/zblat2.f	/^      PROGRAM ZBLAT2$/;"	p
ZBLAT3	blas/testing/zblat3.f	/^      PROGRAM ZBLAT3$/;"	p
ZCHK1	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK1(/;"	s
ZCHK1	blas/testing/zblat3.f	/^      SUBROUTINE ZCHK1(/;"	s
ZCHK2	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK2(/;"	s
ZCHK2	blas/testing/zblat3.f	/^      SUBROUTINE ZCHK2(/;"	s
ZCHK3	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK3(/;"	s
ZCHK3	blas/testing/zblat3.f	/^      SUBROUTINE ZCHK3(/;"	s
ZCHK4	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK4(/;"	s
ZCHK4	blas/testing/zblat3.f	/^      SUBROUTINE ZCHK4(/;"	s
ZCHK5	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK5(/;"	s
ZCHK5	blas/testing/zblat3.f	/^      SUBROUTINE ZCHK5(/;"	s
ZCHK6	blas/testing/zblat2.f	/^      SUBROUTINE ZCHK6(/;"	s
ZCHKE	blas/testing/zblat2.f	/^      SUBROUTINE ZCHKE(/;"	s
ZCHKE	blas/testing/zblat3.f	/^      SUBROUTINE ZCHKE(/;"	s
ZDOTC	blas/fortran/complexdots.f	/^      DOUBLE COMPLEX FUNCTION ZDOTC(/;"	f
ZDOTU	blas/fortran/complexdots.f	/^      DOUBLE COMPLEX FUNCTION ZDOTU(/;"	f
ZERO	blas/testing/cblat2.f	/^      COMPLEX            ZERO,/;"	v	program:CBLAT2
ZERO	blas/testing/cblat3.f	/^      COMPLEX            ZERO,/;"	v	program:CBLAT3
ZERO	blas/testing/dblat2.f	/^      DOUBLE PRECISION   ZERO,/;"	v	program:DBLAT2
ZERO	blas/testing/dblat3.f	/^      DOUBLE PRECISION   ZERO,/;"	v	program:DBLAT3
ZERO	blas/testing/sblat2.f	/^      REAL               ZERO,/;"	v	program:SBLAT2
ZERO	blas/testing/sblat3.f	/^      REAL               ZERO,/;"	v	program:SBLAT3
ZERO	blas/testing/zblat2.f	/^      COMPLEX*16         ZERO,/;"	v	program:ZBLAT2
ZERO	blas/testing/zblat3.f	/^      COMPLEX*16         ZERO,/;"	v	program:ZBLAT3
ZLACGV	lapack/zlacgv.f	/^      SUBROUTINE ZLACGV(/;"	s
ZLADIV	lapack/zladiv.f	/^      COMPLEX*16     FUNCTION ZLADIV(/;"	f
ZLARF	lapack/zlarf.f	/^      SUBROUTINE ZLARF(/;"	s
ZLARFB	lapack/zlarfb.f	/^      SUBROUTINE ZLARFB(/;"	s
ZLARFG	lapack/zlarfg.f	/^      SUBROUTINE ZLARFG(/;"	s
ZLARFT	lapack/zlarft.f	/^      SUBROUTINE ZLARFT(/;"	s
ZMAKE	blas/testing/zblat2.f	/^      SUBROUTINE ZMAKE(/;"	s
ZMAKE	blas/testing/zblat3.f	/^      SUBROUTINE ZMAKE(/;"	s
ZMMCH	blas/testing/zblat3.f	/^      SUBROUTINE ZMMCH(/;"	s
ZMVCH	blas/testing/zblat2.f	/^      SUBROUTINE ZMVCH(/;"	s
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase
ZeroDiag	Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::UpLoType
ZeroSign	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
_Arg1Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg1Nested>::type _Arg1Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg1Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg1Nested>::type _Arg1Nested;$/;"	t	struct:Eigen::internal::traits
_Arg1Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<Arg1Nested>::type _Arg1Nested;$/;"	t	struct:Eigen::internal::traits
_Arg2Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg2Nested>::type _Arg2Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg2Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg2Nested>::type _Arg2Nested;$/;"	t	struct:Eigen::internal::traits
_Arg2Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<Arg2Nested>::type _Arg2Nested;$/;"	t	struct:Eigen::internal::traits
_Arg3Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename internal::remove_reference<Arg3Nested>::type _Arg3Nested;$/;"	t	class:Eigen::CwiseTernaryOp
_Arg3Nested	Eigen/src/Core/CwiseTernaryOp.h	/^  typedef typename remove_reference<Arg3Nested>::type _Arg3Nested;$/;"	t	struct:Eigen::internal::traits
_Arg3Nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<Arg3Nested>::type _Arg3Nested;$/;"	t	struct:Eigen::internal::traits
_BENCH_FIXED_SIZE_HH_	bench/btl/generic_bench/static/intel_bench_fixed_size.hh	21;"	d
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	100;"	d
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	321;"	d
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	377;"	d
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	612;"	d
_EIGEN_ALIGNED_PTR	Eigen/src/Core/arch/AltiVec/PacketMath.h	93;"	d
_EIGEN_ALIGNED_PTR	Eigen/src/Core/arch/ZVector/PacketMath.h	103;"	d
_EIGEN_DECLARE_CONST_FAST_Packet2d	Eigen/src/Core/arch/ZVector/PacketMath.h	67;"	d
_EIGEN_DECLARE_CONST_FAST_Packet2l	Eigen/src/Core/arch/ZVector/PacketMath.h	70;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	44;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	47;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	Eigen/src/Core/arch/ZVector/PacketMath.h	64;"	d
_EIGEN_DECLARE_CONST_Packet16f	Eigen/src/Core/arch/AVX512/MathFunctions.h	20;"	d
_EIGEN_DECLARE_CONST_Packet16f_FROM_INT	Eigen/src/Core/arch/AVX512/MathFunctions.h	23;"	d
_EIGEN_DECLARE_CONST_Packet2d	Eigen/src/Core/arch/AltiVec/PacketMath.h	56;"	d
_EIGEN_DECLARE_CONST_Packet2d	Eigen/src/Core/arch/SSE/PacketMath.h	82;"	d
_EIGEN_DECLARE_CONST_Packet2d	Eigen/src/Core/arch/ZVector/PacketMath.h	76;"	d
_EIGEN_DECLARE_CONST_Packet2l	Eigen/src/Core/arch/AltiVec/PacketMath.h	59;"	d
_EIGEN_DECLARE_CONST_Packet2l	Eigen/src/Core/arch/ZVector/PacketMath.h	79;"	d
_EIGEN_DECLARE_CONST_Packet4d	Eigen/src/Core/arch/AVX/PacketMath.h	42;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	50;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/NEON/PacketMath.h	76;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/SSE/PacketMath.h	79;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/AltiVec/PacketMath.h	62;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/NEON/PacketMath.h	79;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/SSE/PacketMath.h	85;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	53;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/NEON/PacketMath.h	82;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/SSE/PacketMath.h	88;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/ZVector/PacketMath.h	73;"	d
_EIGEN_DECLARE_CONST_Packet8d	Eigen/src/Core/arch/AVX512/MathFunctions.h	26;"	d
_EIGEN_DECLARE_CONST_Packet8d_FROM_INT64	Eigen/src/Core/arch/AVX512/MathFunctions.h	29;"	d
_EIGEN_DECLARE_CONST_Packet8f	Eigen/src/Core/arch/AVX/PacketMath.h	39;"	d
_EIGEN_DECLARE_CONST_Packet8f_FROM_INT	Eigen/src/Core/arch/AVX/PacketMath.h	45;"	d
_EIGEN_DECLARE_CONST_Packet8i	Eigen/src/Core/arch/AVX/PacketMath.h	48;"	d
_EIGEN_MASK_ALIGNMENT	Eigen/src/Core/arch/AltiVec/PacketMath.h	88;"	d
_EIGEN_MASK_ALIGNMENT	Eigen/src/Core/arch/AltiVec/PacketMath.h	90;"	d
_EIGEN_MASK_ALIGNMENT	Eigen/src/Core/arch/ZVector/PacketMath.h	101;"	d
_EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE	unsupported/Eigen/src/Skyline/SkylineUtil.h	52;"	d
_ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_FLOAT	bench/benchBlasGemm.cpp	7;"	d	file:
_Flags	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^          _Flags = traits<T>::Flags$/;"	e	enum:Eigen::internal::eval::__anon43
_GENERATE_HEADER	bench/basicbenchmark.cpp	15;"	d	file:
_HasDirectAccess	Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon823
_LAPACKE_H_	Eigen/src/misc/lapacke.h	37;"	d
_Lhs	Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type
_LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<SkylineProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::SkylineProduct
_LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_LhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_LinearAccessMask	Eigen/src/Core/ProductEvaluators.h	/^    _LinearAccessMask = (MatrixType::RowsAtCompileTime==1 || MatrixType::ColsAtCompileTime==1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
_MIXED_PERF_ANALYSER_HH	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	21;"	d
_MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase
_MatrixTypeNested	Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate
_MatrixTypeNested	Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename SparseMatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::internal::sparse_matrix_block_impl
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
_MatrixTypeNested	Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Nested	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef typename remove_reference<Nested>::type _Nested;$/;"	t	struct:Eigen::internal::traits
_Options	Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Options = ((Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon842
_Options	Eigen/src/SparseCore/SparseUtil.h	/^  enum { _Options = ((evaluator<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon843
_PORTABLE_PERF_ANALYZER_HH	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	22;"	d
_PORTABLE_PERF_ANALYZER_HH	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	21;"	d
_PORTABLE_TIMER_HH	bench/btl/generic_bench/timers/portable_timer.hh	23;"	d
_RUN_BENCH	bench/basicbenchmark.cpp	23;"	d	file:
_ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
_ResPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_Rhs	Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type
_RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<SkylineProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::SkylineProduct
_RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_RhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_STATIC_SIZE_GENERATOR_HH	bench/btl/generic_bench/static/static_size_generator.hh	21;"	d
_STL_PERF_ANALYSER_HH	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	21;"	d
_SameTypes	Eigen/src/Core/ProductEvaluators.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
_Scalar	Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval
_Scalar	Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type
_Scalar	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	class:Eigen::internal::eval
_ScalarAccessOnDiag	Eigen/src/Core/ProductEvaluators.h	/^    _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
_StorageIndex	Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::StorageIndex _StorageIndex;$/;"	t	struct:Eigen::internal::sparse_eval
_StorageIndex	Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::StorageIndex _StorageIndex;$/;"	t	struct:Eigen::internal::plain_matrix_type
_StorageOrder	Eigen/src/Core/ProductEvaluators.h	/^    _StorageOrder = MatrixFlags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
_Vectorizable	Eigen/src/Core/ProductEvaluators.h	/^    _Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::diagonal_product_evaluator_base::__anon430
_X86_PERF_ANALYSER_HH	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	21;"	d
_X86_TIMER_HH	bench/btl/generic_bench/timers/x86_timer.hh	21;"	d
_XprTypeNested	Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_XprTypeNested	Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_XprTypeNested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
__DBL_EPSILON__	Eigen/src/Core/util/Meta.h	192;"	d
__EIGEN_DATATYPES_H__	blas/f2c/datatypes.h	6;"	d
__FLT_EPSILON__	Eigen/src/Core/util/Meta.h	191;"	d
__MPREAL_H__	unsupported/test/mpreal/mpreal.h	49;"	d
__half_raw	Eigen/src/Core/arch/CUDA/Half.h	/^    typedef half_impl::__half_raw __half_raw;$/;"	t	struct:Eigen::half
__half_raw	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC __half_raw() : x(0) {}$/;"	f	struct:Eigen::half_impl::__half_raw
__half_raw	Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC __half_raw(unsigned short raw) : x(raw) {}$/;"	f	struct:Eigen::half_impl::__half_raw
__half_raw	Eigen/src/Core/arch/CUDA/Half.h	/^struct __half_raw {$/;"	s	namespace:Eigen::half_impl
__has_feature	Eigen/src/Core/util/Macros.h	349;"	d
__has_feature	unsupported/test/mpreal/mpreal.h	85;"	d
__init__	debug/gdb/printers.py	/^		def __init__ (self, dataPtr):$/;"	m	class:EigenQuaternionPrinter._iterator
__init__	debug/gdb/printers.py	/^		def __init__ (self, rows, cols, dataPtr, rowMajor):$/;"	m	class:EigenMatrixPrinter._iterator
__init__	debug/gdb/printers.py	/^	def __init__(self, val):$/;"	m	class:EigenQuaternionPrinter
__init__	debug/gdb/printers.py	/^	def __init__(self, variety, val):$/;"	m	class:EigenMatrixPrinter
__iter__	debug/gdb/printers.py	/^		def __iter__ (self):$/;"	m	class:EigenMatrixPrinter._iterator	file:
__iter__	debug/gdb/printers.py	/^		def __iter__ (self):$/;"	m	class:EigenQuaternionPrinter._iterator	file:
__ldg	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half __ldg(const Eigen::half* ptr) {$/;"	f
__next__	debug/gdb/printers.py	/^		def __next__(self):$/;"	m	class:EigenMatrixPrinter._iterator	file:
__next__	debug/gdb/printers.py	/^		def __next__(self):$/;"	m	class:EigenQuaternionPrinter._iterator	file:
__shfl_xor	Eigen/src/Core/arch/CUDA/Half.h	/^__device__ EIGEN_STRONG_INLINE Eigen::half __shfl_xor(Eigen::half var, int laneMask, int width=warpSize) {$/;"	f
_ac4r	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _ac4r;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
_alpha	bench/btl/actions/action_axpby.hh	/^  typename Interface::real_type _alpha;$/;"	m	class:Action_axpby
_assignProduct	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularViewImpl<MatrixType,UpLo,Dense>::_assignProduct(const ProductType& prod, const Scalar& alpha, bool beta)$/;"	f	class:Eigen::TriangularViewImpl
_beta	bench/btl/actions/action_axpby.hh	/^  typename Interface::real_type _beta;$/;"	m	class:Action_axpby
_check_template_params	Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase
_check_template_params	Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion
_chronos	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  STL_Timer _chronos;$/;"	m	class:STL_Perf_Analyzer
_chronos	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  Portable_Timer _chronos;$/;"	m	class:Portable_Perf_Analyzer
_chronos	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  Portable_Timer _chronos;$/;"	m	class:Portable_Perf_Analyzer
_chronos	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  X86_Timer _chronos;$/;"	m	class:X86_Perf_Analyzer
_cil	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef contained_in_list_gf<Equality, first_generator, elements> _cil;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
_cil	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef contained_in_list_gf<Equality, new_coset_rep, elements> _cil;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
_click_start	bench/btl/generic_bench/timers/x86_timer.hh	/^  } _click_start;$/;"	m	class:X86_Timer	typeref:union:X86_Timer::__anon6
_click_stop	bench/btl/generic_bench/timers/x86_timer.hh	/^  } _click_stop;$/;"	m	class:X86_Timer	typeref:union:X86_Timer::__anon7
_coef	bench/btl/actions/action_axpy.hh	/^  typename Interface::real_type _coef;$/;"	m	class:Action_axpy
_compute	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition
_cost	bench/btl/actions/action_cholesky.hh	/^  double _cost;$/;"	m	class:Action_cholesky
_cost	bench/btl/actions/action_hessenberg.hh	/^  double _cost;$/;"	m	class:Action_hessenberg
_cost	bench/btl/actions/action_hessenberg.hh	/^  double _cost;$/;"	m	class:Action_tridiagonalization
_cost	bench/btl/actions/action_lu_decomp.hh	/^  double _cost;$/;"	m	class:Action_lu_decomp
_cost	bench/btl/actions/action_partial_lu.hh	/^  double _cost;$/;"	m	class:Action_partial_lu
_cost	bench/btl/actions/action_trisolve.hh	/^  double _cost;$/;"	m	class:Action_trisolve
_cost	bench/btl/actions/action_trisolve_matrix.hh	/^  double _cost;$/;"	m	class:Action_trisolve_matrix
_cost	bench/btl/actions/action_trmm.hh	/^  double _cost;$/;"	m	class:Action_trmm
_counted_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  map<unsigned long long,unsigned long long> _counted_clicks;$/;"	m	class:X86_Timer
_data	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Storage& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED const Storage& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const std::vector<internal::CompressedStorage<Scalar,StorageIndex> >& _data() const { return m_data; }$/;"	f	class:Eigen::DynamicSparseMatrix
_data	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    std::vector<internal::CompressedStorage<Scalar,StorageIndex> >& _data() { return m_data; }$/;"	f	class:Eigen::DynamicSparseMatrix
_diagPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _diagPtr() {$/;"	f	class:Eigen::SkylineMatrix
_diagPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _diagPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_expression	Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
_expression	Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp
_frequency	bench/btl/generic_bench/timers/x86_timer.hh	/^  double _frequency ;$/;"	m	class:X86_Timer
_gain	unsupported/test/autodiff.cpp	/^    const Scalar _gain;$/;"	m	struct:integratorFunctor	file:
_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _helper;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _helper;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _helper;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_generator
_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _helper;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _helper;$/;"	t	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
_history_mean_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  vector<double> _history_mean_clicks;$/;"	m	class:X86_Timer
_history_most_occured_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  vector<double> _history_most_occured_clicks;$/;"	m	class:X86_Timer
_history_shortest_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  vector<double> _history_shortest_clicks;$/;"	m	class:X86_Timer
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Derived& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other){$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Index& val0,$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar& val0,$/;"	f	class:Eigen::PlainObjectBase
_init1	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init1(const Scalar* data){$/;"	f	class:Eigen::PlainObjectBase
_init2	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init2	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,$/;"	f	class:Eigen::PlainObjectBase
_init2	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_iterator	debug/gdb/printers.py	/^	class _iterator:$/;"	c	class:EigenMatrixPrinter
_iterator	debug/gdb/printers.py	/^	class _iterator:$/;"	c	class:EigenQuaternionPrinter
_lib_name	bench/btl/data/mean.cxx	/^  string _lib_name;$/;"	m	class:Lib_Mean	file:
_lowerProfilePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index* _lowerProfilePtr() {$/;"	f	class:Eigen::SkylineMatrix
_lowerProfilePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Index* _lowerProfilePtr() const {$/;"	f	class:Eigen::SkylineMatrix
_lowerPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _lowerPtr() {$/;"	f	class:Eigen::SkylineMatrix
_lowerPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _lowerPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_mean_in_cache	bench/btl/data/mean.cxx	/^  double _mean_in_cache;$/;"	m	class:Lib_Mean	file:
_mean_out_of_cache	bench/btl/data/mean.cxx	/^  double _mean_out_of_cache;$/;"	m	class:Lib_Mean	file:
_mm_castpd_ps	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128  _mm_castpd_ps   (__m128d x) { return reinterpret_cast<__m128&>(x);  }$/;"	f
_mm_castpd_si128	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128i _mm_castpd_si128(__m128d x) { return reinterpret_cast<__m128i&>(x); }$/;"	f
_mm_castps_pd	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128d _mm_castps_pd   (__m128  x) { return reinterpret_cast<__m128d&>(x); }$/;"	f
_mm_castps_si128	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128i _mm_castps_si128(__m128  x) { return reinterpret_cast<__m128i&>(x); }$/;"	f
_mm_castsi128_pd	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128d _mm_castsi128_pd(__m128i x) { return reinterpret_cast<__m128d&>(x); }$/;"	f
_mm_castsi128_ps	Eigen/src/Core/arch/SSE/PacketMath.h	/^static inline __m128  _mm_castsi128_ps(__m128i x) { return reinterpret_cast<__m128&>(x);  }$/;"	f
_nb_calc	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  unsigned long long _nb_calc;$/;"	m	class:Portable_Perf_Analyzer
_nb_calc	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  unsigned long long _nb_calc;$/;"	m	class:Portable_Perf_Analyzer
_nb_init	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  unsigned long long _nb_init;$/;"	m	class:Portable_Perf_Analyzer
_nb_sample	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  unsigned long long _nb_sample;$/;"	m	class:STL_Perf_Analyzer
_nb_sample	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  unsigned long long _nb_sample;$/;"	m	class:X86_Perf_Analyzer
_nb_sample	bench/btl/generic_bench/timers/x86_timer.hh	/^  unsigned long long _nb_sample;$/;"	m	class:X86_Timer
_next_iter	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > _next_iter;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
_ppa	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  Portable_Perf_Analyzer<Action> _ppa;$/;"	m	class:Mixed_Perf_Analyzer
_resize_to_match	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_noalias	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_size	bench/btl/actions/action_aat_product.hh	/^  int _size;$/;"	m	class:Action_aat_product
_size	bench/btl/actions/action_ata_product.hh	/^  int _size;$/;"	m	class:Action_ata_product
_size	bench/btl/actions/action_atv_product.hh	/^  int _size;$/;"	m	class:Action_atv_product
_size	bench/btl/actions/action_axpby.hh	/^  int _size;$/;"	m	class:Action_axpby
_size	bench/btl/actions/action_axpy.hh	/^  int _size;$/;"	m	class:Action_axpy
_size	bench/btl/actions/action_cholesky.hh	/^  int _size;$/;"	m	class:Action_cholesky
_size	bench/btl/actions/action_ger.hh	/^  int _size;$/;"	m	class:Action_ger
_size	bench/btl/actions/action_hessenberg.hh	/^  int _size;$/;"	m	class:Action_hessenberg
_size	bench/btl/actions/action_hessenberg.hh	/^  int _size;$/;"	m	class:Action_tridiagonalization
_size	bench/btl/actions/action_lu_decomp.hh	/^  int _size;$/;"	m	class:Action_lu_decomp
_size	bench/btl/actions/action_matrix_matrix_product.hh	/^  int _size;$/;"	m	class:Action_matrix_matrix_product
_size	bench/btl/actions/action_matrix_vector_product.hh	/^  int _size;$/;"	m	class:Action_matrix_vector_product
_size	bench/btl/actions/action_partial_lu.hh	/^  int _size;$/;"	m	class:Action_partial_lu
_size	bench/btl/actions/action_rot.hh	/^  int _size;$/;"	m	class:Action_rot
_size	bench/btl/actions/action_symv.hh	/^  int _size;$/;"	m	class:Action_symv
_size	bench/btl/actions/action_syr2.hh	/^  int _size;$/;"	m	class:Action_syr2
_size	bench/btl/actions/action_trisolve.hh	/^  int _size;$/;"	m	class:Action_trisolve
_size	bench/btl/actions/action_trisolve_matrix.hh	/^  int _size;$/;"	m	class:Action_trisolve_matrix
_size	bench/btl/actions/action_trmm.hh	/^  int _size;$/;"	m	class:Action_trmm
_solve_impl	Eigen/src/Cholesky/LDLT.h	/^void LDLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::LDLT
_solve_impl	Eigen/src/Cholesky/LLT.h	/^void LLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::LLT
_solve_impl	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve_impl	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve_impl(const SparseMatrixBase<RhsDerived> &b, SparseMatrixBase<DestDerived> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve_impl	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::TriangularViewImpl
_solve_impl	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner
_solve_impl	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve_impl	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve_impl	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteCholesky
_solve_impl	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT
_solve_impl	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_impl(const Rhs& b, SparseMatrixBase<DestDerived> &aDest) const$/;"	f	class:Eigen::IterativeSolverBase
_solve_impl	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const$/;"	f	class:Eigen::LeastSquaresConjugateGradient
_solve_impl	Eigen/src/LU/FullPivLU.h	/^void FullPivLU<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivLU
_solve_impl	Eigen/src/LU/PartialPivLU.h	/^    void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::PartialPivLU
_solve_impl	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase
_solve_impl	Eigen/src/PardisoSupport/PardisoSupport.h	/^void PardisoImpl<Derived>::_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl
_solve_impl	Eigen/src/QR/ColPivHouseholderQR.h	/^void ColPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::ColPivHouseholderQR
_solve_impl	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<_MatrixType>::_solve_impl($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
_solve_impl	Eigen/src/QR/FullPivHouseholderQR.h	/^void FullPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivHouseholderQR
_solve_impl	Eigen/src/QR/HouseholderQR.h	/^void HouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::HouseholderQR
_solve_impl	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SPQR
_solve_impl	Eigen/src/SVD/SVDBase.h	/^void SVDBase<Derived>::_solve_impl(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::SVDBase
_solve_impl	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve_impl	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve_impl	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve_impl	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve_impl	Eigen/src/SparseCore/SparseSolverBase.h	/^    void _solve_impl(const SparseMatrixBase<Rhs> &b, SparseMatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseSolverBase
_solve_impl	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE void _solve_impl(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::TriangularViewImpl
_solve_impl	Eigen/src/SparseLU/SparseLU.h	/^    bool _solve_impl(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const$/;"	f	class:Eigen::SparseLU
_solve_impl	Eigen/src/SparseQR/SparseQR.h	/^    bool _solve_impl(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseQR
_solve_impl	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU
_solve_impl	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU
_solve_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU
_solve_impl	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  void _solve_impl(const Rhs& b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::DGMRES
_solve_impl	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void _solve_impl(const Rhs& b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::GMRES
_solve_impl	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    void _solve_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLU
_solve_impl	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        void _solve_impl(const Rhs& b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::MINRES
_solve_impl_transposed	Eigen/src/LU/FullPivLU.h	/^void FullPivLU<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const$/;"	f	class:Eigen::FullPivLU
_solve_impl_transposed	Eigen/src/LU/PartialPivLU.h	/^    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const {$/;"	f	class:Eigen::PartialPivLU
_solve_with_guess_impl	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve_with_guess_impl	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve_with_guess_impl	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::LeastSquaresConjugateGradient
_solve_with_guess_impl	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DGMRES
_solve_with_guess_impl	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::GMRES
_solve_with_guess_impl	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        void _solve_with_guess_impl(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::MINRES
_sort_matrix_Q	Eigen/src/SparseQR/SparseQR.h	/^    inline void _sort_matrix_Q()$/;"	f	class:Eigen::SparseQR
_subdivide	demos/opengl/icosphere.cpp	/^void IcoSphere::_subdivide(void)$/;"	f	class:IcoSphere
_transformVector	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(const Vector3& v) const$/;"	f	class:Eigen::QuaternionBase
_transformVector	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase
_upperProfilePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index* _upperProfilePtr() {$/;"	f	class:Eigen::SkylineMatrix
_upperProfilePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Index* _upperProfilePtr() const {$/;"	f	class:Eigen::SkylineMatrix
_upperPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _upperPtr() {$/;"	f	class:Eigen::SkylineMatrix
_upperPtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _upperPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_use_ppa	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  bool _use_ppa;$/;"	m	class:Mixed_Perf_Analyzer
_x	unsupported/test/NonLinearOptimization.cpp	/^    static const double _x[11];$/;"	m	struct:MGH09_functor	file:
_x	unsupported/test/NonLinearOptimization.cpp	/^    static const double _x[37];$/;"	m	struct:thurber_functor	file:
_x	unsupported/test/NonLinearOptimization.cpp	/^const double MGH09_functor::_x[11] = { 4., 2., 1., 5.E-1 , 2.5E-01, 1.670000E-01, 1.250000E-01,  1.E-01, 8.330000E-02, 7.140000E-02, 6.250000E-02 };$/;"	m	class:MGH09_functor	file:
_x	unsupported/test/NonLinearOptimization.cpp	/^const double thurber_functor::_x[37] = { -3.067E0, -2.981E0, -2.921E0, -2.912E0, -2.840E0, -2.797E0, -2.702E0, -2.699E0, -2.633E0, -2.481E0, -2.363E0, -2.322E0, -1.501E0, -1.460E0, -1.274E0, -1.212E0, -1.100E0, -1.046E0, -0.915E0, -0.714E0, -0.566E0, -0.545E0, -0.400E0, -0.309E0, -0.109E0, -0.103E0, 0.010E0, 0.119E0, 0.377E0, 0.790E0, 0.963E0, 1.006E0, 1.115E0, 1.572E0, 1.841E0, 2.047E0, 2.200E0 };$/;"	m	class:thurber_functor	file:
_x	unsupported/test/levenberg_marquardt.cpp	/^    static const double _x[11];$/;"	m	struct:MGH09_functor	file:
_x	unsupported/test/levenberg_marquardt.cpp	/^    static const double _x[37];$/;"	m	struct:thurber_functor	file:
_x	unsupported/test/levenberg_marquardt.cpp	/^const double MGH09_functor::_x[11] = { 4., 2., 1., 5.E-1 , 2.5E-01, 1.670000E-01, 1.250000E-01,  1.E-01, 8.330000E-02, 7.140000E-02, 6.250000E-02 };$/;"	m	class:MGH09_functor	file:
_x	unsupported/test/levenberg_marquardt.cpp	/^const double thurber_functor::_x[37] = { -3.067E0, -2.981E0, -2.921E0, -2.912E0, -2.840E0, -2.797E0, -2.702E0, -2.699E0, -2.633E0, -2.481E0, -2.363E0, -2.322E0, -1.501E0, -1.460E0, -1.274E0, -1.212E0, -1.100E0, -1.046E0, -0.915E0, -0.714E0, -0.566E0, -0.545E0, -0.400E0, -0.309E0, -0.109E0, -0.103E0, 0.010E0, 0.119E0, 0.377E0, 0.790E0, 0.963E0, 1.006E0, 1.115E0, 1.572E0, 1.841E0, 2.047E0, 2.200E0 };$/;"	m	class:thurber_functor	file:
_x86pa	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  X86_Perf_Analyzer<Action> _x86pa;$/;"	m	class:Mixed_Perf_Analyzer
_y	unsupported/test/NonLinearOptimization.cpp	/^    static const double _y[37];$/;"	m	struct:thurber_functor	file:
_y	unsupported/test/NonLinearOptimization.cpp	/^const double thurber_functor::_y[37] = { 80.574E0, 84.248E0, 87.264E0, 87.195E0, 89.076E0, 89.608E0, 89.868E0, 90.101E0, 92.405E0, 95.854E0, 100.696E0, 101.060E0, 401.672E0, 390.724E0, 567.534E0, 635.316E0, 733.054E0, 759.087E0, 894.206E0, 990.785E0, 1090.109E0, 1080.914E0, 1122.643E0, 1178.351E0, 1260.531E0, 1273.514E0, 1288.339E0, 1327.543E0, 1353.863E0, 1414.509E0, 1425.208E0, 1421.384E0, 1442.962E0, 1464.350E0, 1468.705E0, 1447.894E0, 1457.628E0};$/;"	m	class:thurber_functor	file:
_y	unsupported/test/levenberg_marquardt.cpp	/^    static const double _y[37];$/;"	m	struct:thurber_functor	file:
_y	unsupported/test/levenberg_marquardt.cpp	/^const double thurber_functor::_y[37] = { 80.574E0, 84.248E0, 87.264E0, 87.195E0, 89.076E0, 89.608E0, 89.868E0, 90.101E0, 92.405E0, 95.854E0, 100.696E0, 101.060E0, 401.672E0, 390.724E0, 567.534E0, 635.316E0, 733.054E0, 759.087E0, 894.206E0, 990.785E0, 1090.109E0, 1080.914E0, 1122.643E0, 1178.351E0, 1260.531E0, 1273.514E0, 1288.339E0, 1327.543E0, 1353.863E0, 1414.509E0, 1425.208E0, 1421.384E0, 1442.962E0, 1464.350E0, 1468.705E0, 1447.894E0, 1457.628E0};$/;"	m	class:thurber_functor	file:
a	Eigen/src/Core/util/Meta.h	/^  struct no  {int a[2];};$/;"	m	struct:Eigen::internal::is_convertible_impl::no
a	Eigen/src/Core/util/Meta.h	/^  struct yes {int a[1];};$/;"	m	struct:Eigen::internal::is_convertible_impl::yes
a	Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none
a	Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type
a	Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result
a	Eigen/src/Core/util/Meta.h	/^struct meta_no  { char a[2]; };$/;"	m	struct:Eigen::internal::meta_no
a	Eigen/src/Core/util/Meta.h	/^struct meta_yes { char a[1]; };$/;"	m	struct:Eigen::internal::meta_yes
a	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct no  {int a[2];};$/;"	m	struct:Eigen::internal::is_ref_compatible_impl::no
a	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct yes {int a[1];};$/;"	m	struct:Eigen::internal::is_ref_compatible_impl::yes
a	Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon779
a	doc/snippets/Cwise_product.cpp	/^Array33i a = Array33i::Random(), b = Array33i::Random();$/;"	v
a	doc/snippets/MatrixBase_bottomRows_int.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_cwiseProduct.cpp	/^Matrix3i a = Matrix3i::Random(), b = Matrix3i::Random();$/;"	v
a	doc/snippets/MatrixBase_leftCols_int.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_noalias.cpp	/^Matrix2d a, b, c; a << 1,2,3,4; b << 5,6,7,8;$/;"	v
a	doc/snippets/MatrixBase_rightCols_int.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_template_int_bottomRows.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_template_int_leftCols.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_template_int_rightCols.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_template_int_topRows.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/MatrixBase_topRows_int.cpp	/^Array44i a = Array44i::Random();$/;"	v
a	doc/snippets/tut_arithmetic_transpose_aliasing.cpp	/^Matrix2i a; a << 1, 2, 3, 4;$/;"	v
a	doc/snippets/tut_arithmetic_transpose_conjugate.cpp	/^MatrixXcf a = MatrixXcf::Random(2,2);$/;"	v
a1	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^Array33f a1 = Array33f::Zero();$/;"	v
a1	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << a1 << "\\n\\n";$/;"	v
a2	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^ArrayXf a2 = ArrayXf::Zero(3);$/;"	v
a2	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << a2 << "\\n\\n";$/;"	v
a3	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^ArrayXXf a3 = ArrayXXf::Zero(3, 4);$/;"	v
a3	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << a3 << "\\n";$/;"	v
a_	bench/tensors/tensor_benchmarks.h	/^  T* a_;$/;"	m	class:BenchmarkSuite
aat_product	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void aat_product(gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:blas_interface
aat_product	bench/btl/libs/STL/STL_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N)$/;"	f	class:STL_interface
aat_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:blaze_interface
aat_product	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N)$/;"	f	class:blitz_interface
aat_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:eigen2_interface
aat_product	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
aat_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:gmm_interface
aat_product	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void aat_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:mtl4_interface
aat_product	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void aat_product(gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:ublas_interface
abs	Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE double  abs(double x) { return cl::sycl::fabs(x); }$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE float   abs(float x) { return cl::sycl::fabs(x); }$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^abs(const T &x) {$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^double      abs(double      x) { return (fabs(x));  }$/;"	f	namespace:Eigen
abs	Eigen/src/Core/MathFunctions.h	/^double abs(const double &x) { return ::fabs(x); }$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^double abs(const std::complex<double>& x) {$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^float       abs(float       x) { return (fabsf(x)); }$/;"	f	namespace:Eigen
abs	Eigen/src/Core/MathFunctions.h	/^float abs(const float &x) { return ::fabsf(x); }$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^float abs(const std::complex<float>& x) {$/;"	f	namespace:Eigen::numext
abs	Eigen/src/Core/MathFunctions.h	/^long        abs(long        x) { return (labs(x));  }$/;"	f	namespace:Eigen
abs	Eigen/src/Core/MathFunctions.h	/^long double abs(long double x) { return (fabsl(x)); }$/;"	f	namespace:Eigen
abs	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half abs(const half& a) {$/;"	f	namespace:Eigen::half_impl
abs	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f
abs	blas/f2c/datatypes.h	17;"	d
abs	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    abs() const {$/;"	f	class:Eigen::TensorBase
abs	unsupported/test/mpreal/mpreal.h	/^inline const mpreal abs   (const mpreal& x, mp_rnd_t r)                             {   MPREAL_UNARY_MATH_FUNCTION_BODY(abs  );    }$/;"	f	namespace:mpfr
abs2	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::numext
abs2	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f
abs2_impl	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl_default	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default$/;"	s	namespace:Eigen::internal
abs2_impl_default	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default<Scalar, true> \/\/ IsComplex$/;"	s	namespace:Eigen::internal
abs2_retval	Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
absDeterminant	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::absDeterminant() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
absDeterminant	Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
absDeterminant	Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR
absDeterminant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar absDeterminant()$/;"	f	class:Eigen::SparseLU
absDiagIndex	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
absDistance	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar absDistance(const VectorType& p) const { return numext::abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
absGreatestRealRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& absGreatestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
absSmallestRealRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& absSmallestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
abs_knowing_score	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar, typename=void> struct abs_knowing_score$/;"	s	namespace:Eigen::internal
abs_knowing_score	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct abs_knowing_score<Scalar, typename scalar_score_coeff_op<Scalar>::Score_is_abs>$/;"	s	namespace:Eigen::internal
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacketType& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const ResPacketHalf& c, const ResPacketHalf& alpha, ResPacketHalf& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits
accessors_level	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
accumulator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Op& accumulator() const {$/;"	f	struct:Eigen::TensorEvaluator
accumulator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Op accumulator() const { return m_accumulator; }$/;"	f	class:Eigen::TensorScanOp
acos	Eigen/src/Core/MathFunctions.h	/^T acos(const T &x) {$/;"	f	namespace:Eigen::numext
acos	Eigen/src/Core/MathFunctions.h	/^double acos(const double &x) { return ::acos(x); }$/;"	f	namespace:Eigen::numext
acos	Eigen/src/Core/MathFunctions.h	/^float acos(const float &x) { return ::acosf(x); }$/;"	f	namespace:Eigen::numext
acos	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f
acos	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acos  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(acos );    }$/;"	f	namespace:mpfr
acosh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acosh (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(acosh);    }$/;"	f	namespace:mpfr
acot	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acot  (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return atan (1\/v, r);                      }$/;"	f	namespace:mpfr
acoth	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acoth (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return atanh(1\/v, r);                      }$/;"	f	namespace:mpfr
acsc	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acsc  (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return asin (1\/v, r);                      }$/;"	f	namespace:mpfr
acsch	unsupported/test/mpreal/mpreal.h	/^inline const mpreal acsch (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return asinh(1\/v, r);                      }$/;"	f	namespace:mpfr
action_t	bench/analyze-blocking-sizes.cpp	/^struct action_t$/;"	s	file:
activateGL	demos/opengl/camera.cpp	/^void Camera::activateGL(void)$/;"	f	class:Camera
actred	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar actred, prered;$/;"	m	class:Eigen::HybridNonLinearSolver
actred	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
actualDim	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE DenseIndex actualDim() const {$/;"	f	struct:Eigen::internal::DimensionId
actual_alignment	Eigen/src/Core/Matrix.h	/^      actual_alignment = ((_Options&DontAlign)==0) ? default_alignment : 0,$/;"	e	enum:Eigen::internal::traits::__anon438
actual_df	unsupported/test/NumericalDiff.cpp	/^    int actual_df(const VectorXd &x, MatrixXd &fjac) const$/;"	f	struct:my_functor
actual_dim	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  const DenseIndex actual_dim;$/;"	m	struct:Eigen::internal::DimensionId
add	Eigen/src/Core/ProductEvaluators.h	/^  struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
add	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void add(Gen_) { add(Gen_::One, Gen_::Two, Gen_::Flags); }$/;"	f	class:Eigen::DynamicSGroup
add	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^inline void DynamicSGroup::add(int one, int two, int flags)$/;"	f	class:Eigen::DynamicSGroup
addAntiHermiticity	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void addAntiHermiticity(int one, int two) { add(one, two, NegationFlag | ConjugationFlag); }$/;"	f	class:Eigen::DynamicSGroup
addAntiSymmetry	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void addAntiSymmetry(int one, int two) { add(one, two, NegationFlag); }$/;"	f	class:Eigen::DynamicSGroup
addHermiticity	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void addHermiticity(int one, int two) { add(one, two, ConjugationFlag); }$/;"	f	class:Eigen::DynamicSGroup
addSymmetry	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void addSymmetry(int one, int two) { add(one, two, 0); }$/;"	f	class:Eigen::DynamicSGroup
addTo	Eigen/src/Core/EigenBase.h	/^  inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
addTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
addTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
addTo	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
addTo	Eigen/src/SparseCore/SparseProduct.h	/^  static void addTo(Dest& dst, const ActualLhs& lhs, const Rhs& rhs, typename enable_if<is_same<typename evaluator_traits<Dest>::Shape,DenseShape>::value,int*>::type* = 0)$/;"	f	struct:Eigen::internal::generic_product_impl
add_all	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void add_all(internal::type_list<>)$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
add_all	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline void add_all(internal::type_list<Gen1, GenNext...>)$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
add_assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct add_assign_op {$/;"	s	namespace:Eigen::internal
add_assign_using_evaluator	test/evaluators.cpp	/^  void add_assign_using_evaluator(const DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen
add_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
add_coset	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static bool add_coset = !_cil::value;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
add_get_click	bench/btl/generic_bench/timers/x86_timer.hh	/^  void  add_get_click( void ){$/;"	f	class:X86_Timer
add_online_info_into_contributors_list	scripts/eigen_gen_credits.cpp	/^void add_online_info_into_contributors_list(list<contributor>& contributors_list, const char *filename)$/;"	f
add_sycl_buffer	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template<typename T> inline  std::pair<std::map<const void *, std::shared_ptr<void>>::iterator,bool> add_sycl_buffer(const T *ptr, size_t num_bytes) const {$/;"	f	struct:Eigen::SyclDevice
add_vals	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	649;"	d
add_vals	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	689;"	d
add_vals	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	997;"	d
adds	Eigen/src/Core/ProductEvaluators.h	/^    explicit adds(const Scalar& s) : m_scale(s) {}$/;"	f	struct:Eigen::internal::generic_product_impl::adds
adds	Eigen/src/Core/ProductEvaluators.h	/^  struct adds {$/;"	s	struct:Eigen::internal::generic_product_impl
adjoint	Eigen/src/Cholesky/LDLT.h	/^    const LDLT& adjoint() const { return *this; };$/;"	f	class:Eigen::LDLT
adjoint	Eigen/src/Cholesky/LLT.h	/^    const LLT& adjoint() const { return *this; };$/;"	f	class:Eigen::LLT
adjoint	Eigen/src/Core/SelfAdjointView.h	/^    inline const AdjointReturnType adjoint() const$/;"	f	class:Eigen::SelfAdjointView
adjoint	Eigen/src/Core/SolverBase.h	/^    inline AdjointReturnType adjoint() const$/;"	f	class:Eigen::SolverBase
adjoint	Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase
adjoint	Eigen/src/Core/TriangularMatrix.h	/^    inline const AdjointReturnType adjoint() const$/;"	f	class:Eigen::TriangularView
adjoint	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence
adjoint	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation
adjoint	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> adjoint() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
adjoint	Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return AdjointReturnType(transpose()); }$/;"	f	class:Eigen::SparseMatrixBase
adjoint	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> adjoint() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
adjoint	test/adjoint.cpp	/^template<typename MatrixType> void adjoint(const MatrixType& m)$/;"	f
adjointInPlace	Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase
adjoint_specific	test/adjoint.cpp	/^template<> struct adjoint_specific<false> {$/;"	s	file:
adjoint_specific	test/adjoint.cpp	/^template<> struct adjoint_specific<true> {$/;"	s	file:
adolc_forward_jacobian	unsupported/test/forward_adolc.cpp	/^template<typename Func> void adolc_forward_jacobian(const Func& f)$/;"	f
affine	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
affine	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
agm	unsupported/test/mpreal/mpreal.h	/^inline const mpreal agm (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
ai	unsupported/test/mpreal/mpreal.h	/^inline const mpreal ai      (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(ai);          }$/;"	f	namespace:mpfr
algebraicFunc	bench/tensors/tensor_benchmarks.h	/^  void algebraicFunc(int num_iters) {$/;"	f	class:BenchmarkSuite
aliasing_with_resize	test/product_extra.cpp	/^void aliasing_with_resize()$/;"	f
alignBlockSize	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static Index alignBlockSize(Index size) {$/;"	f	struct:Eigen::internal::EvalRange
aligned	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC bool aligned(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
aligned	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool aligned(Index) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator() : std::allocator<T>() {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator<U>& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^class aligned_allocator : public std::allocator<T>$/;"	c	namespace:Eigen
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen
aligned_delete	Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline void aligned_delete(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_free	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
aligned_malloc	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void* aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_new	Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline T* aligned_new(std::size_t size)$/;"	f	namespace:Eigen::internal
aligned_realloc	Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, std::size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler : noncopyable$/;"	c	namespace:Eigen::internal
alignedbox	test/geo_alignedbox.cpp	/^template<typename BoxType> void alignedbox(const BoxType& _box)$/;"	f
alignedboxCastTests	test/geo_alignedbox.cpp	/^void alignedboxCastTests(const BoxType& _box)$/;"	f
alignedvector3	unsupported/test/alignedvector3.cpp	/^void alignedvector3()$/;"	f
alignment	Eigen/src/Core/Redux.h	/^    alignment = Derived::Alignment$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon490
alignment	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon651
alignment	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon649
alignment	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon660
alignment	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon659
alignment	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon661
alignment	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon667
alignment	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon669
alignment	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 8, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon668
alignment	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon697
alignment	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon695
alignment	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon703
alignment	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon700
alignment	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon701
alignment	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon693
alignment	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon692
alignment	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon685
alignment	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon707
alignment	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon705
alignment	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon713
alignment	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon710
alignment	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon711
alignment	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon734
alignment	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon732
alignment	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon742
alignment	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon741
alignment	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon743
alignment	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon718
alignment	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon717
alignment	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon726
alignment	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon725
alignment	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon724
all	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase
all	Eigen/src/Core/VectorwiseOp.h	/^    const AllReturnType all() const$/;"	f	class:Eigen::VectorwiseOp
all	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    all() const {$/;"	f	class:Eigen::TensorBase
all	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    all(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
allFinite	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::allFinite() const$/;"	f	class:Eigen::DenseBase
all_indices_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool all_indices_known_statically() {$/;"	f	namespace:Eigen::internal
all_indices_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct all_indices_known_statically_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
all_indices_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct all_indices_known_statically_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
all_indices_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct all_indices_known_statically_impl {$/;"	s	namespace:Eigen::internal
all_indices_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct all_indices_known_statically_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
all_indices_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct all_indices_known_statically_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
all_pot_sizes	bench/analyze-blocking-sizes.cpp	/^    all_pot_sizes,$/;"	m	class:inputfile_t::type_t	file:
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
all_values_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr bool all_values_known_statically() const {$/;"	f	struct:Eigen::IndexList
allocate	Eigen/src/Core/util/Memory.h	/^  pointer allocate(size_type num, const void* \/*hint*\/ = 0)$/;"	f	class:Eigen::aligned_allocator
allocate	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::BDCSVD
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
allocate	Eigen/src/SVD/SVDBase.h	/^bool SVDBase<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::SVDBase
allocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE void* allocate(size_t num_bytes) const {$/;"	f	struct:Eigen::GpuDevice
allocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual void* allocate(size_t num_bytes) const {$/;"	f	class:Eigen::CudaStreamDevice
allocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void* allocate(size_t num_bytes) const {$/;"	f	struct:Eigen::DefaultDevice
allocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void *allocate(size_t) const {$/;"	f	struct:Eigen::SyclDevice
allocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void* allocate(size_t num_bytes) const {$/;"	f	struct:Eigen::ThreadPoolDevice
allocateA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocatedSize	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage
allocatedSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index allocatedSize() const {$/;"	f	class:Eigen::SkylineStorage
alpha	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar alpha() const { return m_angles[0]; }$/;"	f	class:Eigen::EulerAngles
alpha	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar& alpha() { return m_angles[0]; }$/;"	f	class:Eigen::EulerAngles
alphas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType alphas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
alt_prod	bench/product_threshold.cpp	/^template<int M, int N,int K> struct alt_prod$/;"	s	file:
always_search_subsets_of_size_at_least	bench/analyze-blocking-sizes.cpp	/^const size_t always_search_subsets_of_size_at_least = 2;$/;"	v
always_void	Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
amax_	blas/level1_impl.h	/^int EIGEN_CAT(EIGEN_CAT(i,SCALAR_SUFFIX),amax_)(int *n, RealScalar *px, int *incx)$/;"	f
amd_flip	Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal
amd_mark	Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal
amd_marked	Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal
amd_unflip	Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal
amin_	blas/level1_impl.h	/^int EIGEN_CAT(EIGEN_CAT(i,SCALAR_SUFFIX),amin_)(int *n, RealScalar *px, int *incx)$/;"	f
analyzePattern	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
analyzePattern	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner
analyzePattern	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
analyzePattern	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
analyzePattern	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
analyzePattern	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
analyzePattern	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
analyzePattern	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
analyzePattern	Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseLU
analyzePattern	Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU
analyzePattern	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
analyzePattern_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern_impl()$/;"	f	class:Eigen::UmfPackLU
analyzePattern_preordered	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
angle	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angleToVec	test/geo_transformations.cpp	/^Matrix<T,2,1> angleToVec(T a)$/;"	f
angles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Vector3& angles() { return m_angles; }$/;"	f	class:Eigen::EulerAngles
angles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      const Vector3& angles() const { return m_angles; }$/;"	f	class:Eigen::EulerAngles
angularDistance	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
animate	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::animate()$/;"	f	class:RenderingWidget
any	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase
any	Eigen/src/Core/VectorwiseOp.h	/^    const AnyReturnType any() const$/;"	f	class:Eigen::VectorwiseOp
any	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    any() const {$/;"	f	class:Eigen::TensorBase
any	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    any(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
any_conversion	Eigen/src/Core/util/Meta.h	/^  struct any_conversion$/;"	s	struct:Eigen::internal::is_convertible_impl
any_conversion	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct any_conversion$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
append	Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage
append	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(utility::tuple::append(AccessorConstructor::template getAccessor<cl::sycl::access::mode::write>(cgh, eval), AccessorConstructor::getTuple(cgh, eval.impl()))){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
append	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^Tuple<Args..., T> append(Tuple<Args...> t, T a) {$/;"	f	namespace:utility::tuple
append	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^Tuple<Args1..., Args2...> append(Tuple<Args1...> t1,Tuple<Args2...> t2) {$/;"	f	namespace:utility::tuple
append_base	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^Tuple<Args..., T> append_base(Tuple<Args...> t, T a,IndexList<I...>) {$/;"	f	namespace:utility::tuple
append_base	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^Tuple<Args1..., Args2...> append_base(Tuple<Args1...> t1, Tuple<Args2...> t2, IndexList<I1...>, IndexList<I2...>) {$/;"	f	namespace:utility::tuple
apply	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline RV apply(const std::array<Index, N>& idx, RV initial, Args&&... args) const$/;"	f	class:Eigen::DynamicSGroup
apply	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline RV apply(const std::vector<Index>& idx, RV initial, Args&&... args) const$/;"	f	class:Eigen::DynamicSGroup
apply	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    static inline RV apply(const std::array<Index, N>& idx, RV initial, Args&&... args)$/;"	f	class:Eigen::StaticSGroup
apply	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    static inline RV apply(const std::vector<Index>& idx, RV initial, Args&&... args)$/;"	f	class:Eigen::StaticSGroup
applyHouseholderOnTheLeft	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase
applyHouseholderOnTheRight	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase
applyOP	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void applyOP(MatrixSolver &OP, const MatrixType &A, int n, Scalar *in, Scalar *out)$/;"	f	struct:Eigen::internal::OP
applyOnTheLeft	Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyThisOnTheLeft	Eigen/src/Core/EigenBase.h	/^  EIGEN_DEVICE_FUNC inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheLeft	Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheLeft	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	Eigen/src/Core/EigenBase.h	/^  EIGEN_DEVICE_FUNC inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheRight	Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyTranspositionOnTheLeft	Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyTranspositionOnTheRight	Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyZAdjointOnTheLeftInPlace	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
apply_block_householder_on_the_left	Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs, bool forward)$/;"	f	namespace:Eigen::internal
apply_op_from_left	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct apply_op_from_left { typedef decltype(h_apply_op<true, op, additional_param>::helper(a())) type; };$/;"	s	namespace:Eigen::internal
apply_op_from_right	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct apply_op_from_right { typedef decltype(h_apply_op<false, op, additional_param>::helper(a())) type; };$/;"	s	namespace:Eigen::internal
apply_rotation_in_the_plane	Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal
apply_rotation_in_the_plane_selector	Eigen/src/Jacobi/Jacobi.h	/^struct apply_rotation_in_the_plane_selector$/;"	s	namespace:Eigen::internal
apply_rotation_in_the_plane_selector	Eigen/src/Jacobi/Jacobi.h	/^struct apply_rotation_in_the_plane_selector<Scalar,OtherScalar,SizeAtCompileTime,MinAlignment,true \/* vectorizable *\/>$/;"	s	namespace:Eigen::internal
areApprox	test/packetmath.cpp	/^template<typename Scalar> bool areApprox(const Scalar* a, const Scalar* b, int size)$/;"	f
areApproxAbs	test/packetmath.cpp	/^template<typename Scalar> bool areApproxAbs(const Scalar* a, const Scalar* b, int size, const typename NumTraits<Scalar>::Real& refvalue)$/;"	f
areNotApprox	test/product.h	/^bool areNotApprox(const MatrixBase<Derived1>& m1, const MatrixBase<Derived2>& m2, typename Derived1::RealScalar epsilon = NumTraits<typename Derived1::RealScalar>::dummy_precision())$/;"	f
are_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct are_inner_most_dims {$/;"	s	namespace:Eigen::internal
are_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct are_inner_most_dims<ReducedDims, NumTensorDims, ColMajor>{$/;"	s	namespace:Eigen::internal
are_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct are_inner_most_dims<ReducedDims, NumTensorDims, RowMajor>{$/;"	s	namespace:Eigen::internal
arg	Eigen/src/Core/CoreEvaluators.h	/^  const ArgType& arg() const$/;"	f	class:Eigen::internal::EvalToTemp
arg	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(arg, Scalar) arg(const Scalar& x)$/;"	f	namespace:Eigen::numext
arg	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^arg() const$/;"	f
arg1	Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg1Nested& arg1() const { return m_arg1; }$/;"	f	class:Eigen::CwiseTernaryOp
arg1Expr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<Arg1Expr, Dev> > arg1Expr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
arg1Expression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    arg1Expression() const { return m_arg1_xpr; }$/;"	f	class:Eigen::TensorCwiseTernaryOp
arg1Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<Arg1Type, Device> & arg1Impl() const { return m_arg1Impl; }$/;"	f	struct:Eigen::TensorEvaluator
arg2	Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg2Nested& arg2() const { return m_arg2; }$/;"	f	class:Eigen::CwiseTernaryOp
arg2Expr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<Arg2Expr, Dev> > arg2Expr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
arg2Expression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    arg2Expression() const { return m_arg2_xpr; }$/;"	f	class:Eigen::TensorCwiseTernaryOp
arg2Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<Arg2Type, Device>& arg2Impl() const { return m_arg2Impl; }$/;"	f	struct:Eigen::TensorEvaluator
arg3	Eigen/src/Core/CwiseTernaryOp.h	/^  const _Arg3Nested& arg3() const { return m_arg3; }$/;"	f	class:Eigen::CwiseTernaryOp
arg3Expr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<Arg3Expr, Dev> > arg3Expr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
arg3Expression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    arg3Expression() const { return m_arg3_xpr; }$/;"	f	class:Eigen::TensorCwiseTernaryOp
arg3Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<Arg3Type, Device>& arg3Impl() const { return m_arg3Impl; }$/;"	f	struct:Eigen::TensorEvaluator
arg_default_impl	Eigen/src/Core/MathFunctions.h	/^  struct arg_default_impl$/;"	s	namespace:Eigen::internal
arg_default_impl	Eigen/src/Core/MathFunctions.h	/^  struct arg_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
arg_impl	Eigen/src/Core/MathFunctions.h	/^  struct arg_impl {$/;"	s	namespace:Eigen::internal
arg_impl	Eigen/src/Core/MathFunctions.h	/^  template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
arg_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template <> struct arg_prod<empty_list> {$/;"	s	namespace:Eigen::internal
arg_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template <class NList> struct arg_prod {$/;"	s	namespace:Eigen::internal
arg_retval	Eigen/src/Core/MathFunctions.h	/^struct arg_retval$/;"	s	namespace:Eigen::internal
argmax	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    argmax() const {$/;"	f	class:Eigen::TensorBase
argmax	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    argmax(const int return_dim) const {$/;"	f	class:Eigen::TensorBase
argmin	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    argmin() const {$/;"	f	class:Eigen::TensorBase
argmin	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    argmin(const int return_dim) const {$/;"	f	class:Eigen::TensorBase
args_	bench/tensors/benchmark.h	/^  std::vector<int> args_;$/;"	m	class:testing::Benchmark
arpack_wrapper	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^template <> struct arpack_wrapper<double, double>$/;"	s	namespace:Eigen::internal
arpack_wrapper	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^template <> struct arpack_wrapper<float, float>$/;"	s	namespace:Eigen::internal
arpack_wrapper	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^template<typename Scalar, typename RealScalar> struct arpack_wrapper$/;"	s	namespace:Eigen::internal
arr	doc/snippets/TopicAliasing_cwise.cpp	/^ArrayXXf arr = mat;$/;"	v
array	Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase
array	Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  T array[1];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ArrayWrapper<Derived> array() { return ArrayWrapper<Derived>(derived()); }$/;"	f	class:Eigen::MatrixBase
array	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const ArrayWrapper<const Derived> array() const { return ArrayWrapper<const Derived>(derived()); }$/;"	f	class:Eigen::MatrixBase
array	doc/snippets/Map_general_stride.cpp	/^int array[24];$/;"	v
array	doc/snippets/Map_inner_stride.cpp	/^int array[12];$/;"	v
array	doc/snippets/Map_outer_stride.cpp	/^int array[12];$/;"	v
array	doc/snippets/Map_simple.cpp	/^int array[9];$/;"	v
array	doc/snippets/Tutorial_Map_rowmajor.cpp	/^int array[8];$/;"	v
array	test/array.cpp	/^template<typename ArrayType> void array(const ArrayType& m)$/;"	f
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_DEVICE_FUNC array(std::initializer_list<T> l) : dummy() {$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array($/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array() : dummy() { }$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array() { }$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(const T& v) {$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(const T& v1, const T& v2) {$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(const T& v1, const T& v2, const T& v3) {$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(const T& v1, const T& v2, const T& v3, const T& v4,$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(const T& v1, const T& v2, const T& v3,$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE array(std::initializer_list<T> l) {$/;"	f	class:Eigen::array
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template <typename T, size_t n> class array {$/;"	c	namespace:Eigen
array	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template <typename T> class array<T, 0> {$/;"	c	namespace:Eigen
array_	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  Elem array_[kSize];$/;"	m	class:Eigen::RunQueue
array_apply_and_reduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^inline bool array_apply_and_reduce(const array<A, N>& a) {$/;"	f	namespace:Eigen::internal
array_complex	test/array.cpp	/^template<typename ArrayType> void array_complex(const ArrayType& m)$/;"	f
array_for_matrix	test/array_for_matrix.cpp	/^template<typename MatrixType> void array_for_matrix(const MatrixType& m)$/;"	f
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^template<DenseIndex n, typename Index, std::size_t Rank> const Index array_get(DimensionList<Index, Rank>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^template<DenseIndex n, typename Index, std::size_t Rank> const Index array_get(const DimensionList<Index, Rank>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <std::ptrdiff_t n, typename std::ptrdiff_t... Indices> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t array_get(const Sizes<Indices...>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <std::ptrdiff_t n> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t array_get(const Sizes<>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <std::size_t n, std::size_t V1, std::size_t V2, std::size_t V3, std::size_t V4, std::size_t V5> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::size_t array_get(const Sizes<V1,V2,V3,V4,V5>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC constexpr const typename IndexTupleExtractor<N, T, O...>::ValType& array_get(const IndexTuple<T, O...>& tuple) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC constexpr typename IndexTupleExtractor<N, T, O...>::ValType& array_get(IndexTuple<T, O...>& tuple) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<DenseIndex N, typename FirstType, typename... OtherTypes> EIGEN_DEVICE_FUNC constexpr DenseIndex array_get(IndexList<FirstType, OtherTypes...>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<DenseIndex N, typename FirstType, typename... OtherTypes> EIGEN_DEVICE_FUNC constexpr DenseIndex array_get(const IndexList<FirstType, OtherTypes...>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	/^template<std::size_t I, class T> constexpr inline T const& array_get(std::vector<T> const& a) { return a[I]; }$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	/^template<std::size_t I, class T> constexpr inline T&       array_get(std::vector<T>&       a) { return a[I]; }$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	/^template<std::size_t I, class T> constexpr inline T&&      array_get(std::vector<T>&&      a) { return a[I]; }$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T& array_get(array<T,N>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const T& array_get(const array<T,N>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T& array_get(std::vector<T>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const T& array_get(const std::vector<T>& a) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename Head::type array_get(const type_list<Head, Tail>&) {$/;"	f	namespace:Eigen::internal
array_get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename Head::type array_get(type_list<Head, Tail>&) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t array_prod(const Sizes<Indices...>&) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<typename FirstType, typename... OtherTypes> size_t array_prod(const IndexList<FirstType, OtherTypes...>& sizes) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE t array_prod(const array<t, 0>& \/*a*\/) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE t array_prod(const array<t, n>& a) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE t array_prod(const std::vector<t>& a) {$/;"	f	namespace:Eigen::internal
array_prod	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename NList::HeadType::type array_prod(const NList&) {$/;"	f	namespace:Eigen::internal
array_real	test/array.cpp	/^template<typename ArrayType> void array_real(const ArrayType& m)$/;"	f
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^template<typename Index, std::size_t Rank> struct array_size<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^template<typename Index, std::size_t Rank> struct array_size<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <std::size_t V1, std::size_t V2, std::size_t V3, std::size_t V4, std::size_t V5> struct array_size<Sizes<V1,V2,V3,V4,V5> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <std::size_t V1, std::size_t V2, std::size_t V3, std::size_t V4, std::size_t V5> struct array_size<const Sizes<V1,V2,V3,V4,V5> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <typename DenseIndex, int NumDims> struct array_size<DSizes<DenseIndex, NumDims> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <typename DenseIndex, int NumDims> struct array_size<const DSizes<DenseIndex, NumDims> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <typename std::ptrdiff_t... Indices> struct array_size<Sizes<Indices...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template <typename std::ptrdiff_t... Indices> struct array_size<const Sizes<Indices...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct array_size<IndexTuple<T, O...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct array_size<const IndexTuple<T, O...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<typename FirstType, typename... OtherTypes> struct array_size<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<typename FirstType, typename... OtherTypes> struct array_size<IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<typename FirstType, typename... OtherTypes> struct array_size<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^template<typename FirstType, typename... OtherTypes> struct array_size<const IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template<class T, std::size_t N> struct array_size<array<T,N> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template<class T, std::size_t N> struct array_size<array<T,N>& > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template<class T, std::size_t N> struct array_size<const array<T,N> > {$/;"	s	namespace:Eigen::internal
array_size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^template<class T, std::size_t N> struct array_size<const array<T,N>& > {$/;"	s	namespace:Eigen::internal
array_special_functions	unsupported/test/special_functions.cpp	/^template<typename ArrayType> void array_special_functions()$/;"	f
array_zip_and_reduce	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^inline bool array_zip_and_reduce(const array<A, N>& a, const array<B, N>& b) {$/;"	f	namespace:Eigen::internal
asDiagonal	Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase
asPermutation	Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase
asSluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal
as_scalar_product	test/diagonalmatrices.cpp	/^template<typename MatrixType> void as_scalar_product(const MatrixType& m)$/;"	f
asec	unsupported/test/mpreal/mpreal.h	/^inline const mpreal asec  (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return acos (1\/v, r);                      }$/;"	f	namespace:mpfr
asech	unsupported/test/mpreal/mpreal.h	/^inline const mpreal asech (const mpreal& v, mp_rnd_t r = mpreal::get_default_rnd()) {   return acosh(1\/v, r);                      }$/;"	f	namespace:mpfr
asin	Eigen/src/Core/MathFunctions.h	/^T asin(const T &x) {$/;"	f	namespace:Eigen::numext
asin	Eigen/src/Core/MathFunctions.h	/^double asin(const double &x) { return ::asin(x); }$/;"	f	namespace:Eigen::numext
asin	Eigen/src/Core/MathFunctions.h	/^float asin(const float &x) { return ::asinf(x); }$/;"	f	namespace:Eigen::numext
asin	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f
asin	unsupported/test/mpreal/mpreal.h	/^inline const mpreal asin  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(asin );    }$/;"	f	namespace:mpfr
asinh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal asinh (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(asinh);    }$/;"	f	namespace:mpfr
assignCoeff	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignCoeff	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignCoeff	Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignCoeff	Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a *= b; }$/;"	f	struct:Eigen::internal::mul_assign_op
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a += b; }$/;"	f	struct:Eigen::internal::add_assign_op
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a -= b; }$/;"	f	struct:Eigen::internal::sub_assign_op
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }$/;"	f	struct:Eigen::internal::assign_op
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a \/= b; }$/;"	f	struct:Eigen::internal::div_assign_op
assignCoeff	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Scalar& a, const Scalar& b) const$/;"	f	struct:Eigen::internal::swap_assign_op
assignCoeffByOuterInner	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignDiagonalCoeff	Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignDiagonalCoeff	Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignGeneric	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other) {$/;"	f	class:Eigen::SkylineMatrixBase
assignOppositeCoeff	Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index, Index)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignOppositeCoeff	Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index row, Index col)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
assignPacket	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	Eigen/src/Core/Swap.h	/^  void assignPacket(Index index)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	Eigen/src/Core/Swap.h	/^  void assignPacket(Index row, Index col)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacket	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::add_assign_op
assignPacket	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::assign_op
assignPacket	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::div_assign_op
assignPacket	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::mul_assign_op
assignPacket	Eigen/src/Core/functors/AssignmentFunctors.h	/^  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const$/;"	f	struct:Eigen::internal::sub_assign_op
assignPacketByOuterInner	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignPacketByOuterInner	Eigen/src/Core/Swap.h	/^  void assignPacketByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
assignProduct	Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase
assignTranspose	Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct assign_op {$/;"	s	namespace:Eigen::internal
assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar> struct assign_op<DstScalar,void> {};$/;"	s	namespace:Eigen::internal
assign_sparse_to_sparse	Eigen/src/SparseCore/SparseAssign.h	/^void assign_sparse_to_sparse(DstXprType &dst, const SrcXprType &src)$/;"	f	namespace:Eigen::internal
assignment_from_xpr_op_product	Eigen/src/Core/ProductEvaluators.h	/^struct assignment_from_xpr_op_product$/;"	s	namespace:Eigen::internal
asum	blas/level1_real_impl.h	/^RealScalar EIGEN_BLAS_FUNC(asum)(int *n, RealScalar *px, int *incx)$/;"	f
asum_	blas/level1_cplx_impl.h	/^RealScalar EIGEN_CAT(EIGEN_CAT(REAL_SCALAR_SUFFIX,SCALAR_SUFFIX),asum_)(int *n, RealScalar *px, int *incx)$/;"	f
at	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atInRange	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(Index start, Index end, Index key, const Scalar &defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atWithInsertion	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage
ata_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void ata_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:blaze_interface
ata_product	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void ata_product(const gene_matrix & A, gene_matrix & X, int N)$/;"	f	class:blitz_interface
ata_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void ata_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:eigen2_interface
ata_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void ata_product(const gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:gmm_interface
ata_product	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void ata_product(gene_matrix & A, gene_matrix & X, int N){$/;"	f	class:ublas_interface
atan	Eigen/src/Core/MathFunctions.h	/^T atan(const T &x) {$/;"	f	namespace:Eigen::numext
atan	Eigen/src/Core/MathFunctions.h	/^double atan(const double &x) { return ::atan(x); }$/;"	f	namespace:Eigen::numext
atan	Eigen/src/Core/MathFunctions.h	/^float atan(const float &x) { return ::atanf(x); }$/;"	f	namespace:Eigen::numext
atan	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^atan() const$/;"	f
atan	unsupported/test/mpreal/mpreal.h	/^inline const mpreal atan  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(atan );    }$/;"	f	namespace:mpfr
atan2	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^atan2(const AutoDiffScalar<DerTypeA>& a, const AutoDiffScalar<DerTypeB>& b)$/;"	f	namespace:Eigen
atan2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal atan2 (const mpreal& y, const mpreal& x, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
atanh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal atanh (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(atanh);    }$/;"	f	namespace:mpfr
atomicExchCustom	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__device__ inline Type atomicExchCustom(Type* address, Type val) {$/;"	f	namespace:Eigen::internal
atomicExchCustom	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__device__ inline double atomicExchCustom(double* address, double val) {$/;"	f	namespace:Eigen::internal
atomicReduce	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__device__ EIGEN_ALWAYS_INLINE void atomicReduce(T* output, T accum, R& reducer) {$/;"	f	namespace:Eigen::internal
atomicReduce	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__device__ inline void atomicReduce(float* output, float accum, SumReducer<float>&) {$/;"	f	namespace:Eigen::internal
atomicReduce	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^__device__ inline void atomicReduce(half2* output, half2 accum, R<half>& reducer) {$/;"	f	namespace:Eigen::internal
attachMyMatrix	doc/examples/matrixfree_cg.cpp	/^  void attachMyMatrix(const SparseMatrix<double> &mat) {$/;"	f	class:MatrixReplacement
atv_product	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blas_interface
atv_product	bench/btl/libs/STL/STL_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:STL_interface
atv_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blaze_interface
atv_product	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:blitz_interface
atv_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:eigen2_interface
atv_product	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
atv_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:gmm_interface
atv_product	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:mtl4_interface
atv_product	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:tvmet_interface
atv_product	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void atv_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:ublas_interface
auto_diff_special_op	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct auto_diff_special_op<_DerType, false>$/;"	s	namespace:Eigen::internal
auto_diff_special_op	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct auto_diff_special_op<_DerType, true>$/;"	s	namespace:Eigen::internal
aux_evalSolver	unsupported/test/polynomialsolver.cpp	/^bool aux_evalSolver( const POLYNOMIAL& pols, SOLVER& psolve )$/;"	f
avec	test/dynalloc.cpp	/^    Vector8f avec;$/;"	m	class:MyClassA	file:
avec	test/dynalloc.cpp	/^  Vector8f avec;$/;"	m	struct:MyStruct	file:
axis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    EIGEN_DEVICE_FUNC const Axis& axis() const { return m_axis; }$/;"	f	class:Eigen::TensorConcatenationOp
axis	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Index axis() const { return m_axis; }$/;"	f	class:Eigen::TensorScanOp
axpby	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void axpby(SCALAR a, const gene_vector & X, SCALAR b, gene_vector & Y, int N){$/;"	f	class:blas_interface
axpby	bench/btl/libs/STL/STL_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:STL_interface
axpby	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:blaze_interface
axpby	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:eigen2_interface
axpby	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int  \/*N*\/){$/;"	f	class:eigen3_interface
axpby	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:gmm_interface
axpby	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:mtl4_interface
axpby	bench/btl/libs/tensors/tensor_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int  \/*N*\/){$/;"	f	class:tensor_interface
axpby	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void axpby(real a, const gene_vector & X, real b, gene_vector & Y, int N){$/;"	f	class:ublas_interface
axpy	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void axpy(SCALAR coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:blas_interface
axpy	bench/btl/libs/STL/STL_interface.hh	/^  static inline void axpy(real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:STL_interface
axpy	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:blaze_interface
axpy	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N)$/;"	f	class:blitz_interface
axpy	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:tiny_blitz_interface
axpy	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void axpy(real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:eigen2_interface
axpy	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void axpy(real coef, const gene_vector & X, gene_vector & Y, int  \/*N*\/){$/;"	f	class:eigen3_interface
axpy	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:gmm_interface
axpy	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:mtl4_interface
axpy	bench/btl/libs/tensors/tensor_interface.hh	/^  static inline void axpy(real coef, const gene_vector & X, gene_vector & Y, int  \/*N*\/){$/;"	f	class:tensor_interface
axpy	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:tvmet_interface
axpy	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void axpy(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:ublas_interface
axpy	blas/level1_impl.h	/^int EIGEN_BLAS_FUNC(axpy)(const int *n, const RealScalar *palpha, const RealScalar *px, const int *incx, RealScalar *py, const int *incy)$/;"	f
axpy_slow	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void axpy_slow(const real coef, const gene_vector & X, gene_vector & Y, int N){$/;"	f	class:ublas_interface
b	Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon779
b	doc/snippets/Cwise_product.cpp	/^Array33i a = Array33i::Random(), b = Array33i::Random();$/;"	v
b	doc/snippets/LeastSquaresNormalEquations.cpp	/^VectorXf b = VectorXf::Random(3);$/;"	v
b	doc/snippets/LeastSquaresQR.cpp	/^VectorXf b = VectorXf::Random(3);$/;"	v
b	doc/snippets/MatrixBase_cwiseProduct.cpp	/^Matrix3i a = Matrix3i::Random(), b = Matrix3i::Random();$/;"	v
b	doc/snippets/MatrixBase_noalias.cpp	/^Matrix2d a, b, c; a << 1,2,3,4; b << 5,6,7,8;$/;"	v
b	doc/snippets/Tutorial_solve_matrix_inverse.cpp	/^Vector3f b;$/;"	v
b	doc/snippets/Tutorial_solve_reuse_decomposition.cpp	/^Vector3f b;$/;"	v
b	doc/snippets/Tutorial_solve_singular.cpp	/^Vector3f b;$/;"	v
b	doc/snippets/Tutorial_solve_triangular.cpp	/^Vector3f b;$/;"	v
b	doc/snippets/Tutorial_solve_triangular_inplace.cpp	/^A.triangularView<Upper>().solveInPlace(b);$/;"	v
b	doc/snippets/Tutorial_solve_triangular_inplace.cpp	/^Vector3f b;$/;"	v
b_	bench/tensors/tensor_benchmarks.h	/^  T* b_;$/;"	m	class:BenchmarkSuite
back	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& back() { return values[n-1]; }$/;"	f	class:Eigen::array
back	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& back() {$/;"	f	class:Eigen::array
back	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& back() const { return values[n-1]; }$/;"	f	class:Eigen::array
back	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& back() const {$/;"	f	class:Eigen::array
back	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T& back() {$/;"	f	class:Eigen::MaxSizeVector
back	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  const T& back() const {$/;"	f	class:Eigen::MaxSizeVector
back_	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  std::atomic<unsigned> back_;$/;"	m	class:Eigen::RunQueue
balance	unsupported/Eigen/src/Polynomials/Companion.h	/^void companion<_Scalar,_Deg>::balance()$/;"	f	class:Eigen::internal::companion
balanced	unsupported/Eigen/src/Polynomials/Companion.h	/^bool companion<_Scalar,_Deg>::balanced( Scalar colNorm, Scalar rowNorm,$/;"	f	class:Eigen::internal::companion
balancedR	unsupported/Eigen/src/Polynomials/Companion.h	/^bool companion<_Scalar,_Deg>::balancedR( Scalar colNorm, Scalar rowNorm,$/;"	f	class:Eigen::internal::companion
band_solve_triangular_selector	blas/BandTriangularSolver.h	/^struct band_solve_triangular_selector<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ColMajor>$/;"	s	namespace:internal
band_solve_triangular_selector	blas/BandTriangularSolver.h	/^struct band_solve_triangular_selector<Index,Mode,LhsScalar,ConjLhs,RhsScalar,RowMajor>$/;"	s	namespace:internal
bandmatrix	test/bandmatrix.cpp	/^template<typename MatrixType> void bandmatrix(const MatrixType& _m)$/;"	f
base	Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    inline Self& base()             { return *this; }$/;"	f	class:Eigen::Tensor
base	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    inline const Self& base() const { return *this; }$/;"	f	class:Eigen::Tensor
base	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    inline Self& base()             { return *this; }$/;"	f	class:Eigen::TensorFixedSize
base	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    inline const Self& base() const { return *this; }$/;"	f	class:Eigen::TensorFixedSize
baseline	bench/btl/generic_bench/timers/STL_timer.hh	/^  bool baseline;$/;"	m	class:STL_Timer
baseline_time	bench/btl/generic_bench/timers/STL_timer.hh	/^  double baseline_time;$/;"	m	class:STL_Timer
basicStuff	test/basicstuff.cpp	/^template<typename MatrixType> void basicStuff(const MatrixType& m)$/;"	f
basicStuffComplex	test/basicstuff.cpp	/^template<typename MatrixType> void basicStuffComplex(const MatrixType& m)$/;"	f
basisFunctionDerivatives	unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::basisFunctionDerivatives(Scalar u, DenseIndex order) const$/;"	f	class:Eigen::Spline
basisFunctions	unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::basisFunctions(Scalar u) const$/;"	f	class:Eigen::Spline
bdcSvd	Eigen/src/SVD/BDCSVD.h	/^MatrixBase<Derived>::bdcSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
bdcsvd	test/bdcsvd.cpp	/^void bdcsvd(const MatrixType& a = MatrixType(), bool pickrandom = true)$/;"	f
bdcsvd_method	test/bdcsvd.cpp	/^void bdcsvd_method()$/;"	f
begin	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T* begin() { return data_; }$/;"	f	class:Eigen::MaxSizeVector
begin	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  const T* begin() const { return data_; }$/;"	f	class:Eigen::MaxSizeVector
beginsWith	bench/btl/generic_bench/btl.hh	/^    bool beginsWith(const BtlString& str) const$/;"	f	class:BtlString
bench	bench/benchFFT.cpp	/^void bench(int nfft,bool fwd,bool unscaled=false, bool halfspec=false)$/;"	f
bench	bench/btl/generic_bench/bench.hh	/^BTL_DONT_INLINE void bench( int size_min, int size_max, int nb_point )$/;"	f
bench	bench/btl/generic_bench/bench.hh	/^BTL_DONT_INLINE void bench( int size_min, int size_max, int nb_point ){$/;"	f
bench	bench/dense_solvers.cpp	/^void bench(int id, int rows, int size = Size)$/;"	f
bench	bench/geometry.cpp	/^EIGEN_DONT_INLINE void bench(const std::string& msg, const Transformation& t)$/;"	f
bench	bench/perf_monitoring/gemm/gemm.cpp	/^double bench(long m, long n, long k)$/;"	f
bench	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^double bench()$/;"	f
bench	bench/quatmul.cpp	/^template<typename Quat> void bench(const std::string& label)$/;"	f
benchBasic	bench/basicbenchmark.h	/^double benchBasic(const MatrixType& mat, int iterations, int tries)$/;"	f
benchBasic_loop	bench/basicbenchmark.h	/^void benchBasic_loop(const MatrixType& I, MatrixType& m, int iterations)$/;"	f
benchEigenSolver	bench/benchEigenSolver.cpp	/^__attribute__ ((noinline)) void benchEigenSolver(const MatrixType& m)$/;"	f
benchLLT	bench/benchCholesky.cpp	/^__attribute__ ((noinline)) void benchLLT(const MatrixType& m)$/;"	f
benchVec	bench/benchVecAdd.cpp	/^void benchVec(MatrixXf& a, MatrixXf& b, MatrixXf& c)$/;"	f
benchVec	bench/benchVecAdd.cpp	/^void benchVec(Scalar* a, Scalar* b, Scalar* c, int size)$/;"	f
benchVec	bench/benchVecAdd.cpp	/^void benchVec(VectorXf& a, VectorXf& b, VectorXf& c)$/;"	f
bench_eigengemm	bench/benchBlasGemm.cpp	/^void bench_eigengemm(MyMatrix& mc, const MyMatrix& ma, const MyMatrix& mb, int nbloops)$/;"	f
bench_fixed_size	bench/btl/generic_bench/static/intel_bench_fixed_size.hh	/^double bench_fixed_size(int size, unsigned long long  & nb_calc,unsigned long long & nb_init)$/;"	f
bench_impl	bench/geometry.cpp	/^struct bench_impl$/;"	s	file:
bench_impl	bench/geometry.cpp	/^struct bench_impl<Transformation,0>$/;"	s	file:
bench_mnk	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^double bench_mnk(int m, int n, int k, int t)$/;"	f
bench_printhelp	bench/spbench/spbenchsolver.cpp	/^void bench_printhelp()$/;"	f
bench_prod	bench/product_threshold.cpp	/^EIGEN_DONT_INLINE void bench_prod()$/;"	f
bench_reverse	bench/bench_reverse.cpp	/^__attribute__ ((noinline)) void bench_reverse(const MatrixType& m)$/;"	f
bench_static	bench/btl/generic_bench/static/bench_static.hh	/^BTL_DONT_INLINE  void bench_static(void)$/;"	f
bench_svd	unsupported/bench/bench_svd.cpp	/^void bench_svd(const MatrixType& a = MatrixType())$/;"	f
bench_t	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^double bench_t(int t)$/;"	f
besselj0	unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselj0(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(j0     );    }$/;"	f	namespace:mpfr
besselj1	unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselj1(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(j1     );    }$/;"	f	namespace:mpfr
besseljn	unsupported/test/mpreal/mpreal.h	/^inline const mpreal besseljn (long n, const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
bessely0	unsupported/test/mpreal/mpreal.h	/^inline const mpreal bessely0(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(y0     );    }$/;"	f	namespace:mpfr
bessely1	unsupported/test/mpreal/mpreal.h	/^inline const mpreal bessely1(const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(y1     );    }$/;"	f	namespace:mpfr
besselyn	unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselyn (long n, const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
best	bench/BenchTimer.h	/^  inline double best(int TIMER = CPU_TIMER) const$/;"	f	class:Eigen::BenchTimer
best_pot_block_size	bench/analyze-blocking-sizes.cpp	/^    uint16_t best_pot_block_size;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
best_pot_gflops	bench/analyze-blocking-sizes.cpp	/^    float best_pot_gflops;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
best_time_id	bench/spbench/spbenchsolver.h	/^int best_time_id; \/\/  id of the best solver for the current system $/;"	v
best_time_val	bench/spbench/spbenchsolver.h	/^double best_time_val; \/\/ Current best time overall solvers $/;"	v
beta	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar beta() const { return m_angles[1]; }$/;"	f	class:Eigen::EulerAngles
beta	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar& beta() { return m_angles[1]; }$/;"	f	class:Eigen::EulerAngles
betainc	unsupported/Eigen/CXX11/src/Tensor/TensorGlobalFunctions.h	/^    betainc(const ADerived& a, const BDerived& b, const XDerived& x) {$/;"	f	namespace:Eigen
betainc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^betainc(const Eigen::ArrayBase<ArgADerived>& a, const Eigen::ArrayBase<ArgBDerived>& b, const Eigen::ArrayBase<ArgXDerived>& x)$/;"	f	namespace:Eigen
betainc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half betainc(const Eigen::half& a, const Eigen::half& b, const Eigen::half& x) {$/;"	f	namespace:Eigen::numext
betainc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    betainc(const Scalar& a, const Scalar& b, const Scalar& x) {$/;"	f	namespace:Eigen::numext
betainc_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_helper {};$/;"	s	namespace:Eigen::internal
betainc_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_helper<double> {$/;"	s	namespace:Eigen::internal
betainc_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_helper<float> {$/;"	s	namespace:Eigen::internal
betainc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_impl {$/;"	s	namespace:Eigen::internal
betainc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_impl<double> {$/;"	s	namespace:Eigen::internal
betainc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_impl<float> {$/;"	s	namespace:Eigen::internal
betainc_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct betainc_retval {$/;"	s	namespace:Eigen::internal
betas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType betas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
bfly2	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly2( Complex * Fout, const size_t fstride, int m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly3	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly3( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly4	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly4( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly5	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly5( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly_generic	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly_generic($/;"	f	struct:Eigen::internal::kiss_cpx_fft
bicgstab	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
bidiagonal	Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
big	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar big() { assert(false && "big not supported for this type"); return 0.0; }$/;"	f	struct:Eigen::internal::cephes_helper
big	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double big() {$/;"	f	struct:Eigen::internal::cephes_helper
big	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float big() {$/;"	f	struct:Eigen::internal::cephes_helper
big_sparse_triplet	test/sparse_basic.cpp	/^void big_sparse_triplet(Index rows, Index cols, double density) {$/;"	f
biginv	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar biginv() { assert(false && "biginv not supported for this type"); return 0.0; }$/;"	f	struct:Eigen::internal::cephes_helper
biginv	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double biginv() {$/;"	f	struct:Eigen::internal::cephes_helper
biginv	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float biginv() {$/;"	f	struct:Eigen::internal::cephes_helper
binaryExpr	Eigen/src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f
binaryExpr	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    binaryExpr(const OtherDerived& other, const CustomBinaryOp& func) const {$/;"	f	class:Eigen::TensorBase
binary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit binary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit binary_evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit binary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::binary_evaluator
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_boolean_and_op, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_product_op<T1,T2>, Lhs, Rhs>, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
binary_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct binary_evaluator<CwiseBinaryOp<scalar_quotient_op<T1,T2>, Lhs, Rhs>, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
binary_op_base	Eigen/src/Core/functors/BinaryFunctors.h	/^struct binary_op_base$/;"	s	namespace:Eigen::internal
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	s	namespace:Eigen::internal
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
bind1st_op	Eigen/src/Core/functors/BinaryFunctors.h	/^  bind1st_op(const first_argument_type &val) : m_value(val) {}$/;"	f	struct:Eigen::internal::bind1st_op
bind1st_op	Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct bind1st_op : BinaryOp {$/;"	s	namespace:Eigen::internal
bind2nd_op	Eigen/src/Core/functors/BinaryFunctors.h	/^  bind2nd_op(const second_argument_type &val) : m_value(val) {}$/;"	f	struct:Eigen::internal::bind2nd_op
bind2nd_op	Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct bind2nd_op : BinaryOp {$/;"	s	namespace:Eigen::internal
binom	unsupported/test/matrix_exponential.cpp	/^double binom(int n, int k)$/;"	f
bits2digits	unsupported/test/mpreal/mpreal.h	/^inline int bits2digits(mp_prec_t b)$/;"	f	namespace:mpfr
bk	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Index bk(Index k) const { return k + 1 < nk_ ? bk_ : k_ + bk_ - bk_ * nk_; }$/;"	f	class:Eigen::TensorEvaluator::Context
bk_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index bk_;$/;"	m	class:Eigen::TensorEvaluator::Context
bl2passNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar bl2passNorm(T& v)$/;"	f
blas_PRODUIT_MATRICE_VECTEUR_HH	bench/btl/libs/BLAS/blas_interface.hh	21;"	d
blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper
blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper {$/;"	c	namespace:Eigen::internal
blas_gemm	bench/bench_gemm.cpp	/^EIGEN_DONT_INLINE void blas_gemm(const MatrixXd& a, const MatrixXd& b, MatrixXd& c)$/;"	f
blas_gemm	bench/bench_gemm.cpp	/^void blas_gemm(const MatrixXcd& a, const MatrixXcd& b, MatrixXcd& c)$/;"	f
blas_gemm	bench/bench_gemm.cpp	/^void blas_gemm(const MatrixXcf& a, const MatrixXcf& b, MatrixXcf& c)$/;"	f
blas_gemm	bench/bench_gemm.cpp	/^void blas_gemm(const MatrixXf& a, const MatrixXf& b, MatrixXf& c)$/;"	f
blas_interface	bench/btl/libs/BLAS/blas_interface_impl.hh	/^template<> class blas_interface<SCALAR> : public c_interface_base<SCALAR>$/;"	c
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain1>,$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
blaze_interface	bench/btl/libs/blaze/blaze_interface.hh	/^class blaze_interface {$/;"	c
blitz_LU_solve_interface	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^class blitz_LU_solve_interface : public blitz_interface<real>$/;"	c
blitz_LU_solve_interface	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^class blitz_LU_solve_interface : public blitz_interface<real>$/;"	c
blitz_LU_solve_interface	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^class blitz_LU_solve_interface : public blitz_interface<real>$/;"	c
blitz_interface	bench/btl/libs/blitz/blitz_interface.hh	/^class blitz_interface{$/;"	c
block	Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol) const$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol,$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol)$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<NRows,NCols>::Type block(Index startRow, Index startCol,$/;"	f
block	test/block.cpp	/^template<typename MatrixType> void block(const MatrixType& m)$/;"	f
blockA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking
blockA	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  LhsScalar* blockA;$/;"	m	struct:Eigen::internal::packLhsArg
blockAs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const MaxSizeVector<LhsScalar*>* blockAs;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
blockB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking
blockB	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  RhsScalar* blockB;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
blockCols	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl
blockCols	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
blockCols	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockCols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl
blockCols	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockCols() const$/;"	f	class:Eigen::BlockSparseMatrix
blockColsIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockColsIndex(Index bj) const$/;"	f	class:Eigen::BlockSparseMatrix
blockDim	test/cuda_common.h	/^dim3 threadIdx, blockDim, blockIdx;$/;"	v
blockIdx	test/cuda_common.h	/^dim3 threadIdx, blockDim, blockIdx;$/;"	v
blockInnerIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockInnerIndex(Index bi) const$/;"	f	class:Eigen::BlockSparseMatrix
blockInnerSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockInnerSize(Index bi) const$/;"	f	class:Eigen::BlockSparseMatrix
blockOuterIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockOuterIndex(Index bj) const$/;"	f	class:Eigen::BlockSparseMatrix
blockOuterSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockOuterSize(Index bj) const$/;"	f	class:Eigen::BlockSparseMatrix
blockPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index blockPtr(Index id) const$/;"	f	class:Eigen::BlockSparseMatrix
blockRows	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl
blockRows	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
blockRows	Eigen/src/SparseCore/SparseBlock.h	/^    Index blockRows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl
blockRows	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockRows() const$/;"	f	class:Eigen::BlockSparseMatrix
blockRowsIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index blockRowsIndex(Index bi) const$/;"	f	class:Eigen::BlockSparseMatrix
block_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)$/;"	f	struct:Eigen::internal::block_evaluator
block_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \/* HasDirectAccess *\/ true>$/;"	s	namespace:Eigen::internal
block_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, \/*HasDirectAccess*\/ false>$/;"	s	namespace:Eigen::internal
block_evaluator_type	Eigen/src/Core/CoreEvaluators.h	/^  typedef block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block_evaluator_type;$/;"	t	struct:Eigen::internal::evaluator
block_real_only	test/block.cpp	/^block_real_only(const MatrixType &, Index, Index, Index, Index, const Scalar&) {$/;"	f
block_real_only	test/block.cpp	/^block_real_only(const MatrixType &m1, Index r1, Index r2, Index c1, Index c2, const Scalar& s1) {$/;"	f
block_size	bench/analyze-blocking-sizes.cpp	/^  uint16_t block_size;$/;"	m	struct:preprocessed_inputfile_entry_t	file:
blocked	Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
blocked	Eigen/src/Cholesky/LLT.h	/^  static Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace
blocked_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  std::atomic<unsigned> blocked_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
blocked_lu	Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl
blueNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase
blueNorm	Eigen/src/Core/VectorwiseOp.h	/^    const BlueNormReturnType blueNorm() const$/;"	f	class:Eigen::VectorwiseOp
blueNorm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::SparseMatrixBase
blueNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar blueNorm(T& v)$/;"	f
blueNorm_impl	Eigen/src/Core/StableNorm.h	/^blueNorm_impl(const EigenBase<Derived>& _vec)$/;"	f	namespace:Eigen::internal
bm	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Index bm(Index m) const { return m + 1 < nm0_ ? bm_ : m_ + bm_ - bm_ * nm0_; }$/;"	f	class:Eigen::TensorEvaluator::Context
bm_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index bm_;$/;"	m	class:Eigen::TensorEvaluator::Context
bn	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Index bn(Index n) const { return n + 1 < nn0_ ? bn_ : n_ + bn_ - bn_ * nn0_; }$/;"	f	class:Eigen::TensorEvaluator::Context
bn_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index bn_;$/;"	m	class:Eigen::TensorEvaluator::Context
boost	test/boostmultiprec.cpp	/^namespace boost {$/;"	n	file:
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomLeftCorner() const$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomLeftCorner()$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomRightCorner() const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomRightCorner()$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows(Index n = N) const$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows(Index n = N)$/;"	f
bottom_value	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T bottom_value() {$/;"	f	struct:Eigen::internal::MinMaxBottomValue
bounded_acos	test/geo_quaternion.cpp	/^template<typename T> T bounded_acos(T v)$/;"	f
bounding_box	unsupported/doc/examples/BVH_Example.cpp	/^  Box2d bounding_box(const Vector2d &v) { return Box2d(v, v); } \/\/compute the bounding box of a single point$/;"	f	namespace:Eigen
bounding_box	unsupported/test/BVH.cpp	/^template<int Dim> AlignedBox<double, Dim> bounding_box(const Ball<Dim> &b)$/;"	f
bounding_box	unsupported/test/BVH.cpp	/^template<typename Scalar, int Dim> AlignedBox<Scalar, Dim> bounding_box(const Matrix<Scalar, Dim, 1> &v) { return AlignedBox<Scalar, Dim>(v); }$/;"	f	namespace:Eigen
boxes	unsupported/Eigen/src/BVH/KdBVH.h	/^  VolumeList boxes;$/;"	m	class:Eigen::KdBVH
broadcast	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    broadcast(const Broadcast& broadcast) const {$/;"	f	class:Eigen::TensorBase
broadcast	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    const Broadcast& broadcast() const { return m_broadcast; }$/;"	f	class:Eigen::TensorBroadcastingOp
broadcastRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, DoublePacketType& b0, DoublePacketType& b1)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void broadcastRhs(const RhsScalar* b, RhsScalar& b0, RhsScalar& b1)$/;"	f	class:Eigen::internal::gebp_traits
broadcastRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  void broadcastRhs(const RhsScalar* b, RhsPacket& b0, RhsPacket& b1, RhsPacket& b2, RhsPacket& b3)$/;"	f	class:Eigen::internal::gebp_traits
broadcasting	bench/tensors/tensor_benchmarks.h	/^  void broadcasting(int num_iters) {$/;"	f	class:BenchmarkSuite
broadcasting	bench/tensors/tensor_benchmarks_sycl.cc	/^BM_FuncGPU(broadcasting);$/;"	v
bruteforce_det3_helper	Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal
bruteforce_det4_helper	Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal
buffer	demos/mandelbrot/mandelbrot.h	/^    unsigned char *buffer;$/;"	m	class:MandelbrotWidget
buffer	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    EIGEN_DEVICE_FUNC PointerType buffer() const { return m_buffer; }$/;"	f	class:Eigen::TensorEvalToOp
buffer_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Scalar* const buffer_;$/;"	m	class:Eigen::TensorEvaluator::Context
buffer_map	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  mutable std::map<const void *, std::shared_ptr<void>> buffer_map;$/;"	m	struct:Eigen::SyclDevice
bug1213_1	test/bug1213.cpp	/^bool bug1213_1(const Eigen::Vector3f& x)$/;"	f
bug1213_2	test/bug1213_main.cpp	/^bool bug1213_2(const Eigen::Matrix<T,dim,1>& )$/;"	f
bug1453	test/mapstride.cpp	/^void bug1453()$/;"	f
bug890	test/permutationmatrices.cpp	/^void bug890()$/;"	f
bug987	test/diagonalmatrices.cpp	/^void bug987()$/;"	f
bug_1014	test/eigensolver_selfadjoint.cpp	/^void bug_1014()$/;"	f
bug_1204	test/eigensolver_selfadjoint.cpp	/^void bug_1204()$/;"	f
bug_1222	unsupported/test/autodiff.cpp	/^double bug_1222() {$/;"	f
bug_1223	unsupported/test/autodiff.cpp	/^double bug_1223() {$/;"	f
bug_1225	test/eigensolver_selfadjoint.cpp	/^void bug_1225()$/;"	f
bug_1260	unsupported/test/autodiff.cpp	/^void bug_1260() {$/;"	f
bug_1261	unsupported/test/autodiff.cpp	/^double bug_1261() {$/;"	f
bug_1264	unsupported/test/autodiff.cpp	/^double bug_1264() {$/;"	f
bug_127	test/product_extra.cpp	/^void bug_127()$/;"	f
bug_1308	test/product_extra.cpp	/^void bug_1308()$/;"	f
bug_1311	test/product_small.cpp	/^void bug_1311()$/;"	f
bug_159	test/selfadjoint.cpp	/^void bug_159()$/;"	f
bug_159	test/triangular.cpp	/^void bug_159()$/;"	f
bug_817	test/product_extra.cpp	/^template<int> void bug_817()$/;"	f
bug_854	test/eigensolver_selfadjoint.cpp	/^void bug_854()$/;"	f
bug_942	test/sparse_product.cpp	/^void bug_942()$/;"	f
build	unsupported/Eigen/src/BVH/KdBVH.h	/^  void build(VIPairList &objCenters, int from, int to, const VolumeList &objBoxes, int dim)$/;"	f	class:Eigen::KdBVH
buildProblem	doc/special_examples/Tutorial_sparse_example_details.cpp	/^void buildProblem(std::vector<T>& coefficients, Eigen::VectorXd& b, int n)$/;"	f
build_eigen_dictionary	debug/gdb/printers.py	/^def build_eigen_dictionary ():$/;"	f
butterfly_1D_merge	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void butterfly_1D_merge($/;"	f	struct:Eigen::TensorEvaluator
butterfly_2	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void butterfly_2(ComplexScalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
butterfly_4	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void butterfly_4(ComplexScalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
butterfly_8	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void butterfly_8(ComplexScalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
bytes_loaded	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double bytes_loaded() const {$/;"	f	class:Eigen::TensorOpCost
bytes_loaded_	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  double bytes_loaded_;$/;"	m	class:Eigen::TensorOpCost
bytes_stored	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double bytes_stored() const {$/;"	f	class:Eigen::TensorOpCost
bytes_stored_	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  double bytes_stored_;$/;"	m	class:Eigen::TensorOpCost
c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	doc/snippets/Cwise_product.cpp	/^Array33i c = a * b;$/;"	v
c	doc/snippets/MatrixBase_cwiseProduct.cpp	/^Matrix3i c = a.cwiseProduct(b);$/;"	v
c	doc/snippets/MatrixBase_noalias.cpp	/^Matrix2d a, b, c; a << 1,2,3,4; b << 5,6,7,8;$/;"	v
c	unsupported/test/cxx11_meta.cpp	/^  int c;$/;"	m	struct:dummy_inst	file:
c_	bench/tensors/tensor_benchmarks.h	/^  T* c_;$/;"	m	class:BenchmarkSuite
c_interface_base	bench/btl/libs/BLAS/c_interface_base.h	/^template<class real> class c_interface_base$/;"	c
c_to_eigen	demos/mix_eigen_and_c/binary_library.cpp	/^inline Map<MatrixXd>& c_to_eigen(C_Map_MatrixXd* ptr)$/;"	f
c_to_eigen	demos/mix_eigen_and_c/binary_library.cpp	/^inline MatrixXd& c_to_eigen(C_MatrixXd* ptr)$/;"	f
c_to_eigen	demos/mix_eigen_and_c/binary_library.cpp	/^inline const Map<MatrixXd>& c_to_eigen(const C_Map_MatrixXd* ptr)$/;"	f
c_to_eigen	demos/mix_eigen_and_c/binary_library.cpp	/^inline const MatrixXd& c_to_eigen(const C_MatrixXd* ptr)$/;"	f
c_to_fortran_numbering	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
calcMagic	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC void calcMagic(int32_t d) {$/;"	f	class:Eigen::internal::TensorIntDivisor
calculate	bench/btl/actions/action_aat_product.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_aat_product
calculate	bench/btl/actions/action_ata_product.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_ata_product
calculate	bench/btl/actions/action_atv_product.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_atv_product
calculate	bench/btl/actions/action_axpby.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_axpby
calculate	bench/btl/actions/action_axpy.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_axpy
calculate	bench/btl/actions/action_cholesky.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_cholesky
calculate	bench/btl/actions/action_ger.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_ger
calculate	bench/btl/actions/action_hessenberg.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_hessenberg
calculate	bench/btl/actions/action_hessenberg.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_tridiagonalization
calculate	bench/btl/actions/action_lu_decomp.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_lu_decomp
calculate	bench/btl/actions/action_lu_solve.hh	/^  static double calculate( int nb_calc, int size ) {$/;"	f	class:Action_lu_solve
calculate	bench/btl/actions/action_matrix_matrix_product.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_matrix_matrix_product
calculate	bench/btl/actions/action_matrix_matrix_product_bis.hh	/^  static double calculate( int nb_calc, int size ) {$/;"	f	class:Action_matrix_matrix_product_bis
calculate	bench/btl/actions/action_matrix_vector_product.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_matrix_vector_product
calculate	bench/btl/actions/action_partial_lu.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_partial_lu
calculate	bench/btl/actions/action_rot.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_rot
calculate	bench/btl/actions/action_symv.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_symv
calculate	bench/btl/actions/action_syr2.hh	/^  BTL_DONT_INLINE void calculate( void ) {$/;"	f	class:Action_syr2
calculate	bench/btl/actions/action_trisolve.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_trisolve
calculate	bench/btl/actions/action_trisolve_matrix.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_trisolve_matrix
calculate	bench/btl/actions/action_trmm.hh	/^  inline void calculate( void ) {$/;"	f	class:Action_trmm
call_assignment	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if< evaluator_assume_aliasing<Src>::value, void*>::type = 0)$/;"	f	namespace:Eigen::internal
call_assignment	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if<!evaluator_assume_aliasing<Src>::value, void*>::type = 0)$/;"	f	namespace:Eigen::internal
call_assignment	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(NoAlias<Dst,StorageBase>& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_assignment	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment(const Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment	test/evaluators.cpp	/^    EIGEN_DEVICE_FUNC void call_assignment(const NoAlias<Dst,StorageBase>& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias(Dst& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias_no_transpose	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src)$/;"	f	namespace:Eigen::internal
call_assignment_no_alias_no_transpose	Eigen/src/Core/AssignEvaluator.h	/^void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src, const Func& func)$/;"	f	namespace:Eigen::internal
call_dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen::internal
call_dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)$/;"	f	namespace:Eigen::internal
call_directsolver	bench/spbench/spbenchsolver.h	/^void call_directsolver(Solver& solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)$/;"	f
call_itersolver	bench/spbench/spbenchsolver.h	/^void call_itersolver(Solver &solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX, std::string& statFile)$/;"	f
call_ref	failtest/ref_1.cpp	/^void call_ref(Ref<VectorXf> a) { }$/;"	f
call_ref	failtest/ref_2.cpp	/^void call_ref(Ref<VectorXf> a) { }$/;"	f
call_ref	failtest/ref_3.cpp	/^void call_ref(Ref<VectorXf> a) { }$/;"	f
call_ref	failtest/ref_4.cpp	/^void call_ref(Ref<MatrixXf,0,OuterStride<> > a) {}$/;"	f
call_ref	failtest/ref_5.cpp	/^void call_ref(Ref<VectorXf> a) { }$/;"	f
call_ref	failtest/sparse_ref_1.cpp	/^void call_ref(Ref<SparseMatrix<float> > a) { }$/;"	f
call_ref	failtest/sparse_ref_2.cpp	/^void call_ref(Ref<SparseMatrix<float> > a) { }$/;"	f
call_ref	failtest/sparse_ref_3.cpp	/^void call_ref(Ref<SparseMatrix<float> > a) { }$/;"	f
call_ref	failtest/sparse_ref_4.cpp	/^void call_ref(Ref<SparseMatrix<float> > a) {}$/;"	f
call_ref	failtest/sparse_ref_5.cpp	/^void call_ref(Ref<SparseMatrix<float> > a) { }$/;"	f
call_ref	test/ref.cpp	/^void call_ref()$/;"	f
call_ref	test/sparse_ref.cpp	/^void call_ref()$/;"	f
call_ref_1	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_1(Ref<VectorXf> a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_1	test/sparse_ref.cpp	/^EIGEN_DONT_INLINE void call_ref_1(Ref<SparseMatrix<float> > a, const B &b) { VERIFY_IS_EQUAL(a.toDense(),b.toDense()); }$/;"	f
call_ref_2	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_2(const Ref<const VectorXf>& a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_2	test/sparse_ref.cpp	/^EIGEN_DONT_INLINE void call_ref_2(const Ref<const SparseMatrix<float> >& a, const B &b) { VERIFY_IS_EQUAL(a.toDense(),b.toDense()); }$/;"	f
call_ref_3	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_3(Ref<VectorXf,0,InnerStride<> > a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_3	test/sparse_ref.cpp	/^EIGEN_DONT_INLINE void call_ref_3(const Ref<const SparseMatrix<float>, StandardCompressedFormat>& a, const B &b) {$/;"	f
call_ref_4	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_4(const Ref<const VectorXf,0,InnerStride<> >& a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_4	test/sparse_ref.cpp	/^EIGEN_DONT_INLINE void call_ref_4(Ref<SparseVector<float> > a, const B &b) { VERIFY_IS_EQUAL(a.toDense(),b.toDense()); }$/;"	f
call_ref_5	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_5(Ref<MatrixXf,0,OuterStride<> > a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_5	test/sparse_ref.cpp	/^EIGEN_DONT_INLINE void call_ref_5(const Ref<const SparseVector<float> >& a, const B &b) { VERIFY_IS_EQUAL(a.toDense(),b.toDense()); }$/;"	f
call_ref_6	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_6(const Ref<const MatrixXf,0,OuterStride<> >& a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_ref_7	test/ref.cpp	/^EIGEN_DONT_INLINE void call_ref_7(Ref<Matrix<float,Dynamic,3> > a, const B &b) { VERIFY_IS_EQUAL(a,b); }$/;"	f
call_solver	bench/spbench/spbenchsolver.h	/^void call_solver(Solver &solver, const int solver_id, const typename Solver::MatrixType& A, const Matrix<Scalar, Dynamic, 1>& b, const Matrix<Scalar, Dynamic, 1>& refX,std::ofstream& statbuf)$/;"	f
call_triangular_assignment_loop	Eigen/src/Core/TriangularMatrix.h	/^void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen::internal
call_triangular_assignment_loop	Eigen/src/Core/TriangularMatrix.h	/^void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)$/;"	f	namespace:Eigen::internal
calls	unsupported/doc/examples/BVH_Example.cpp	/^  int calls;$/;"	m	struct:PointPointMinimizer	file:
calls	unsupported/test/BVH.cpp	/^  int calls;$/;"	m	struct:BallPointStuff	file:
cast	Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal
cast	Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase
cast	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling
cast	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform
cast	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f
cast	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cast() const {$/;"	f	class:Eigen::TensorBase
cast_impl	Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast_impl	test/boostmultiprec.cpp	/^    struct cast_impl<Real,NewType> {$/;"	s	namespace:Eigen::internal	file:
cast_impl	test/boostmultiprec.cpp	/^    struct cast_impl<Real,std::complex<Real> > {$/;"	s	namespace:Eigen::internal	file:
cast_to_pointer_type	Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map
casting	test/basicstuff.cpp	/^void casting()$/;"	f
cauchy_max_bound	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^typename NumTraits<typename Polynomial::Scalar>::Real cauchy_max_bound( const Polynomial& poly )$/;"	f	namespace:Eigen
cauchy_min_bound	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^typename NumTraits<typename Polynomial::Scalar>::Real cauchy_min_bound( const Polynomial& poly )$/;"	f	namespace:Eigen
cbrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal cbrt  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(cbrt );    }$/;"	f	namespace:mpfr
cd	Eigen/src/Core/arch/ZVector/Complex.h	/^    Packet1cd cd[2];$/;"	m	union:Eigen::internal::Packet2cf::__anon714
cdone	bench/bench_gemm.cpp	/^static std::complex<double> cdone = 1;$/;"	v	file:
cdotc_	blas/f2c/complexdots.c	/^complex cdotc_(integer *n, complex *cx, integer $/;"	f
cdotu_	blas/f2c/complexdots.c	/^complex cdotu_(integer *n, complex *cx, integer $/;"	f
cdzero	bench/bench_gemm.cpp	/^static std::complex<double> cdzero = 0;$/;"	v	file:
ceil	Eigen/src/Core/MathFunctions.h	/^T (ceil)(const T& x)$/;"	f	namespace:Eigen::numext
ceil	Eigen/src/Core/MathFunctions.h	/^double ceil(const double &x) { return ::ceil(x); }$/;"	f	namespace:Eigen::numext
ceil	Eigen/src/Core/MathFunctions.h	/^float ceil(const float &x) { return ::ceilf(x); }$/;"	f	namespace:Eigen::numext
ceil	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half ceil(const half& a) {$/;"	f	namespace:Eigen::half_impl
ceil	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^ceil() const$/;"	f
ceil	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    ceil() const {$/;"	f	class:Eigen::TensorBase
ceil	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  static unsigned int ceil(unsigned int num, unsigned int denom) {$/;"	f	struct:Eigen::TensorEvaluator
ceil	unsupported/test/mpreal/mpreal.h	/^inline const mpreal ceil(const mpreal& v)$/;"	f	namespace:mpfr
ceilh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half ceilh(const Eigen::half& a) {$/;"	f
center	Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox
center	demos/mandelbrot/mandelbrot.h	/^    Eigen::Vector2d center;$/;"	m	class:MandelbrotWidget
center	unsupported/test/BVH.cpp	/^  VectorType center;$/;"	m	struct:Ball	file:
centered_smooth_curve	bench/btl/data/smooth.cxx	/^void centered_smooth_curve(const vector<double> & tab_mflops, vector<double> & smooth_tab_mflops,int window_half_width){$/;"	f
cephes	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^namespace cephes {$/;"	n	namespace:Eigen::internal
cephes_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct cephes_helper {$/;"	s	namespace:Eigen::internal
cephes_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct cephes_helper<double> {$/;"	s	namespace:Eigen::internal
cephes_helper	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct cephes_helper<float> {$/;"	s	namespace:Eigen::internal
ces	doc/snippets/ComplexEigenSolver_compute.cpp	/^ComplexEigenSolver<MatrixXcf> ces;$/;"	v
cfone	bench/bench_gemm.cpp	/^static std::complex<float> cfone = 1;$/;"	v	file:
cfzero	bench/bench_gemm.cpp	/^static std::complex<float> cfzero = 0;$/;"	v	file:
changedlines	scripts/eigen_gen_credits.cpp	/^  int changedlines;$/;"	m	struct:contributor	file:
changesets	scripts/eigen_gen_credits.cpp	/^  int changesets;$/;"	m	struct:contributor	file:
chbmv_	blas/f2c/chbmv.c	/^\/* Subroutine *\/ int chbmv_(char *uplo, integer *n, integer *k, complex *$/;"	f
check	bench/btl/generic_bench/timers/STL_timer.hh	/^  bool check()$/;"	f	class:STL_Timer
check	test/fastmath.cpp	/^void check(bool b, bool ref)$/;"	f
checkChildrenData	doc/eigen_navtree_hacks.js	/^function checkChildrenData(node) {$/;"	f
checkGrain	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  int checkGrain(Index m, Index n, Index bm, Index bn, Index bk, Index gm,$/;"	f	struct:Eigen::TensorEvaluator
checkIdx	unsupported/test/cxx11_tensor_symmetry.cpp	/^struct checkIdx {$/;"	s	file:
checkIndexRange	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    bool checkIndexRange(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::Tensor
checkIndexRange	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE bool checkIndexRange(const array<Index, NumIndices>& \/*indices*\/) const$/;"	f	class:Eigen::TensorFixedSize
checkResults	bench/btl/generic_bench/btl.hh	/^  bool checkResults;$/;"	m	class:BtlConfig
checkSanity	Eigen/src/Core/MapBase.h	/^    void checkSanity(typename internal::enable_if<(internal::traits<T>::Alignment>0),void*>::type = 0) const$/;"	f	class:Eigen::MapBase
checkSanity	Eigen/src/Core/MapBase.h	/^    void checkSanity(typename internal::enable_if<internal::traits<T>::Alignment==0,void*>::type = 0) const$/;"	f	class:Eigen::MapBase
checkTransposeAliasing_impl	Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
check_DenseIndex_is_signed	Eigen/src/Core/DenseBase.h	/^static inline void check_DenseIndex_is_signed() {$/;"	f	namespace:Eigen::internal
check_abs	test/numext.cpp	/^void check_abs() {$/;"	f
check_accuracy	bench/bench_norm.cpp	/^void check_accuracy(double basef, double based, int s)$/;"	f
check_accuracy_var	bench/bench_norm.cpp	/^void check_accuracy_var(int ef0, int ef1, int ed0, int ed1, int s)$/;"	f
check_aligned_malloc	test/dynalloc.cpp	/^void check_aligned_malloc()$/;"	f
check_aligned_new	test/dynalloc.cpp	/^void check_aligned_new()$/;"	f
check_aligned_stack_alloc	test/dynalloc.cpp	/^void check_aligned_stack_alloc()$/;"	f
check_all_files_in_same_exact_order	bench/analyze-blocking-sizes.cpp	/^void check_all_files_in_same_exact_order($/;"	f
check_all_in_range	test/rand.cpp	/^template<typename Scalar> void check_all_in_range(Scalar x, Scalar y)$/;"	f
check_all_var	test/geo_eulerangles.cpp	/^template<typename Scalar> void check_all_var(const Matrix<Scalar,3,1>& ea)$/;"	f
check_all_var	unsupported/test/EulerAngles.cpp	/^template<typename Scalar> void check_all_var(const Matrix<Scalar,3,1>& ea)$/;"	f
check_atan2	unsupported/test/autodiff_scalar.cpp	/^template<typename Scalar> void check_atan2()$/;"	f
check_const_correctness	test/geo_quaternion.cpp	/^template<typename PlainObjectType> void check_const_correctness(const PlainObjectType&)$/;"	f
check_const_correctness	test/mapped_matrix.cpp	/^template<typename PlainObjectType> void check_const_correctness(const PlainObjectType&)$/;"	f
check_const_correctness	test/ref.cpp	/^template<typename PlainObjectType> void check_const_correctness(const PlainObjectType&)$/;"	f
check_const_correctness	test/sparse_ref.cpp	/^template<typename PlainObjectType> void check_const_correctness(const PlainObjectType&)$/;"	f
check_coordinates	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_custom_new_delete	test/dynalloc.cpp	/^template<typename T> void check_custom_new_delete()$/;"	f
check_dimension	unsupported/test/kronecker_product.cpp	/^void check_dimension(const MatrixType& ab, const int rows,  const int cols)$/;"	f
check_dynaligned	test/dynalloc.cpp	/^template<typename T> void check_dynaligned()$/;"	f
check_extremity_accuracy	test/nullary.cpp	/^void check_extremity_accuracy(const VectorType &v, const typename VectorType::Scalar &low, const typename VectorType::Scalar &high)$/;"	f
check_for_aliasing	Eigen/src/Core/Transpose.h	/^void check_for_aliasing(const Dst &dst, const Src &src)$/;"	f	namespace:Eigen::internal
check_global_interpolation2d	unsupported/test/splines.cpp	/^void check_global_interpolation2d()$/;"	f
check_global_interpolation_with_derivatives2d	unsupported/test/splines.cpp	/^void check_global_interpolation_with_derivatives2d()$/;"	f
check_handmade_aligned_malloc	test/dynalloc.cpp	/^void check_handmade_aligned_malloc()$/;"	f
check_histogram	test/rand.cpp	/^template<typename Scalar> void check_histogram(Scalar x, Scalar y, int bins)$/;"	f
check_hyperbolic_functions	unsupported/test/autodiff_scalar.cpp	/^template<typename Scalar> void check_hyperbolic_functions()$/;"	f
check_in_range	test/rand.cpp	/^template<typename Scalar> Scalar check_in_range(Scalar x, Scalar y)$/;"	f
check_inf_nan	test/fastmath.cpp	/^void check_inf_nan(bool dryrun) {$/;"	f
check_is_convertible	test/meta.cpp	/^bool check_is_convertible(const From&, const To&)$/;"	f
check_kronecker_product	unsupported/test/kronecker_product.cpp	/^void check_kronecker_product(const MatrixType& ab)$/;"	f
check_limits_specialization	unsupported/test/autodiff_scalar.cpp	/^void check_limits_specialization()$/;"	f
check_op	blas/common.h	/^inline bool check_op(const char* op)$/;"	f
check_product	bench/benchBlasGemm.cpp	/^void check_product(int M, int N, int K)$/;"	f
check_product	bench/benchBlasGemm.cpp	/^void check_product(void)$/;"	f
check_qtvector_matrix	test/qtvector.cpp	/^void check_qtvector_matrix(const MatrixType& m)$/;"	f
check_qtvector_quaternion	test/qtvector.cpp	/^void check_qtvector_quaternion(const QuaternionType&)$/;"	f
check_qtvector_transform	test/qtvector.cpp	/^void check_qtvector_transform(const TransformType&)$/;"	f
check_range	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::check_range (int t, mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
check_result	bench/btl/actions/action_aat_product.hh	/^  void check_result( void ){$/;"	f	class:Action_aat_product
check_result	bench/btl/actions/action_ata_product.hh	/^  void check_result( void ){$/;"	f	class:Action_ata_product
check_result	bench/btl/actions/action_atv_product.hh	/^  void check_result( void )$/;"	f	class:Action_atv_product
check_result	bench/btl/actions/action_axpby.hh	/^  void check_result( void ){$/;"	f	class:Action_axpby
check_result	bench/btl/actions/action_axpy.hh	/^  void check_result( void ){$/;"	f	class:Action_axpy
check_result	bench/btl/actions/action_cholesky.hh	/^  void check_result( void ){$/;"	f	class:Action_cholesky
check_result	bench/btl/actions/action_ger.hh	/^  BTL_DONT_INLINE void check_result( void ){$/;"	f	class:Action_ger
check_result	bench/btl/actions/action_hessenberg.hh	/^  void check_result( void ){$/;"	f	class:Action_hessenberg
check_result	bench/btl/actions/action_hessenberg.hh	/^  void check_result( void ){$/;"	f	class:Action_tridiagonalization
check_result	bench/btl/actions/action_lu_decomp.hh	/^  void check_result( void ){$/;"	f	class:Action_lu_decomp
check_result	bench/btl/actions/action_matrix_matrix_product.hh	/^  void check_result( void ){$/;"	f	class:Action_matrix_matrix_product
check_result	bench/btl/actions/action_matrix_vector_product.hh	/^  BTL_DONT_INLINE void check_result( void ){$/;"	f	class:Action_matrix_vector_product
check_result	bench/btl/actions/action_partial_lu.hh	/^  void check_result( void ){$/;"	f	class:Action_partial_lu
check_result	bench/btl/actions/action_rot.hh	/^  BTL_DONT_INLINE void check_result( void ){$/;"	f	class:Action_rot
check_result	bench/btl/actions/action_symv.hh	/^  BTL_DONT_INLINE void check_result( void ){$/;"	f	class:Action_symv
check_result	bench/btl/actions/action_syr2.hh	/^  BTL_DONT_INLINE void check_result( void ){$/;"	f	class:Action_syr2
check_result	bench/btl/actions/action_trisolve.hh	/^  void check_result(){$/;"	f	class:Action_trisolve
check_result	bench/btl/actions/action_trisolve_matrix.hh	/^  void check_result( void ){$/;"	f	class:Action_trisolve_matrix
check_result	bench/btl/actions/action_trmm.hh	/^  void check_result( void ){$/;"	f	class:Action_trmm
check_rows_cols_for_overflow	Eigen/src/Core/PlainObjectBase.h	/^template<> struct check_rows_cols_for_overflow<Dynamic> {$/;"	s	namespace:Eigen::internal
check_rows_cols_for_overflow	Eigen/src/Core/PlainObjectBase.h	/^template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {$/;"	s	namespace:Eigen::internal
check_side	blas/common.h	/^inline bool check_side(const char* side)$/;"	f
check_size_for_overflow	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void check_size_for_overflow(std::size_t size)$/;"	f	namespace:Eigen::internal
check_slerp	test/geo_quaternion.cpp	/^template<typename QuatType> void check_slerp(const QuatType& q0, const QuatType& q1)$/;"	f
check_sparse_abs_determinant	test/sparse_solver.h	/^void check_sparse_abs_determinant(Solver& solver, const typename Solver::MatrixType& A, const DenseMat& dA)$/;"	f
check_sparse_determinant	test/sparse_solver.h	/^void check_sparse_determinant(Solver& solver, const typename Solver::MatrixType& A, const DenseMat& dA)$/;"	f
check_sparse_kronecker_product	unsupported/test/kronecker_product.cpp	/^void check_sparse_kronecker_product(const MatrixType& ab)$/;"	f
check_sparse_leastsquare_solving	test/sparse_solver.h	/^template<typename Solver> void check_sparse_leastsquare_solving(Solver& solver)$/;"	f
check_sparse_solving	test/sparse_solver.h	/^void check_sparse_solving(Solver& solver, const typename Solver::MatrixType& A, const Rhs& b, const DenseMat& dA, const DenseRhs& db)$/;"	f
check_sparse_solving_real_cases	test/sparse_solver.h	/^void check_sparse_solving_real_cases(Solver& solver, const typename Solver::MatrixType& A, const Rhs& b, const typename Solver::MatrixType& fullA, const Rhs& refX)$/;"	f
check_sparse_spd_determinant	test/sparse_solver.h	/^template<typename Solver> void check_sparse_spd_determinant(Solver& solver)$/;"	f
check_sparse_spd_solving	test/sparse_solver.h	/^template<typename Solver> void check_sparse_spd_solving(Solver& solver, int maxSize = 300, int maxRealWorldSize = 100000)$/;"	f
check_sparse_square_abs_determinant	test/sparse_solver.h	/^template<typename Solver> void check_sparse_square_abs_determinant(Solver& solver)$/;"	f
check_sparse_square_determinant	test/sparse_solver.h	/^template<typename Solver> void check_sparse_square_determinant(Solver& solver)$/;"	f
check_sparse_square_solving	test/sparse_solver.h	/^template<typename Solver> void check_sparse_square_solving(Solver& solver, int maxSize = 300, int maxRealWorldSize = 100000, bool checkDeficient = false)$/;"	f
check_static_allocation_size	Eigen/src/Core/DenseStorage.h	/^void check_static_allocation_size()$/;"	f	namespace:Eigen::internal
check_stddeque_matrix	test/stddeque.cpp	/^void check_stddeque_matrix(const MatrixType& m)$/;"	f
check_stddeque_matrix	test/stddeque_overload.cpp	/^void check_stddeque_matrix(const MatrixType& m)$/;"	f
check_stddeque_quaternion	test/stddeque.cpp	/^void check_stddeque_quaternion(const QuaternionType&)$/;"	f
check_stddeque_quaternion	test/stddeque_overload.cpp	/^void check_stddeque_quaternion(const QuaternionType&)$/;"	f
check_stddeque_transform	test/stddeque.cpp	/^void check_stddeque_transform(const TransformType&)$/;"	f
check_stddeque_transform	test/stddeque_overload.cpp	/^void check_stddeque_transform(const TransformType&)$/;"	f
check_stdlist_matrix	test/stdlist.cpp	/^void check_stdlist_matrix(const MatrixType& m)$/;"	f
check_stdlist_matrix	test/stdlist_overload.cpp	/^void check_stdlist_matrix(const MatrixType& m)$/;"	f
check_stdlist_quaternion	test/stdlist.cpp	/^void check_stdlist_quaternion(const QuaternionType&)$/;"	f
check_stdlist_quaternion	test/stdlist_overload.cpp	/^void check_stdlist_quaternion(const QuaternionType&)$/;"	f
check_stdlist_transform	test/stdlist.cpp	/^void check_stdlist_transform(const TransformType&)$/;"	f
check_stdlist_transform	test/stdlist_overload.cpp	/^void check_stdlist_transform(const TransformType&)$/;"	f
check_stdvector_matrix	test/stdvector.cpp	/^void check_stdvector_matrix(const MatrixType& m)$/;"	f
check_stdvector_matrix	test/stdvector_overload.cpp	/^void check_stdvector_matrix(const MatrixType& m)$/;"	f
check_stdvector_quaternion	test/stdvector.cpp	/^void check_stdvector_quaternion(const QuaternionType&)$/;"	f
check_stdvector_quaternion	test/stdvector_overload.cpp	/^void check_stdvector_quaternion(const QuaternionType&)$/;"	f
check_stdvector_transform	test/stdvector.cpp	/^void check_stdvector_transform(const TransformType&)$/;"	f
check_stdvector_transform	test/stdvector_overload.cpp	/^void check_stdvector_transform(const TransformType&)$/;"	f
check_template_parameters	Eigen/src/Cholesky/LDLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LDLT
check_template_parameters	Eigen/src/Cholesky/LLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LLT
check_template_parameters	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ComplexEigenSolver
check_template_parameters	Eigen/src/Eigenvalues/EigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::EigenSolver
check_template_parameters	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::GeneralizedEigenSolver
check_template_parameters	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SelfAdjointEigenSolver
check_template_parameters	Eigen/src/LU/FullPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivLU
check_template_parameters	Eigen/src/LU/PartialPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::PartialPivLU
check_template_parameters	Eigen/src/QR/ColPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ColPivHouseholderQR
check_template_parameters	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  static void check_template_parameters() {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
check_template_parameters	Eigen/src/QR/FullPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivHouseholderQR
check_template_parameters	Eigen/src/QR/HouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::HouseholderQR
check_template_parameters	Eigen/src/SVD/SVDBase.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SVDBase
check_template_parameters	Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix
check_template_parameters	Eigen/src/SparseCore/SparseVector.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SparseVector
check_template_params	Eigen/src/Geometry/Transform.h	/^    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform
check_that_malloc_is_allowed	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_unalignedassert_good	test/unalignedassert.cpp	/^void check_unalignedassert_good()$/;"	f
check_uplo	blas/common.h	/^inline bool check_uplo(const char* uplo)$/;"	f
children	debug/gdb/printers.py	/^	def children(self):$/;"	m	class:EigenMatrixPrinter
children	debug/gdb/printers.py	/^	def children(self):$/;"	m	class:EigenQuaternionPrinter
children	unsupported/Eigen/src/BVH/KdBVH.h	/^  std::vector<int> children; \/\/children of x are children[2x] and children[2x+1], indices bigger than boxes.size() index into objects.$/;"	m	class:Eigen::KdBVH
chip	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    chip(const Index offset) const {$/;"	f	class:Eigen::TensorBase
chip	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    chip(const Index offset) {$/;"	f	class:Eigen::TensorBase
chip	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    chip(const Index offset, const Index dim) const {$/;"	f	class:Eigen::TensorBase
chip	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    chip(const Index offset, const Index dim) {$/;"	f	class:Eigen::TensorBase
chkder	unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^void chkder($/;"	f	namespace:Eigen::internal
chkder_factor	unsupported/Eigen/src/NonLinearOptimization/chkder.h	2;"	d
chkder_log10e	unsupported/Eigen/src/NonLinearOptimization/chkder.h	1;"	d
cholesky	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void cholesky(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:blas_interface
cholesky	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void cholesky(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:eigen2_interface
cholesky	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void cholesky(const gene_matrix & X, gene_matrix & C, int  \/*N*\/){$/;"	f	class:eigen3_interface
cholesky	test/cholesky.cpp	/^template<typename MatrixType> void cholesky(const MatrixType& m)$/;"	f
cholesky_bug241	test/cholesky.cpp	/^template<typename MatrixType> void cholesky_bug241(const MatrixType& m)$/;"	f
cholesky_cplx	test/cholesky.cpp	/^template<typename MatrixType> void cholesky_cplx(const MatrixType& m)$/;"	f
cholesky_definiteness	test/cholesky.cpp	/^template<typename MatrixType> void cholesky_definiteness(const MatrixType& m)$/;"	f
cholesky_faillure_cases	test/cholesky.cpp	/^void cholesky_faillure_cases()$/;"	f
cholesky_verify_assert	test/cholesky.cpp	/^template<typename MatrixType> void cholesky_verify_assert()$/;"	f
cholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase
cholmodCommon	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    cholmod_common *cholmodCommon() const { return &m_cc; }$/;"	f	class:Eigen::SPQR
cholmod_configure_matrix	Eigen/src/CholmodSupport/CholmodSupport.h	/^template<> struct cholmod_configure_matrix<double> {$/;"	s	namespace:Eigen::internal
cholmod_configure_matrix	Eigen/src/CholmodSupport/CholmodSupport.h	/^template<> struct cholmod_configure_matrix<std::complex<double> > {$/;"	s	namespace:Eigen::internal
choose	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^const T1& choose(Cond<true>, const T1& first, const T2&) {$/;"	f	namespace:Eigen
choose	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^const T2& choose(Cond<false>, const T1&, const T2& second) {$/;"	f	namespace:Eigen
chpmv_	blas/f2c/chpmv.c	/^\/* Subroutine *\/ int chpmv_(char *uplo, integer *n, complex *alpha, complex *$/;"	f
chwirut2_functor	unsupported/test/NonLinearOptimization.cpp	/^    chwirut2_functor(void) : Functor<double>(3,54) {}$/;"	f	struct:chwirut2_functor
chwirut2_functor	unsupported/test/NonLinearOptimization.cpp	/^struct chwirut2_functor : Functor<double>$/;"	s	file:
chwirut2_functor	unsupported/test/levenberg_marquardt.cpp	/^    chwirut2_functor(void) : DenseFunctor<double>(3,54) {}$/;"	f	struct:chwirut2_functor
chwirut2_functor	unsupported/test/levenberg_marquardt.cpp	/^struct chwirut2_functor : DenseFunctor<double>$/;"	s	file:
circulant_functor	doc/examples/make_circulant2.cpp	/^  circulant_functor(const ArgType& arg) : m_vec(arg) {}$/;"	f	class:circulant_functor
circulant_functor	doc/examples/make_circulant2.cpp	/^class circulant_functor {$/;"	c	file:
circulant_helper	doc/examples/make_circulant2.cpp	/^struct circulant_helper {$/;"	s	file:
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
clamp	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clamp	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  static EIGEN_STRONG_INLINE Index clamp(Index value, Index min, Index max) {$/;"	f	struct:Eigen::TensorEvaluator
clean	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup()$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup()$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() { }$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() { }$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
cleanup	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void cleanup() {$/;"	f	struct:Eigen::TensorEvaluator
clear	Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage
clear	bench/btl/generic_bench/timers/x86_timer.hh	/^  void clear( void )$/;"	f	class:X86_Timer
clear	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void clear() $/;"	f	struct:Eigen::internal::fftw_impl
clear	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  void clear() $/;"	f	struct:Eigen::internal::kissfft_impl
clear	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void clear() {$/;"	f	class:Eigen::SkylineStorage
clear	unsupported/test/mpreal/mpreal.h	/^inline void mpreal::clear(::mpfr_ptr x)$/;"	f	class:mpfr::mpreal
clearFactors	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase
clear_mark	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  IndexType clear_mark  \/* return the new value for tag_mark *\/$/;"	f	namespace:internal
clobber	bench/BenchTimer.h	/^static void clobber() {$/;"	f
closed_spline2d	unsupported/test/splines.cpp	/^Spline<double, 2, Dynamic> closed_spline2d()$/;"	f
cmp_EQ	Eigen/src/Core/util/Constants.h	/^  cmp_EQ = 0,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_GE	Eigen/src/Core/util/Constants.h	/^  cmp_GE = 6$/;"	e	enum:Eigen::internal::ComparisonName
cmp_GT	Eigen/src/Core/util/Constants.h	/^  cmp_GT = 5,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LE	Eigen/src/Core/util/Constants.h	/^  cmp_LE = 2,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LT	Eigen/src/Core/util/Constants.h	/^  cmp_LT = 1,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_NEQ	Eigen/src/Core/util/Constants.h	/^  cmp_NEQ = 4,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_UNORD	Eigen/src/Core/util/Constants.h	/^  cmp_UNORD = 3,$/;"	e	enum:Eigen::internal::ComparisonName
cmpabs	unsupported/test/mpreal/mpreal.h	/^inline int cmpabs(const mpreal& a,const mpreal& b)$/;"	f	namespace:mpfr
coarsenM	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  Index coarsenM(Index m, Index n, Index bm, Index bn, Index bk, Index gn,$/;"	f	struct:Eigen::TensorEvaluator
coarsenN	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  Index coarsenN(Index m, Index n, Index bm, Index bn, Index bk, Index gm,$/;"	f	struct:Eigen::TensorEvaluator
cod	test/qr_colpivoting.cpp	/^void cod() {$/;"	f
cod_fixedsize	test/qr_colpivoting.cpp	/^void cod_fixedsize() {$/;"	f
coeff	Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::binary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::ternary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::unary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::binary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::ternary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::unary_evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(Index row, Index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(IndexType index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  CoeffReturnType coeff(IndexType row, IndexType col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  const Scalar coeff(Index i, Index j) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/CoreEvaluators.h	/^  const Scalar coeff(Index index) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index idx) const$/;"	f	class:Eigen::Diagonal
coeff	Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeff	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase
coeff	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeff	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue
coeff	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
coeff	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeff	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeff	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index i) const$/;"	f	class:Eigen::ProductImpl
coeff	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::ProductImpl
coeff	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
coeff	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC const CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::internal::product_evaluator
coeff	Eigen/src/Core/Redux.h	/^  CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::redux_evaluator
coeff	Eigen/src/Core/Redux.h	/^  CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::redux_evaluator
coeff	Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select
coeff	Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select
coeff	Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView
coeff	Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase
coeff	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase
coeff	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularViewImpl
coeff	Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::visitor_evaluator
coeff	Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_StorageIndex>::coeff(Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index index) const$/;"	f	class:Eigen::BlockImpl
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index index) const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::BlockImpl
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeff	Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Scalar& coeff(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
coeff	Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMapBase
coeff	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix
coeff	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const$/;"	f	class:Eigen::SparseVector
coeff	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector
coeff	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& coeff() const$/;"	f	class:Eigen::Tensor
coeff	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& coeff(CustomIndices& indices) const$/;"	f	class:Eigen::Tensor
coeff	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::Tensor
coeff	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& coeff(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::Tensor
coeff	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC inline const Scalar& coeff(Index firstIndex, Index secondIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::Tensor
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE typename Tensor::Scalar coeff(typename Tensor::Index index) const { return loadConstant(m_data+index); }$/;"	f	struct:Eigen::internal::CoeffLoader
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE typename Tensor::Scalar coeff(typename Tensor::Index index) const { return m_tensor.coeff(index); }$/;"	f	struct:Eigen::internal::CoeffLoader
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(const array<DenseIndex, NumCoords>& coords) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& coeff(Index firstIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::TensorFixedSize
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff() const$/;"	f	class:Eigen::TensorFixedSize
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::TensorFixedSize
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::TensorFixedSize
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::TensorRef
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::TensorRef
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC virtual const Scalar coeff(DenseIndex index) const {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff($/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeff	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    Scalar coeff(Index i) const$/;"	f	class:Eigen::KroneckerProductBase
coeff	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::KroneckerProductBase
coeff	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeff(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeff	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Map<const BlockScalar> coeff(Index brow, Index bcol) const$/;"	f	class:Eigen::BlockSparseMatrix
coeff	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Scalar coeff(Index row, Index col)$/;"	f	class:Eigen::BlockSparseMatrixView
coeff	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Scalar coeff(Index bi) const$/;"	f	class:Eigen::BlockVectorView
coeff	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Scalar coeff(Index bi, Index j) const$/;"	f	class:Eigen::BlockVectorView
coeff	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DynamicSparseMatrix
coeff	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  Scalar coeff(Index row, Index col) const { return m_matrix->coeff(row,col); }$/;"	f	struct:Eigen::internal::evaluator
coeffByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
coeffByOuterInner	Eigen/src/Core/Redux.h	/^  CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::internal::redux_evaluator
coeffColMajor	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeffColMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeffDiag	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffDiag(Index idx) const {$/;"	f	class:Eigen::SkylineMatrix
coeffExistLower	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline bool coeffExistLower(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffExistUpper	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline bool coeffExistUpper(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffLower	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffLower(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::mapbase_evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  Scalar& coeffRef(Index row, Index)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	Eigen/src/Core/CoreEvaluators.h	/^  typename XprType::Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::internal::unary_evaluator
coeffRef	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index idx)$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index idx) const$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue
coeffRef	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView
coeffRef	Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase
coeffRef	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase
coeffRef	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularViewImpl
coeffRef	Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_StorageIndex>::coeffRef(Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeffRef	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::BlockImpl
coeffRef	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::BlockImpl
coeffRef	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
coeffRef	Eigen/src/SparseCore/SparseCompressedBase.h	/^  Scalar& coeffRef(Index row, Index col)$/;"	f	struct:Eigen::internal::evaluator
coeffRef	Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMapBase
coeffRef	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
coeffRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector
coeffRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector
coeffRef	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef()$/;"	f	class:Eigen::Tensor
coeffRef	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(CustomIndices& indices)$/;"	f	class:Eigen::Tensor
coeffRef	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Tensor
coeffRef	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::Tensor
coeffRef	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    inline Scalar& coeffRef(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::Tensor
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index index) {$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(const array<DenseIndex, NumCoords>& coords) {$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index firstIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::TensorFixedSize
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef()$/;"	f	class:Eigen::TensorFixedSize
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::TensorFixedSize
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::TensorFixedSize
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index firstIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index i0, Index i1)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index i0, Index i1, Index i2)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index i0, Index i1, Index i2, Index i3, Index i4)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::TensorRef
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index index) {$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC virtual Scalar& coeffRef(DenseIndex \/*index*\/) {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC virtual Scalar& coeffRef(DenseIndex index) {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorWritable
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index index) {$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	struct:Eigen::TensorEvaluator
coeffRef	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType coeffRef(Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
coeffRef	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType coeffRef(Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
coeffRef	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Ref<BlockScalar> coeffRef(Index brow, Index bcol)$/;"	f	class:Eigen::BlockSparseMatrix
coeffRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Scalar coeffRef(Index row, Index col)$/;"	f	class:Eigen::BlockSparseMatrixView
coeffRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Scalar coeffRef(Index bi)$/;"	f	class:Eigen::BlockVectorReturn
coeffRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Scalar coeffRef(Index bi, Index j)$/;"	f	class:Eigen::BlockVectorReturn
coeffRef	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
coeffRefByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRefDiag	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefDiag(Index idx) {$/;"	f	class:Eigen::SkylineMatrix
coeffRefLower	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefLower(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffRefUpper	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefUpper(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffRowMajor	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType coeffRowMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
coeffSeparator	Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat
coeffUpper	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffUpper(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeffWiseOp	bench/tensors/tensor_benchmarks.h	/^  void coeffWiseOp(int num_iters) {$/;"	f	class:BenchmarkSuite
coeffWiseOp	bench/tensors/tensor_benchmarks_sycl.cc	/^BM_FuncGPU(coeffWiseOp);$/;"	v
coeff_visitor	Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper
coeffs	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Map<Array<Scalar,Dynamic,1> > coeffs() { eigen_assert(isCompressed()); return Array<Scalar,Dynamic,1>::Map(valuePtr(),nonZeros()); }$/;"	f	class:Eigen::SparseCompressedBase
coeffs	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Map<const Array<Scalar,Dynamic,1> > coeffs() const { eigen_assert(isCompressed()); return Array<Scalar,Dynamic,1>::Map(valuePtr(),nonZeros()); }$/;"	f	class:Eigen::SparseCompressedBase
coeffs	demos/opengl/quaternion_demo.cpp	/^  Vector3& coeffs() { return m_angles; }$/;"	f	class:EulerAngles
coeffs	demos/opengl/quaternion_demo.cpp	/^  const Vector3& coeffs() const { return m_angles; }$/;"	f	class:EulerAngles
cofactor_3x3	Eigen/src/LU/InverseImpl.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal
cofactor_4x4	Eigen/src/LU/InverseImpl.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal
col	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
col	Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon457
col	Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon458
col	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index col() const             { return m_iter.col(); }$/;"	f	class:Eigen::InnerIterator
col	Eigen/src/Core/CoreIterators.h	/^  inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::internal::inner_iterator_selector
col	Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ DstXprType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_loop::__anon456
col	Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon642
col	Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
col	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index col()    const { return EvalIterator::col()   - m_block.startCol(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
col	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index col()    const { return IsRowMajor ? index() : 0; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
col	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
col	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return IsRowMajor ? m_id : m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return IsRowMajor ? m_id : m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index col()   const { return NeedToTranspose ? LhsIterator::index() : m_outer; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const    { return SparseXprType::IsRowMajor ? m_sparseIter.index() : m_sparseIter.outer(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseTranspose.h	/^      Index col() const { return EvalIterator::row(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
col	Eigen/src/SparseCore/SparseUtil.h	/^  const StorageIndex& col() const { return m_col; }$/;"	f	class:Eigen::Triplet
col	Eigen/src/SparseCore/SparseView.h	/^        inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
col	Eigen/src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f
col	Eigen/src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f
col	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index col() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
col	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index col() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
col	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index col() const {return outer(); }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
col	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index col() const {return outer(); }$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
col	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? Base::index() : m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
col	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? Base::index() : m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
colChip	bench/tensors/tensor_benchmarks.h	/^  void colChip(int num_iters) {$/;"	f	class:BenchmarkSuite
colIndexByOuterInner	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
colIndexByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
colIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* colIndexPtr()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* colIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colInflateStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index colInflateStride() const { return m_col_inflate_strides; }$/;"	f	struct:Eigen::TensorEvaluator
colInflateStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index colInflateStride() const { return m_col_inflate_strides; }$/;"	f	struct:Eigen::TensorEvaluator
colOffset	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }$/;"	f	struct:Eigen::internal::evaluator
colOffset	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal
colPaddingLeft	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index colPaddingLeft() const { return m_colPaddingLeft; }$/;"	f	struct:Eigen::TensorEvaluator
colPaddingLeft	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index colPaddingLeft() const { return m_colPaddingLeft; }$/;"	f	struct:Eigen::TensorEvaluator
colPivHouseholderQr	Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
colReduction	bench/tensors/tensor_benchmarks.h	/^  void colReduction(int num_iters) {$/;"	f	class:BenchmarkSuite
colStride	Eigen/src/Core/CoreEvaluators.h	/^  inline Index colStride() const { return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value(); }$/;"	f	struct:Eigen::internal::mapbase_evaluator
colStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase
colToSup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* colToSup()  { return m_col_to_sup; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colToSup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* colToSup() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex col_inflate_strides() const { return m_col_inflate_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex col_inflate_strides() const { return m_col_inflate_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex col_strides() const { return m_col_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex col_strides() const { return m_col_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
colamd	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static bool colamd(IndexType n_row, IndexType n_col, IndexType Alen, IndexType *A, IndexType *p, double knobs[COLAMD_KNOBS], IndexType stats[COLAMD_STATS])$/;"	f	namespace:internal
colamd_c	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType colamd_c(IndexType n_col) $/;"	f	namespace:internal
colamd_col	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct colamd_col$/;"	s	namespace:internal
colamd_r	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType  colamd_r(IndexType n_row)$/;"	f	namespace:internal
colamd_recommended	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline IndexType colamd_recommended ( IndexType nnz, IndexType n_row, IndexType n_col)$/;"	f	namespace:internal
colamd_set_defaults	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])$/;"	f	namespace:internal
colblk	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index colblk; \/\/ The minimum column dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
coletree	Eigen/src/SparseCore/SparseColEtree.h	/^int coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::StorageIndex *perm=0)$/;"	f	namespace:Eigen::internal
collapseDuplicates	Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::collapseDuplicates(DupFunctor dup_func)$/;"	f	class:Eigen::SparseMatrix
cols	Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT
cols	Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT
cols	Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline StorageIndex cols() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }$/;"	f	class:Eigen::CholmodBase
cols	Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper
cols	Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper
cols	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index cols() const        { return m_dstExpr.cols(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
cols	Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix
cols	Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
cols	Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
cols	Eigen/src/Core/CoreEvaluators.h	/^  Index cols() const $/;"	f	class:Eigen::internal::EvalToTemp
cols	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp
cols	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
cols	Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseTernaryOp
cols	Eigen/src/Core/CwiseUnaryOp.h	/^    Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp
cols	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView
cols	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols() const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal
cols	Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
cols	Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase
cols	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess
cols	Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::Inverse
cols	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase
cols	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue
cols	Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
cols	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase
cols	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::Product
cols	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::internal::redux_evaluator
cols	Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate
cols	Eigen/src/Core/ReturnByValue.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue
cols	Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse
cols	Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select
cols	Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView
cols	Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::Solve
cols	Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
cols	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose
cols	Eigen/src/Core/Transpositions.h	/^    Index cols() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
cols	Eigen/src/Core/Transpositions.h	/^    Index cols() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
cols	Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase
cols	Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView
cols	Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr
cols	Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::internal::visitor_evaluator
cols	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
cols	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
cols	Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
cols	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
cols	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
cols	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transform
cols	Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence
cols	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
cols	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    Index cols() const { return m_L.cols(); }$/;"	f	class:Eigen::IncompleteCholesky
cols	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT
cols	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return matrix().cols(); }$/;"	f	class:Eigen::IterativeSolverBase
cols	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SolveWithGuess
cols	Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU
cols	Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU
cols	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase
cols	Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
cols	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR
cols	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index cols() const { return m_cpqr.cols(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
cols	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR
cols	Eigen/src/QR/FullPivHouseholderQR.h	/^  Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
cols	Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR
cols	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index cols() const { return m_cR->ncol; }$/;"	f	class:Eigen::SPQR
cols	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
cols	Eigen/src/SVD/SVDBase.h	/^  inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::SVDBase
cols	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
cols	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl
cols	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
cols	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl
cols	Eigen/src/SparseCore/SparseMap.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMapBase
cols	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
cols	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase
cols	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView
cols	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
cols	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector
cols	Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView
cols	Eigen/src/SparseLU/SparseLU.h	/^    inline Index cols() const { return m_mat.cols(); }$/;"	f	class:Eigen::SparseLU
cols	Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
cols	Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
cols	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index cols() { return m_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
cols	Eigen/src/SparseQR/SparseQR.h	/^    inline Index cols() const { return m_pmat.cols();}$/;"	f	class:Eigen::SparseQR
cols	Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct
cols	Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
cols	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase
cols	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return mp_matrix.cols(); }$/;"	f	class:Eigen::UmfPackLU
cols	Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base
cols	Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base
cols	doc/examples/matrixfree_cg.cpp	/^  Index cols() const { return mp_mat->cols(); }$/;"	f	class:MatrixReplacement
cols	doc/snippets/Tutorial_commainit_02.cpp	/^int rows=5, cols=5;$/;"	v
cols	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLU
cols	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    inline Index cols() const { return m_A.cols() * m_B.cols(); }$/;"	f	class:Eigen::KroneckerProductBase
cols	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    Index cols() const { return m_src.cols(); }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixFunctionReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixComplexPowerReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixPower
cols	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixPowerReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index cols() const { return m_pow.cols(); }$/;"	f	class:Eigen::MatrixPowerParenthesesReturnValue
cols	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    Index cols() const { return m_src.cols(); }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
cols	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index cols() const {$/;"	f	class:Eigen::SkylineMatrix
cols	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index cols() const {$/;"	f	class:Eigen::SkylineMatrixBase
cols	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::internal::SkylineProduct
cols	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index cols() const$/;"	f	class:Eigen::BlockSparseMatrixView
cols	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index cols() const { return (m_mat.m_blockSize==Dynamic) ? (m_mat.m_outerOffset[m_outer+1]-m_mat.m_outerOffset[m_outer]) : m_mat.m_blockSize;}$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
cols	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index cols() const$/;"	f	class:Eigen::BlockSparseMatrix
cols	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index cols() const$/;"	f	class:Eigen::BlockVectorView
cols	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : outerSize(); }$/;"	f	class:Eigen::DynamicSparseMatrix
colsPermutation	Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR
colsPermutation	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const PermutationType& colsPermutation() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
colsPermutation	Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR
colsPermutation	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    PermutationType colsPermutation() const$/;"	f	class:Eigen::SPQR
colsPermutation	Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseLU
colsPermutation	Eigen/src/SparseQR/SparseQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseQR
cols_select	Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon290
column_bmod	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^Index SparseLUImpl<Scalar,StorageIndex>::column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv,$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^Index SparseLUImpl<Scalar,StorageIndex>::column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs_traits	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, StorageIndex>::GlobalLU_t& glu, SparseLUImpl<Scalar, StorageIndex>& luImpl)$/;"	f	struct:Eigen::internal::column_dfs_traits
column_dfs_traits	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^struct column_dfs_traits : no_assignment_operator$/;"	s	namespace:Eigen::internal
colwise	Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {$/;"	f	class:Eigen::DenseBase
colwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase
compact_size_triple	bench/analyze-blocking-sizes.cpp	/^uint16_t compact_size_triple(size_t k, size_t m, size_t n)$/;"	f
companion	unsupported/Eigen/src/Polynomials/Companion.h	/^    companion( const VectorType& poly ){$/;"	f	class:Eigen::internal::companion
companion	unsupported/Eigen/src/Polynomials/Companion.h	/^class companion$/;"	c	namespace:Eigen::internal
compare_bdc_jacobi	test/bdcsvd.cpp	/^void compare_bdc_jacobi(const MatrixType& a = MatrixType(), unsigned int computationOptions = 0)$/;"	f
compare_using_data_and_stride	test/block.cpp	/^void compare_using_data_and_stride(const MatrixType& m)$/;"	f
comparisons	test/array.cpp	/^template<typename ArrayType> void comparisons(const ArrayType& m)$/;"	f
comparisons	test/array_for_matrix.cpp	/^template<typename MatrixType> void comparisons(const MatrixType& m)$/;"	f
completeOrthogonalDecomposition	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^MatrixBase<Derived>::completeOrthogonalDecomposition() const {$/;"	f	class:Eigen::MatrixBase
complex	blas/f2c/datatypes.h	/^typedef struct { real r, i; } complex;$/;"	t	typeref:struct:__anon203
complex_schur_reduce_to_hessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
complex_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftw_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
complex_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftwf_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
complex_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftwl_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
compute	Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const EigenBase<InputType>& a)$/;"	f	class:Eigen::LDLT
compute	Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const EigenBase<InputType>& a)$/;"	f	class:Eigen::LLT
compute	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
compute	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
compute	Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur
compute	Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver
compute	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^GeneralizedEigenSolver<MatrixType>::compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)$/;"	f	class:Eigen::GeneralizedEigenSolver
compute	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
compute	Eigen/src/Eigenvalues/RealQZ.h	/^    RealQZ<MatrixType>& RealQZ<MatrixType>::compute(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)$/;"	f	class:Eigen::RealQZ
compute	Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur
compute	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const EigenBase<InputType>& a_matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::Tridiagonalization
compute	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
compute	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
compute	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
compute	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
compute	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
compute	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
compute	Eigen/src/LU/FullPivLU.h	/^    FullPivLU& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::FullPivLU
compute	Eigen/src/LU/PartialPivLU.h	/^    PartialPivLU& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::PartialPivLU
compute	Eigen/src/LU/PartialPivLU.h	/^void PartialPivLU<MatrixType>::compute()$/;"	f	class:Eigen::PartialPivLU
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
compute	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
compute	Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
compute	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
compute	Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const EigenBase<InputType>& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
compute	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR& compute(const EigenBase<InputType>& matrix) {$/;"	f	class:Eigen::HouseholderQR
compute	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void compute(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
compute	Eigen/src/SVD/BDCSVD.h	/^  BDCSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::BDCSVD
compute	Eigen/src/SVD/BDCSVD.h	/^BDCSVD<MatrixType>& BDCSVD<MatrixType>::compute(const MatrixType& matrix, unsigned int computationOptions) $/;"	f	class:Eigen::BDCSVD
compute	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD
compute	Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
compute	Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
compute	Eigen/src/SparseLU/SparseLU.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
compute	Eigen/src/SparseQR/SparseQR.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
compute	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase
compute	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
compute	bench/dense_solvers.cpp	/^void compute(Solver &solver, const MatrixType &A) {$/;"	f
compute	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^::compute(const MatrixType& A, Index nbrEigenvalues,$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
compute	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^::compute(const MatrixType& A, const MatrixType& B, Index nbrEigenvalues,$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
compute	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU& compute(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteLU
compute	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void compute (const MatrixType& mat)$/;"	f	class:Eigen::IterScaling
compute	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^MatrixType MatrixFunctionAtomic<MatrixType>::compute(const MatrixType& A)$/;"	f	class:Eigen::internal::MatrixFunctionAtomic
compute	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^MatrixType MatrixLogarithmAtomic<MatrixType>::compute(const MatrixType& A)$/;"	f	class:Eigen::internal::MatrixLogarithmAtomic
compute	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPower<MatrixType>::compute(ResultType& res, RealScalar p)$/;"	f	class:Eigen::MatrixPower
compute	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPowerAtomic<MatrixType>::compute(ResultType& res) const$/;"	f	class:Eigen::MatrixPowerAtomic
compute	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    void compute( const OtherPolynomial& poly )$/;"	f	class:Eigen::PolynomialSolver
compute	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^void SkylineInplaceLU<MatrixType>::compute() {$/;"	f	class:Eigen::SkylineInplaceLU
compute2x2	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPowerAtomic<MatrixType>::compute2x2(ResultType& res, RealScalar p) const$/;"	f	class:Eigen::MatrixPowerAtomic
computeBig	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPowerAtomic<MatrixType>::computeBig(ResultType& res) const$/;"	f	class:Eigen::MatrixPowerAtomic
computeCol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	346;"	d
computeCol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	382;"	d
computeDirect	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeFracPower	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPower<MatrixType>::computeFracPower(ResultType& res, RealScalar p)$/;"	f	class:Eigen::MatrixPower
computeFromHessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)$/;"	f	class:Eigen::ComplexSchur
computeFromHessenberg	Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)$/;"	f	class:Eigen::RealSchur
computeFromTridiagonal	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeFromTridiagonal(const RealVectorType& diag, const SubDiagonalType& subdiag , int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeFromTridiagonal_impl	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^ComputationInfo computeFromTridiagonal_impl(DiagType& diag, SubDiagType& subdiag, const Index maxIterations, bool computeEigenvectors, MatrixType& eivec)$/;"	f	namespace:Eigen::internal
computeInPlace	Eigen/src/LU/FullPivLU.h	/^void FullPivLU<MatrixType>::computeInPlace()$/;"	f	class:Eigen::FullPivLU
computeInPlace	Eigen/src/QR/ColPivHouseholderQR.h	/^void ColPivHouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::ColPivHouseholderQR
computeInPlace	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^void CompleteOrthogonalDecomposition<MatrixType>::computeInPlace()$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
computeInPlace	Eigen/src/QR/FullPivHouseholderQR.h	/^void FullPivHouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::FullPivHouseholderQR
computeInPlace	Eigen/src/QR/HouseholderQR.h	/^void HouseholderQR<MatrixType>::computeInPlace()$/;"	f	class:Eigen::HouseholderQR
computeIndex	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE Index computeIndex(Index row, Index col) const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
computeIndexPair	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE IndexPair<Index> computeIndexPair(Index row, Index col, const Index distance) const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
computeIntPower	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPower<MatrixType>::computeIntPower(ResultType& res, RealScalar p)$/;"	f	class:Eigen::MatrixPower
computeInverseAndDetWithCheck	Eigen/src/LU/InverseImpl.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase
computeInverseWithCheck	Eigen/src/LU/InverseImpl.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase
computeMultiplier	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^    static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE uint32_t computeMultiplier(const int log_div, const T divider) {$/;"	f	struct:Eigen::internal::__anon139::DividerHelper
computeMultiplier	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^    static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE uint64_t computeMultiplier(const int log_div, const T divider) {$/;"	f	struct:Eigen::internal::__anon139::DividerHelper
computeNormOfT	Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur
computeNorms	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::computeNorms()$/;"	f	class:Eigen::RealQZ
computePade	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPowerAtomic<MatrixType>::computePade(int degree, const MatrixType& IminusT, ResultType& res) const$/;"	f	class:Eigen::MatrixPowerAtomic
computePass	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	356;"	d
computePass	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	383;"	d
computeProductBlockingSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
computeProductBlockingSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
computeRef	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void computeRef (MatrixType& mat)$/;"	f	class:Eigen::IterScaling
computeRoots	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
computeRoots	bench/eig33.cpp	/^inline void computeRoots(const Matrix& m, Roots& roots)$/;"	f
computeRotationScaling	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeRowMajor	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^void SkylineInplaceLU<MatrixType>::computeRowMajor() {$/;"	f	class:Eigen::SkylineInplaceLU
computeSVDofM	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSVDofM(Index firstCol, Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)$/;"	f	class:Eigen::BDCSVD
computeScalingRotation	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeShift	Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur
computeShift	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur
computeSingVals	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSingVals(const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm,$/;"	f	class:Eigen::BDCSVD
computeSingVecs	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::computeSingVecs$/;"	f	class:Eigen::BDCSVD
computeSuperDiag	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^MatrixPowerAtomic<MatrixType>::computeSuperDiag(RealScalar curr, RealScalar prev, RealScalar p)$/;"	f	class:Eigen::MatrixPowerAtomic
computeSuperDiag	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^MatrixPowerAtomic<MatrixType>::computeSuperDiag(const ComplexScalar& curr, const ComplexScalar& prev, RealScalar p)$/;"	f	class:Eigen::MatrixPowerAtomic
computeU	Eigen/src/SVD/SVDBase.h	/^  inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::SVDBase
computeUnblocked	Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::computeUnblocked(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
computeV	Eigen/src/SVD/SVDBase.h	/^  inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::SVDBase
compute_1D_Butterfly	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void compute_1D_Butterfly($/;"	f	struct:Eigen::TensorEvaluator
compute_block_size	test/product_extra.cpp	/^Index compute_block_size()$/;"	f
compute_cycles	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double compute_cycles() const {$/;"	f	class:Eigen::TensorOpCost
compute_cycles_	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  double compute_cycles_;$/;"	m	class:Eigen::TensorOpCost
compute_inverse	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	Eigen/src/LU/InverseImpl.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size3_helper	Eigen/src/LU/InverseImpl.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/InverseImpl.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_norm_equation	bench/dense_solvers.cpp	/^void compute_norm_equation(Solver &solver, const MatrixType &A) {$/;"	f
compute_tensor_flags	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^class compute_tensor_flags$/;"	c	namespace:Eigen::internal
concat	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T... as, T... bs>   struct concat<numeric_list<T, as...>, numeric_list<T, bs...> > { typedef numeric_list<T, as..., bs...> type; };$/;"	s	namespace:Eigen::internal
concat	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename... as, typename... bs> struct concat<type_list<as...>,       type_list<bs...>>        { typedef type_list<as..., bs...> type; };$/;"	s	namespace:Eigen::internal
concatenate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    concatenate(const OtherDerived& other, Axis axis) const {$/;"	f	class:Eigen::TensorBase
concatenate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    concatenate(const OtherDerived& other, const Axis& axis) const {$/;"	f	class:Eigen::TensorBase
concatenate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    concatenate(const OtherDerived& other, const Axis& axis) {$/;"	f	class:Eigen::TensorBase
cond_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<IfArgType, Device> & cond_impl() const { return m_condImpl; }$/;"	f	struct:Eigen::TensorEvaluator
conditionMatrix	Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select
conditional	Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditional_aligned_delete	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_delete_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete_auto(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	Eigen/src/Core/util/Memory.h	/^template<> EIGEN_DEVICE_FUNC inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	Eigen/src/Core/util/Memory.h	/^template<bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	Eigen/src/Core/util/Memory.h	/^template<> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc<false>(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	Eigen/src/Core/util/Memory.h	/^template<bool Align> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new_auto(std::size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, std::size_t new_size, std::size_t)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_realloc_new(T* pts, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, std::size_t new_size, std::size_t old_size)$/;"	f	namespace:Eigen::internal
conj	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::numext
conj	test/exceptions.cpp	/^ScalarWithExceptions conj(const ScalarWithExceptions &x) { return x; }$/;"	f
conj	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline const AutoDiffScalar<DerType>& conj(const AutoDiffScalar<DerType>& x)  { return x; }$/;"	f	namespace:Eigen
conj_expr_if	Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet2cd, Packet2cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct conj_helper<Packet4cf, Packet4cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^struct conj_helper$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	Eigen/src/Core/MathFunctions.h	/^struct conj_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
conj_prod	Eigen/src/Core/Dot.h	/^  typedef scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> conj_prod;$/;"	t	struct:Eigen::internal::dot_nocheck
conj_retval	Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
conjugate	Eigen/src/Core/SelfAdjointView.h	/^    inline const ConjugateReturnType conjugate() const$/;"	f	class:Eigen::SelfAdjointView
conjugate	Eigen/src/Core/TriangularMatrix.h	/^    inline const ConjugateReturnType conjugate() const$/;"	f	class:Eigen::TriangularView
conjugate	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase
conjugate	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence
conjugate	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f
conjugate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    conjugate() const {$/;"	f	class:Eigen::TensorBase
conjugate_gradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index size, Index, Index cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index size, Index rows, Index)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(Index, Index, Index cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/SparseCore/SparseMatrix.h	/^    void conservativeResize(Index rows, Index cols) $/;"	f	class:Eigen::SparseMatrix
conservativeResize	Eigen/src/SparseCore/SparseVector.h	/^    void conservativeResize(Index newSize)$/;"	f	class:Eigen::SparseVector
conservativeResizeLike	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
conservative_resize_like_impl	Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_impl	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, bool sortedInsertion = false)$/;"	f	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
const_blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE const_blas_data_mapper(const Scalar *data, Index stride) : blas_data_mapper<const Scalar, Index, StorageOrder>(data, stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper
const_blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper : public blas_data_mapper<const Scalar, Index, StorageOrder> {$/;"	c	namespace:Eigen::internal
const_cast_derived	Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase
const_cast_derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase
const_cast_derived	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived& const_cast_derived() const {$/;"	f	class:Eigen::SkylineMatrixBase
const_catalan	unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_catalan (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_derived	Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase
const_euler	unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_euler (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_infinity	unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_infinity (int sign = 1, mp_prec_t p = mpreal::get_default_prec())$/;"	f	namespace:mpfr
const_log2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_log2 (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_pi	unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_pi (mp_prec_t p = mpreal::get_default_prec(), mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
const_pointer	Eigen/src/Core/util/Memory.h	/^  typedef const T*        const_pointer;$/;"	t	class:Eigen::aligned_allocator
const_pointer	Eigen/src/StlSupport/details.h	/^    typedef const T*        const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
const_ptr	test/mapstaticmethods.cpp	/^const float *const_ptr;$/;"	v
const_reference	Eigen/src/Core/util/Memory.h	/^  typedef const T&        const_reference;$/;"	t	class:Eigen::aligned_allocator
const_reference	Eigen/src/StlSupport/details.h	/^    typedef const T&        const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection
constant	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    constant(const Scalar& value) const {$/;"	f	class:Eigen::TensorBase
constrained_cg	unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^void constrained_cg(const TMatrix& A, const CMatrix& C, VectorX& x,$/;"	f	namespace:Eigen::internal
construct	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/Core/Ref.h	/^    EIGEN_DEVICE_FUNC void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC void construct(Expression& expr)$/;"	f	class:Eigen::RefBase
construct	Eigen/src/SparseCore/SparseRef.h	/^    void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/SparseCore/SparseRef.h	/^    void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/SparseCore/SparseRef.h	/^  void construct(Expression& expr)$/;"	f	class:Eigen::internal::SparseRefBase
construct_at_boundary	test/unalignedassert.cpp	/^void construct_at_boundary(int boundary)$/;"	f
construct_elements_of_array	Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline T* construct_elements_of_array(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
constructor_without_unaligned_array_assert	Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
contained_in_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list<test, check_against, h_list, true>$/;"	s	namespace:Eigen::internal
contained_in_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, false> { constexpr static bool value = false; };$/;"	s	namespace:Eigen::internal
contained_in_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list<test, check_against, type_list<a, as...>, false> : contained_in_list<test, check_against, type_list<as...>, test<check_against, a>::value> {};$/;"	s	namespace:Eigen::internal
contained_in_list_gf	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list_gf<test, check_against, h_list, default_flags, true, last_check_flags>$/;"	s	namespace:Eigen::internal
contained_in_list_gf	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list_gf<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, default_flags, false, last_check_flags> { constexpr static bool value = false; constexpr static int global_flags = default_flags; };$/;"	s	namespace:Eigen::internal
contained_in_list_gf	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list_gf<test, check_against, type_list<a, as...>, default_flags, false, last_check_flags> : contained_in_list_gf<test, check_against, type_list<as...>, default_flags, test<check_against, a>::value, test<check_against, a>::global_flags> {};$/;"	s	namespace:Eigen::internal
contains	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool contains(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
contains	bench/btl/generic_bench/btl.hh	/^    bool contains(const BtlString& str) const$/;"	f	class:BtlString
contract	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    contract(const OtherDerived& other, const Dimensions& dims) const {$/;"	f	class:Eigen::TensorBase
contract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, ContractDims> contract_t;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
contract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, ContractDims> contract_t;$/;"	t	struct:Eigen::TensorEvaluator
contract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef array<Index, ContractDims> contract_t;$/;"	t	struct:Eigen::TensorEvaluator
contract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef array<Index, ContractDims> contract_t;$/;"	t	struct:Eigen::TensorEvaluator
contraction	bench/tensors/tensor_benchmarks.h	/^  void contraction(int num_iters) {$/;"	f	class:BenchmarkSuite
contractionCost	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  TensorOpCost contractionCost(Index m, Index n, Index bm, Index bn, Index bk,$/;"	f	struct:Eigen::TensorEvaluator
contributor	scripts/eigen_gen_credits.cpp	/^  contributor() : changedlines(0), changesets(0) {}$/;"	f	struct:contributor
contributor	scripts/eigen_gen_credits.cpp	/^struct contributor$/;"	s	file:
contributor_name	scripts/eigen_gen_credits.cpp	/^std::string contributor_name(const std::string& line)$/;"	f
contributors_map_from_churn_output	scripts/eigen_gen_credits.cpp	/^map<string,int> contributors_map_from_churn_output(const char *filename)$/;"	f
converged	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool converged() const { return m_res <= m_rhsn * m_resmax; }$/;"	f	class:Eigen::IterationController
converged	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool converged(double nr)$/;"	f	class:Eigen::IterationController
converged	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    template<typename VectorType> bool converged(const VectorType &v)$/;"	f	class:Eigen::IterationController
conversion_overflow	unsupported/test/mpreal/mpreal.h	/^class conversion_overflow : public std::exception {$/;"	c	namespace:mpfr
convert_index	Eigen/src/Core/util/XprHelper.h	/^inline IndexDest convert_index(const IndexSrc& idx) {$/;"	f	namespace:Eigen::internal
convert_index	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex convert_index(Index idx)$/;"	f	class:Eigen::internal::AmbiVector
convert_index	Eigen/src/SparseCore/SparseMatrixBase.h	/^    static inline StorageIndex convert_index(const Index idx) {$/;"	f	class:Eigen::SparseMatrixBase
convolution	bench/tensors/tensor_benchmarks.h	/^  void convolution(int num_iters, int kernel_x, int kernel_y) {$/;"	f	class:BenchmarkSuite
convolve	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    convolve(const KernelDerived& kernel, const Dimensions& dims) const {$/;"	f	class:Eigen::TensorBase
convolve	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC void convolve(Index firstIndex, Index firstKernel, int DimIndex, CoeffReturnType& accum) const {$/;"	f	struct:Eigen::TensorEvaluator
convolvePacket	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC void convolvePacket(Index firstIndex, Index firstKernel, int DimIndex, Packet& accum) const {$/;"	f	struct:Eigen::TensorEvaluator
coo_tocsr	bench/sparse_setter.cpp	/^void coo_tocsr(const int n_row,$/;"	f
coprimes_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  MaxSizeVector<unsigned> coprimes_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
copy	blas/level1_impl.h	/^int EIGEN_BLAS_FUNC(copy)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy)$/;"	f
copy	test/stable_norm.cpp	/^template<typename T> EIGEN_DONT_INLINE T copy(const T& x)$/;"	f
copyCoeff	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase
copyUV	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::copyUV(const HouseholderU &householderU, const HouseholderV &householderV, const NaiveU &naiveU, const NaiveV &naiveV)$/;"	f	class:Eigen::BDCSVD
copyUpperTriangularPart	doc/examples/TemplateKeyword_flexible.cpp	/^void copyUpperTriangularPart(MatrixBase<Derived1>& dst, const MatrixBase<Derived2>& src)$/;"	f
copyUpperTriangularPart	doc/examples/TemplateKeyword_simple.cpp	/^void copyUpperTriangularPart(MatrixXf& dst, const MatrixXf& src)$/;"	f
copy_back	blas/common.h	/^T* copy_back(T* x_cpy, T* x, int n, int incx)$/;"	f
copy_bool	Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal
copy_matrix	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:c_interface_base
copy_matrix	bench/btl/libs/STL/STL_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:STL_interface
copy_matrix	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:blaze_interface
copy_matrix	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:blitz_interface
copy_matrix	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:tiny_blitz_interface
copy_matrix	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:eigen2_interface
copy_matrix	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static EIGEN_DONT_INLINE void copy_matrix(const gene_matrix & source, gene_matrix & cible, int  \/*N*\/){$/;"	f	class:eigen3_interface
copy_matrix	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:gmm_interface
copy_matrix	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:mtl4_interface
copy_matrix	bench/btl/libs/tensors/tensor_interface.hh	/^  static EIGEN_DONT_INLINE void copy_matrix(const gene_matrix & source, gene_matrix & cible, int  \/*N*\/){$/;"	f	class:tensor_interface
copy_matrix	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:tvmet_interface
copy_matrix	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void copy_matrix(const gene_matrix & source, gene_matrix & cible, int N){$/;"	f	class:ublas_interface
copy_to_ucol	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^Index SparseLUImpl<Scalar,StorageIndex>::copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep,$/;"	f	class:Eigen::internal::SparseLUImpl
copy_using_evaluator	test/evaluators.cpp	/^  DstXprType& copy_using_evaluator(const EigenBase<DstXprType> &dst, const SrcXprType &src)$/;"	f	namespace:Eigen
copy_using_evaluator	test/evaluators.cpp	/^  DstXprType& copy_using_evaluator(const PlainObjectBase<DstXprType> &dst, const SrcXprType &src)$/;"	f	namespace:Eigen
copy_using_evaluator	test/evaluators.cpp	/^  const DstXprType& copy_using_evaluator(const NoAlias<DstXprType, StorageBase>& dst, const SrcXprType &src)$/;"	f	namespace:Eigen
copy_using_evaluator_DefaultTraversal_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_InnerUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_DefaultTraversal_InnerUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_LinearTraversal_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_LinearTraversal_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_CompleteUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_CompleteUnrolling<Kernel, Stop, Stop>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_InnerUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
copy_using_evaluator_innervec_InnerUnrolling	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_innervec_InnerUnrolling<Kernel, Stop, Stop, SrcAlignment, DstAlignment>$/;"	s	namespace:Eigen::internal
copy_using_evaluator_traits	Eigen/src/Core/AssignEvaluator.h	/^struct copy_using_evaluator_traits$/;"	s	namespace:Eigen::internal
copy_vector	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:c_interface_base
copy_vector	bench/btl/libs/STL/STL_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:STL_interface
copy_vector	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:blaze_interface
copy_vector	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:blitz_interface
copy_vector	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:tiny_blitz_interface
copy_vector	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:eigen2_interface
copy_vector	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static EIGEN_DONT_INLINE void copy_vector(const gene_vector & source, gene_vector & cible, int  \/*N*\/){$/;"	f	class:eigen3_interface
copy_vector	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:gmm_interface
copy_vector	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:mtl4_interface
copy_vector	bench/btl/libs/tensors/tensor_interface.hh	/^  static EIGEN_DONT_INLINE void copy_vector(const gene_vector & source, gene_vector & cible, int  \/*N*\/){$/;"	f	class:tensor_interface
copy_vector	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:tvmet_interface
copy_vector	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void copy_vector(const gene_vector & source, gene_vector & cible, int N){$/;"	f	class:ublas_interface
copysign	unsupported/test/mpreal/mpreal.h	/^inline mpreal copysign(const mpreal& x, const  mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
corner	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox
corners	test/corners.cpp	/^template<typename MatrixType> void corners(const MatrixType& m)$/;"	f
corners_fixedsize	test/corners.cpp	/^template<typename MatrixType, int CRows, int CCols, int SRows, int SCols> void corners_fixedsize()$/;"	f
cos	Eigen/src/Core/MathFunctions.h	/^T cos(const T &x) {$/;"	f	namespace:Eigen::numext
cos	Eigen/src/Core/MathFunctions.h	/^double cos(const double &x) { return ::cos(x); }$/;"	f	namespace:Eigen::numext
cos	Eigen/src/Core/MathFunctions.h	/^float cos(const float &x) { return ::cosf(x); }$/;"	f	namespace:Eigen::numext
cos	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half cos(const half& a) {$/;"	f	namespace:Eigen::half_impl
cos	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f
cos	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::cos() const$/;"	f	class:Eigen::MatrixBase
cos	unsupported/test/mpreal/mpreal.h	/^inline const mpreal cos   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(cos  );    }$/;"	f	namespace:mpfr
coset_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  >::type coset_elements;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
cosh	Eigen/src/Core/MathFunctions.h	/^T cosh(const T &x) {$/;"	f	namespace:Eigen::numext
cosh	Eigen/src/Core/MathFunctions.h	/^double cosh(const double &x) { return ::cosh(x); }$/;"	f	namespace:Eigen::numext
cosh	Eigen/src/Core/MathFunctions.h	/^float cosh(const float &x) { return ::coshf(x); }$/;"	f	namespace:Eigen::numext
cosh	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cosh() const$/;"	f
cosh	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::cosh() const$/;"	f	class:Eigen::MatrixBase
cosh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal cosh  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(cosh );    }$/;"	f	namespace:mpfr
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  costPerCoeff(bool) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
costPerCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  costPerCoeff(bool vectorized) const {$/;"	f	struct:Eigen::TensorEvaluator
cot	unsupported/test/mpreal/mpreal.h	/^inline const mpreal cot   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(cot  );    }$/;"	f	namespace:mpfr
coth	unsupported/test/mpreal/mpreal.h	/^inline const mpreal coth  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(coth );    }$/;"	f	namespace:mpfr
count	Eigen/src/Core/BooleanRedux.h	/^inline Eigen::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase
count	Eigen/src/Core/VectorwiseOp.h	/^    const CountReturnType count() const$/;"	f	class:Eigen::VectorwiseOp
count	bench/btl/generic_bench/timers/STL_timer.hh	/^  unsigned long count;$/;"	m	class:STL_Timer
count	doc/snippets/MatrixBase_cwiseEqual.cpp	/^Index count = m.cwiseEqual(MatrixXi::Identity(2,2)).count();$/;"	v
count	doc/snippets/MatrixBase_cwiseNotEqual.cpp	/^Index count = m.cwiseNotEqual(MatrixXi::Identity(2,2)).count();$/;"	v
count	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static const int count = NumDims;$/;"	m	struct:Eigen::DSizes
count	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  constexpr static int count = 1 + sizeof...(O);$/;"	m	struct:Eigen::internal::IndexTuple
count	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  constexpr static int count = 1;$/;"	m	struct:Eigen::internal::IndexTuple
count	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct numeric_list { constexpr static std::size_t count = sizeof...(nn); };$/;"	m	struct:Eigen::internal::numeric_list
count	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct numeric_list<T, n, nn...> { constexpr static std::size_t count = sizeof...(nn) + 1; constexpr static T first_value = n; };$/;"	m	struct:Eigen::internal::numeric_list
count	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct type_list { constexpr static int count = sizeof...(tt); };$/;"	m	struct:Eigen::internal::type_list
count	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct type_list<t, tt...> { constexpr static int count = sizeof...(tt) + 1; typedef t first_type; };$/;"	m	struct:Eigen::internal::type_list
count	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const std::size_t count = 1 + Tail::count;$/;"	m	struct:Eigen::internal::type_list
count	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct empty_list { static const std::size_t count = 0; };$/;"	m	struct:Eigen::internal::empty_list
count	unsupported/test/BVH.cpp	/^  int count;$/;"	m	struct:BallPointStuff	file:
count_leading_zeros	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  typename internal::enable_if<sizeof(T)==4,int>::type count_leading_zeros(const T val)$/;"	f	namespace:Eigen::internal::__anon139
count_leading_zeros	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  typename internal::enable_if<sizeof(T)==8,int>::type count_leading_zeros(const T val)$/;"	f	namespace:Eigen::internal::__anon139
countdown	test/exceptions.cpp	/^    static int countdown;$/;"	m	class:ScalarWithExceptions	file:
countdown	test/exceptions.cpp	/^int ScalarWithExceptions::countdown = 0;$/;"	m	class:ScalarWithExceptions	file:
countnz	Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,StorageIndex>::countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
cout	doc/snippets/Tutorial_AdvancedInitialization_LinSpaced.cpp	/^std::cout << "  Degrees   Radians      Sine    Cosine\\n";$/;"	m	class:std	file:
cout	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << "A fixed-size array:\\n";$/;"	m	class:std	file:
cout	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << "A one-dimensional dynamic-size array:\\n";$/;"	m	class:std	file:
cout	doc/snippets/Tutorial_AdvancedInitialization_Zero.cpp	/^std::cout << "A two-dimensional dynamic-size array:\\n";$/;"	m	class:std	file:
covar	unsupported/Eigen/src/LevenbergMarquardt/LMcovar.h	/^void covar($/;"	f	namespace:Eigen::internal
covar	unsupported/Eigen/src/NonLinearOptimization/covar.h	/^void covar($/;"	f	namespace:Eigen::internal
cpuid_is_vendor	Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])$/;"	f	namespace:Eigen::internal
createIndent	doc/eigen_navtree_hacks.js	/^function createIndent(o,domNode,node,level)$/;"	f
createNavigationControlWidget	demos/opengl/quaternion_demo.cpp	/^QWidget* RenderingWidget::createNavigationControlWidget()$/;"	f	class:RenderingWidget
createPlaceHolderExpression	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^struct createPlaceHolderExpression {$/;"	s	namespace:Eigen::TensorSycl::internal
createRandomPIMatrixOfRank	test/main.h	/^void createRandomPIMatrixOfRank(Index desired_rank, Index rows, Index cols, MatrixType& m)$/;"	f	namespace:Eigen
createShader	unsupported/test/openglsupport.cpp	/^GLint createShader(const char* vtx, const char* frg)$/;"	f
cross	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross	Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
cross3	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross3_impl	Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3_impl	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross_product_return_type	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase
cs_sorted_multiply	bench/sparse_dense_product.cpp	/^cs* cs_sorted_multiply(const cs* a, const cs* b)$/;"	f
cs_sorted_multiply	bench/sparse_product.cpp	/^cs* cs_sorted_multiply(const cs* a, const cs* b)$/;"	f
cs_sorted_multiply2	bench/sparse_product.cpp	/^cs* cs_sorted_multiply2(const cs* a, const cs* b)$/;"	f
cs_tdfs	Eigen/src/OrderingMethods/Amd.h	/^StorageIndex cs_tdfs(StorageIndex j, StorageIndex k, StorageIndex *head, const StorageIndex *next, StorageIndex *post, StorageIndex *stack)$/;"	f	namespace:Eigen::internal
cs_wclear	Eigen/src/OrderingMethods/Amd.h	/^static StorageIndex cs_wclear (StorageIndex mark, StorageIndex lemax, StorageIndex *w, StorageIndex n)$/;"	f	namespace:Eigen::internal
csc	unsupported/test/mpreal/mpreal.h	/^inline const mpreal csc   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(csc  );    }$/;"	f	namespace:mpfr
csch	unsupported/test/mpreal/mpreal.h	/^inline const mpreal csch  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(csch );    }$/;"	f	namespace:mpfr
csr_sort_indices	bench/sparse_setter.cpp	/^void csr_sort_indices(const I n_row,$/;"	f
csr_sum_duplicates	bench/sparse_setter.cpp	/^void csr_sum_duplicates(const I n_row,$/;"	f
ctbmv_	blas/f2c/ctbmv.c	/^\/* Subroutine *\/ int ctbmv_(char *uplo, char *trans, char *diag, integer *n, $/;"	f
ctms_decompositions	test/nomalloc.cpp	/^void ctms_decompositions()$/;"	f
ctor_init1	test/constructor.cpp	/^template<typename MatrixType> void ctor_init1(const MatrixType& m)$/;"	f
ctrls	unsupported/Eigen/src/Splines/Spline.h	/^    const ControlPointVectorType& ctrls() const { return m_ctrls; }$/;"	f	class:Eigen::Spline
cube	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f
cube	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cube() const {$/;"	f	class:Eigen::TensorBase
cumprod	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cumprod(const Index& axis, bool exclusive = false) const {$/;"	f	class:Eigen::TensorBase
cumsum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cumsum(const Index& axis, bool exclusive = false) const {$/;"	f	class:Eigen::TensorBase
currentThreadId	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE int currentThreadId() const {$/;"	f	struct:Eigen::ThreadPoolDevice
customIndices2Array	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  array<Index, 0> customIndices2Array(IndexType&, numeric_list<Index>) {$/;"	f	namespace:Eigen::internal
customIndices2Array	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  array<Index, NumIndices> customIndices2Array(IndexType& idx) {$/;"	f	namespace:Eigen::internal
customIndices2Array	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  array<Index, sizeof...(Is)> customIndices2Array(IndexType& idx, numeric_list<Index, Is...>) {$/;"	f	namespace:Eigen::internal
customOp	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    const TensorCustomBinaryOp<const CustomBinaryFunc, const Derived, const OtherDerived> customOp(const OtherDerived& other, const CustomBinaryFunc& op) const {$/;"	f	class:Eigen::TensorBase
customOp	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    const TensorCustomUnaryOp<const CustomUnaryFunc, const Derived> customOp(const CustomUnaryFunc& op) const {$/;"	f	class:Eigen::TensorBase
cv	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^    std::condition_variable cv;$/;"	m	class:Eigen::EventCount::Waiter
cv	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    std::condition_variable cv;$/;"	m	struct:Eigen::SimpleThreadPoolTempl::Waiter
cv_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  std::condition_variable cv_;$/;"	m	class:Eigen::Barrier
cwiseAbs	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return CwiseAbsReturnType(derived()); }$/;"	f
cwiseAbs2	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return CwiseAbs2ReturnType(derived()); }$/;"	f
cwiseEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f
cwiseInverse	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return CwiseInverseReturnType(derived()); }$/;"	f
cwiseMax	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMax	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f
cwiseMax	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cwiseMax(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
cwiseMax	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cwiseMax(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
cwiseMax	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost cwiseMax($/;"	f	class:Eigen::TensorOpCost
cwiseMin	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMin	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f
cwiseMin	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cwiseMin(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
cwiseMin	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    cwiseMin(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
cwiseMin	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost cwiseMin($/;"	f	class:Eigen::TensorOpCost
cwiseNotEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseProduct	Eigen/src/Core/MatrixBase.h	/^    cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
cwiseProduct	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
cwiseProduct	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseQuotient	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseSign	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSign() const { return CwiseSignReturnType(derived()); }$/;"	f
cwiseSqrt	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return CwiseSqrtReturnType(derived()); }$/;"	f
cwise_min_max	test/array_for_matrix.cpp	/^template<typename MatrixType> void cwise_min_max(const MatrixType& m)$/;"	f
d	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  double    d[2];$/;"	m	union:Eigen::internal::__anon720
d_cnjg	blas/f2c/d_cnjg.c	/^void d_cnjg(doublecomplex *r, doublecomplex *z) {$/;"	f
dabs	blas/f2c/datatypes.h	18;"	d
data	Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Scalar* data() { return &(this->coeffRef(0)); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return &(this->coeff(0)); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	Eigen/src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() {$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase
data	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase
data	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::internal::blas_data_mapper
data	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	Eigen/src/SparseCore/SparseVector.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseVector
data	Eigen/src/SparseCore/SparseVector.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
data	doc/snippets/Map_placement_new.cpp	/^int data[] = {1,2,3,4,5,6,7,8,9};$/;"	v
data	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar                        *data()                        { return m_storage.data(); }$/;"	f	class:Eigen::Tensor
data	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar                  *data()                  const { return m_storage.data(); }$/;"	f	class:Eigen::Tensor
data	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType* data() const { return m_leftImpl.data(); }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType* data() const {$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar* data() const { return m_result; }$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
data	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType* data() const { return m_result; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC DevicePointer data() const { return m_buffer; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC CoeffReturnType* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC typename internal::traits<Derived>::template MakePointer<Scalar>::Type data() const { return m_data; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC typename internal::traits<Derived>::template MakePointer<const Scalar>::Type data() const { return m_data; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return m_data; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar                   *data()                        { return m_storage.data(); }$/;"	f	class:Eigen::TensorFixedSize
data	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar             *data()                  const { return m_storage.data(); }$/;"	f	class:Eigen::TensorFixedSize
data	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC typename MakePointer<Scalar>::Type data() const { return m_buffer; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return m_impl.data(); }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE PointerType data() { return m_data; }$/;"	f	class:Eigen::TensorMap
data	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const PointerType data() const { return m_data; }$/;"	f	class:Eigen::TensorMap
data	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar* data() const {$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return const_cast<Scalar*>(m_impl.data()); }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC typename MakePointer_<Scalar>::Type data() const { return m_result; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar* data() const { return m_evaluator->data(); }$/;"	f	class:Eigen::TensorRef
data	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return m_ref.data(); }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC virtual const Scalar* data() const {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
data	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE CoeffReturnType* data() const$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T *data() { return m_data; }$/;"	f	class:Eigen::TensorStorage
data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const T *data() const { return m_data; }$/;"	f	class:Eigen::TensorStorage
data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_STRONG_INLINE T *data() { return m_data; }$/;"	f	class:Eigen::TensorStorage
data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_STRONG_INLINE const T *data() const { return m_data; }$/;"	f	class:Eigen::TensorStorage
data	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC Scalar* data() const { return NULL; }$/;"	f	struct:Eigen::TensorEvaluator
data	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T* data() { return data_; }$/;"	f	class:Eigen::MaxSizeVector
data	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  const T* data() const { return data_; }$/;"	f	class:Eigen::MaxSizeVector
data_	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T* data_;$/;"	m	class:Eigen::MaxSizeVector
data_and_stride	test/block.cpp	/^void data_and_stride(const MatrixType& m)$/;"	f
dcomplex	Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
deallocate	Eigen/src/Core/util/Memory.h	/^  void deallocate(pointer p, size_type \/*num*\/)$/;"	f	class:Eigen::aligned_allocator
deallocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE void deallocate(void* buffer) const {$/;"	f	struct:Eigen::GpuDevice
deallocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual void deallocate(void* buffer) const {$/;"	f	class:Eigen::CudaStreamDevice
deallocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void deallocate(void* buffer) const {$/;"	f	struct:Eigen::DefaultDevice
deallocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template <typename T> void deallocate(T *p) const {$/;"	f	struct:Eigen::SyclDevice
deallocate	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void deallocate(void* buffer) const {$/;"	f	struct:Eigen::ThreadPoolDevice
deallocate_all	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  void deallocate_all() const {$/;"	f	struct:Eigen::SyclDevice
debug	Eigen/src/Core/AssignEvaluator.h	/^  static void debug()$/;"	f	struct:Eigen::internal::copy_using_evaluator_traits
debug	Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type
debug	Eigen/src/Core/Redux.h	/^  static void debug()$/;"	f	struct:Eigen::internal::redux_traits
debugName	Eigen/src/Core/util/Constants.h	/^struct BandShape              { static std::string debugName() { return "BandShape"; } };$/;"	f	struct:Eigen::BandShape
debugName	Eigen/src/Core/util/Constants.h	/^struct DenseShape             { static std::string debugName() { return "DenseShape"; } };$/;"	f	struct:Eigen::DenseShape
debugName	Eigen/src/Core/util/Constants.h	/^struct DiagonalShape          { static std::string debugName() { return "DiagonalShape"; } };$/;"	f	struct:Eigen::DiagonalShape
debugName	Eigen/src/Core/util/Constants.h	/^struct HomogeneousShape       { static std::string debugName() { return "HomogeneousShape"; } };$/;"	f	struct:Eigen::HomogeneousShape
debugName	Eigen/src/Core/util/Constants.h	/^struct PermutationShape       { static std::string debugName() { return "PermutationShape"; } };$/;"	f	struct:Eigen::PermutationShape
debugName	Eigen/src/Core/util/Constants.h	/^struct SelfAdjointShape       { static std::string debugName() { return "SelfAdjointShape"; } };$/;"	f	struct:Eigen::SelfAdjointShape
debugName	Eigen/src/Core/util/Constants.h	/^struct SolverShape            { static std::string debugName() { return "SolverShape"; } };$/;"	f	struct:Eigen::SolverShape
debugName	Eigen/src/Core/util/Constants.h	/^struct SparseShape            { static std::string debugName() { return "SparseShape"; } };$/;"	f	struct:Eigen::SparseShape
debugName	Eigen/src/Core/util/Constants.h	/^struct TranspositionsShape    { static std::string debugName() { return "TranspositionsShape"; } };$/;"	f	struct:Eigen::TranspositionsShape
debugName	Eigen/src/Core/util/Constants.h	/^struct TriangularShape        { static std::string debugName() { return "TriangularShape"; } };$/;"	f	struct:Eigen::TriangularShape
debugName	Eigen/src/SparseCore/SparseUtil.h	/^struct SparseSelfAdjointShape { static std::string debugName() { return "SparseSelfAdjointShape"; } };$/;"	f	struct:Eigen::internal::SparseSelfAdjointShape
debugName	Eigen/src/SparseCore/SparseUtil.h	/^struct SparseTriangularShape  { static std::string debugName() { return "SparseTriangularShape"; } };$/;"	f	struct:Eigen::internal::SparseTriangularShape
dec	Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC const Decomposition& dec() const { return m_dec; }$/;"	f	class:Eigen::Solve
dec	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const Decomposition& dec()   const { return m_dec; }$/;"	f	class:Eigen::SolveWithGuess
dec	Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base
dec	Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base
decltype	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(AccessorConstructor::template getAccessor<cl::sycl::access::mode::read>(cgh, eval)){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
decltype	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  template<typename A, typename B> EIGEN_DEVICE_FUNC constexpr static inline auto run(A a, B b) -> decltype(a * b)   { return a * b;   }$/;"	f	struct:Eigen::internal::product_op
decltype	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct equal_op         { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a == b)  { return a == b;  } };$/;"	f	struct:Eigen::internal::equal_op
decltype	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct logical_and_op   { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a && b)  { return a && b;  } };$/;"	f	struct:Eigen::internal::logical_and_op
decomposePathAndFile	bench/btl/generic_bench/btl.hh	/^    void decomposePathAndFile(BtlString& path, BtlString& filename) const$/;"	f	class:BtlString
decrRefCount	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  void decrRefCount() { --m_refcount; }$/;"	f	class:Eigen::internal::TensorLazyBaseEvaluator
decrement_if_fixed_size	unsupported/Eigen/src/Polynomials/Companion.h	/^struct decrement_if_fixed_size$/;"	s	namespace:Eigen::internal
decrement_size	Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
defaultL1CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL1CacheSize = 16*1024;$/;"	m	namespace:Eigen::internal
defaultL1CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL1CacheSize = 32*1024;$/;"	m	namespace:Eigen::internal
defaultL2CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL2CacheSize = 256*1024;$/;"	m	namespace:Eigen::internal
defaultL2CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL2CacheSize = 512*1024;$/;"	m	namespace:Eigen::internal
defaultL3CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL3CacheSize = 2*1024*1024;$/;"	m	namespace:Eigen::internal
defaultL3CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const std::ptrdiff_t defaultL3CacheSize = 512*1024;$/;"	m	namespace:Eigen::internal
default_alignment	Eigen/src/Core/Matrix.h	/^      default_alignment = compute_default_alignment<_Scalar,max_size>::value,$/;"	e	enum:Eigen::internal::traits::__anon438
default_block_size	bench/analyze-blocking-sizes.cpp	/^    size_triple_t default_block_size;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
default_digits10_impl	Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl$/;"	s	namespace:Eigen::internal
default_digits10_impl	Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl<T,false,false> \/\/ Floating point$/;"	s	namespace:Eigen::internal
default_digits10_impl	Eigen/src/Core/NumTraits.h	/^struct default_digits10_impl<T,false,true> \/\/ Integer$/;"	s	namespace:Eigen::internal
default_efficiency	bench/analyze-blocking-sizes.cpp	/^    float default_efficiency;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
default_gflops	bench/analyze-blocking-sizes.cpp	/^    float default_gflops;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
default_mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    default_mr = (EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)\/2\/nr)*LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
default_packet_traits	Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_precision	bench/analyze-blocking-sizes.cpp	/^const int default_precision = 4;$/;"	v
default_prunning_func	Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
default_prunning_func	Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix
default_stream	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static const cudaStream_t default_stream = cudaStreamDefault;$/;"	m	namespace:Eigen
deflSize	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  Index deflSize() {return m_r; }$/;"	f	class:Eigen::DGMRES
deflation	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation(Index firstCol, Index lastCol, Index k, Index firstRowW, Index firstColW, Index shift)$/;"	f	class:Eigen::BDCSVD
deflation43	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation43(Index firstCol, Index shift, Index i, Index size)$/;"	f	class:Eigen::BDCSVD
deflation44	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::deflation44(Index firstColu , Index firstColm, Index firstRowW, Index firstColW, Index i, Index j, Index size)$/;"	f	class:Eigen::BDCSVD
degree	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType degree ;  \/* number of principal & non-principal columns in row *\/$/;"	m	union:internal::Colamd_Row::__anon872
degree	unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::degree() const$/;"	f	class:Eigen::Spline
degree_next	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType degree_next ; \/* next column, if col is in a degree list *\/$/;"	m	union:internal::colamd_col::__anon871
delta	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar delta;$/;"	m	class:Eigen::HybridNonLinearSolver
delta	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar delta;$/;"	m	class:Eigen::LevenbergMarquardt
demo_Map_MatrixXd	demos/mix_eigen_and_c/example.c	/^void demo_Map_MatrixXd()$/;"	f
demo_MatrixXd	demos/mix_eigen_and_c/example.c	/^void demo_MatrixXd()$/;"	f
demo_all_types	unsupported/doc/examples/FFT.cpp	/^void demo_all_types(int nfft)$/;"	f
denorm_min	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half denorm_min() { return Eigen::half_impl::raw_uint16_to_half(0x1); }$/;"	f	struct:std::numeric_limits
denorm_min	unsupported/test/mpreal/mpreal.h	/^        inline static const mpfr::mpreal denorm_min()       { return (min)();                    }$/;"	f	class:std::numeric_limits
denseMatrix	unsupported/Eigen/src/Polynomials/Companion.h	/^    DenseCompanionMatrixType denseMatrix() const$/;"	f	class:Eigen::internal::companion
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>$/;"	s	namespace:Eigen::internal
dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
dense_product_base	Eigen/src/Core/Product.h	/^class dense_product_base$/;"	c	namespace:Eigen::internal
dense_product_base	Eigen/src/Core/Product.h	/^class dense_product_base<Lhs, Rhs, Option, InnerProduct>$/;"	c	namespace:Eigen::internal
dense_storage_assignment	test/dense_storage.cpp	/^void dense_storage_assignment()$/;"	f
dense_storage_copy	test/dense_storage.cpp	/^void dense_storage_copy()$/;"	f
dense_xpr_base_dispatcher	Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::doxygen
dense_xpr_base_dispatcher	Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::doxygen
depth_select	Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon290
deque	Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
deque_base	Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque
derivatives	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline DerType& derivatives() { return m_derivatives; }$/;"	f	class:Eigen::AutoDiffScalar
derivatives	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const DerType& derivatives() const { return m_derivatives; }$/;"	f	class:Eigen::AutoDiffScalar
derivatives	unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::derivatives(Scalar u, DenseIndex order) const$/;"	f	class:Eigen::Spline
derivativesImpl	unsupported/Eigen/src/Splines/Spline.h	/^  void derivativesImpl(const SplineType& spline, typename SplineType::Scalar u, DenseIndex order, DerivativeType& der)$/;"	f	namespace:Eigen
derived	Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/SVD/SVDBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SVDBase
derived	Eigen/src/SVD/SVDBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SVDBase
derived	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	Eigen/src/SparseCore/SparseSolverBase.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseSolverBase
derived	Eigen/src/SparseCore/SparseSolverBase.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseSolverBase
derived	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TensorBase
derived	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TensorBase
derived	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const Derived& derived() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
derived	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  AutoDiffScalar<_DerType>& derived() { return *static_cast<AutoDiffScalar<_DerType>*>(this); }$/;"	f	struct:Eigen::internal::auto_diff_special_op
derived	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  const AutoDiffScalar<_DerType>& derived() const { return *static_cast<const AutoDiffScalar<_DerType>*>(this); }$/;"	f	struct:Eigen::internal::auto_diff_special_op
derived	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived& derived() {$/;"	f	class:Eigen::SkylineMatrixBase
derived	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline const Derived& derived() const {$/;"	f	class:Eigen::SkylineMatrixBase
destruct_elements_of_array	Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC inline void destruct_elements_of_array(T *ptr, std::size_t size)$/;"	f	namespace:Eigen::internal
detect_super_cols	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols$/;"	f	namespace:internal
determinant	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Scalar determinant() const$/;"	f	class:Eigen::CholmodBase
determinant	Eigen/src/Core/PermutationMatrix.h	/^    Index determinant() const$/;"	f	class:Eigen::PermutationBase
determinant	Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView
determinant	Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase
determinant	Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU
determinant	Eigen/src/LU/PartialPivLU.h	/^typename PartialPivLU<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT
determinant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar determinant()$/;"	f	class:Eigen::SparseLU
determinant	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU
determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU
determinant	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^double determinant;$/;"	v
determinant	test/determinant.cpp	/^template<typename MatrixType> void determinant(const MatrixType& m)$/;"	f
determinant_impl	Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
device	Eigen/src/Core/util/Meta.h	/^namespace device {$/;"	n	namespace:Eigen::internal
device	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    TensorDevice<Derived, DeviceType> device(const DeviceType& device) {$/;"	f	class:Eigen::TensorBase
device	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  const Device& device() const{return m_device;}$/;"	f	struct:Eigen::TensorEvaluator
device	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const Device& device() const{return m_device;}$/;"	f	struct:Eigen::TensorEvaluator
device	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  const Device& device() const{return m_device;}$/;"	f	struct:Eigen::TensorEvaluator
device	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  const Device& device() const{return m_device;}$/;"	f	struct:Eigen::TensorEvaluator
device	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Device& device() const {$/;"	f	struct:Eigen::TensorEvaluator
deviceProperties	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  const cudaDeviceProp& deviceProperties() const {$/;"	f	class:Eigen::CudaStreamDevice
device_	bench/tensors/tensor_benchmarks.h	/^  Device device_;$/;"	m	class:BenchmarkSuite
device_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Device& device_;$/;"	m	class:Eigen::TensorEvaluator::Context
device_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  int device_;$/;"	m	class:Eigen::CudaStreamDevice
df	test/denseLM.cpp	/^  int df(const VectorType& uv, JacobianType& fjac)$/;"	f	struct:DenseLM
df	test/sparseLM.cpp	/^  int df(const VectorType& uv, JacobianType& fjac)$/;"	f	struct:sparseGaussianTest
df	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    int df(const InputType& _x, JacobianType &jac) const$/;"	f	class:Eigen::NumericalDiff
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:Bennett5_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:BoxBOD_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH09_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH10_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH17_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:chwirut2_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:eckerle4_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:hahn1_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:lanczos1_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1a_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1d_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat42_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat43_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:thurber_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, MatrixXd &fjac) const$/;"	f	struct:lmder_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, MatrixXd &fjac)$/;"	f	struct:hybrj_functor
df	unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, VectorXd &jac_row, VectorXd::Index rownb)$/;"	f	struct:lmstr_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:Bennett5_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:BoxBOD_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH09_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH10_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH17_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:chwirut2_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:eckerle4_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:hahn1_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:lanczos1_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1a_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1d_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat42_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat43_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:thurber_functor
df	unsupported/test/levenberg_marquardt.cpp	/^    int df(const VectorXd &x, MatrixXd &fjac) const$/;"	f	struct:lmder_functor
dfs_kernel	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,StorageIndex>::dfs_kernel(const StorageIndex jj, IndexVector& perm_r,$/;"	f	class:Eigen::internal::SparseLUImpl
dget	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^template<std::size_t n, typename Dimension> struct dget {$/;"	s	namespace:Eigen::internal
dgmres	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^void DGMRES<_MatrixType, _Preconditioner>::dgmres(const MatrixType& mat,const Rhs& rhs, Dest& x,$/;"	f	class:Eigen::DGMRES
dgmresApplyDeflation	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^Index DGMRES<_MatrixType, _Preconditioner>::dgmresApplyDeflation(const RhsType &x, DestType &y) const$/;"	f	class:Eigen::DGMRES
dgmresComputeDeflationData	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^Index DGMRES<_MatrixType, _Preconditioner>::dgmresComputeDeflationData(const MatrixType& mat, const Preconditioner& precond, const Index& it, StorageIndex& neig) const$/;"	f	class:Eigen::DGMRES
dgmresCycle	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^Index DGMRES<_MatrixType, _Preconditioner>::dgmresCycle(const MatrixType& mat, const Preconditioner& precond, Dest& x, DenseVector& r0, RealScalar& beta, const RealScalar& normRhs, Index& nbIts) const$/;"	f	class:Eigen::DGMRES
dgmresInitDeflation	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^void DGMRES<_MatrixType, _Preconditioner>::dgmresInitDeflation(Index& rows) const$/;"	f	class:Eigen::DGMRES
diag	doc/snippets/Tridiagonalization_diagonal.cpp	/^VectorXd diag = triOfA.diagonal();$/;"	v
diag	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType& diag() {return m_diag; }$/;"	f	class:Eigen::LevenbergMarquardt
diag	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
diag	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
diag	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& diag(Index i) {$/;"	f	class:Eigen::SkylineStorage
diag	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& diag(Index i) const {$/;"	f	class:Eigen::SkylineStorage
diagSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index diagSize() const {$/;"	f	class:Eigen::SkylineStorage
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	Eigen/src/Core/SelfAdjointView.h	/^    typename MatrixType::ConstDiagonalReturnType diagonal() const$/;"	f	class:Eigen::SelfAdjointView
diagonal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization
diagonal	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline CwiseBinaryOp< internal::scalar_difference_op<Scalar,Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox
diagonal	Eigen/src/SparseCore/SparseMatrix.h	/^    DiagonalReturnType diagonal() { return DiagonalReturnType(*this); }$/;"	f	class:Eigen::SparseMatrix
diagonal	Eigen/src/SparseCore/SparseMatrix.h	/^    const ConstDiagonalReturnType diagonal() const { return ConstDiagonalReturnType(*this); }$/;"	f	class:Eigen::SparseMatrix
diagonal	test/diagonal.cpp	/^template<typename MatrixType> void diagonal(const MatrixType& m)$/;"	f
diagonalLength	Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonalSize	Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (numext::mini)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase
diagonal_assert	test/diagonal.cpp	/^template<typename MatrixType> void diagonal_assert(const MatrixType& m) {$/;"	f
diagonal_product_evaluator_base	Eigen/src/Core/ProductEvaluators.h	/^  diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag)$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
diagonal_product_evaluator_base	Eigen/src/Core/ProductEvaluators.h	/^struct diagonal_product_evaluator_base$/;"	s	namespace:Eigen::internal
diagonalmatrices	test/diagonalmatrices.cpp	/^template<typename MatrixType> void diagonalmatrices(const MatrixType& m)$/;"	f
dif_rmse	unsupported/test/FFTW.cpp	/^    long double dif_rmse( const VT1 buf1,const VT2 buf2)$/;"	f
difference_type	Eigen/src/Core/util/Memory.h	/^  typedef std::ptrdiff_t  difference_type;$/;"	t	class:Eigen::aligned_allocator
difference_type	Eigen/src/StlSupport/details.h	/^    typedef std::ptrdiff_t  difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection
digamma	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^digamma() const$/;"	f
digamma	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    digamma() const {$/;"	f	class:Eigen::TensorBase
digamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half digamma(const Eigen::half& a) {$/;"	f	namespace:Eigen::numext
digamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    digamma(const Scalar& x) {$/;"	f	namespace:Eigen::numext
digamma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal digamma (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(digamma);     }$/;"	f	namespace:mpfr
digamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct digamma_impl {$/;"	s	namespace:Eigen::internal
digamma_impl_maybe_poly	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct digamma_impl_maybe_poly {$/;"	s	namespace:Eigen::internal
digamma_impl_maybe_poly	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct digamma_impl_maybe_poly<double> {$/;"	s	namespace:Eigen::internal
digamma_impl_maybe_poly	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct digamma_impl_maybe_poly<float> {$/;"	s	namespace:Eigen::internal
digamma_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct digamma_retval {$/;"	s	namespace:Eigen::internal
digits	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int digits = 11;$/;"	m	struct:std::numeric_limits
digits	unsupported/test/mpreal/mpreal.h	/^        inline static int digits()                        {    return int(mpfr::mpreal::get_default_prec());    }$/;"	f	class:std::numeric_limits
digits	unsupported/test/mpreal/mpreal.h	/^        inline static int digits(const mpfr::mpreal& x)   {    return x.getPrecision();                         }$/;"	f	class:std::numeric_limits
digits	unsupported/test/mpreal/mpreal.h	/^        static const int digits       = 53;$/;"	m	class:std::numeric_limits
digits10	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int digits10 = 3;      \/\/ according to http:\/\/half.sourceforge.net\/structstd_1_1numeric__limits_3_01half__float_1_1half_01_4.html$/;"	m	struct:std::numeric_limits
digits10	unsupported/test/mpreal/mpreal.h	/^        inline static int digits10(const mpfr::mpreal& x)$/;"	f	class:std::numeric_limits
digits10	unsupported/test/mpreal/mpreal.h	/^        inline static int digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits
digits10	unsupported/test/mpreal/mpreal.h	/^        static const int digits10     = 15;$/;"	m	class:std::numeric_limits
digits2bits	unsupported/test/mpreal/mpreal.h	/^inline mp_prec_t digits2bits(int d)$/;"	f	namespace:mpfr
dim	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox
dim	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dim	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  const Index dim() const { return m_dim.actualDim(); }$/;"	f	class:Eigen::TensorChippingOp
dim	unsupported/Eigen/src/BVH/KdBVH.h	/^    int dim;$/;"	m	struct:Eigen::KdBVH::VectorComparator
dim	unsupported/test/mpreal/mpreal.h	/^inline const mpreal dim(const mpreal& a, const mpreal& b, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
dimension	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                         dimension(std::size_t n) const { return m_storage.dimensions()[n]; }$/;"	f	class:Eigen::Tensor
dimension	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                    dimension(std::size_t n) const { return m_storage.dimensions()[n]; }$/;"	f	class:Eigen::TensorFixedSize
dimension	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Index dimension(Index n) const { return m_dimensions[n]; }$/;"	f	class:Eigen::TensorMap
dimension	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Index dimension(Index n) const { return m_evaluator->dimensions()[n]; }$/;"	f	class:Eigen::TensorRef
dimensionOfKernel	Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU
dimensionOfKernel	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR
dimensionOfKernel	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index dimensionOfKernel() const { return m_cpqr.dimensionOfKernel(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
dimensionOfKernel	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR
dimensions	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions&             dimensions()             const { return m_storage.dimensions(); }$/;"	f	class:Eigen::Tensor
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const {$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_impl.dimensions(); }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const { return m_impl.dimensions(); }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dims; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const { return m_argImpl.dimensions(); }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const {$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions&        dimensions()             const { return m_storage.dimensions(); }$/;"	f	class:Eigen::TensorFixedSize
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC const Dimensions& dimensions() const { return m_impl.dimensions(); }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	class:Eigen::TensorMap
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const NewDimensions& dimensions() const { return m_dims; }$/;"	f	class:Eigen::TensorReshapingOp
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_evaluator->dimensions(); }$/;"	f	class:Eigen::TensorRef
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_ref.dimensions(); }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC virtual const Dimensions& dimensions() const {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  const Dimensions& dimensions() const { return this->m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const {$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const {return m_dimensions;}$/;"	f	class:Eigen::TensorStorage
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_STRONG_INLINE const FixedDimensions& dimensions() const { return m_dimensions; }$/;"	f	class:Eigen::TensorStorage
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorSycl::internal::FunctorExtractor
dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Dimensions& dimensions() const { return m_dimensions; }$/;"	f	struct:Eigen::TensorEvaluator
dimensions	unsupported/test/cxx11_tensor_custom_op.cpp	/^  DSizes<DenseIndex, 2> dimensions(const Tensor<float, 2>& input) const {$/;"	f	struct:InsertZeros
dimensions	unsupported/test/cxx11_tensor_custom_op.cpp	/^  DSizes<DenseIndex, 3> dimensions(const Tensor<float, 3>& input1, const Tensor<float, 3>& input2) const {$/;"	f	struct:BatchMatMul
dimensions_match	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^EIGEN_DEVICE_FUNC bool dimensions_match(Dims1& dims1, Dims2& dims2) {$/;"	f	namespace:Eigen
dimino_add_all_coset_spaces	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_all_coset_spaces$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_all_coset_spaces	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_all_coset_spaces<Multiply, Equality, id, sub_group_elements, elements, generators, sub_group_size, rep_pos, true>$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_cosets_for_rep	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_cosets_for_rep<Multiply, Equality, id, sub_group_elements, elements, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, rep_element, sub_group_size>$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_cosets_for_rep	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_cosets_for_rep<Multiply, Equality, id, sub_group_elements, elements, type_list<g, gs...>, rep_element, sub_group_size>$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_generator	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_generator$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_generator	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_generator<Multiply, Equality, id, elements, generators_done, current_generator, true>$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_remaining_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_remaining_generators$/;"	s	namespace:Eigen::internal::group_theory
dimino_add_remaining_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_add_remaining_generators<Multiply, Equality, id, generators_done, type_list<>, elements>$/;"	s	namespace:Eigen::internal::group_theory
dimino_first_step_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_first_step_elements$/;"	s	namespace:Eigen::internal::group_theory
dimino_first_step_elements_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_first_step_elements_helper$/;"	s	namespace:Eigen::internal::group_theory
dimino_first_step_elements_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_first_step_elements_helper<Multiply, Equality, id, g, current_element, elements, true>$/;"	s	namespace:Eigen::internal::group_theory
dimino_get_coset_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_get_coset_elements$/;"	s	namespace:Eigen::internal::group_theory
dimino_get_coset_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct dimino_get_coset_elements<Multiply, sub_group_elements, new_coset_rep, false>$/;"	s	namespace:Eigen::internal::group_theory
dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    const Dims& dims() const { return m_dims; }$/;"	f	class:Eigen::TensorReductionOp
dirder	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
direction	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	demos/opengl/camera.cpp	/^Vector3f Camera::direction(void) const$/;"	f	class:Camera
display_vector	bench/btl/libs/STL/STL_interface.hh	/^  static inline void display_vector(const stl_vector & A)$/;"	f	class:STL_interface
distance	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC RealScalar distance(const VectorType& p) const { EIGEN_USING_STD_MATH(sqrt) return sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
div_2si	unsupported/test/mpreal/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
div_2ui	unsupported/test/mpreal/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
div_assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar, typename SrcScalar=DstScalar> struct div_assign_op {$/;"	s	namespace:Eigen::internal
div_ceil	Eigen/src/Core/util/Meta.h	/^T div_ceil(const T &a, const T &b)$/;"	f	namespace:numext
divacNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar divacNorm(T& v)$/;"	f
divide	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::divide (Index firstCol, Index lastCol, Index firstRowW, Index firstColW, Index shift)$/;"	f	class:Eigen::BDCSVD
divide	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE int divide(const int32_t n) const {$/;"	f	class:Eigen::internal::TensorIntDivisor
divide	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T divide(const T numerator) const {$/;"	f	struct:Eigen::internal::TensorIntDivisor
divide_assign_using_evaluator	test/evaluators.cpp	/^  void divide_assign_using_evaluator(const DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen
divup	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^T divup(const T x, const T y) {$/;"	f	namespace:Eigen
divup	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^T divup(const X x, const Y y) {$/;"	f	namespace:Eigen
dmax	blas/f2c/datatypes.h	22;"	d
dmin	blas/f2c/datatypes.h	21;"	d
doAssign	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline void doAssign(Scalar const& value)$/;"	f	class:Eigen::internal::tensor_symmetry_value_setter
doCheck_	unsupported/test/cxx11_tensor_symmetry.cpp	/^  static inline int doCheck_(ArrType e, int flags, int dummy, std::set<uint64_t>& found, std::map<uint64_t, int> const& expected)$/;"	f	struct:checkIdx
doComputeEigenvectors	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver
doComputeEigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver
doEigen	bench/sparse_cholesky.cpp	/^void doEigen(const char* name, const EigenSparseSelfAdjointMatrix& sm1, int flags = 0)$/;"	f
doEigen	bench/sparse_lu.cpp	/^void doEigen(const char* name, const EigenSparseMatrix& sm1, const VectorX& b, VectorX& x, int flags = 0)$/;"	f
dogleg	unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^void dogleg($/;"	f	namespace:Eigen::internal
done	bench/bench_gemm.cpp	/^static double done = 1;$/;"	v	file:
done_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Notification done_;$/;"	m	class:Eigen::TensorEvaluator::Context
done_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  std::atomic<bool> done_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
dont_over_optimize	test/geo_transformations.cpp	/^void dont_over_optimize(T& x) { volatile typename T::Scalar tmp = x(0); x(0) = tmp; }$/;"	f
dontalign	test/dontalign.cpp	/^void dontalign(const MatrixType& m)$/;"	f
dostuff	bench/sparse_randomsetter.cpp	/^void dostuff(const char* name, EigenSparseMatrix& sm1)$/;"	f
dot	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
dot	Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> EIGEN_DEVICE_FUNC inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase
dot	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	blas/level1_real_impl.h	/^Scalar EIGEN_BLAS_FUNC(dot)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy)$/;"	f
dot_nocheck	Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
dotcw	blas/level1_cplx_impl.h	/^int EIGEN_BLAS_FUNC(dotcw)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar* pres)$/;"	f
dotuw	blas/level1_cplx_impl.h	/^int EIGEN_BLAS_FUNC(dotuw)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar* pres)$/;"	f
doublecomplex	blas/f2c/datatypes.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	t	typeref:struct:__anon204
doublereal	blas/f2c/datatypes.h	/^typedef double doublereal;$/;"	t
doxygen	Eigen/src/Core/PlainObjectBase.h	/^namespace doxygen {$/;"	n	namespace:Eigen
dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<double,DPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase
dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase
draft	demos/mandelbrot/mandelbrot.h	/^    int draft;$/;"	m	class:MandelbrotWidget
draw	demos/opengl/gpuhelper.h	/^inline void GpuHelper::draw(GLenum mode, const std::vector<uint>* pIndexes)$/;"	f	class:GpuHelper
draw	demos/opengl/gpuhelper.h	/^inline void GpuHelper::draw(GLenum mode, uint nofElement)$/;"	f	class:GpuHelper
draw	demos/opengl/gpuhelper.h	/^inline void GpuHelper::draw(GLenum mode, uint start, uint end)$/;"	f	class:GpuHelper
draw	demos/opengl/icosphere.cpp	/^void IcoSphere::draw(int level)$/;"	f	class:IcoSphere
draw	demos/opengl/quaternion_demo.cpp	/^    void draw()$/;"	f	class:FancySpheres
drawScene	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::drawScene()$/;"	f	class:RenderingWidget
drawUnitCube	demos/opengl/gpuhelper.cpp	/^void GpuHelper::drawUnitCube(void)$/;"	f	class:GpuHelper
drawUnitSphere	demos/opengl/gpuhelper.cpp	/^void GpuHelper::drawUnitSphere(int level)$/;"	f	class:GpuHelper
drawVector	demos/opengl/gpuhelper.cpp	/^void GpuHelper::drawVector(const Vector3f& position, const Vector3f& vec, const Color& color, float aspect \/* = 50.*\/)$/;"	f	class:GpuHelper
drawVectorBox	demos/opengl/gpuhelper.cpp	/^void GpuHelper::drawVectorBox(const Vector3f& position, const Vector3f& vec, const Color& color, float aspect)$/;"	f	class:GpuHelper
dropMemoryCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC void dropMemoryCost() {$/;"	f	class:Eigen::TensorOpCost
drotm_	blas/f2c/drotm.c	/^\/* Subroutine *\/ int drotm_(integer *n, doublereal *dx, integer *incx, $/;"	f
drotmg_	blas/f2c/drotmg.c	/^\/* Subroutine *\/ int drotmg_(doublereal *dd1, doublereal *dd2, doublereal *$/;"	f
dsbmv_	blas/f2c/dsbmv.c	/^\/* Subroutine *\/ int dsbmv_(char *uplo, integer *n, integer *k, doublereal *$/;"	f
dsdot	blas/double.cpp	/^double BLASFUNC(dsdot)(int* n, float* x, int* incx, float* y, int* incy)$/;"	f
dspmv_	blas/f2c/dspmv.c	/^\/* Subroutine *\/ int dspmv_(char *uplo, integer *n, doublereal *alpha, $/;"	f
dstDataPtr	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC const Scalar* dstDataPtr() const$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
dstEvaluator	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() { return m_dst; }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
dtbmv_	blas/f2c/dtbmv.c	/^\/* Subroutine *\/ int dtbmv_(char *uplo, char *trans, char *diag, integer *n, $/;"	f
dummy	test/ctorleak.cpp	/^  int dummy;$/;"	m	struct:Foo	file:
dummy	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  T dummy;$/;"	m	class:Eigen::array
dummy_a	unsupported/test/cxx11_meta.cpp	/^struct dummy_a {};$/;"	s	file:
dummy_b	unsupported/test/cxx11_meta.cpp	/^struct dummy_b {};$/;"	s	file:
dummy_c	unsupported/test/cxx11_meta.cpp	/^struct dummy_c {};$/;"	s	file:
dummy_d	unsupported/test/cxx11_meta.cpp	/^struct dummy_d {};$/;"	s	file:
dummy_e	unsupported/test/cxx11_meta.cpp	/^struct dummy_e {};$/;"	s	file:
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  dummy_inst() : c(0) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  dummy_inst(int, int) : c(2) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  dummy_inst(int, int, int) : c(3) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  dummy_inst(int, int, int, int) : c(4) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  dummy_inst(int, int, int, int, int) : c(5) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^  explicit dummy_inst(int) : c(1) {}$/;"	f	struct:dummy_inst
dummy_inst	unsupported/test/cxx11_meta.cpp	/^struct dummy_inst$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_a> { typedef dummy_e type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_b> { typedef dummy_c type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_c> { typedef dummy_d type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_a> { typedef dummy_d type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_b> { typedef dummy_e type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_c> { typedef dummy_a type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_a> { typedef dummy_b type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_b> { typedef dummy_d type; };$/;"	s	file:
dummy_op	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_c> { typedef dummy_e type; };$/;"	s	file:
dummy_precision	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half dummy_precision() { return Eigen::half(1e-2f); }$/;"	f	struct:Eigen::NumTraits
dummy_precision	test/boostmultiprec.cpp	/^    static inline Real dummy_precision() { return 1e-50; }$/;"	f	struct:Eigen::NumTraits
dummy_precision	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static inline Real dummy_precision() { return 0; }$/;"	f	struct:Eigen::NumTraits
dummy_test	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_a, dummy_a>     { constexpr static bool value = true;  constexpr static int global_flags = 1; };$/;"	s	file:
dummy_test	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_b, dummy_b>     { constexpr static bool value = true;  constexpr static int global_flags = 2; };$/;"	s	file:
dummy_test	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_c, dummy_c>     { constexpr static bool value = true;  constexpr static int global_flags = 4; };$/;"	s	file:
dummy_test	unsupported/test/cxx11_meta.cpp	/^template<typename A, typename B> struct dummy_test { constexpr static bool value = false; constexpr static int global_flags = 0; };$/;"	s	file:
dummychar	test/dynalloc.cpp	/^    char dummychar;$/;"	m	class:MyClassA	file:
dummychar	test/dynalloc.cpp	/^  char dummychar;$/;"	m	struct:MyStruct	file:
dumpMemory	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::CholmodBase
dumpMemory	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase
dumpMemory	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::SuperLUBase
dump_history	bench/btl/generic_bench/timers/x86_timer.hh	/^  void dump_history(string filemane){$/;"	f	class:X86_Timer
dump_statistics	bench/btl/generic_bench/timers/x86_timer.hh	/^  void dump_statistics(string filemane){$/;"	f	class:X86_Timer
dump_table_for_subset	bench/analyze-blocking-sizes.cpp	/^void dump_table_for_subset($/;"	f
dump_tables	bench/analyze-blocking-sizes.cpp	/^bool dump_tables = false;$/;"	v
dump_xy_file	bench/btl/generic_bench/utils/xy_file.hh	/^void dump_xy_file(const Vector_A & X, const Vector_B & Y, const std::string & filename){$/;"	f
ec_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  EventCount ec_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
eckerle4_functor	unsupported/test/NonLinearOptimization.cpp	/^    eckerle4_functor(void) : Functor<double>(3,35) {}$/;"	f	struct:eckerle4_functor
eckerle4_functor	unsupported/test/NonLinearOptimization.cpp	/^struct eckerle4_functor : Functor<double>$/;"	s	file:
eckerle4_functor	unsupported/test/levenberg_marquardt.cpp	/^    eckerle4_functor(void) : DenseFunctor<double>(3,35) {}$/;"	f	struct:eckerle4_functor
eckerle4_functor	unsupported/test/levenberg_marquardt.cpp	/^struct eckerle4_functor : DenseFunctor<double>$/;"	s	file:
efficiency	bench/analyze-blocking-sizes.cpp	/^  float efficiency;$/;"	m	struct:preprocessed_inputfile_entry_t	file:
efficiency_of_partition	bench/analyze-blocking-sizes.cpp	/^float efficiency_of_partition($/;"	f
efficiency_of_subset	bench/analyze-blocking-sizes.cpp	/^float efficiency_of_subset($/;"	f
eiToCSparse	bench/BenchSparseUtil.h	/^void eiToCSparse(const EigenSparseMatrix& src, cs* &dst)$/;"	f
eiToDense	bench/BenchSparseUtil.h	/^void eiToDense(const EigenSparseMatrix& src, DenseMatrix& dst)$/;"	f
eiToGmm	bench/BenchSparseUtil.h	/^void eiToGmm(const EigenSparseMatrix& src, GmmSparse& dst)$/;"	f
eiToGmm	bench/BenchUtil.h	/^void eiToGmm(const EigenMatrixType& src, GmmMatrixType& dst)$/;"	f
eiToGsl	bench/BenchUtil.h	/^void eiToGsl(const EigenMatrixType& src, gsl_matrix** dst)$/;"	f
eiToMtl	bench/BenchSparseUtil.h	/^void eiToMtl(const EigenSparseMatrix& src, MtlSparse& dst)$/;"	f
eiToUblas	bench/BenchSparseUtil.h	/^void eiToUblas(const EigenSparseMatrix& src, UBlasSparse& dst)$/;"	f
eiToUblas	bench/BenchUtil.h	/^void eiToUblas(const EigenMatrixType& src, UblasMatrixType& dst)$/;"	f
eiToUblasVec	bench/BenchSparseUtil.h	/^void eiToUblasVec(const EigenType& src, UblasType& dst)$/;"	f
eiToUblasVec	bench/BenchUtil.h	/^void eiToUblasVec(const EigenType& src, UblasType& dst)$/;"	f
ei_declare_aligned_stack_constructed_variable	Eigen/src/Core/util/Memory.h	634;"	d
ei_test_init_cuda	test/cuda_common.h	/^void ei_test_init_cuda()$/;"	f
eigen2_interface	bench/btl/libs/eigen2/eigen2_interface.hh	/^class eigen2_interface$/;"	c
eigen2support	test/eigen2support.cpp	/^template<typename MatrixType> void eigen2support(const MatrixType& m)$/;"	f
eigen33	bench/eig33.cpp	/^void eigen33(const Matrix& mat, Matrix& evecs, Vector& evals)$/;"	f
eigen3_interface	bench/btl/libs/eigen3/eigen3_interface.hh	/^class eigen3_interface$/;"	c
eigen_assert	Eigen/src/Core/util/Macros.h	579;"	d
eigen_assert	test/main.h	202;"	d
eigen_assert_exception	test/main.h	/^      eigen_assert_exception(void) {}$/;"	f	struct:Eigen::eigen_assert_exception
eigen_assert_exception	test/main.h	/^    struct eigen_assert_exception$/;"	s	namespace:Eigen
eigen_assert_list	test/main.h	/^      static std::vector<std::string> eigen_assert_list;$/;"	m	namespace:Eigen
eigen_block_size_k	bench/benchmark-blocking-sizes.cpp	/^int eigen_block_size_k, eigen_block_size_m, eigen_block_size_n;$/;"	v
eigen_block_size_m	bench/benchmark-blocking-sizes.cpp	/^int eigen_block_size_k, eigen_block_size_m, eigen_block_size_n;$/;"	v
eigen_block_size_n	bench/benchmark-blocking-sizes.cpp	/^int eigen_block_size_k, eigen_block_size_m, eigen_block_size_n;$/;"	v
eigen_internal_assert	Eigen/src/Core/util/Macros.h	583;"	d
eigen_packet_wrapper	Eigen/src/Core/arch/NEON/PacketMath.h	/^  eigen_packet_wrapper() {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	Eigen/src/Core/arch/NEON/PacketMath.h	/^  eigen_packet_wrapper(const T &v) : m_val(v) {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	Eigen/src/Core/arch/NEON/PacketMath.h	/^struct eigen_packet_wrapper$/;"	s	namespace:Eigen::internal
eigen_packet_wrapper	Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper() {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper(const T &v) : m_val(v) {}$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
eigen_packet_wrapper	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct eigen_packet_wrapper$/;"	s	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  inline void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  inline void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  inline void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  inline void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_plain_assert	Eigen/src/Core/util/Macros.h	541;"	d
eigen_plain_assert	Eigen/src/Core/util/Macros.h	549;"	d
eigen_static_assert_exception	test/main.h	/^      eigen_static_assert_exception(void) {}$/;"	f	struct:Eigen::eigen_static_assert_exception
eigen_static_assert_exception	test/main.h	/^    struct eigen_static_assert_exception$/;"	s	namespace:Eigen
eigen_to_c	demos/mix_eigen_and_c/binary_library.cpp	/^inline C_Map_MatrixXd* eigen_to_c(Map<MatrixXd>& ref)$/;"	f
eigen_to_c	demos/mix_eigen_and_c/binary_library.cpp	/^inline C_MatrixXd* eigen_to_c(MatrixXd& ref)$/;"	f
eigen_to_c	demos/mix_eigen_and_c/binary_library.cpp	/^inline const C_Map_MatrixXd* eigen_to_c(const Map<MatrixXd>& ref)$/;"	f
eigen_to_c	demos/mix_eigen_and_c/binary_library.cpp	/^inline const C_MatrixXd* eigen_to_c(const MatrixXd& ref)$/;"	f
eigen_unaligned_array_assert_workaround_gcc47	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }$/;"	f	namespace:Eigen::internal
eigen_use_specific_block_size	bench/benchmark-blocking-sizes.cpp	/^bool eigen_use_specific_block_size;$/;"	v
eigensolver	test/eigensolver_complex.cpp	/^template<typename MatrixType> void eigensolver(const MatrixType& m)$/;"	f
eigensolver	test/eigensolver_generic.cpp	/^template<typename MatrixType> void eigensolver(const MatrixType& m)$/;"	f
eigensolver_verify_assert	test/eigensolver_complex.cpp	/^template<typename MatrixType> void eigensolver_verify_assert(const MatrixType& m)$/;"	f
eigensolver_verify_assert	test/eigensolver_generic.cpp	/^template<typename MatrixType> void eigensolver_verify_assert(const MatrixType& m)$/;"	f
eigenvalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvalues	Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver
eigenvalues	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvalueType eigenvalues() const$/;"	f	class:Eigen::GeneralizedEigenSolver
eigenvalues	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase
eigenvalues	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView
eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eigenvalues	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  const Matrix<Scalar, Dynamic, 1>& eigenvalues() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
eigenvalues_selector	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
eigenvalues_selector	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvectors	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver
eigenvectors	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvectorsType eigenvectors() const {$/;"	f	class:Eigen::GeneralizedEigenSolver
eigenvectors	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const EigenvectorsType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eigenvectors	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  const Matrix<Scalar, Dynamic, Dynamic>& eigenvectors() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
eint	unsupported/test/mpreal/mpreal.h	/^inline const mpreal eint    (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(eint   );    }$/;"	f	namespace:mpfr
eivals	doc/snippets/MatrixBase_eigenvalues.cpp	/^VectorXcd eivals = ones.eigenvalues();$/;"	v
eivals	doc/snippets/SelfAdjointView_eigenvalues.cpp	/^VectorXd eivals = ones.selfadjointView<Lower>().eigenvalues();$/;"	v
elapsed	bench/btl/generic_bench/timers/portable_timer.hh	/^   double elapsed() {$/;"	f	class:Portable_Timer
elapsed	bench/btl/generic_bench/timers/portable_timer.hh	/^  double elapsed()$/;"	f	class:Portable_Timer
elevations	doc/snippets/LLT_solve.cpp	/^VectorXf elevations = 2*samples.col(0) + 3*samples.col(1) + VectorXf::Random(12)*0.1;$/;"	v
elseExpr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<ElseExpr, Dev> > elseExpr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
elseExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const ElseXprType& elseExpression() const { return m_else; }$/;"	f	class:Eigen::TensorSelectOp
elseMatrix	Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select
else_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<ElseArgType, Device>& else_impl() const { return m_elseImpl; }$/;"	f	struct:Eigen::TensorEvaluator
empty	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  bool empty() const { return size_ == 0; }$/;"	f	class:Eigen::MaxSizeVector
emptyIdxLU	Eigen/src/SparseLU/SparseLU_Memory.h	/^enum {emptyIdxLU = -1};$/;"	e	enum:Eigen::internal::__anon878
empty_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  std::condition_variable empty_;   \/\/ Signaled on pending_.empty()$/;"	m	class:Eigen::SimpleThreadPoolTempl
empty_list	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct empty_list { static const std::size_t count = 0; };$/;"	s	namespace:Eigen::internal
enable_if	Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
enable_if_ref	Eigen/src/LU/PartialPivLU.h	/^struct enable_if_ref<Ref<T>,Derived> {$/;"	s	namespace:Eigen::internal
end	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T* end() { return data_ + size_; }$/;"	f	class:Eigen::MaxSizeVector
end	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  const T* end() const { return data_ + size_; }$/;"	f	class:Eigen::MaxSizeVector
endFill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector
endFill	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::DynamicSparseMatrix
endl	doc/snippets/BiCGSTAB_simple.cpp	/^  std::cout << "#iterations:     " << solver.iterations() << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/BiCGSTAB_simple.cpp	/^  std::cout << "estimated error: " << solver.error()      << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/ColPivHouseholderQR_solve.cpp	/^cout << "Here is a solution x to the equation mx=y:" << endl << x << endl;$/;"	v
endl	doc/snippets/ColPivHouseholderQR_solve.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/ColPivHouseholderQR_solve.cpp	/^cout << "Here is the matrix y:" << endl << y << endl;$/;"	v
endl	doc/snippets/ComplexEigenSolver_compute.cpp	/^cout << "... and A * v = " << endl << A * v << endl << endl;$/;"	v
endl	doc/snippets/ComplexEigenSolver_compute.cpp	/^cout << "Consider the first eigenvalue, lambda = " << lambda << endl;$/;"	v
endl	doc/snippets/ComplexEigenSolver_compute.cpp	/^cout << "Here is a random 4x4 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/ComplexEigenSolver_compute.cpp	/^cout << "If v is the corresponding eigenvector, then lambda * v = " << endl << lambda * v << endl;$/;"	v
endl	doc/snippets/ComplexEigenSolver_compute.cpp	/^cout << "The matrix of eigenvectors, V, is:" << endl << ces.eigenvectors() << endl << endl;$/;"	v
endl	doc/snippets/ComplexSchur_matrixT.cpp	/^cout << "Here is a random 4x4 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/ComplexSchur_matrixU.cpp	/^cout << "Here is a random 4x4 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/Cwise_arg.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_boolean_not.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_ceil.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_floor.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_isFinite.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_isInf.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_isNaN.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_minus_equal.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Cwise_plus.cpp	/^cout << v+5 << endl;$/;"	v
endl	doc/snippets/Cwise_plus_equal.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Cwise_product.cpp	/^cout << "a:\\n" << a << "\\nb:\\n" << b << "\\nc:\\n" << c << endl;$/;"	v
endl	doc/snippets/Cwise_quotient.cpp	/^cout << v\/w << endl;$/;"	v
endl	doc/snippets/Cwise_round.cpp	/^cout << v << endl << endl;$/;"	v
endl	doc/snippets/Cwise_slash_equal.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Cwise_times_equal.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/DenseBase_LinSpacedInt.cpp	/^cout << "Even spacing inputs:" << endl;$/;"	v
endl	doc/snippets/DenseBase_LinSpacedInt.cpp	/^cout << "Uneven spacing inputs:" << endl;$/;"	v
endl	doc/snippets/DenseBase_setLinSpaced.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/DirectionWise_hnormalized.cpp	/^cout << "(P*M).colwise().hnormalized():" << endl << (P*M).colwise().hnormalized() << endl << endl;/;"	v
endl	doc/snippets/DirectionWise_hnormalized.cpp	/^cout << "M.colwise().hnormalized():" << endl << M.colwise().hnormalized() << endl << endl;$/;"	v
endl	doc/snippets/DirectionWise_hnormalized.cpp	/^cout << "P*M:" << endl << P*M << endl << endl;$/;"	v
endl	doc/snippets/DirectionWise_hnormalized.cpp	/^cout << "The matrix M is:" << endl << M << endl << endl;$/;"	v
endl	doc/snippets/DirectionWise_replicate.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/DirectionWise_replicate.cpp	/^cout << "m.colwise().replicate<3>() = ..." << endl;$/;"	v
endl	doc/snippets/DirectionWise_replicate_int.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/DirectionWise_replicate_int.cpp	/^cout << "v.rowwise().replicate(5) = ..." << endl;$/;"	v
endl	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^cout << "... and A * v = " << endl << A.cast<complex<double> >() * v << endl << endl;$/;"	v
endl	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^cout << "Consider the first eigenvalue, lambda = " << lambda << endl;$/;"	v
endl	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^cout << "Here is a random 6x6 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^cout << "If v is the corresponding eigenvector, then lambda * v = " << endl << lambda * v << endl;$/;"	v
endl	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^cout << "The matrix of eigenvectors, V, is:" << endl << es.eigenvectors() << endl << endl;$/;"	v
endl	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^cout << "Here is a random 6x6 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^cout << "The pseudo-eigenvalue matrix D is:" << endl << D << endl;$/;"	v
endl	doc/snippets/EigenSolver_pseudoEigenvectors.cpp	/^cout << "The pseudo-eigenvector matrix V is:" << endl << V << endl;$/;"	v
endl	doc/snippets/FullPivHouseholderQR_solve.cpp	/^cout << "Here is a solution x to the equation mx=y:" << endl << x << endl;$/;"	v
endl	doc/snippets/FullPivHouseholderQR_solve.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/FullPivHouseholderQR_solve.cpp	/^cout << "Here is the matrix y:" << endl << y << endl;$/;"	v
endl	doc/snippets/FullPivLU_image.cpp	/^     << "columns are linearly dependent." << endl;$/;"	v
endl	doc/snippets/FullPivLU_image.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/FullPivLU_kernel.cpp	/^     << endl << ker << endl;$/;"	v
endl	doc/snippets/FullPivLU_kernel.cpp	/^     << endl << m*ker << endl;$/;"	v
endl	doc/snippets/FullPivLU_kernel.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/FullPivLU_solve.cpp	/^  cout << "The equation mx=y does not have any solution." << endl;$/;"	v
endl	doc/snippets/FullPivLU_solve.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/FullPivLU_solve.cpp	/^cout << "Here is the matrix y:" << endl << y << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^cout << "Here is a random 4x4 matrix:" << endl << A << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^cout << "The Hessenberg matrix H is:" << endl << H << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_matrixH.cpp	/^cout << "The orthogonal matrix Q is:" << endl << Q << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^cout << "Here is a random 4x4 matrix:" << endl << A << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^cout << "The packed matrix M is:" << endl << pm << endl;$/;"	v
endl	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^cout << "The vector of Householder coefficients is:" << endl << hc << endl;$/;"	v
endl	doc/snippets/HouseholderQR_solve.cpp	/^cout << "Here is a solution x to the equation mx=y:" << endl << x << endl;$/;"	v
endl	doc/snippets/HouseholderQR_solve.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/HouseholderQR_solve.cpp	/^cout << "Here is the matrix y:" << endl << y << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "If we construct a HouseholderSequence from v and h" << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "The first Householder reflection is represented by H_0 = " << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "The matrix v is:" << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "The second Householder reflection is represented by H_1 = " << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "The third Householder reflection is represented by H_2 = " << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "Their product is H_0 H_1 H_2 = " << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << "and convert it to a matrix, we get:" << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << H0 * H1 * H2 << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << H0 << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << H1 << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << H2 << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << hhSeqAsMatrix << endl;$/;"	v
endl	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/JacobiSVD_basic.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/JacobiSVD_basic.cpp	/^cout << "Now consider this rhs vector:" << endl << rhs << endl;$/;"	v
endl	doc/snippets/Jacobi_makeGivens.cpp	/^cout << "Here is the vector J' * v:" << endl << v << endl;/;"	v
endl	doc/snippets/Jacobi_makeGivens.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/Jacobi_makeJacobi.cpp	/^cout << "Here is the matrix J' * m * J:" << endl << m << endl;/;"	v
endl	doc/snippets/Jacobi_makeJacobi.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/LLT_example.cpp	/^cout << "The Cholesky factor L is" << endl << L << endl;$/;"	v
endl	doc/snippets/LLT_example.cpp	/^cout << "The matrix A is" << endl << A << endl;$/;"	v
endl	doc/snippets/LLT_example.cpp	/^cout << "This should equal the matrix A" << endl;$/;"	v
endl	doc/snippets/LLT_example.cpp	/^cout << "To check this, let us compute L * L.transpose()" << endl;$/;"	v
endl	doc/snippets/LLT_solve.cpp	/^cout << xy << endl;$/;"	v
endl	doc/snippets/MatrixBase_adjoint.cpp	/^cout << "Here is the 2x2 complex matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_applyOnTheLeft.cpp	/^cout << "After applyOnTheLeft, A = " << endl << A << endl;$/;"	v
endl	doc/snippets/MatrixBase_applyOnTheLeft.cpp	/^cout << "At start, A = " << endl << A << endl;$/;"	v
endl	doc/snippets/MatrixBase_applyOnTheRight.cpp	/^cout << "After A *= B, A = " << endl << A << endl;$/;"	v
endl	doc/snippets/MatrixBase_applyOnTheRight.cpp	/^cout << "After applyOnTheRight, A = " << endl << A << endl;$/;"	v
endl	doc/snippets/MatrixBase_applyOnTheRight.cpp	/^cout << "At start, A = " << endl << A << endl;$/;"	v
endl	doc/snippets/MatrixBase_array.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_block_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_block_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_block_int_int_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_block_int_int_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomLeftCorner_int_int.cpp	/^cout << "Here is m.bottomLeftCorner(2, 2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomLeftCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomLeftCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRightCorner_int_int.cpp	/^cout << "Here is m.bottomRightCorner(2, 2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRightCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRightCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRows_int.cpp	/^cout << "Here is a.bottomRows(2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRows_int.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_bottomRows_int.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_col.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_colwise.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^cout << "Its determinant is " << determinant << endl;$/;"	v
endl	doc/snippets/MatrixBase_computeInverseWithCheck.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_cwiseEqual.cpp	/^cout << "Comparing m with identity matrix:" << endl;$/;"	v
endl	doc/snippets/MatrixBase_cwiseEqual.cpp	/^cout << "Number of coefficients that are equal: " << count << endl;$/;"	v
endl	doc/snippets/MatrixBase_cwiseNotEqual.cpp	/^cout << "Comparing m with identity matrix:" << endl;$/;"	v
endl	doc/snippets/MatrixBase_cwiseNotEqual.cpp	/^cout << "Number of coefficients that are not equal: " << count << endl;$/;"	v
endl	doc/snippets/MatrixBase_cwiseProduct.cpp	/^cout << "a:\\n" << a << "\\nb:\\n" << b << "\\nc:\\n" << c << endl;$/;"	v
endl	doc/snippets/MatrixBase_diagonal.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_diagonal_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_diagonal_template_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_eigenvalues.cpp	/^cout << "The eigenvalues of the 3x3 matrix of ones are:" << endl << eivals << endl;$/;"	v
endl	doc/snippets/MatrixBase_end_int.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_end_int.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << "If we do m.col(1) = m.row(0), then m becomes:" << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << "Now let us instead do m.col(1) = m.row(0).eval(). Then m becomes" << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << "Now we want to copy a column into a row." << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << m << endl << "which is right." << endl;$/;"	v
endl	doc/snippets/MatrixBase_eval.cpp	/^cout << m << endl << "which is wrong!" << endl;$/;"	v
endl	doc/snippets/MatrixBase_fixedBlock_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_fixedBlock_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_inverse.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_isDiagonal.cpp	/^cout << "Here's the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_isIdentity.cpp	/^cout << "Here's the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_isOnes.cpp	/^cout << "Here's the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_isOrthogonal.cpp	/^cout << "Here's the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_isOrthogonal.cpp	/^cout << "Here's the vector w:" << endl << w << endl;$/;"	v
endl	doc/snippets/MatrixBase_isUnitary.cpp	/^cout << "Here's the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_isZero.cpp	/^cout << "Here's the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_leftCols_int.cpp	/^cout << "Here is a.leftCols(2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_leftCols_int.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_leftCols_int.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_noalias.cpp	/^cout << c << endl;$/;"	v
endl	doc/snippets/MatrixBase_prod.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_replicate.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_replicate.cpp	/^cout << "m.replicate<3,2>() = ..." << endl;$/;"	v
endl	doc/snippets/MatrixBase_replicate_int_int.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_replicate_int_int.cpp	/^cout << "v.replicate(2,5) = ..." << endl;$/;"	v
endl	doc/snippets/MatrixBase_reverse.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_reverse.cpp	/^cout << "Let us overwrite this coefficient with the value 4." << endl;$/;"	v
endl	doc/snippets/MatrixBase_reverse.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_rightCols_int.cpp	/^cout << "Here is a.rightCols(2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_rightCols_int.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_rightCols_int.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_row.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_rowwise.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_segment_int_int.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_segment_int_int.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_select.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_selfadjointView.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_set.cpp	/^cout << m1 << endl << endl;$/;"	v
endl	doc/snippets/MatrixBase_set.cpp	/^cout << m2 << endl << endl;$/;"	v
endl	doc/snippets/MatrixBase_set.cpp	/^cout << m2 << endl;$/;"	v
endl	doc/snippets/MatrixBase_setIdentity.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_setOnes.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_setRandom.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_setZero.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_start_int.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_start_int.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_bottomRows.cpp	/^cout << "Here is a.bottomRows<2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_bottomRows.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_bottomRows.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_end.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_end.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_block_int_int_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_block_int_int_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner.cpp	/^cout << "Here is m.bottomLeftCorner<2,2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner_int_int.cpp	/^cout << "Here is m.bottomLeftCorner<2,Dynamic>(2,2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner.cpp	/^cout << "Here is m.bottomRightCorner<2,2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner_int_int.cpp	/^cout << "Here is m.bottomRightCorner<2,Dynamic>(2,2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_bottomRightCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner.cpp	/^cout << "Here is m.topLeftCorner<2,2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner_int_int.cpp	/^cout << "Here is m.topLeftCorner<2,Dynamic>(2,2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topLeftCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner.cpp	/^cout << "Here is m.topRightCorner<2,2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner_int_int.cpp	/^cout << "Here is m.topRightCorner<2,Dynamic>(2,2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_int_topRightCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_leftCols.cpp	/^cout << "Here is a.leftCols<2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_leftCols.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_leftCols.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_rightCols.cpp	/^cout << "Here is a.rightCols<2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_rightCols.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_rightCols.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_segment.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_segment.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_start.cpp	/^cout << "Here is the vector v:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_start.cpp	/^cout << "Now the vector v is:" << endl << v << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_topRows.cpp	/^cout << "Here is a.topRows<2>():" << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_topRows.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_template_int_topRows.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_topLeftCorner_int_int.cpp	/^cout << "Here is m.topLeftCorner(2, 2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_topLeftCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_topLeftCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRightCorner_int_int.cpp	/^cout << "Here is m.topRightCorner(2, 2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRightCorner_int_int.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRightCorner_int_int.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRows_int.cpp	/^cout << "Here is a.topRows(2):" << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRows_int.cpp	/^cout << "Here is the array a:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_topRows_int.cpp	/^cout << "Now the array a is:" << endl << a << endl;$/;"	v
endl	doc/snippets/MatrixBase_transpose.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_transpose.cpp	/^cout << "Let us overwrite this coefficient with the value 0." << endl;$/;"	v
endl	doc/snippets/MatrixBase_transpose.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/MatrixBase_triangularView.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/Matrix_Map_stride.cpp	/^std::cout << Matrix2i::Map(&A(1,1),Stride<8,2>()) << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Matrix_resize_int_int.cpp	/^cout << "here's the 2x3 matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/Matrix_resize_int_int.cpp	/^cout << "here's the 3x2 matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/Matrix_resize_int_int.cpp	/^cout << "let's resize m to 3x2. This is a conservative resizing because 2*3==3*2." << endl;$/;"	v
endl	doc/snippets/Matrix_resize_int_int.cpp	/^cout << "now let's resize m to size 2x2. This is NOT a conservative resizing, so it becomes uninitialized:" << endl;$/;"	v
endl	doc/snippets/Matrix_resize_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/Matrix_setConstant_int.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Matrix_setConstant_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/Matrix_setIdentity_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/Matrix_setOnes_int.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Matrix_setOnes_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/Matrix_setRandom_int.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Matrix_setRandom_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/Matrix_setZero_int.cpp	/^cout << v << endl;$/;"	v
endl	doc/snippets/Matrix_setZero_int_int.cpp	/^cout << m << endl;$/;"	v
endl	doc/snippets/PartialPivLU_solve.cpp	/^cout << "Here is the (unique) solution X to the equation AX=B:" << endl << X << endl;$/;"	v
endl	doc/snippets/PartialPivLU_solve.cpp	/^cout << "Here is the invertible matrix A:" << endl << A << endl;$/;"	v
endl	doc/snippets/PartialPivLU_solve.cpp	/^cout << "Here is the matrix B:" << endl << B << endl;$/;"	v
endl	doc/snippets/PartialRedux_count.cpp	/^cout << "Here is the count of elements larger or equal than 0.5 of each row:" << endl;$/;"	v
endl	doc/snippets/PartialRedux_count.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_count.cpp	/^cout << res << endl;$/;"	v
endl	doc/snippets/PartialRedux_maxCoeff.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_minCoeff.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_norm.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_prod.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_squaredNorm.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/PartialRedux_sum.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/RealSchur_RealSchur_MatrixType.cpp	/^cout << "Here is a random 6x6 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/RealSchur_RealSchur_MatrixType.cpp	/^cout << "The quasi-triangular matrix T is:" << endl << schur.matrixT() << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^cout << "... and A * v = " << endl << A * v << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^cout << "Consider the first eigenvalue, lambda = " << lambda << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^cout << "Here is a random symmetric 5x5 matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^cout << "If v is the corresponding eigenvector, then lambda * v = " << endl << lambda * v << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^cout << "The matrix of eigenvectors, V, is:" << endl << es.eigenvectors() << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "... and lambda * B * v = " << endl << lambda * B * v << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "Consider the first eigenvalue, lambda = " << lambda << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "Here is a random symmetric matrix, A:" << endl << A << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "If v is the corresponding eigenvector, then A * v = " << endl << A * v << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "The matrix of eigenvectors, V, is:" << endl << es.eigenvectors() << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^cout << "and a random postive-definite matrix, B:" << endl << B << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp	/^cout << "Here is a random positive-definite matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp	/^cout << "The inverse square root of A is: " << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorInverseSqrt.cpp	/^cout << "We can also compute it with operatorSqrt() and inverse(). That yields: " << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^cout << "Here is a random positive-definite matrix, A:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^cout << "If we square this, we get: " << endl << sqrtA*sqrtA << endl;$/;"	v
endl	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^cout << "The square root of A is: " << endl << sqrtA << endl;$/;"	v
endl	doc/snippets/SelfAdjointView_eigenvalues.cpp	/^cout << "The eigenvalues of the 3x3 matrix of ones are:" << endl << eivals << endl;$/;"	v
endl	doc/snippets/TopicAliasing_block.cpp	/^cout << "After the assignment, mat = \\n" << mat << endl;$/;"	v
endl	doc/snippets/TopicAliasing_block.cpp	/^cout << "Here is the matrix mat:\\n" << mat << endl;$/;"	v
endl	doc/snippets/TopicAliasing_block_correct.cpp	/^cout << "After the assignment, mat = \\n" << mat << endl;$/;"	v
endl	doc/snippets/TopicAliasing_block_correct.cpp	/^cout << "Here is the matrix mat:\\n" << mat << endl;$/;"	v
endl	doc/snippets/TopicAliasing_cwise.cpp	/^cout << "After 'mat = 2 * mat', mat = \\n" << mat << endl << endl;$/;"	v
endl	doc/snippets/TopicAliasing_cwise.cpp	/^cout << "After squaring, it becomes\\n" << arr << endl << endl;$/;"	v
endl	doc/snippets/TopicAliasing_cwise.cpp	/^cout << "After the subtraction, it becomes\\n" << mat << endl << endl;$/;"	v
endl	doc/snippets/TopicAliasing_cwise.cpp	/^cout << "Doing everything at once yields\\n" << mat << endl << endl;$/;"	v
endl	doc/snippets/TopicAliasing_cwise.cpp	/^cout << "Here is the matrix mat:\\n" << mat << endl << endl;$/;"	v
endl	doc/snippets/TopicAliasing_mult2.cpp	/^cout << matB << endl << endl;$/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << "In memory (column-major):" << endl;$/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << "In memory (row-major):" << endl;$/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << "The matrix A:" << endl;$/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << Acolmajor << endl << endl; $/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << endl << endl;$/;"	v
endl	doc/snippets/TopicStorageOrders_example.cpp	/^cout << endl;$/;"	v
endl	doc/snippets/Triangular_solve.cpp	/^cout << "Here is the matrix m:\\n" << m << endl;$/;"	v
endl	doc/snippets/Triangular_solve.cpp	/^cout << "Here is the matrix n:\\n" << n << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^cout << "Here is a random symmetric 5x5 matrix:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^cout << "The orthogonal matrix Q is:" << endl << Q << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_Tridiagonalization_MatrixType.cpp	/^cout << "The tridiagonal matrix T is:" << endl << T << endl << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_compute.cpp	/^cout << "The matrix T in the tridiagonal decomposition of 2A is: " << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_compute.cpp	/^cout << "The matrix T in the tridiagonal decomposition of A is: " << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^cout << "Here is a random symmetric 5x5 matrix:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^cout << "The diagonal of the tridiagonal matrix T is:" << endl << diag << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^cout << "The orthogonal matrix Q is:" << endl << A << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_decomposeInPlace.cpp	/^cout << "The subdiagonal of the tridiagonal matrix T is:" << endl << subdiag << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_diagonal.cpp	/^cout << "Here is a random self-adjoint 4x4 matrix:" << endl << A << endl << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_diagonal.cpp	/^cout << "The diagonal is:" << endl << diag << endl; $/;"	v
endl	doc/snippets/Tridiagonalization_diagonal.cpp	/^cout << "The subdiagonal is:" << endl << subdiag << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_diagonal.cpp	/^cout << "The tridiagonal matrix T is:" << endl << T << endl << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_diagonal.cpp	/^cout << "We can also extract the diagonals of T directly ..." << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_householderCoefficients.cpp	/^cout << "Here is a random symmetric 4x4 matrix:" << endl << A << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_householderCoefficients.cpp	/^cout << "The vector of Householder coefficients is:" << endl << hc << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_packedMatrix.cpp	/^cout << "Here is a random symmetric 4x4 matrix:" << endl << A << endl;$/;"	v
endl	doc/snippets/Tridiagonalization_packedMatrix.cpp	/^cout << "The packed matrix M is:" << endl << pm << endl;$/;"	v
endl	doc/snippets/Tutorial_AdvancedInitialization_Block.cpp	/^std::cout << matB << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_CommaTemporary.cpp	/^std::cout << mat << std::endl << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_CommaTemporary.cpp	/^std::cout << mat << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_Join.cpp	/^std::cout << "joined = " << joined << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_Join.cpp	/^std::cout << "vec1 = " << vec1 << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_Join.cpp	/^std::cout << "vec2 = " << vec2 << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_LinSpaced.cpp	/^std::cout << table << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_ThreeWays.cpp	/^std::cout << mat1 << std::endl << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_ThreeWays.cpp	/^std::cout << mat2 << std::endl << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_AdvancedInitialization_ThreeWays.cpp	/^std::cout << mat3 << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/Tutorial_Map_using.cpp	/^cout << "Updated m2: " << m2 << endl;$/;"	v
endl	doc/snippets/Tutorial_Map_using.cpp	/^cout << "m1: " << m1 << endl;$/;"	v
endl	doc/snippets/Tutorial_Map_using.cpp	/^cout << "m2: " << m2 << endl;$/;"	v
endl	doc/snippets/Tutorial_ReshapeMat2Mat.cpp	/^cout << "M2:" << endl << M2 << endl;/;"	v
endl	doc/snippets/Tutorial_ReshapeMat2Vec.cpp	/^cout << "v1:" << endl << v1 << endl;$/;"	v
endl	doc/snippets/Tutorial_ReshapeMat2Vec.cpp	/^cout << "v2:" << endl << v2 << endl;/;"	v
endl	doc/snippets/Tutorial_SlicingVec.cpp	/^cout << "Even:" << v2 << endl;/;"	v
endl	doc/snippets/Tutorial_SlicingVec.cpp	/^cout << "Input:" << endl << v << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_matrix_inverse.cpp	/^cout << "The solution is:" << endl << x << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_multiple_rhs.cpp	/^cout << "The solution with right-hand side (1,1,1) is:" << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_multiple_rhs.cpp	/^cout << "The solution with right-hand side (3,3,4) is:" << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_reuse_decomposition.cpp	/^cout << "The solution with right-hand side (1,1,1) is:" << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_reuse_decomposition.cpp	/^cout << "The solution with right-hand side (3,3,4) is:" << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_reuse_decomposition.cpp	/^cout << x << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_singular.cpp	/^cout << "Here is the matrix A:" << endl << A << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_singular.cpp	/^cout << "Here is the vector b:" << endl << b << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_singular.cpp	/^cout << "The solution is:" << endl << x << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_triangular.cpp	/^cout << "Here is the matrix A:" << endl << A << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_triangular.cpp	/^cout << "Here is the vector b:" << endl << b << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_triangular.cpp	/^cout << "The solution is:" << endl << x << endl;$/;"	v
endl	doc/snippets/Tutorial_solve_triangular_inplace.cpp	/^cout << "The solution is:" << endl << b << endl;$/;"	v
endl	doc/snippets/VectorwiseOp_homogeneous.cpp	/^cout << "M.colwise().homogeneous():" << endl << M.colwise().homogeneous() << endl << endl;$/;"	v
endl	doc/snippets/VectorwiseOp_homogeneous.cpp	/^cout << "P * M.colwise().homogeneous().hnormalized(): " << endl << (P * M.colwise().homogeneous()).colwise().hnormalized() << endl << endl;/;"	v
endl	doc/snippets/VectorwiseOp_homogeneous.cpp	/^cout << "P * M.colwise().homogeneous():" << endl << P * M.colwise().homogeneous() << endl << endl;$/;"	v
endl	doc/snippets/VectorwiseOp_homogeneous.cpp	/^cout << "The matrix M is:" << endl << M << endl << endl;$/;"	v
endl	doc/snippets/Vectorwise_reverse.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/Vectorwise_reverse.cpp	/^cout << "Let us overwrite this coefficient with the value 4." << endl;$/;"	v
endl	doc/snippets/Vectorwise_reverse.cpp	/^cout << "Now the matrix m is:" << endl << m << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << "Here is the L part:" << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << "Here is the U part:" << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << "Here is the matrix m:" << endl << m << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << "Let us now reconstruct the original matrix m:" << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << l << endl;$/;"	v
endl	doc/snippets/class_FullPivLU.cpp	/^cout << u << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^       << ") is at position " << i << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  cout << "Here is the matrix m:\\n" << m << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  cout << "Here is the vector v: " << v << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_transpose_aliasing.cpp	/^cout << "Here is the matrix a:\\n" << a << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_transpose_aliasing.cpp	/^cout << "and the result of the aliasing effect:\\n" << a << endl;/;"	v
endl	doc/snippets/tut_arithmetic_transpose_conjugate.cpp	/^cout << "Here is the matrix a\\n" << a << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_transpose_inplace.cpp	/^cout << "Here is the initial matrix a:\\n" << a << endl;$/;"	v
endl	doc/snippets/tut_arithmetic_transpose_inplace.cpp	/^cout << "and after being transposed:\\n" << a << endl;/;"	v
endl	doc/snippets/tut_matrix_assignment_resizing.cpp	/^std::cout << "a is now of size " << a.rows() << "x" << a.cols() << std::endl;$/;"	m	class:std	file:
endl	doc/snippets/tut_matrix_assignment_resizing.cpp	/^std::cout << "a is of size " << a.rows() << "x" << a.cols() << std::endl;$/;"	m	class:std	file:
endsWith	bench/btl/generic_bench/btl.hh	/^    bool endsWith(const BtlString& str) const$/;"	f	class:BtlString
enqueue	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE Notification* enqueue(Function&& f, Args&&... args) const {$/;"	f	struct:Eigen::ThreadPoolDevice
enqueueNoNotification	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void enqueueNoNotification(Function&& f, Args&&... args) const {$/;"	f	struct:Eigen::ThreadPoolDevice
enqueue_packing	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void enqueue_packing(Index k, bool rhs) {$/;"	f	class:Eigen::TensorEvaluator::Context
enqueue_packing_helper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void enqueue_packing_helper(Index start, Index end, Index k, bool rhs) {$/;"	f	class:Eigen::TensorEvaluator::Context
enqueue_with_barrier	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void enqueue_with_barrier(Barrier* b,$/;"	f	struct:Eigen::ThreadPoolDevice
entries	bench/analyze-blocking-sizes.cpp	/^  vector<inputfile_entry_t> entries;$/;"	m	struct:inputfile_t	file:
entries	bench/analyze-blocking-sizes.cpp	/^  vector<preprocessed_inputfile_entry_t> entries;$/;"	m	struct:preprocessed_inputfile_t	file:
enumerate_group_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct enumerate_group_elements$/;"	s	namespace:Eigen::internal::group_theory
enumerate_group_elements_noid	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct enumerate_group_elements_noid$/;"	s	namespace:Eigen::internal::group_theory
enumerate_group_elements_noid	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct enumerate_group_elements_noid<Multiply, Equality, id, type_list<>, initial_global_flags>$/;"	s	namespace:Eigen::internal::group_theory
env_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  Environment env_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
env_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  Environment env_;$/;"	m	class:Eigen::SimpleThreadPoolTempl
epoch	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^    uint64_t epoch;$/;"	m	class:Eigen::EventCount::Waiter
epsfcn	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar epsfcn;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
epsfcn	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar epsfcn;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
epsfcn	unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Scalar epsfcn;$/;"	m	class:Eigen::NumericalDiff
epsilon	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half epsilon() {$/;"	f	struct:Eigen::NumTraits
epsilon	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half epsilon() { return Eigen::half_impl::raw_uint16_to_half(0x0800); }$/;"	f	struct:std::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static T epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static double epsilon() { return __DBL_EPSILON__; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static float epsilon() { return __FLT_EPSILON__; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static int epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static long long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static unsigned int epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static unsigned long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/Core/util/Meta.h	/^  static unsigned long long epsilon() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
epsilon	Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
epsilon	Eigen/src/SparseCore/SparseView.h	/^  RealScalar epsilon() const { return m_epsilon; }$/;"	f	class:Eigen::SparseView
epsilon	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static inline Real epsilon() { return 0; }$/;"	f	struct:Eigen::NumTraits
epsilon	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar epsilon() const {return m_epsfcn; }$/;"	f	class:Eigen::LevenbergMarquardt
epsilon	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal epsilon(const mpfr::mpreal& x) {  return mpfr::machine_epsilon(x);  }$/;"	f	class:std::numeric_limits
epsilon	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal epsilon(mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::machine_epsilon(precision); }$/;"	f	class:std::numeric_limits
equal_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct equal_op         { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a == b)  { return a == b;  } };$/;"	s	namespace:Eigen::internal
equal_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct equal_op {$/;"	s	namespace:Eigen::internal
equal_strict	Eigen/src/Core/util/Meta.h	/^bool equal_strict(const X& x,const Y& y) { return x == y; }$/;"	f	namespace:numext
equal_strict	Eigen/src/Core/util/Meta.h	/^bool equal_strict(const double& x,const double& y) { return std::equal_to<double>()(x,y); }$/;"	f	namespace:numext
equal_strict	Eigen/src/Core/util/Meta.h	/^bool equal_strict(const float& x,const float& y) { return std::equal_to<float>()(x,y); }$/;"	f	namespace:numext
equalsIdentity	test/nullary.cpp	/^bool equalsIdentity(const MatrixType& A)$/;"	f
erf	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^erf() const$/;"	f
erf	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    erf() const {$/;"	f	class:Eigen::TensorBase
erf	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half erf(const Eigen::half& a) {$/;"	f	namespace:Eigen::numext
erf	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    erf(const Scalar& x) {$/;"	f	namespace:Eigen::numext
erf	unsupported/test/mpreal/mpreal.h	/^inline const mpreal erf     (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(erf    );    }$/;"	f	namespace:mpfr
erf_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erf_impl {$/;"	s	namespace:Eigen::internal
erf_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erf_impl<double> {$/;"	s	namespace:Eigen::internal
erf_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erf_impl<float> {$/;"	s	namespace:Eigen::internal
erf_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erf_retval {$/;"	s	namespace:Eigen::internal
erfc	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^erfc() const$/;"	f
erfc	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    erfc() const {$/;"	f	class:Eigen::TensorBase
erfc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half erfc(const Eigen::half& a) {$/;"	f	namespace:Eigen::numext
erfc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    erfc(const Scalar& x) {$/;"	f	namespace:Eigen::numext
erfc	unsupported/test/mpreal/mpreal.h	/^inline const mpreal erfc    (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(erfc   );    }$/;"	f	namespace:mpfr
erfc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erfc_impl {$/;"	s	namespace:Eigen::internal
erfc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erfc_impl<double> {$/;"	s	namespace:Eigen::internal
erfc_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erfc_impl<float> {$/;"	s	namespace:Eigen::internal
erfc_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct erfc_retval {$/;"	s	namespace:Eigen::internal
error	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase
es	doc/snippets/EigenSolver_compute.cpp	/^EigenSolver<MatrixXf> es;$/;"	v
es	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver.cpp	/^SelfAdjointEigenSolver<Matrix4f> es;$/;"	v
escape	bench/BenchTimer.h	/^static void escape(void *p) {$/;"	f
essentialVector	Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence
essentialVector	Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etor_product_packet_impl	Eigen/src/Core/ProductEvaluators.h	/^struct etor_product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
etree_find	Eigen/src/SparseCore/SparseColEtree.h	/^Index etree_find (Index i, IndexVector& pp)$/;"	f	namespace:Eigen::internal
eulerAngles	Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase
eulerangles	test/geo_eulerangles.cpp	/^template<typename Scalar> void eulerangles()$/;"	f
eulerangles	unsupported/test/EulerAngles.cpp	/^template<typename Scalar> void eulerangles()$/;"	f
eval	Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase
eval	Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return derived(); }$/;"	f	class:Eigen::InverseImpl
eval	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase
eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal
eval	test/sparse_permutations.cpp	/^typename internal::nested_eval<T,1>::type eval(const T &xpr)$/;"	f
eval	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct eval<TensorIndexTupleOp<XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct eval<TensorTupleReducerOp<ReduceOp, Dims, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^struct eval<TensorAssignOp<LhsXprType, RhsXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    const TensorForcedEvalOp<const Derived> eval() const {$/;"	f	class:Eigen::TensorBase
eval	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct eval<TensorBroadcastingOp<Broadcast, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct eval<TensorChippingOp<DimId, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^struct eval<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct eval<TensorContractionOp<Dimensions, LhsXprType, RhsXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct eval<TensorConversionOp<TargetType, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct eval<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct eval<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct eval<TensorCustomUnaryOp<CustomUnaryFunc, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^struct eval<TensorEvalToOp<XprType, MakePointer_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct eval<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct eval<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct eval<TensorCwiseUnaryOp<UnaryOp, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct eval<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^struct eval<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>, Eigen::Dense> {$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^struct eval<TensorForcedEvalOp<XprType, MakePointer_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^struct eval<TensorGeneratorOp<Generator, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^struct eval<TensorImagePatchOp<Rows, Cols, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^struct eval<TensorInflationOp<Strides, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^struct eval<TensorLayoutSwapOp<XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct eval<TensorReshapingOp<NewDimensions, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct eval<TensorSlicingOp<StartIndices, Sizes, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct eval<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^struct eval<TensorPaddingOp<PaddingDimensions, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^struct eval<TensorPatchOp<PatchDim, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct eval<TensorReductionOp<Op, Dims, XprType, MakePointer_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^struct eval<TensorReverseOp<ReverseDimensions, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct eval<TensorScanOp<Op, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^struct eval<TensorShufflingOp<Shuffle, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^struct eval<TensorStridingOp<Strides, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<Tensor<_Scalar, NumIndices_, Options, IndexType_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<TensorMap<PlainObjectType, Options, MakePointer>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<TensorRef<PlainObjectType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<const Tensor<_Scalar, NumIndices_, Options, IndexType_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<const TensorMap<PlainObjectType, Options, MakePointer>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct eval<const TensorRef<PlainObjectType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^struct eval<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, Eigen::Dense>$/;"	s	namespace:Eigen::internal
eval	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    EIGEN_STRONG_INLINE const typename internal::eval<Derived, IsSkyline>::type eval() const {$/;"	f	class:Eigen::SkylineMatrixBase
eval	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^template<typename T> class eval<T,IsSkyline>$/;"	c	namespace:Eigen::internal
eval	unsupported/test/cxx11_tensor_custom_op.cpp	/^  void eval(const Tensor<float, 2>& input, Output& output, const Device& device) const$/;"	f	struct:InsertZeros
eval	unsupported/test/cxx11_tensor_custom_op.cpp	/^  void eval(const Tensor<float, 3>& input1, const Tensor<float, 3>& input2,$/;"	f	struct:BatchMatMul
evalGemm	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC void evalGemm(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
evalGemm	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  void evalGemm(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorEvaluator
evalGemv	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC void evalGemv(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
evalPacket	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalPacket(Index i) {$/;"	f	struct:Eigen::TensorEvaluator
evalPacket	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalPacket(Index i) {$/;"	f	struct:Eigen::TensorEvaluator
evalProduct	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC void evalProduct(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorEvaluator
evalProduct	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  void evalProduct(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorEvaluator
evalScalar	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalScalar(Index i) {$/;"	f	struct:Eigen::TensorEvaluator
evalScalar	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalScalar(Index i) {$/;"	f	struct:Eigen::TensorEvaluator
evalSolver	unsupported/test/polynomialsolver.cpp	/^void evalSolver( const POLYNOMIAL& pols )$/;"	f
evalSolverSugarFunction	unsupported/test/polynomialsolver.cpp	/^void evalSolverSugarFunction( const POLYNOMIAL& pols, const ROOTS& roots, const REAL_ROOTS& real_roots )$/;"	f
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/)$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* data) {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* data)$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(DevicePointer scalar) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType* dest) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType*) { return true; }$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(OutputScalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(CoeffReturnType*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool evalSubExprsIfNeeded(typename MakePointer_<CoeffReturnType>::Type data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar*) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalSubExprsIfNeeded	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool evalSubExprsIfNeeded(Scalar* \/*data*\/) {$/;"	f	struct:Eigen::TensorEvaluator
evalTo	Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper
evalTo	Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase
evalTo	Eigen/src/Core/DenseBase.h	/^    inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase
evalTo	Eigen/src/Core/EigenBase.h	/^  inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
evalTo	Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::InverseImpl
evalTo	Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ProductEvaluators.h	/^  static void evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue
evalTo	Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval
evalTo	Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
evalTo	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
evalTo	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const Homogeneous<LhsArg,Horizontal>& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const Lhs& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void evalTo(Dest& dst, const TransformType& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Homogeneous<RhsArg,Vertical>& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
evalTo	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval
evalTo	Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval
evalTo	Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  void evalTo(ResType& res) const$/;"	f	struct:Eigen::SPQR_QProduct
evalTo	Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, DenseShape)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/SparseCore/SparseProduct.h	/^  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, SparseShape)$/;"	f	struct:Eigen::internal::generic_product_impl
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  void evalTo(DesType& res) const$/;"	f	struct:Eigen::SparseQR_QProduct
evalTo	Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base
evalTo	Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base
evalTo	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC void evalTo(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
evalTo	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  void evalTo(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorEvaluator
evalTo	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  void evalTo(typename XprType::Scalar* buffer) {$/;"	f	struct:Eigen::TensorEvaluator
evalTo	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC void evalTo(Scalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalTo	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void KroneckerProduct<Lhs,Rhs>::evalTo(Dest& dst) const$/;"	f	class:Eigen::KroneckerProduct
evalTo	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void KroneckerProductSparse<Lhs,Rhs>::evalTo(Dest& dst) const$/;"	f	class:Eigen::KroneckerProductSparse
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::MatrixExponentialReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixFunctionReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixLogarithmReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixComplexPowerReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixPowerParenthesesReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixPowerReturnValue
evalTo	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixSquareRootReturnValue
evalTo	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    void evalTo(MatrixBase<DenseDerived>& dst) const {$/;"	f	class:Eigen::SkylineMatrixBase
evalToBuf	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalToBuf(OutputScalar* data) {$/;"	f	struct:Eigen::TensorEvaluator
evalToLazy	Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
evalTyped	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  void evalTyped(Scalar* buffer) const {$/;"	f	struct:Eigen::TensorEvaluator
eval_closed_spline2d	unsupported/test/splines.cpp	/^void eval_closed_spline2d()$/;"	f
eval_mflops	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  inline double eval_mflops(int size)$/;"	f	class:STL_Perf_Analyzer
eval_mflops	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  inline double eval_mflops(int size)$/;"	f	class:Mixed_Perf_Analyzer
eval_mflops	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  BTL_DONT_INLINE double eval_mflops(int size)$/;"	f	class:Portable_Perf_Analyzer
eval_mflops	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  inline double eval_mflops(int size)$/;"	f	class:Portable_Perf_Analyzer
eval_mflops	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  inline double eval_mflops(int size)$/;"	f	class:X86_Perf_Analyzer
eval_spline3d	unsupported/test/splines.cpp	/^void eval_spline3d()$/;"	f
eval_spline3d_onbrks	unsupported/test/splines.cpp	/^void eval_spline3d_onbrks()$/;"	f
evaluateProductBlockingSizesHeuristic	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void evaluateProductBlockingSizesHeuristic(Index& k, Index& m, Index& n, Index num_threads = 1)$/;"	f	namespace:Eigen::internal
evaluate_defaults_action_t	bench/analyze-blocking-sizes.cpp	/^struct evaluate_defaults_action_t : action_t$/;"	s	file:
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator()$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC evaluator(const ArgType& arg)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType& m)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const T& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& block) : block_evaluator_type(block)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& diagonal)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& map)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& n)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& ref)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& select)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^  explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator : public unary_evaluator<T>$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Diagonal<ArgType, DiagIndex> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<EvalToTemp<ArgType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<PlainObjectBase<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Ref<PlainObjectType, RefOptions, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator<const T>$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> > $/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator<Product<Lhs, Rhs, Options> > $/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/ReturnByValue.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/ReturnByValue.h	/^struct evaluator<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC explicit evaluator(const SolveType& solve)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/Core/Solve.h	/^struct evaluator<Solve<Decomposition,RhsType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  evaluator(const SolveType& solve)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct evaluator<SolveWithGuess<Decomposition,RhsType, GuessType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct evaluator<MappedSparseMatrix<_Scalar,_Options,_StorageIndex> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseCompressedBase.h	/^  evaluator() : m_matrix(0), m_zero(0)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseCompressedBase.h	/^  explicit evaluator(const Derived &mat) : m_matrix(&mat), m_zero(0)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseCompressedBase.h	/^struct evaluator<SparseCompressedBase<Derived> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseMap.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseMap.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseMap.h	/^struct evaluator<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseMap.h	/^struct evaluator<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseMatrix.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseMatrix.h	/^  explicit evaluator(const SparseMatrixType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseMatrix.h	/^struct evaluator<SparseMatrix<_Scalar,_Options,_StorageIndex> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseRef.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseRef.h	/^  explicit evaluator(const XprType &mat) : Base(mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseRef.h	/^struct evaluator<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
evaluator	Eigen/src/SparseCore/SparseVector.h	/^  evaluator() : Base() {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseVector.h	/^  explicit evaluator(const SparseVectorType &mat) : m_matrix(&mat)$/;"	f	struct:Eigen::internal::evaluator
evaluator	Eigen/src/SparseCore/SparseVector.h	/^struct evaluator<SparseVector<_Scalar,_Options,_Index> >$/;"	s	namespace:Eigen::internal
evaluator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  evaluator() : m_matrix(0) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  evaluator(const SparseMatrixType &mat) : m_matrix(&mat) {}$/;"	f	struct:Eigen::internal::evaluator
evaluator	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^struct evaluator<DynamicSparseMatrix<_Scalar,_Options,_StorageIndex> >$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_assume_aliasing {$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_difference_op<typename OtherXpr::Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, const OtherXpr,$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_sum_op<typename OtherXpr::Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, const OtherXpr,$/;"	s	namespace:Eigen::internal
evaluator_assume_aliasing	Eigen/src/Core/ProductEvaluators.h	/^struct evaluator_assume_aliasing<Product<Lhs, Rhs, DefaultProduct> > {$/;"	s	namespace:Eigen::internal
evaluator_base	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_base : public noncopyable$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Core/BandMatrix.h	/^struct evaluator_traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Core/BandMatrix.h	/^struct evaluator_traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_traits : public evaluator_traits_base<T>$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Core/SelfAdjointView.h	/^struct evaluator_traits<SelfAdjointView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Core/TriangularMatrix.h	/^struct evaluator_traits<TriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Geometry/Homogeneous.h	/^struct evaluator_traits<Homogeneous<ArgType,Direction> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/Householder/HouseholderSequence.h	/^struct evaluator_traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct evaluator_traits<SparseSelfAdjointView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
evaluator_traits	Eigen/src/SparseQR/SparseQR.h	/^struct evaluator_traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
evaluator_traits_base	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_traits_base$/;"	s	namespace:Eigen::internal
evaluator_wrapper_base	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit evaluator_wrapper_base(const ArgType& arg) : m_argImpl(arg) {}$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
evaluator_wrapper_base	Eigen/src/Core/CoreEvaluators.h	/^struct evaluator_wrapper_base$/;"	s	namespace:Eigen::internal
exclusions	scripts/relicense.py	/^exclusions = set(['relicense.py'])$/;"	v
exclusive	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool exclusive() const {$/;"	f	struct:Eigen::TensorEvaluator
exclusive	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  bool exclusive() const { return m_exclusive; }$/;"	f	class:Eigen::TensorScanOp
executeEval	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  void executeEval(Scalar* data) const {$/;"	f	struct:Eigen::TensorEvaluator
exiting_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  bool exiting_ = false;$/;"	m	class:Eigen::SimpleThreadPoolTempl
exp	Eigen/src/Core/MathFunctions.h	/^T exp(const T &x) {$/;"	f	namespace:Eigen::numext
exp	Eigen/src/Core/MathFunctions.h	/^double exp(const double &x) { return ::exp(x); }$/;"	f	namespace:Eigen::numext
exp	Eigen/src/Core/MathFunctions.h	/^float exp(const float &x) { return ::expf(x); }$/;"	f	namespace:Eigen::numext
exp	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half exp(const half& a) {$/;"	f	namespace:Eigen::half_impl
exp	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f
exp	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    exp() const {$/;"	f	class:Eigen::TensorBase
exp	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^const MatrixExponentialReturnValue<Derived> MatrixBase<Derived>::exp() const$/;"	f	class:Eigen::MatrixBase
exp	unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(exp  );    }$/;"	f	namespace:mpfr
exp10	unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp10 (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(exp10);    }$/;"	f	namespace:mpfr
exp2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp2  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(exp2 );    }$/;"	f	namespace:mpfr
expand	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index  SparseLUImpl<Scalar,StorageIndex>::expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions) $/;"	f	class:Eigen::internal::SparseLUImpl
expfn	unsupported/doc/examples/MatrixFunction.cpp	/^std::complex<double> expfn(std::complex<double> x, int)$/;"	f
expfn	unsupported/test/matrix_exponential.cpp	/^T expfn(T x, int)$/;"	f
exph	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half exph(const Eigen::half& a) {$/;"	f
expm1	unsupported/test/mpreal/mpreal.h	/^inline const mpreal expm1   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(expm1  );    }$/;"	f	namespace:mpfr
expr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^  PtrType expr;$/;"	m	struct:Eigen::TensorSycl::internal::EvalToLHSConstructor
expression	Eigen/src/Core/NoAlias.h	/^    ExpressionType& expression() const$/;"	f	class:Eigen::NoAlias
expression	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorIndexTupleOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorTupleReducerOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorBroadcastingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorChippingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorConversionOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  expression() const { return m_expr; }$/;"	f	class:Eigen::TensorCustomUnaryOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorEvalToOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  ArgType expression() const { return m_expression; }$/;"	f	struct:Eigen::TensorEvaluator
expression	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const typename internal::remove_all<typename XprType::Nested>::type& expression() const {$/;"	f	class:Eigen::TensorFFTOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorForcedEvalOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorGeneratorOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorImagePatchOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorInflationOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorLayoutSwapOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorReshapingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorSlicingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorStridingSlicingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorPaddingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorPatchOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    const XprType& expression() const { return m_expr; }$/;"	f	class:Eigen::TensorReductionOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorReverseOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const XprType& expression() const { return m_expr; }$/;"	f	class:Eigen::TensorScanOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorShufflingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorStridingOp
expression	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    expression() const { return m_xpr; }$/;"	f	class:Eigen::TensorVolumePatchOp
extend	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& extend(const MatrixBase<Derived>& p)$/;"	f	class:Eigen::AlignedBox
extendedTo	Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
extendedToOpposite	Eigen/src/Core/VectorwiseOp.h	/^    extendedToOpposite(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
exteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.lhs()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.rhs()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return ExtractType(Base::extract(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extractData	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase
extractData	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits
extract_coordinates	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  void extract_coordinates(Index index, array<Index, NumDims>& coords) const {$/;"	f	struct:Eigen::TensorEvaluator
extract_data	Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal
extract_data_selector	Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
extract_image_patches	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    extract_image_patches(const Index patch_rows = 1, const Index patch_cols = 1,$/;"	f	class:Eigen::TensorBase
extract_image_patches	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    extract_image_patches(const Index patch_rows, const Index patch_cols,$/;"	f	class:Eigen::TensorBase
extract_kernel	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
extract_patches	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    extract_patches(const PatchDims& patch_dims) const {$/;"	f	class:Eigen::TensorBase
extract_volume_patches	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    extract_volume_patches(const Index patch_planes, const Index patch_rows, const Index patch_cols,$/;"	f	class:Eigen::TensorBase
f	Eigen/src/Core/arch/CUDA/Half.h	/^  float f;$/;"	m	union:Eigen::half_impl::float32_bits
f	test/unalignedassert.cpp	/^  float f; \/\/ make the struct have sizeof%16!=0 to make it a little more tricky when we allow an array of 2 such objects$/;"	m	struct:TestNew4	file:
f	test/unalignedassert.cpp	/^  float f; \/\/ try the f at first -- the EIGEN_ALIGN_MAX attribute of m should make that still work$/;"	m	struct:TestNew5	file:
f	test/unalignedassert.cpp	/^  float f;$/;"	m	struct:Depends	file:
f	test/unalignedassert.cpp	/^  float f;$/;"	m	struct:TestNew6	file:
f	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^    std::function<void()> f;$/;"	m	struct:Eigen::StlThreadEnvironment::Task
f	unsupported/test/cxx11_tensor_map.cpp	/^static int f(const TensorMap<Tensor<int, 3> >& tensor) {$/;"	f	file:
fabs	test/boostmultiprec.cpp	/^  Real fabs(const Real& a) { return abs EIGEN_NOT_A_MACRO (a); }$/;"	f	namespace:boost::multiprecision
fabs	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fabs  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(abs  );    }$/;"	f	namespace:mpfr
fabsh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half fabsh(const Eigen::half& a) {$/;"	f
fac_ui	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fac_ui (unsigned long int v, mp_prec_t prec     = mpreal::get_default_prec(),$/;"	f	namespace:mpfr
factor	Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar factor() const {return m_factor; }$/;"	f	class:Eigen::LevenbergMarquardt
factor	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar factor;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
factor	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar factor;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
factorize	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
factorize	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
factorize	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
factorize	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    LeastSquareDiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
factorize	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^void IncompleteCholesky<Scalar,_UpLo, OrderingType>::factorize(const _MatrixType& mat)$/;"	f	class:Eigen::IncompleteCholesky
factorize	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
factorize	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const EigenBase<MatrixDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
factorize	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
factorize	Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::factorize(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
factorize	Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::factorize(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
factorize	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU
factorize	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU
factorize	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
factorize	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  void factorize(int nfft)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
factorize_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize_impl()$/;"	f	class:Eigen::UmfPackLU
factorize_preordered	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
false_type	Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
fcn_chkder	unsupported/test/NonLinearOptimization.cpp	/^int fcn_chkder(const VectorXd &x, VectorXd &fvec, MatrixXd &fjac, int iflag)$/;"	f
fdjac1	unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^DenseIndex fdjac1($/;"	f	namespace:Eigen::internal
ffa	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int ffa = A::flags;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
ffa	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int ffa = A::flags;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_multiply
ffb	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int ffb = B::flags;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
ffb	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int ffb = B::flags;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_multiply
fft	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    fft(const FFT& fft) const {$/;"	f	class:Eigen::TensorBase
fft	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const FFT& fft() const { return m_fft; }$/;"	f	class:Eigen::TensorFFTOp
fft_rmse	unsupported/test/FFTW.cpp	/^    long double fft_rmse( const VT1 & fftbuf,const VT2 & timebuf)$/;"	f
fftw_cast	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  T * fftw_cast(const T* p)$/;"	f	namespace:Eigen::internal
fftw_cast	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftw_complex * fftw_cast( const std::complex<double> * p)$/;"	f	namespace:Eigen::internal
fftw_cast	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftwf_complex * fftw_cast( const std::complex<float> * p)$/;"	f	namespace:Eigen::internal
fftw_cast	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftwl_complex * fftw_cast( const std::complex<long double> * p)$/;"	f	namespace:Eigen::internal
fftw_impl	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_impl$/;"	s	namespace:Eigen::internal
fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftw_plan() :m_plan(NULL) {}$/;"	f	struct:Eigen::internal::fftw_plan
fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan {};$/;"	s	namespace:Eigen::internal
fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<double>$/;"	s	namespace:Eigen::internal
fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<float>$/;"	s	namespace:Eigen::internal
fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<long double>$/;"	s	namespace:Eigen::internal
filename	bench/analyze-blocking-sizes.cpp	/^  string filename;$/;"	m	struct:inputfile_t	file:
filename	bench/analyze-blocking-sizes.cpp	/^  string filename;$/;"	m	struct:preprocessed_inputfile_t	file:
fill	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& val)$/;"	f	class:Eigen::DenseBase
fill	Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularViewImpl
fill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector
fill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fill	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED Scalar& fill(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
fillMatrix	bench/BenchSparseUtil.h	/^void fillMatrix(float density, int rows, int cols,  EigenSparseMatrix& dst)$/;"	f
fillMatrix	bench/sparse_trisolver.cpp	/^void fillMatrix(float density, int rows, int cols,  EigenSparseTriMatrix& dst)$/;"	f
fillMatrix2	bench/BenchSparseUtil.h	/^void fillMatrix2(int nnzPerCol, int rows, int cols,  EigenSparseMatrix& dst)$/;"	f
fillSpdMatrix	bench/sparse_cholesky.cpp	/^void fillSpdMatrix(float density, int rows, int cols,  EigenSparseSelfAdjointMatrix& dst)$/;"	f
fill_history_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  void fill_history_clicks( void ){$/;"	f	class:X86_Timer
fillfactor	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index fillfactor; \/\/ The estimated fills factors for L and U, compared with A$/;"	m	struct:Eigen::internal::perfvalues
fillrand	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector
fillrand	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fillrand	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
final	bench/btl/generic_bench/timers/STL_timer.hh	/^  time_t initial, final;$/;"	m	class:STL_Timer
finalize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix
finalize	Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {$/;"	f	struct:Eigen::internal::MaxReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {$/;"	f	struct:Eigen::internal::MeanReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {$/;"	f	struct:Eigen::internal::MinReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {$/;"	f	struct:Eigen::internal::ProdReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {$/;"	f	struct:Eigen::internal::SumReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T& accum) const {$/;"	f	struct:Eigen::internal::ArgMaxTupleReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T& accum) const {$/;"	f	struct:Eigen::internal::ArgMinTupleReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool finalize(bool accum) const {$/;"	f	struct:Eigen::internal::AndReducer
finalize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool finalize(bool accum) const {$/;"	f	struct:Eigen::internal::OrReducer
finalize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void finalize() {$/;"	f	class:Eigen::SkylineMatrix
finalize	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void finalize() {}$/;"	f	class:Eigen::DynamicSparseMatrix
finalize	unsupported/test/cxx11_tensor_reduction.cpp	/^  float finalize(const float accum) const { return 1.0f \/ (accum + offset_); }$/;"	f	struct:UserReducer
finalizeBenchmark	bench/tensors/tensor_benchmarks.h	/^  inline void finalizeBenchmark(int64_t num_items) {$/;"	f	class:BenchmarkSuite
finalizeBoth	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MaxReducer
finalizeBoth	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MeanReducer
finalizeBoth	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MinReducer
finalizeBoth	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::ProdReducer
finalizeBoth	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::SumReducer
finalizePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MaxReducer
finalizePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MeanReducer
finalizePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::MinReducer
finalizePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::ProdReducer
finalizePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {$/;"	f	struct:Eigen::internal::SumReducer
find	Eigen/src/SparseCore/SparseCompressedBase.h	/^  Index find(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
findElement	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline int findElement(GroupElement e) const$/;"	f	class:Eigen::DynamicSGroup
findGoodComposite	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE static Index findGoodComposite(Index n) {$/;"	f	struct:Eigen::TensorEvaluator
findSmallDiagEntry	Eigen/src/Eigenvalues/RealQZ.h	/^    inline Index RealQZ<MatrixType>::findSmallDiagEntry(Index f, Index l)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	Eigen/src/Eigenvalues/RealQZ.h	/^    inline Index RealQZ<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	Eigen/src/Eigenvalues/RealSchur.h	/^inline Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealSchur
find_frequency	bench/btl/generic_bench/timers/x86_timer.hh	/^  inline void find_frequency( void ){$/;"	f	class:X86_Timer
find_ordering	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType find_ordering \/* return the number of garbage collections *\/$/;"	f	namespace:internal
find_partition_with_efficiency_higher_than	bench/analyze-blocking-sizes.cpp	/^void find_partition_with_efficiency_higher_than($/;"	f
find_pivot	test/eigensolver_complex.cpp	/^template<typename MatrixType> bool find_pivot(typename MatrixType::Scalar tol, MatrixType &diffs, Index col=0)$/;"	f
find_subset_with_efficiency_higher_than	bench/analyze-blocking-sizes.cpp	/^void find_subset_with_efficiency_higher_than($/;"	f
finished	Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() {$/;"	f	struct:Eigen::CommaInitializer
finished	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool finished(const MatrixBase<VectorType> &v)$/;"	f	class:Eigen::IterationController
finished	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool finished(double nr)$/;"	f	class:Eigen::IterationController
first	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  Packet first;$/;"	m	struct:Eigen::internal::DoublePacket
first	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const DenseIndex first = f;$/;"	m	struct:Eigen::type2indexpair
first	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  Idx first;$/;"	m	struct:Eigen::IndexPair
first	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  U first;$/;"	m	struct:Eigen::Tuple
first	unsupported/Eigen/src/BVH/KdBVH.h	/^  VectorType first;$/;"	m	struct:Eigen::internal::vector_int_pair
first	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool first() { return m_nit == 0; }$/;"	f	class:Eigen::IterationController
firstAligned	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC Index firstAligned(Index size) const {$/;"	f	class:Eigen::internal::blas_data_mapper
firstAligned	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Index firstAligned(Index size) const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
firstInput	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index firstInput(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
firstInput	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index firstInput(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
firstLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE size_t firstLevelCacheSize() const {$/;"	f	struct:Eigen::GpuDevice
firstLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t firstLevelCacheSize() const {$/;"	f	struct:Eigen::DefaultDevice
firstLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE size_t firstLevelCacheSize() const {$/;"	f	struct:Eigen::ThreadPoolDevice
firstTwo	doc/examples/class_FixedVectorBlock.cpp	/^firstTwo(MatrixBase<Derived>& v)$/;"	f
firstTwo	doc/examples/class_FixedVectorBlock.cpp	/^firstTwo(const MatrixBase<Derived>& v)$/;"	f
first_aligned	Eigen/src/Core/DenseCoeffsBase.h	/^static inline Index first_aligned(const DenseBase<Derived>& m)$/;"	f	namespace:Eigen::internal
first_aligned	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_aligned_impl	Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned_impl	Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Alignment, Derived, false>$/;"	s	namespace:Eigen::internal
first_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef Arg1 first_argument_type;$/;"	t	struct:Eigen::internal::binary_op_base
first_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::first_argument_type  first_argument_type;$/;"	t	struct:Eigen::internal::bind1st_op
first_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::first_argument_type  first_argument_type;$/;"	t	struct:Eigen::internal::bind2nd_op
first_column	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType first_column ;\/* first column in row (used in garbage collection) *\/$/;"	m	union:internal::Colamd_Row::__anon873
first_default_aligned	Eigen/src/Core/DenseCoeffsBase.h	/^static inline Index first_default_aligned(const DenseBase<Derived>& m)$/;"	f	namespace:Eigen::internal
first_default_aligned	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline Index first_default_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_generator	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename get<0, generators>::type first_generator;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements
first_generator	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename get<0, remaining_generators>::type first_generator;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
first_multiple	Eigen/src/Core/util/Memory.h	/^inline Index first_multiple(Index size, Index base)$/;"	f	namespace:Eigen::internal
first_step	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef dimino_first_step_elements<Multiply, Equality, id, generators> first_step;$/;"	t	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
first_step_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename first_step::type first_step_elements;$/;"	t	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
first_type	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  typedef U first_type;$/;"	t	struct:Eigen::Tuple
first_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct type_list<t, tt...> { constexpr static int count = sizeof...(tt) + 1; typedef t first_type; };$/;"	t	struct:Eigen::internal::type_list
first_value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct numeric_list<T, n, nn...> { constexpr static std::size_t count = sizeof...(nn) + 1; constexpr static T first_value = n; };$/;"	m	struct:Eigen::internal::numeric_list
fits_in_bits	unsupported/test/mpreal/mpreal.h	/^inline bool mpreal::fits_in_bits(double x, int n)$/;"	f	class:mpfr::mpreal
fixedSizeMatrixConstruction	test/basicstuff.cpp	/^void fixedSizeMatrixConstruction()$/;"	f
fixed_size_tensor_index_extraction_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct fixed_size_tensor_index_extraction_helper$/;"	s	namespace:Eigen::internal
fixed_size_tensor_index_extraction_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct fixed_size_tensor_index_extraction_helper<Index, 0>$/;"	s	namespace:Eigen::internal
fixed_size_tensor_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct fixed_size_tensor_index_linearization_helper$/;"	s	namespace:Eigen::internal
fixed_size_tensor_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct fixed_size_tensor_index_linearization_helper<Index, NumIndices, 0, RowMajor>$/;"	s	namespace:Eigen::internal
fixupL	Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,StorageIndex>::fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
fjac	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    JacobianType fjac;$/;"	m	class:Eigen::HybridNonLinearSolver
fjac	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    JacobianType fjac;$/;"	m	class:Eigen::LevenbergMarquardt
flagged	Eigen/src/Core/DenseBase.h	/^    const Derived& flagged() const$/;"	f	class:Eigen::DenseBase
flags	Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat
flags	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      int flags;$/;"	m	struct:Eigen::DynamicSGroup::Generator
flags	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      int flags;$/;"	m	struct:Eigen::DynamicSGroup::GroupElement
flags	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  constexpr static int flags = flags_;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_element
flags	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int flags() const {$/;"	f	class:Eigen::SkylineInplaceLU
flags_cmp_	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int flags_cmp_ = ffa ^ ffb;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
float32_bits	Eigen/src/Core/arch/CUDA/Half.h	/^union float32_bits {$/;"	u	namespace:Eigen::half_impl
float_to_half_rtne	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw float_to_half_rtne(float ff) {$/;"	f	namespace:Eigen::half_impl
floor	Eigen/src/Core/MathFunctions.h	/^T (floor)(const T& x)$/;"	f	namespace:Eigen::numext
floor	Eigen/src/Core/MathFunctions.h	/^double floor(const double &x) { return ::floor(x); }$/;"	f	namespace:Eigen::numext
floor	Eigen/src/Core/MathFunctions.h	/^float floor(const float &x) { return ::floorf(x); }$/;"	f	namespace:Eigen::numext
floor	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half floor(const half& a) {$/;"	f	namespace:Eigen::half_impl
floor	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^floor() const$/;"	f
floor	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    floor() const {$/;"	f	class:Eigen::TensorBase
floor	unsupported/test/mpreal/mpreal.h	/^inline const mpreal floor(const mpreal& v)$/;"	f	namespace:mpfr
floorh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half floorh(const Eigen::half& a) {$/;"	f
fma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fma (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fmax	test/boostmultiprec.cpp	/^  Real fmax(const Real& a, const Real& b) { using std::max; return max(a,b); }$/;"	f	namespace:boost::multiprecision
fmax	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fmin	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmin(const mpreal& x, const mpreal& y,  mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fmod	Eigen/src/Core/MathFunctions.h	/^T fmod(const T& a, const T& b) {$/;"	f	namespace:Eigen::numext
fmod	Eigen/src/Core/MathFunctions.h	/^double fmod(const double& a, const double& b) {$/;"	f	namespace:Eigen::numext
fmod	Eigen/src/Core/MathFunctions.h	/^float fmod(const float& a, const float& b) {$/;"	f	namespace:Eigen::numext
fmod	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fms	unsupported/test/mpreal/mpreal.h	/^inline const mpreal fms (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fn_	bench/tensors/benchmark.h	/^  void (*fn_)(int);$/;"	m	class:testing::Benchmark
fn_range_	bench/tensors/benchmark.h	/^  void (*fn_range_)(int, int);$/;"	m	class:testing::Benchmark
fnorm	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar fnorm() {return m_fnorm; }$/;"	f	class:Eigen::LevenbergMarquardt
fnorm	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar fnorm;$/;"	m	class:Eigen::HybridNonLinearSolver
fnorm	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar fnorm, gnorm;$/;"	m	class:Eigen::LevenbergMarquardt
fnorm1	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
fnorm1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
fone	bench/bench_gemm.cpp	/^static float fone = 1;$/;"	v	file:
fone	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static SCALAR fone;$/;"	m	class:blas_interface
fone	bench/btl/libs/BLAS/blas_interface_impl.hh	/^SCALAR blas_interface<SCALAR>::fone = SCALAR(1);$/;"	m	class:blas_interface
foo	failtest/block_nonconst_ctor_on_const_xpr_0.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/block_nonconst_ctor_on_const_xpr_1.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/block_nonconst_ctor_on_const_xpr_2.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/block_on_const_type_actually_const_0.cpp	/^void foo(){$/;"	f
foo	failtest/block_on_const_type_actually_const_1.cpp	/^void foo(){$/;"	f
foo	failtest/const_qualified_block_method_retval_0.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/const_qualified_block_method_retval_1.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/const_qualified_diagonal_method_retval.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/const_qualified_transpose_method_retval.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/cwiseunaryview_nonconst_ctor_on_const_xpr.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/cwiseunaryview_on_const_type_actually_const.cpp	/^void foo(){$/;"	f
foo	failtest/diagonal_nonconst_ctor_on_const_xpr.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/diagonal_on_const_type_actually_const.cpp	/^void foo(){$/;"	f
foo	failtest/map_nonconst_ctor_on_const_ptr_0.cpp	/^void foo(CV_QUALIFIER float *ptr){$/;"	f
foo	failtest/map_nonconst_ctor_on_const_ptr_1.cpp	/^void foo(CV_QUALIFIER float *ptr, DenseIndex size){$/;"	f
foo	failtest/map_nonconst_ctor_on_const_ptr_2.cpp	/^void foo(CV_QUALIFIER float *ptr, DenseIndex rows, DenseIndex cols){$/;"	f
foo	failtest/map_nonconst_ctor_on_const_ptr_3.cpp	/^void foo(CV_QUALIFIER float *ptr, DenseIndex rows, DenseIndex cols){$/;"	f
foo	failtest/map_nonconst_ctor_on_const_ptr_4.cpp	/^void foo(const float *ptr, DenseIndex rows, DenseIndex cols){$/;"	f
foo	failtest/map_on_const_type_actually_const_0.cpp	/^void foo(float *ptr){$/;"	f
foo	failtest/map_on_const_type_actually_const_1.cpp	/^void foo(float *ptr){$/;"	f
foo	failtest/selfadjointview_nonconst_ctor_on_const_xpr.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/selfadjointview_on_const_type_actually_const.cpp	/^void foo(){$/;"	f
foo	failtest/transpose_nonconst_ctor_on_const_xpr.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/transpose_on_const_type_actually_const.cpp	/^void foo(){$/;"	f
foo	failtest/triangularview_nonconst_ctor_on_const_xpr.cpp	/^void foo(CV_QUALIFIER Matrix3d &m){$/;"	f
foo	failtest/triangularview_on_const_type_actually_const.cpp	/^void foo(){$/;"	f
foo	unsupported/test/autodiff.cpp	/^EIGEN_DONT_INLINE Scalar foo(const Scalar& x, const Scalar& y)$/;"	f
foo	unsupported/test/autodiff.cpp	/^EIGEN_DONT_INLINE typename Vector::Scalar foo(const Vector& p)$/;"	f
foo	unsupported/test/forward_adolc.cpp	/^EIGEN_DONT_INLINE typename Vector::Scalar foo(const Vector& p)$/;"	f
forceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	Eigen/src/Core/MatrixBase.h	/^    inline Derived& forceAlignedAccess() { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	Eigen/src/Core/MatrixBase.h	/^    inline const Derived& forceAlignedAccess() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline Derived& forceAlignedAccessIf() { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/MatrixBase.h	/^    template<bool Enable> inline const Derived& forceAlignedAccessIf() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
forceMatrixTarget	demos/opengl/gpuhelper.h	/^    inline void forceMatrixTarget(GLenum matrixTarget) {glMatrixMode(mCurrentMatrixTarget=matrixTarget);}$/;"	f	class:GpuHelper
format	Eigen/src/Core/DenseBase.h	/^    inline const WithFormat<Derived> format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase
fortran_to_c_numbering	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
forward_jacobian	unsupported/test/autodiff.cpp	/^template<typename Func> void forward_jacobian(const Func& f)$/;"	f
forward_jacobian_cpp11	unsupported/test/autodiff.cpp	/^template<typename Func> void forward_jacobian_cpp11(const Func& f)$/;"	f
four_denorms	test/svd_fill.h	/^Array4d four_denorms() { return Array4d(5.60844e-313, -5.60844e-313, 4.94e-324, -4.94e-324); }$/;"	f
four_denorms	test/svd_fill.h	/^Array4f four_denorms() { return Array4f(5.60844e-39f, -5.60844e-39f, 4.94e-44f, -4.94e-44f); }$/;"	f
four_denorms	test/svd_fill.h	/^Array<T,4,1> four_denorms() { return four_denorms<double>().cast<T>(); }$/;"	f
fovY	demos/opengl/camera.h	/^    inline float fovY(void) const { return mFovY; }$/;"	f	class:Camera
frac	unsupported/test/mpreal/mpreal.h	/^inline const mpreal frac       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(frac      );     }$/;"	f	namespace:mpfr
frame	demos/opengl/camera.h	/^    const Frame& frame(void) const { return mFrame; }$/;"	f	class:Camera
free_Pivot_Vector	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  inline static void free_Pivot_Vector(Pivot_Vector & pivot)$/;"	f	class:blitz_LU_solve_interface
free_Pivot_Vector	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  inline static void free_Pivot_Vector(Pivot_Vector & pivot)$/;"	f	class:blitz_LU_solve_interface
free_Pivot_Vector	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  inline static void free_Pivot_Vector(Pivot_Vector & pivot)$/;"	f	class:blitz_LU_solve_interface
free_matrix	bench/btl/libs/BLAS/c_interface_base.h	/^  static void free_matrix(gene_matrix & A, int \/*N*\/){$/;"	f	class:c_interface_base
free_matrix	bench/btl/libs/STL/STL_interface.hh	/^  static void free_matrix(gene_matrix & \/*A*\/, int \/*N*\/){}$/;"	f	class:STL_interface
free_matrix	bench/btl/libs/blaze/blaze_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){$/;"	f	class:blaze_interface
free_matrix	bench/btl/libs/blitz/blitz_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){}$/;"	f	class:blitz_interface
free_matrix	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){}$/;"	f	class:tiny_blitz_interface
free_matrix	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static void free_matrix(gene_matrix & A, int N) {}$/;"	f	class:eigen2_interface
free_matrix	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static void free_matrix(gene_matrix & \/*A*\/, int \/*N*\/) {}$/;"	f	class:eigen3_interface
free_matrix	bench/btl/libs/gmm/gmm_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){$/;"	f	class:gmm_interface
free_matrix	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){$/;"	f	class:mtl4_interface
free_matrix	bench/btl/libs/tensors/tensor_interface.hh	/^  static void free_matrix(gene_matrix & \/*A*\/, int \/*N*\/) {}$/;"	f	class:tensor_interface
free_matrix	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static void free_matrix(gene_matrix & A, int N){}$/;"	f	class:tvmet_interface
free_matrix	bench/btl/libs/ublas/ublas_interface.hh	/^  static void free_matrix(gene_matrix & A, int N) {}$/;"	f	class:ublas_interface
free_vector	bench/btl/libs/BLAS/c_interface_base.h	/^  static void free_vector(gene_vector & B){$/;"	f	class:c_interface_base
free_vector	bench/btl/libs/STL/STL_interface.hh	/^  static void free_vector(gene_vector & \/*B*\/){}$/;"	f	class:STL_interface
free_vector	bench/btl/libs/blaze/blaze_interface.hh	/^  static void free_vector(gene_vector & B){$/;"	f	class:blaze_interface
free_vector	bench/btl/libs/blitz/blitz_interface.hh	/^  static void free_vector(gene_vector & B){}$/;"	f	class:blitz_interface
free_vector	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static void free_vector(gene_vector & B){}$/;"	f	class:tiny_blitz_interface
free_vector	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static void free_vector(gene_vector & B) {}$/;"	f	class:eigen2_interface
free_vector	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static void free_vector(gene_vector & \/*B*\/) {}$/;"	f	class:eigen3_interface
free_vector	bench/btl/libs/gmm/gmm_interface.hh	/^  static void free_vector(gene_vector & B){$/;"	f	class:gmm_interface
free_vector	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static void free_vector(gene_vector & B){$/;"	f	class:mtl4_interface
free_vector	bench/btl/libs/tensors/tensor_interface.hh	/^  static void free_vector(gene_vector & \/*B*\/) {}$/;"	f	class:tensor_interface
free_vector	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static void free_vector(gene_vector & B){}$/;"	f	class:tvmet_interface
free_vector	bench/btl/libs/ublas/ublas_interface.hh	/^  static void free_vector(gene_vector & B) {}$/;"	f	class:ublas_interface
frequency	bench/btl/generic_bench/timers/portable_timer.hh	/^   LARGE_INTEGER frequency;$/;"	m	class:Portable_Timer
frequency	bench/btl/generic_bench/timers/x86_timer.hh	/^  inline double frequency( void ){$/;"	f	class:X86_Timer
frexp	unsupported/test/mpreal/mpreal.h	/^inline const mpreal frexp(const mpreal& x, mp_exp_t* exp, mp_rnd_t mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
fromPositionOrientationScale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromRotationMatrix	Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
fromRotationMatrix	Eigen/src/Geometry/Rotation2D.h	/^EIGEN_DEVICE_FUNC Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
front	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& front() { return values[0]; }$/;"	f	class:Eigen::array
front	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& front() {$/;"	f	class:Eigen::array
front	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& front() const { return values[0]; }$/;"	f	class:Eigen::array
front	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& front() const {$/;"	f	class:Eigen::array
front_	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  std::atomic<unsigned> front_;$/;"	m	class:Eigen::RunQueue
ftnlen	blas/f2c/datatypes.h	/^typedef int ftnlen;$/;"	t
ftol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar ftol() const {return m_ftol; }$/;"	f	class:Eigen::LevenbergMarquardt
ftol	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar ftol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
fullPivHouseholderQr	Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
fullPivLu	Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase
fullReduction	bench/tensors/tensor_benchmarks.h	/^  void fullReduction(int num_iters) {$/;"	f	class:BenchmarkSuite
func	bench/benchGeometry.cpp	/^struct func<res, arg1, arg2, TMATV>$/;"	s	file:
func	bench/benchGeometry.cpp	/^struct func<res, arg1, arg2, TMATVMAT>$/;"	s	file:
func	bench/benchGeometry.cpp	/^struct func<res, arg1, arg2, TV>$/;"	s	file:
func	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  const CustomBinaryFunc& func() const { return m_func; }$/;"	f	class:Eigen::TensorCustomBinaryOp
func	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  const CustomUnaryFunc& func() const { return m_func; }$/;"	f	class:Eigen::TensorCustomUnaryOp
func	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  OP func;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
func_opt	bench/benchGeometry.cpp	/^enum func_opt$/;"	g	file:
functor	Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp
functor	Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp
functor	Eigen/src/Core/CwiseTernaryOp.h	/^  const TernaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseTernaryOp
functor	Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp
functor	Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView
functor	Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp& functor() const { return m_functor; }$/;"	f	class:Eigen::PartialReduxExpr
functor	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  Broadcast functor() const { return m_broadcast; }$/;"	f	struct:Eigen::TensorEvaluator
functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  BinaryOp functor() const { return m_functor; }$/;"	f	struct:Eigen::TensorEvaluator
functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  NullaryOp functor() const { return m_functor; }$/;"	f	struct:Eigen::TensorEvaluator
functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  UnaryOp functor() const { return m_functor; }$/;"	f	struct:Eigen::TensorEvaluator
functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::TensorCwiseBinaryOp
functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::TensorCwiseNullaryOp
functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const TernaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::TensorCwiseTernaryOp
functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::TensorCwiseUnaryOp
functor	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FunctorType &functor;$/;"	m	class:Eigen::HybridNonLinearSolver
functor	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FunctorType &functor;$/;"	m	class:Eigen::LevenbergMarquardt
functor_has_linear_access	Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<Eigen::half, float> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<float, Eigen::half> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct functor_traits<scalar_cast_op<int, Eigen::half> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<add_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<div_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<mul_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<sub_assign_op<DstScalar,SrcScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct functor_traits<swap_assign_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_cmp_op<LhsScalar,RhsScalar, cmp> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_difference_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_hypot_op<Scalar,Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_max_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_min_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_pow_op<Scalar,Exponent> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_quotient_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^struct functor_traits<scalar_sum_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct functor_traits<scalar_boolean_xor_op> {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct functor_traits<bind1st_op<BinaryOp> > : functor_traits<BinaryOp> {};$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/BinaryFunctors.h	/^template<typename BinaryOp> struct functor_traits<bind2nd_op<BinaryOp> > : functor_traits<BinaryOp> {};$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/NullaryFunctors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/NullaryFunctors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/NullaryFunctors.h	/^template <typename Scalar, typename PacketType> struct functor_traits< linspaced_op<Scalar,PacketType> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/StlFunctors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_arg_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_atan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_boolean_not_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_ceil_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cosh_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_exp_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_floor_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isfinite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isinf_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_isnan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log10_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log1p_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_log_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_round_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_rsqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_score_coeff_op<Scalar> > : functor_traits<scalar_abs_op<Scalar> > {};$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sign_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sinh_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/functors/UnaryFunctors.h	/^struct functor_traits<scalar_tanh_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	blas/level1_cplx_impl.h	/^    template<> struct functor_traits<scalar_norm1_op >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct functor_traits<GaussianGenerator<T, Index, NumDims> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct functor_traits<scalar_fmod_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct functor_traits<scalar_mod2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct functor_traits<scalar_mod_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct functor_traits<scalar_sigmoid_op<T> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^struct functor_traits<NormalRandomGenerator<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^struct functor_traits<UniformRandomGenerator<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_betainc_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_digamma_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_erf_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_erfc_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_igamma_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_igammac_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_lgamma_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_polygamma_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^struct functor_traits<scalar_zeta_op<Scalar> >$/;"	s	namespace:Eigen::internal
fvec	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType& fvec() {return m_fvec; }$/;"	f	class:Eigen::LevenbergMarquardt
fvec	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
fvec	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
fwd	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd( Complex * dst,const Complex *src,int nfft)$/;"	f	struct:Eigen::internal::fftw_impl
fwd	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd( Complex * dst,const Scalar * src,int nfft) $/;"	f	struct:Eigen::internal::fftw_impl
fwd	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd(complex_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd(complex_type * dst,scalar_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd( Complex * dst,const Complex *src,int nfft)$/;"	f	struct:Eigen::internal::kissfft_impl
fwd	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd( Complex * dst,const Scalar * src,int nfft) $/;"	f	struct:Eigen::internal::kissfft_impl
fwd2	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd2( complex_type * dst,complex_type * src,int n0,int n1) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd2	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd2(Complex * dst, const Complex * src, int n0,int n1)$/;"	f	struct:Eigen::internal::fftw_impl
fwd2	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd2( Complex * dst,const Complex *src,int n0,int n1)$/;"	f	struct:Eigen::internal::kissfft_impl
fwd_inv	unsupported/doc/examples/FFT.cpp	/^void fwd_inv(size_t nfft)$/;"	f
fzero	bench/bench_gemm.cpp	/^static float fzero = 0;$/;"	v	file:
fzero	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static SCALAR fzero;$/;"	m	class:blas_interface
fzero	bench/btl/libs/BLAS/blas_interface_impl.hh	/^SCALAR blas_interface<SCALAR>::fzero = SCALAR(0);$/;"	m	class:blas_interface
gBenchmarks	bench/tensors/benchmark_main.cc	/^BenchmarkMap& gBenchmarks() {$/;"	f
g_benchmark_start_time_ns	bench/tensors/benchmark_main.cc	/^static int64_t g_benchmark_start_time_ns;$/;"	v	file:
g_benchmark_total_time_ns	bench/tensors/benchmark_main.cc	/^static int64_t g_benchmark_total_time_ns;$/;"	v	file:
g_called	test/linearstructure.cpp	/^static bool g_called;$/;"	v	file:
g_called	test/mixingtypes.cpp	/^static bool g_called;$/;"	v	file:
g_flops_processed	bench/tensors/benchmark_main.cc	/^static int64_t g_flops_processed;$/;"	v	file:
g_has_set_repeat	test/main.h	/^  static bool g_has_set_repeat, g_has_set_seed;$/;"	m	namespace:Eigen
g_has_set_seed	test/main.h	/^  static bool g_has_set_repeat, g_has_set_seed;$/;"	m	namespace:Eigen
g_name_column_width	bench/tensors/benchmark_main.cc	/^static int g_name_column_width = 20;$/;"	v	file:
g_realloc_count	test/sparse_basic.cpp	/^static long g_realloc_count = 0;$/;"	v	file:
g_repeat	test/main.h	/^  static int g_repeat;$/;"	m	namespace:Eigen
g_seed	test/main.h	/^  static unsigned int g_seed;$/;"	m	namespace:Eigen
g_test_level	test/main.h	/^  static int g_test_level = 0;$/;"	m	namespace:Eigen
g_test_stack	test/main.h	/^  static std::vector<std::string> g_test_stack;$/;"	m	namespace:Eigen
g_time_info	bench/tensors/benchmark_main.cc	/^  static mach_timebase_info_data_t g_time_info;$/;"	v	file:
g_vectorize_sse	test/packetmath.cpp	/^const bool g_vectorize_sse = false;$/;"	v
g_vectorize_sse	test/packetmath.cpp	/^const bool g_vectorize_sse = true;$/;"	v
gamma	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar gamma() const { return m_angles[2]; }$/;"	f	class:Eigen::EulerAngles
gamma	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Scalar& gamma() { return m_angles[2]; }$/;"	f	class:Eigen::EulerAngles
gamma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal gamma   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(gamma  );    }$/;"	f	namespace:mpfr
garbage_collection	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType garbage_collection  \/* returns the new value of pfree *\/$/;"	f	namespace:internal
gatherPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE SubPacket gatherPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
gbmv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(gbmv)(char *trans, int *m, int *n, int *kl, int *ku, RealScalar *palpha, RealScalar *pa, int *lda,$/;"	f
ge	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline GroupElement ge(Generator const& g) const$/;"	f	class:Eigen::DynamicSGroup
ge	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    typedef typename group_elements::type ge;$/;"	t	class:Eigen::StaticSGroup
gebp_kernel	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal
gebp_madd_selector	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm	bench/bench_gemm.cpp	/^EIGEN_DONT_INLINE void gemm(const A& a, const B& b, C& c)$/;"	f
gemm	bench/perf_monitoring/gemm/gemm.cpp	/^void gemm(const Mat &A, const Mat &B, Mat &C)$/;"	f
gemm	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(gemm)(const char *opa, const char *opb, const int *m, const int *n, const int *k, const RealScalar *palpha,$/;"	f
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(Index \/*rows*\/, Index \/*cols*\/, Index \/*depth*\/, Index \/*num_threads*\/, bool \/*full_rows = false*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(Index rows, Index cols, Index depth, Index num_threads, bool l3_blocking)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true \/* == FiniteAtCompileTime *\/>$/;"	c	namespace:Eigen::internal
gemm_functor	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha, BlockingType& blocking)$/;"	f	struct:Eigen::internal::gemm_functor
gemm_functor	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs<Scalar, Index, DataMapper, Pack1, Pack2, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, DataMapper, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, DataMapper, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(gemv)(const char *opa, const int *m, const int *n, const RealScalar *palpha,$/;"	f
gemv_dense_selector	Eigen/src/Core/GeneralProduct.h	/^struct gemv_dense_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_dense_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_dense_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
gen_numeric_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T start, T... ii>                    struct gen_numeric_list<T, 0, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	s	namespace:Eigen::internal
gen_numeric_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, std::size_t n, T start = 0, T... ii> struct gen_numeric_list                     : gen_numeric_list<T, n-1, start, start + n-1, ii...> {};$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T V, T... nn>                struct gen_numeric_list_repeated<T, 0, V, nn...> { typedef numeric_list<T, nn...> type; };$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, std::size_t n, T V, T... nn> struct gen_numeric_list_repeated                 : gen_numeric_list_repeated<T, n-1, V, V, nn...> {};$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 1, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 2, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 3, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 4, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 5, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 6, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 7, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_repeated	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, T V> struct gen_numeric_list_repeated<T, 8, V> {$/;"	s	namespace:Eigen::internal
gen_numeric_list_reversed	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T start, T... ii>                    struct gen_numeric_list_reversed<T, 0, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	s	namespace:Eigen::internal
gen_numeric_list_reversed	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, std::size_t n, T start = 0, T... ii> struct gen_numeric_list_reversed                     : gen_numeric_list_reversed<T, n-1, start, ii..., start + n-1> {};$/;"	s	namespace:Eigen::internal
gen_numeric_list_swapped_pair	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T b, T start, T... ii>                    struct gen_numeric_list_swapped_pair<T, 0, a, b, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	s	namespace:Eigen::internal
gen_numeric_list_swapped_pair	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, std::size_t n, T a, T b, T start = 0, T... ii> struct gen_numeric_list_swapped_pair                           : gen_numeric_list_swapped_pair<T, n-1, a, b, start, (start + n-1) == a ? b : ((start + n-1) == b ? a : (start + n-1)), ii...> {};$/;"	s	namespace:Eigen::internal
gen_strides	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  EIGEN_DEVICE_FUNC void gen_strides(const InputDimensions& dims, StrideDims& strides) {$/;"	f	struct:Eigen::TensorEvaluator
gene_matrix	bench/btl/libs/BLAS/c_interface_base.h	/^  typedef real* gene_matrix;$/;"	t	class:c_interface_base
gene_matrix	bench/btl/libs/STL/STL_interface.hh	/^  typedef stl_matrix gene_matrix;$/;"	t	class:STL_interface
gene_matrix	bench/btl/libs/blaze/blaze_interface.hh	/^  typedef blaze::DynamicMatrix<real,blaze::columnMajor>  gene_matrix;$/;"	t	class:blaze_interface
gene_matrix	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_matrix gene_matrix;$/;"	t	class:blitz_LU_solve_interface
gene_matrix	bench/btl/libs/blitz/blitz_interface.hh	/^  typedef blitz::Array<real, 2>  gene_matrix;$/;"	t	class:blitz_interface
gene_matrix	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  typedef TinyMatrix<real,SIZE,SIZE> gene_matrix;$/;"	t	class:tiny_blitz_interface
gene_matrix	bench/btl/libs/eigen2/eigen2_interface.hh	/^  typedef Eigen::Matrix<real,SIZE,SIZE> gene_matrix;$/;"	t	class:eigen2_interface
gene_matrix	bench/btl/libs/eigen3/eigen3_interface.hh	/^  typedef Eigen::Matrix<real,SIZE,SIZE> gene_matrix;$/;"	t	class:eigen3_interface
gene_matrix	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_matrix gene_matrix;$/;"	t	class:blitz_LU_solve_interface
gene_matrix	bench/btl/libs/gmm/gmm_interface.hh	/^  typedef gmm::dense_matrix<real> gene_matrix;$/;"	t	class:gmm_interface
gene_matrix	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_matrix gene_matrix;$/;"	t	class:blitz_LU_solve_interface
gene_matrix	bench/btl/libs/mtl4/mtl4_interface.hh	/^  typedef mtl::dense2D<real, mtl::matrix::parameters<mtl::tag::col_major> > gene_matrix;$/;"	t	class:mtl4_interface
gene_matrix	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef Eigen::Tensor<real,2> gene_matrix;$/;"	t	class:tensor_interface
gene_matrix	bench/btl/libs/tvmet/tvmet_interface.hh	/^  typedef Matrix<real,SIZE,SIZE> gene_matrix;$/;"	t	class:tvmet_interface
gene_matrix	bench/btl/libs/ublas/ublas_interface.hh	/^  typedef typename boost::numeric::ublas::matrix<real,boost::numeric::ublas::column_major> gene_matrix;$/;"	t	class:ublas_interface
gene_vector	bench/btl/libs/BLAS/c_interface_base.h	/^  typedef real* gene_vector;$/;"	t	class:c_interface_base
gene_vector	bench/btl/libs/STL/STL_interface.hh	/^  typedef stl_vector gene_vector;$/;"	t	class:STL_interface
gene_vector	bench/btl/libs/blaze/blaze_interface.hh	/^  typedef blaze::DynamicVector<real>  gene_vector;$/;"	t	class:blaze_interface
gene_vector	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_vector gene_vector;$/;"	t	class:blitz_LU_solve_interface
gene_vector	bench/btl/libs/blitz/blitz_interface.hh	/^  typedef blitz::Array<real, 1>  gene_vector;$/;"	t	class:blitz_interface
gene_vector	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  typedef TinyVector<real,SIZE> gene_vector;$/;"	t	class:tiny_blitz_interface
gene_vector	bench/btl/libs/eigen2/eigen2_interface.hh	/^  typedef Eigen::Matrix<real,SIZE,1> gene_vector;$/;"	t	class:eigen2_interface
gene_vector	bench/btl/libs/eigen3/eigen3_interface.hh	/^  typedef Eigen::Matrix<real,SIZE,1> gene_vector;$/;"	t	class:eigen3_interface
gene_vector	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_vector gene_vector;$/;"	t	class:blitz_LU_solve_interface
gene_vector	bench/btl/libs/gmm/gmm_interface.hh	/^  typedef stl_vector gene_vector;$/;"	t	class:gmm_interface
gene_vector	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  typedef typename blitz_interface<real>::gene_vector gene_vector;$/;"	t	class:blitz_LU_solve_interface
gene_vector	bench/btl/libs/mtl4/mtl4_interface.hh	/^  typedef mtl::dense_vector<real>  gene_vector;$/;"	t	class:mtl4_interface
gene_vector	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef Eigen::Tensor<real,1> gene_vector;$/;"	t	class:tensor_interface
gene_vector	bench/btl/libs/tvmet/tvmet_interface.hh	/^  typedef Vector<real,SIZE> gene_vector;$/;"	t	class:tvmet_interface
gene_vector	bench/btl/libs/ublas/ublas_interface.hh	/^  typedef typename boost::numeric::ublas::vector<real> gene_vector;$/;"	t	class:ublas_interface
general_det3_helper	Eigen/src/LU/InverseImpl.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal
general_matrix_matrix_product	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,LhsMapper,ColMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product_wrapper	blas/level2_impl.h	/^struct general_matrix_vector_product_wrapper$/;"	s
general_product_to_triangular_selector	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,false>$/;"	s	namespace:Eigen
general_product_to_triangular_selector	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,true>$/;"	s	namespace:Eigen
general_rank1_update	blas/GeneralRank1Update.h	/^struct general_rank1_update<Scalar,Index,ColMajor,ConjLhs,ConjRhs>$/;"	s	namespace:internal
general_rank1_update	blas/GeneralRank1Update.h	/^struct general_rank1_update<Scalar,Index,RowMajor,ConjLhs,ConjRhs>$/;"	s	namespace:internal
generalized_eigensolver_real	test/eigensolver_generalized_real.cpp	/^template<typename MatrixType> void generalized_eigensolver_real(const MatrixType& m)$/;"	f
generate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    generate(const Generator& generator) const {$/;"	f	class:Eigen::TensorBase
generateTestMatrix	unsupported/test/matrix_functions.h	/^struct generateTestMatrix<MatrixType,0>$/;"	s
generateTestMatrix	unsupported/test/matrix_functions.h	/^struct generateTestMatrix<MatrixType,1>$/;"	s
generate_autotoc	doc/eigen_navtree_hacks.js	/^function generate_autotoc() {$/;"	f
generate_sparse_leastsquare_problem	test/sparse_solver.h	/^void generate_sparse_leastsquare_problem(Solver&, typename Solver::MatrixType& A, DenseMat& dA, int maxSize = 300, int options = ForceNonZeroDiag)$/;"	f
generate_sparse_rectangular_problem	test/sparseqr.cpp	/^int generate_sparse_rectangular_problem(MatrixType& A, DenseMat& dA, int maxRows = 300, int maxCols = 150)$/;"	f
generate_sparse_rectangular_problem	test/spqr_support.cpp	/^int generate_sparse_rectangular_problem(MatrixType& A, DenseMat& dA, int maxRows = 300, int maxCols = 300)$/;"	f
generate_sparse_spd_problem	test/sparse_solver.h	/^int generate_sparse_spd_problem(Solver& , typename Solver::MatrixType& A, typename Solver::MatrixType& halfA, DenseMat& dA, int maxSize = 300)$/;"	f
generate_sparse_square_problem	test/sparse_solver.h	/^Index generate_sparse_square_problem(Solver&, typename Solver::MatrixType& A, DenseMat& dA, int maxSize = 300, int options = ForceNonZeroDiag)$/;"	f
generator	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    const Generator& generator() const { return m_generator; }$/;"	f	class:Eigen::TensorGeneratorOp
generators_done	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef type_list<first_generator> generators_done;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements
generic_dense_assignment_kernel	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
generic_dense_assignment_kernel	Eigen/src/Core/AssignEvaluator.h	/^class generic_dense_assignment_kernel$/;"	c	namespace:Eigen::internal
generic_dense_assignment_kernel	Eigen/src/Core/Swap.h	/^  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
generic_dense_assignment_kernel	Eigen/src/Core/Swap.h	/^class generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, swap_assign_op<typename DstEvaluatorTypeT::Scalar>, Specialized>$/;"	c	namespace:Eigen::internal
generic_fast_tanh_float	Eigen/src/Core/MathFunctionsImpl.h	/^T generic_fast_tanh_float(const T& a_x)$/;"	f	namespace:Eigen::internal
generic_matrix_wrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper()$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper(const InputType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  generic_matrix_wrapper(const MatrixType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
generic_matrix_wrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class generic_matrix_wrapper<MatrixType,false>$/;"	c	namespace:Eigen::internal
generic_matrix_wrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class generic_matrix_wrapper<MatrixType,true>$/;"	c	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Inverse<Lhs>, Rhs, PermutationShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Inverse<Rhs>, MatrixShape, PermutationShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, MatrixShape, PermutationShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, MatrixShape, TranspositionsShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, PermutationShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Rhs, TranspositionsShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs, Transpose<Rhs>, MatrixShape, TranspositionsShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> $/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,InnerProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,OuterProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl<Transpose<Lhs>, Rhs, TranspositionsShape, MatrixShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Homogeneous<LhsArg,Horizontal>, Rhs, HomogeneousShape, DenseShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Lhs, Homogeneous<RhsArg,Vertical>, DenseShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Lhs, Homogeneous<RhsArg,Vertical>, TriangularShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct generic_product_impl<Transform<Scalar,Dim,Mode,Options>, Homogeneous<RhsArg,Vertical>, DenseShape, HomogeneousShape, ProductTag>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, DenseShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, DenseShape, SparseTriangularShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseTriangularShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseShape, SparseTriangularShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseProduct.h	/^struct generic_product_impl<Lhs, Rhs, SparseTriangularShape, SparseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct generic_product_impl<Lhs, RhsView, DenseShape, SparseSelfAdjointShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct generic_product_impl<LhsView, Rhs, SparseSelfAdjointShape, DenseShape, ProductType>$/;"	s	namespace:Eigen::internal
generic_product_impl	doc/examples/matrixfree_cg.cpp	/^  struct generic_product_impl<MatrixReplacement, Rhs, SparseShape, DenseShape, GemvProduct> \/\/ GEMV stands for matrix-vector$/;"	s	namespace:Eigen::internal	file:
generic_product_impl_base	Eigen/src/Core/ProductEvaluators.h	/^struct generic_product_impl_base$/;"	s	namespace:Eigen::internal
generic_xpr_base	Eigen/src/Core/SolverBase.h	/^struct generic_xpr_base<Derived, MatrixXpr, SolverStorage>$/;"	s	namespace:Eigen::internal
generic_xpr_base	Eigen/src/SparseCore/SparseUtil.h	/^struct generic_xpr_base<Derived, MatrixXpr, Sparse>$/;"	s	namespace:Eigen::internal
ger	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void ger(gene_matrix & A, gene_vector & X, gene_vector & Y, int N){$/;"	f	class:blas_interface
ger	bench/btl/libs/STL/STL_interface.hh	/^  static inline void ger(gene_matrix & A, gene_vector & X, gene_vector & Y, int N)$/;"	f	class:STL_interface
ger	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static EIGEN_DONT_INLINE void ger(gene_matrix & A,  gene_vector & X, gene_vector & Y, int  N){$/;"	f	class:eigen3_interface
ger	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(ger)(int *m, int *n, Scalar *palpha, Scalar *px, int *incx, Scalar *py, int *incy, Scalar *pa, int *lda)$/;"	f
gerc	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(gerc)(int *m, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pa, int *lda)$/;"	f
geru	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(geru)(int *m, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pa, int *lda)$/;"	f
ges	doc/snippets/GeneralizedEigenSolver.cpp	/^GeneralizedEigenSolver<MatrixXf> ges;$/;"	v
get	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar get(const RhsEval &rhs, Index outer, Dense = Dense()) const$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
get	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar get(const RhsEval &rhs, Index outer, Sparse = Sparse())$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
get	test/stdlist_overload.cpp	/^typename Container::iterator get(Container & c, Position position)$/;"	f
get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr ValueT get(const DenseIndex \/*i*\/, const IndexTuple<T...>& t) {$/;"	f	struct:Eigen::internal::tuple_coeff
get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr ValueT get(const DenseIndex i, const IndexTuple<T...>& t) {$/;"	f	struct:Eigen::internal::tuple_coeff
get	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC constexpr DenseIndex get(const DenseIndex i) const {$/;"	f	struct:Eigen::IndexList
get	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n, typename a, typename... as>               struct get<n, type_list<a, as...>>   : get<n-1, type_list<as...>> {};$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T... as>                               struct get<0, numeric_list<T, a, as...>>   { constexpr static T value = a; };$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n, T a, T... as>                        struct get<n, numeric_list<T, a, as...>>   : get<n-1, numeric_list<T, as...>> {};$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename... as>                      struct get<0, type_list<a, as...>>   { typedef a type; };$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  get() { eigen_assert(false && "index overflow"); }$/;"	f	struct:Eigen::internal::get
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get<0, type_list<Head, Tail> >$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get<0, type_list<Head, empty_list> >$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get<i, empty_list>$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get<i, type_list<Head, Tail> >$/;"	s	namespace:Eigen::internal
get	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get<i, type_list<Head, empty_list> >$/;"	s	namespace:Eigen::internal
getBaseOffsetFromIndex	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index getBaseOffsetFromIndex(Index index, Index omitted_dim) const {$/;"	f	struct:Eigen::TensorEvaluator
getChildren	unsupported/Eigen/src/BVH/KdBVH.h	/^  EIGEN_STRONG_INLINE void getChildren(Index index, VolumeIterator &outVBegin, VolumeIterator &outVEnd,$/;"	f	class:Eigen::KdBVH
getCpuTime	bench/BenchTimer.h	/^  inline double getCpuTime() const$/;"	f	class:Eigen::BenchTimer
getDim	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^    static inline Dim getDim(InDim dims ) {return Dim(dims.TotalSize());}$/;"	f	struct:Eigen::TensorSycl::internal::DimConstr
getDim	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  static inline Dim getDim(InDim dims ) {return dims;}$/;"	f	struct:Eigen::TensorSycl::internal::DimConstr
getIndexFromOffset	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index getIndexFromOffset(Index base, Index omitted_dim, Index offset) const {$/;"	f	struct:Eigen::TensorEvaluator
getInputIndex	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool getInputIndex(Index index, Index* inputIndex) const$/;"	f	struct:Eigen::TensorEvaluator
getL	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m.adjoint()); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m.adjoint()); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }$/;"	f	struct:Eigen::internal::traits
getLinearMapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getLinearMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
getLog2	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE static Index getLog2(Index m) {$/;"	f	struct:Eigen::TensorEvaluator
getMarketHeader	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^inline bool getMarketHeader(const std::string& filename, int& sym, bool& iscomplex, bool& isvector)$/;"	f	namespace:Eigen
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
getMaxIterations	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexEigenSolver
getMaxIterations	Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexSchur
getMaxIterations	Eigen/src/Eigenvalues/EigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::EigenSolver
getMaxIterations	Eigen/src/Eigenvalues/RealSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::RealSchur
getNbrConvergedEigenValues	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  size_t getNbrConvergedEigenValues() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
getNbrIterations	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  size_t getNbrIterations() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
getNode	doc/eigen_navtree_hacks.js	/^function getNode(o, po)$/;"	f
getNumCudaMultiProcessors	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int getNumCudaMultiProcessors() const {$/;"	f	struct:Eigen::GpuDevice
getPadeDegree	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^inline int MatrixPowerAtomic<MatrixType>::getPadeDegree(double normIminusT)$/;"	f	class:Eigen::MatrixPowerAtomic
getPadeDegree	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^inline int MatrixPowerAtomic<MatrixType>::getPadeDegree(float normIminusT)$/;"	f	class:Eigen::MatrixPowerAtomic
getPadeDegree	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^inline int MatrixPowerAtomic<MatrixType>::getPadeDegree(long double normIminusT)$/;"	f	class:Eigen::MatrixPowerAtomic
getPrecision	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::getPrecision() const$/;"	f	class:mpfr::mpreal
getRealTime	bench/BenchTimer.h	/^  inline double getRealTime() const$/;"	f	class:Eigen::BenchTimer
getRootIndex	unsupported/Eigen/src/BVH/KdBVH.h	/^  inline Index getRootIndex() const { return (int)boxes.size() - 1; }$/;"	f	class:Eigen::KdBVH
getSubMapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE const_blas_data_mapper<Scalar, Index, StorageOrder> getSubMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::const_blas_data_mapper
getSubMapper	Eigen/src/Core/util/BlasUtil.h	/^  getSubMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getSubMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE SubMapper getSubMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::TensorContractionInputMapper
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(AccessorConstructor::getTuple(cgh, eval.arg1Impl(), eval.arg2Impl(), eval.arg3Impl())){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(AccessorConstructor::getTuple(cgh, eval.cond_impl(), eval.then_impl(), eval.else_impl())){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(AccessorConstructor::getTuple(cgh, eval.impl())){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(AccessorConstructor::getTuple(cgh, eval.left_impl(), eval.right_impl())){$/;"	f	struct:Eigen::TensorSycl::internal::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(ExtractAccessor<Arg>::getTuple(cgh, eval)) {$/;"	f	struct:Eigen::TensorSycl::internal::AccessorConstructor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(utility::tuple::append(ExtractAccessor<Arg1>::getTuple(cgh, eval1), ExtractAccessor<Arg2>::getTuple(cgh, eval2))) {$/;"	f	class:Eigen::TensorSycl::internal::AccessorConstructor::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(utility::tuple::append(ExtractAccessor<Arg1>::getTuple(cgh, eval1),utility::tuple::append(ExtractAccessor<Arg2>::getTuple(cgh, eval2), ExtractAccessor<Arg3>::getTuple(cgh, eval3)))) {$/;"	f	class:Eigen::TensorSycl::internal::AccessorConstructor::ExtractAccessor
getTuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^-> decltype(ExtractAccessor<Evaluator>::getTuple(cgh, expr)) {$/;"	f	namespace:Eigen::TensorSycl::internal
getU	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }$/;"	f	struct:Eigen::internal::traits
getVectorMapper	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE VectorMapper getVectorMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
getVectorMapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE VectorMapper getVectorMapper(Index i, Index j) const {$/;"	f	class:Eigen::internal::TensorContractionInputMapper
getVolume	unsupported/Eigen/src/BVH/KdBVH.h	/^  inline const Volume &getVolume(Index index) const$/;"	f	class:Eigen::KdBVH
get_boxes_helper	unsupported/Eigen/src/BVH/KdBVH.h	/^struct get_boxes_helper {$/;"	s	namespace:Eigen::internal
get_boxes_helper	unsupported/Eigen/src/BVH/KdBVH.h	/^struct get_boxes_helper<ObjectList, VolumeList, int> {$/;"	s	namespace:Eigen::internal
get_click	bench/btl/generic_bench/timers/x86_timer.hh	/^  unsigned long long  get_click( void ){$/;"	f	class:X86_Timer
get_compact_vector	blas/common.h	/^T* get_compact_vector(T* x, int n, int incx)$/;"	f
get_cost	test/evaluators.cpp	/^template<typename XprType> long get_cost(const XprType& ) { return Eigen::internal::evaluator<XprType>::CoeffReadCost; }$/;"	f
get_default_prec	unsupported/test/mpreal/mpreal.h	/^    inline static mp_prec_t  get_default_prec()   {    return mpfr_get_default_prec();                            }$/;"	f	class:mpfr::mpreal
get_default_rnd	unsupported/test/mpreal/mpreal.h	/^    inline static mp_rnd_t   get_default_rnd()    {    return (mp_rnd_t)(mpfr_get_default_rounding_mode());       }$/;"	f	class:mpfr::mpreal
get_dim	bench/geometry.cpp	/^struct get_dim<Matrix<S,R,C,O,MR,MC> > { enum { Dim = R }; };$/;"	s	file:
get_dim	bench/geometry.cpp	/^template<typename T> struct get_dim { enum { Dim = T::Dim }; };$/;"	s	file:
get_elapsed_time_in_second	bench/btl/generic_bench/timers/x86_timer.hh	/^  double get_elapsed_time_in_second( void ){$/;"	f	class:X86_Timer
get_emax	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax (void)$/;"	f	class:mpfr::mpreal
get_emax_max	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax_max (void)$/;"	f	class:mpfr::mpreal
get_emax_min	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax_min (void)$/;"	f	class:mpfr::mpreal
get_emin	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin (void)$/;"	f	class:mpfr::mpreal
get_emin_max	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin_max (void)$/;"	f	class:mpfr::mpreal
get_emin_min	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin_min (void)$/;"	f	class:mpfr::mpreal
get_exp	unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_exp ()$/;"	f	class:mpfr::mpreal
get_factor	Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
get_matrixfolder	test/sparse_solver.h	/^inline std::string get_matrixfolder()$/;"	f
get_mean_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  double get_mean_clicks( void ){$/;"	f	class:X86_Timer
get_most_occured_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  double get_most_occured_clicks( void ){$/;"	f	class:X86_Timer
get_nb_calc	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  unsigned long long get_nb_calc()$/;"	f	class:Portable_Perf_Analyzer
get_nb_calc	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  unsigned long long get_nb_calc( void )$/;"	f	class:Portable_Perf_Analyzer
get_options	bench/spbench/spbenchsolver.h	/^bool get_options(int argc, char **args, string option, string* value=0)$/;"	f
get_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanData & get_plan(int n0,int n1,bool inverse,void * dst,const void * src)$/;"	f	struct:Eigen::internal::fftw_impl
get_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanData & get_plan(int nfft,bool inverse,void * dst,const void * src)$/;"	f	struct:Eigen::internal::fftw_impl
get_plan	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    PlanData & get_plan(int nfft, bool inverse)$/;"	f	struct:Eigen::internal::kissfft_impl
get_prec	unsupported/test/mpreal/mpreal.h	/^inline mp_prec_t mpreal::get_prec() const$/;"	f	class:mpfr::mpreal
get_random_seed	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^EIGEN_DEVICE_FUNC uint64_t get_random_seed() {$/;"	f	namespace:Eigen::internal::__anon101
get_random_size	test/product_trmm.cpp	/^int get_random_size()$/;"	f
get_restart	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  Index get_restart() { return m_restart; }$/;"	f	class:Eigen::GMRES
get_shortest_clicks	bench/btl/generic_bench/timers/x86_timer.hh	/^  double get_shortest_clicks( void ){$/;"	f	class:X86_Timer
get_sycl_accessor	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  get_sycl_accessor(size_t num_bytes, cl::sycl::handler &cgh, const T * ptr) const {$/;"	f	struct:Eigen::SyclDevice
get_sycl_buffer	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template <typename T> inline cl::sycl::buffer<T, 1>* get_sycl_buffer(size_t num_bytes,const T * ptr) const {$/;"	f	struct:Eigen::SyclDevice
get_symmetrized_graph	Eigen/src/MetisSupport/MetisSupport.h	/^  void get_symmetrized_graph(const MatrixType& A)$/;"	f	class:Eigen::MetisOrdering
get_test_precision	test/boostmultiprec.cpp	/^  Real get_test_precision(const Real&) {$/;"	f	namespace:boost::multiprecision
get_test_precision	test/main.h	/^typename NumTraits<T>::Real get_test_precision(const T&,typename internal::enable_if<internal::is_arithmetic<typename NumTraits<T>::Real>::value, T>::type* = 0)$/;"	f	namespace:Eigen
get_test_precision	test/main.h	/^typename NumTraits<typename T::Scalar>::Real get_test_precision(const T&, const typename T::Scalar* = 0)$/;"	f	namespace:Eigen
get_time	bench/btl/generic_bench/timers/STL_timer.hh	/^  double get_time( void )$/;"	f	class:STL_Timer
get_type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get_type<0, type_list<Head, Tail> >$/;"	s	namespace:Eigen::internal
get_type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct get_type<i, type_list<Head, Tail> >$/;"	s	namespace:Eigen::internal
get_val	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr ValType& get_val(IndexTuple<T, O...>& val) {$/;"	f	struct:Eigen::internal::IndexTupleExtractor
get_val	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr const ValType& get_val(const IndexTuple<T, O...>& val) {$/;"	f	struct:Eigen::internal::IndexTupleExtractor
gflops	bench/analyze-blocking-sizes.cpp	/^  float gflops;$/;"	m	struct:inputfile_entry_t	file:
globalFlags	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline int globalFlags() const { return m_globalFlags; }$/;"	f	class:Eigen::DynamicSGroup
globalFlags	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static inline int globalFlags() { return group_elements::global_flags; }$/;"	f	class:Eigen::StaticSGroup
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static int global_flags = $/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = 0;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = 0;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = 0;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_generator
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = 0;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = 0;$/;"	m	struct:Eigen::internal::group_theory::strip_identities
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = Equality<current_element, id>::global_flags;$/;"	m	struct:Eigen::internal::group_theory::dimino_first_step_elements_helper
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = Equality<id, t>::global_flags | strip_identities<Equality, id, type_list<ts...>>::global_flags;$/;"	m	struct:Eigen::internal::group_theory::strip_identities
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = _cil::global_flags | _helper::global_flags;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = _helper::global_flags | _ac4r::global_flags;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = _helper::global_flags;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_generator
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = helper::global_flags;$/;"	m	struct:Eigen::internal::group_theory::dimino_first_step_elements
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags = initial_global_flags;$/;"	m	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags =$/;"	m	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
global_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int global_flags =$/;"	m	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
global_flags	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static int global_flags = last_check_flags;$/;"	m	struct:Eigen::internal::contained_in_list_gf
global_flags	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list_gf<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, default_flags, false, last_check_flags> { constexpr static bool value = false; constexpr static int global_flags = default_flags; };$/;"	m	struct:Eigen::internal::contained_in_list_gf
global_flags	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename b> struct is_same_gf : is_same<a, b> { constexpr static int global_flags = 0; };$/;"	m	struct:Eigen::internal::is_same_gf
global_flags	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_a, dummy_a>     { constexpr static bool value = true;  constexpr static int global_flags = 1; };$/;"	m	struct:dummy_test	file:
global_flags	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_b, dummy_b>     { constexpr static bool value = true;  constexpr static int global_flags = 2; };$/;"	m	struct:dummy_test	file:
global_flags	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_c, dummy_c>     { constexpr static bool value = true;  constexpr static int global_flags = 4; };$/;"	m	struct:dummy_test	file:
global_flags	unsupported/test/cxx11_meta.cpp	/^template<typename A, typename B> struct dummy_test { constexpr static bool value = false; constexpr static int global_flags = 0; };$/;"	m	struct:dummy_test	file:
global_math_functions_filtering_base	Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
global_navtree_object	doc/eigen_navtree_hacks.js	/^var global_navtree_object;$/;"	v
glue_shapes	Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,SelfAdjointShape> { typedef SparseSelfAdjointShape type;  };$/;"	s	namespace:Eigen::internal
glue_shapes	Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,TriangularShape > { typedef SparseTriangularShape  type;  };$/;"	s	namespace:Eigen::internal
gm	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Index gm(Index m) const { return m + 1 < nm_ ? gm_ : nm0_ + gm_ - gm_ * nm_; }$/;"	f	class:Eigen::TensorEvaluator::Context
gm_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index gm_;$/;"	m	class:Eigen::TensorEvaluator::Context
gmm_interface	bench/btl/libs/gmm/gmm_interface.hh	/^class gmm_interface {$/;"	c
gmres	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^bool gmres(const MatrixType & mat, const Rhs & rhs, Dest & x, const Preconditioner & precond,$/;"	f	namespace:Eigen::internal
gn	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    Index gn(Index n) const { return n + 1 < nn_ ? gn_ : nn0_ + gn_ - gn_ * nn_; }$/;"	f	class:Eigen::TensorEvaluator::Context
gn_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index gn_;$/;"	m	class:Eigen::TensorEvaluator::Context
gnorm	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar gnorm() {return m_gnorm; }$/;"	f	class:Eigen::LevenbergMarquardt
gnorm	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar fnorm, gnorm;$/;"	m	class:Eigen::LevenbergMarquardt
go	bench/btl/generic_bench/static/static_size_generator.hh	/^  static  void go(vector<double> & tab_sizes, vector<double> & tab_mflops)$/;"	f	struct:static_size_generator
go	bench/btl/generic_bench/static/static_size_generator.hh	/^  static void go(vector<double> & tab_sizes, vector<double> & tab_mflops)$/;"	f	struct:static_size_generator
gpu	demos/opengl/gpuhelper.cpp	/^GpuHelper gpu;$/;"	v
grab	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const EigenBase<MatrixDerived> &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const InputType &A)$/;"	f	class:Eigen::IterativeSolverBase
grab	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const MatrixType &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grab(const Ref<const MatrixType> &mat)$/;"	f	class:Eigen::internal::generic_matrix_wrapper
grab	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grab(const EigenBase<MatrixDerived> &A)$/;"	f	class:Eigen::UmfPackLU
grab	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grab(const UmfpackMatrixRef &A)$/;"	f	class:Eigen::UmfPackLU
grabFrame	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::grabFrame(void)$/;"	f	class:RenderingWidget
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU
grandom	unsupported/test/mpreal/mpreal.h	/^inline const mpreal grandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
grandom	unsupported/test/mpreal/mpreal.h	/^inline const mpreal grandom(unsigned int seed = 0)$/;"	f	namespace:mpfr
greater_equal_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct greater_equal_op {$/;"	s	namespace:Eigen::internal
greater_equal_zero_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct greater_equal_zero_op {$/;"	s	namespace:Eigen::internal
greater_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct greater_op {$/;"	s	namespace:Eigen::internal
greatestRealRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& greatestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
greatestRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& greatestRoot() const$/;"	f	class:Eigen::PolynomialSolverBase
group_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    > group_elements;$/;"	t	class:Eigen::StaticSGroup
group_theory	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^namespace group_theory {$/;"	n	namespace:Eigen::internal
gtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar gtol() const {return m_gtol; }$/;"	f	class:Eigen::LevenbergMarquardt
gtol	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar gtol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
guess	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const GuessType&     guess() const { return m_guess; }$/;"	f	class:Eigen::SolveWithGuess
h	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^Vector3d h = Vector3d::Random();$/;"	v
hCoeffs	Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR
hCoeffs	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const HCoeffsType& hCoeffs() const { return m_cpqr.hCoeffs(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR
hCoeffs	Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR
h_apply_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_apply_op$/;"	s	namespace:Eigen::internal
h_apply_op_helper	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_apply_op_helper                                        { typedef type_list<typename op<values, additional_param>::type...> type; };$/;"	s	namespace:Eigen::internal
h_apply_op_helper	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_apply_op_helper<true, op, additional_param, values...> { typedef type_list<typename op<additional_param, values>::type...> type; };$/;"	s	namespace:Eigen::internal
h_permute	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline std::array<Index, N> h_permute(std::size_t which, const std::array<Index, N>& idx, internal::numeric_list<int, n...>) const$/;"	f	class:Eigen::DynamicSGroup
h_permute	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline std::vector<Index> h_permute(std::size_t which, std::vector<Index> idx) const$/;"	f	class:Eigen::DynamicSGroup
h_skip	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_skip {$/;"	s	namespace:Eigen::internal
h_skip_helper_numeric	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T i, T... ii>        struct h_skip_helper_numeric<T, 0, i, ii...> { typedef numeric_list<T, i, ii...> type; };$/;"	s	namespace:Eigen::internal
h_skip_helper_numeric	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n, T i, T... ii> struct h_skip_helper_numeric<T, n, i, ii...> : h_skip_helper_numeric<T, n-1, ii...> {};$/;"	s	namespace:Eigen::internal
h_skip_helper_numeric	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n>               struct h_skip_helper_numeric<T, n>           { typedef numeric_list<T> type; };$/;"	s	namespace:Eigen::internal
h_skip_helper_numeric	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T>                      struct h_skip_helper_numeric<T, 0>           { typedef numeric_list<T> type; };$/;"	s	namespace:Eigen::internal
h_skip_helper_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<>                                  struct h_skip_helper_type<0>           { typedef type_list<> type; };$/;"	s	namespace:Eigen::internal
h_skip_helper_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n, typename t, typename... tt> struct h_skip_helper_type<n, t, tt...> : h_skip_helper_type<n-1, tt...> {};$/;"	s	namespace:Eigen::internal
h_skip_helper_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n>                             struct h_skip_helper_type<n>           { typedef type_list<> type; };$/;"	s	namespace:Eigen::internal
h_skip_helper_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename t, typename... tt>        struct h_skip_helper_type<0, t, tt...> { typedef type_list<t, tt...> type; };$/;"	s	namespace:Eigen::internal
hahn1_functor	unsupported/test/NonLinearOptimization.cpp	/^    hahn1_functor(void) : Functor<double>(7,236) {}$/;"	f	struct:hahn1_functor
hahn1_functor	unsupported/test/NonLinearOptimization.cpp	/^struct hahn1_functor : Functor<double>$/;"	s	file:
hahn1_functor	unsupported/test/levenberg_marquardt.cpp	/^    hahn1_functor(void) : DenseFunctor<double>(7,236) {}$/;"	f	struct:hahn1_functor
hahn1_functor	unsupported/test/levenberg_marquardt.cpp	/^struct hahn1_functor : DenseFunctor<double>$/;"	s	file:
half	Eigen/src/Core/GenericPacketMath.h	/^  typedef T half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet4d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet4d half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8f half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8f half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8i half;$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half() {}$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half(const __half& h) : half_impl::half_base(h) {}$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half(const __half_raw& h) : half_impl::half_base(h) {}$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half(const half& h) : half_impl::half_base(h) {}$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(bool b)$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(const T& val)$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^  explicit EIGEN_DEVICE_FUNC half(float f)$/;"	f	struct:Eigen::half
half	Eigen/src/Core/arch/CUDA/Half.h	/^struct half : public half_impl::half_base {$/;"	s	namespace:Eigen
half	Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef double2 half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef float4 half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^  typedef half2 half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f half; \/\/ Packet2f intrinsics not implemented yet$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i half; \/\/ Packet2i intrinsics not implemented yet$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet1cd half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet2cf half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet2d half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4f half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4i half;$/;"	t	struct:Eigen::internal::packet_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^template<typename Packet> struct unpacket_traits<DoublePacket<Packet> > { typedef DoublePacket<Packet> half; };$/;"	t	struct:Eigen::internal::unpacket_traits
half_base	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base() {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base(const __half& h) : __half_raw(*(__half_raw*)&h) {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base(const __half_raw& h) : __half_raw(h) {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half_base(const half_base& h) : __half_raw(h) {}$/;"	f	struct:Eigen::half_impl::half_base
half_base	Eigen/src/Core/arch/CUDA/Half.h	/^struct half_base : public __half_raw {$/;"	s	namespace:Eigen::half_impl
half_impl	Eigen/src/Core/arch/CUDA/Half.h	/^namespace half_impl {$/;"	n	namespace:Eigen
half_to_float	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float half_to_float(__half_raw h) {$/;"	f	namespace:Eigen::half_impl
handmade_aligned_free	Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
handmade_aligned_malloc	Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
handmade_aligned_realloc	Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)$/;"	f	namespace:Eigen::internal
hasNaN	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::hasNaN() const$/;"	f	class:Eigen::DenseBase
hasRhs	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool hasRhs() {return m_hasRhs; }$/;"	f	class:Eigen::MatrixMarketIterator
has_ReturnType	Eigen/src/Core/util/Meta.h	/^struct has_ReturnType$/;"	s	namespace:Eigen::internal
has_binary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_binary_operator	Eigen/src/Core/util/Meta.h	/^struct has_binary_operator$/;"	s	namespace:Eigen::internal
has_denorm	Eigen/src/Core/arch/CUDA/Half.h	/^  static const float_denorm_style has_denorm = denorm_present;$/;"	m	struct:std::numeric_limits
has_denorm	unsupported/test/mpreal/mpreal.h	/^        static const float_denorm_style has_denorm  = denorm_absent;$/;"	m	class:std::numeric_limits
has_denorm_loss	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool has_denorm_loss = false;$/;"	m	struct:std::numeric_limits
has_direct_access	Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon607
has_direct_access	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
has_infinity	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool has_infinity = true;$/;"	m	struct:std::numeric_limits
has_infinity	unsupported/test/mpreal/mpreal.h	/^        static const bool has_infinity      = true;$/;"	m	class:std::numeric_limits
has_none	Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
has_nullary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_nullary_operator	Eigen/src/Core/util/Meta.h	/^struct has_nullary_operator$/;"	s	namespace:Eigen::internal
has_quiet_NaN	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool has_quiet_NaN = true;$/;"	m	struct:std::numeric_limits
has_quiet_NaN	unsupported/test/mpreal/mpreal.h	/^        static const bool has_quiet_NaN     = true;$/;"	m	class:std::numeric_limits
has_signaling_NaN	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool has_signaling_NaN = true;$/;"	m	struct:std::numeric_limits
has_signaling_NaN	unsupported/test/mpreal/mpreal.h	/^        static const bool has_signaling_NaN = true;$/;"	m	class:std::numeric_limits
has_std_result_type	Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
has_tr1_result	Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
has_unary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 1}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	s	namespace:Eigen::internal
has_unary_operator	Eigen/src/Core/util/Meta.h	/^struct has_unary_operator$/;"	s	namespace:Eigen::internal
has_write_access	Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon607
hash	Eigen/src/Core/arch/CUDA/Half.h	/^struct hash<Eigen::half> {$/;"	s	namespace:std
hash	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType hash ;  \/* hash value, if col is not in a degree list *\/$/;"	m	union:internal::colamd_col::__anon870
hash_next	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType hash_next ;   \/* next column, if col is in a hash list *\/$/;"	m	union:internal::colamd_col::__anon871
hasrefX	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool hasrefX() {return m_hasrefX; }$/;"	f	class:Eigen::MatrixMarketIterator
hc	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^Vector3d hc = hessOfA.householderCoefficients();$/;"	v
hc	doc/snippets/Tridiagonalization_householderCoefficients.cpp	/^Vector3d hc = triOfA.householderCoefficients();$/;"	v
head	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType head(Index n) const$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType head(Index n)$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type head(Index n = N) const$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type head(Index n = N)$/;"	f
head	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  T head;$/;"	m	struct:Eigen::internal::IndexTuple
head	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  T head;$/;"	m	struct:utility::tuple::Tuple
head	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const T head;$/;"	m	struct:Eigen::internal::type_list
headhash	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType headhash ;  \/* head of a hash bucket, if col is at the head of *\/$/;"	m	union:internal::colamd_col::__anon870
heap_relax_snode	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^void SparseLUImpl<Scalar,StorageIndex>::heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
helper	Eigen/src/Geometry/Homogeneous.h	/^  typedef homogeneous_left_product_refactoring_helper<Lhs,typename Rhs::NestedExpression> helper;$/;"	t	struct:Eigen::internal::product_evaluator
helper	Eigen/src/Geometry/Homogeneous.h	/^  typedef homogeneous_right_product_refactoring_helper<typename Lhs::NestedExpression,Rhs> helper;$/;"	t	struct:Eigen::internal::product_evaluator
helper	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  constexpr static inline numeric_list<int, get<iia, iib>::value...> helper(numeric_list<int, iia...>) {$/;"	f	struct:Eigen::internal::tensor_static_symgroup_multiply_helper
helper	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  > helper;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements
helper	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static inline typename h_skip_helper_numeric<T, n, ii...>::type helper(numeric_list<T, ii...>) { return typename h_skip_helper_numeric<T, n, ii...>::type(); }$/;"	f	struct:Eigen::internal::h_skip
helper	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static inline typename h_skip_helper_type<n, tt...>::type helper(type_list<tt...>) { return typename h_skip_helper_type<n, tt...>::type(); }$/;"	f	struct:Eigen::internal::h_skip
helper	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static typename h_apply_op_helper<from_left, op, additional_param, values...>::type helper(type_list<values...>)$/;"	f	struct:Eigen::internal::h_apply_op
hemm	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(hemm)(const char *side, const char *uplo, const int *m, const int *n, const RealScalar *palpha,$/;"	f
hemv	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(hemv)(const char *uplo, const int *n, const RealScalar *palpha, const RealScalar *pa, const int *lda,$/;"	f
her	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(her)(char *uplo, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *pa, int *lda)$/;"	f
her2	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(her2)(char *uplo, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pa, int *lda)$/;"	f
her2k	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(her2k)(const char *uplo, const char *op, const int *n, const int *k,$/;"	f
herk	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(herk)(const char *uplo, const char *op, const int *n, const int *k,$/;"	f
hessenberg	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void hessenberg(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:blas_interface
hessenberg	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void hessenberg(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:eigen2_interface
hessenberg	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void hessenberg(const gene_matrix & X, gene_matrix & C, int  \/*N*\/){$/;"	f	class:eigen3_interface
hessenberg	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void hessenberg(const gene_matrix & X, gene_matrix & R, int N){$/;"	f	class:gmm_interface
hessenberg	test/hessenberg.cpp	/^template<typename Scalar,int Size> void hessenberg(int size = Size)$/;"	f
hessenbergTriangular	Eigen/src/Eigenvalues/RealQZ.h	/^    void RealQZ<MatrixType>::hessenbergTriangular()$/;"	f	class:Eigen::RealQZ
high	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  HIGH high;$/;"	m	struct:Eigen::internal::TensorUInt128
highest	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half highest() {$/;"	f	struct:Eigen::NumTraits
highest	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static inline Real highest() { return n; }$/;"	f	struct:Eigen::NumTraits
hnormalized	Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase
hnormalized	Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous	Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase
homogeneous	Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous	test/geo_homogeneous.cpp	/^template<typename Scalar,int Size> void homogeneous(void)$/;"	f
homogeneous_left_product_impl	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
homogeneous_left_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal
homogeneous_left_product_refactoring_helper	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_refactoring_helper$/;"	s	namespace:Eigen::internal
homogeneous_right_product_impl	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
homogeneous_right_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal
homogeneous_right_product_refactoring_helper	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_refactoring_helper$/;"	s	namespace:Eigen::internal
householder	Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
householder	test/householder.cpp	/^template<typename MatrixType> void householder(const MatrixType& m)$/;"	f
householderCoefficients	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition
householderCoefficients	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization
householderQ	Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
householderQ	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::householderQ() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
householderQ	Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR
householderQr	Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase
householderSequence	Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
householderU	Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderV	Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization
householder_qr_inplace_blocked	Eigen/src/QR/HouseholderQR.h	/^struct householder_qr_inplace_blocked$/;"	s	namespace:Eigen::internal
householder_qr_inplace_unblocked	Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal
hpr	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(hpr)(char *uplo, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *pap)$/;"	f
hpr2	blas/level2_cplx_impl.h	/^int EIGEN_BLAS_FUNC(hpr2)(char *uplo, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pap)$/;"	f
hseq_side_dependent_impl	Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
hybrd1	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::hybrd1($/;"	f	class:Eigen::HybridNonLinearSolver
hybrd_functor	unsupported/test/NonLinearOptimization.cpp	/^    hybrd_functor(void) : Functor<double>(9,9) {}$/;"	f	struct:hybrd_functor
hybrd_functor	unsupported/test/NonLinearOptimization.cpp	/^struct hybrd_functor : Functor<double>$/;"	s	file:
hybrj1	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::hybrj1($/;"	f	class:Eigen::HybridNonLinearSolver
hybrj_functor	unsupported/test/NonLinearOptimization.cpp	/^    hybrj_functor(void) : Functor<double>(9,9) {}$/;"	f	struct:hybrj_functor
hybrj_functor	unsupported/test/NonLinearOptimization.cpp	/^struct hybrj_functor : Functor<double>$/;"	s	file:
hyperplane	test/geo_hyperplane.cpp	/^template<typename HyperplaneType> void hyperplane(const HyperplaneType& _plane)$/;"	f
hyperplane_alignment	test/geo_hyperplane.cpp	/^template<typename Scalar> void hyperplane_alignment()$/;"	f
hypot	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext
hypot	unsupported/test/mpreal/mpreal.h	/^inline const mpreal hypot (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
hypotNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase
hypotNorm	Eigen/src/Core/VectorwiseOp.h	/^    const HypotNormReturnType hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp
hypotNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar hypotNorm(T& v)$/;"	f
hypot_impl	Eigen/src/Core/MathFunctionsImpl.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot_retval	Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
i	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  int32_t   i[4];$/;"	m	union:Eigen::internal::__anon720
i	blas/f2c/datatypes.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	m	struct:__anon204
i	blas/f2c/datatypes.h	/^typedef struct { real r, i; } complex;$/;"	m	struct:__anon203
i	doc/snippets/BiCGSTAB_step_by_step.cpp	/^  int i = 0;$/;"	v
i	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  std::ptrdiff_t i, j;$/;"	v
icc_11_workaround	Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform
id	demos/mandelbrot/mandelbrot.h	/^    int id, max_iter;$/;"	m	class:MandelbrotThread
id_numeric	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T dummy, typename t> struct id_numeric  { typedef t type; };$/;"	s	namespace:Eigen::internal
id_type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename dummy, typename t>      struct id_type     { typedef t type; };$/;"	s	namespace:Eigen::internal
ifExpr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<IfExpr, Dev> > ifExpr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
ifExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const IfXprType& ifExpression() const { return m_condition; }$/;"	f	class:Eigen::TensorSelectOp
igamma	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    igamma(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
igamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^igamma(const Eigen::ArrayBase<Derived>& a, const Eigen::ArrayBase<ExponentDerived>& x)$/;"	f	namespace:Eigen
igamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half igamma(const Eigen::half& a, const Eigen::half& x) {$/;"	f	namespace:Eigen::numext
igamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    igamma(const Scalar& a, const Scalar& x) {$/;"	f	namespace:Eigen::numext
igamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct igamma_impl {$/;"	s	namespace:Eigen::internal
igamma_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct igamma_retval {$/;"	s	namespace:Eigen::internal
igammac	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    igammac(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
igammac	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^igammac(const Eigen::ArrayBase<Derived>& a, const Eigen::ArrayBase<ExponentDerived>& x)$/;"	f	namespace:Eigen
igammac	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half igammac(const Eigen::half& a, const Eigen::half& x) {$/;"	f	namespace:Eigen::numext
igammac	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    igammac(const Scalar& a, const Scalar& x) {$/;"	f	namespace:Eigen::numext
igammac_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct igammac_impl {$/;"	s	namespace:Eigen::internal
igammac_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct igammac_retval {$/;"	s	namespace:Eigen::internal
ignore_unused_variable	Eigen/src/Core/util/Macros.h	/^    template<typename T> EIGEN_DEVICE_FUNC void ignore_unused_variable(const T&) {}$/;"	f	namespace:Eigen::internal
iia	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    typedef typename A::indices iia;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_equality
iia	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    typedef typename A::indices iia;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_multiply
iib	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    typedef typename B::indices iib;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_equality
iib	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    typedef typename B::indices iib;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_multiply
imag	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return ImagReturnType(derived()); }$/;"	f
imag	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() { return NonConstImagReturnType(derived()); }$/;"	f
imag	test/exceptions.cpp	/^ScalarWithExceptions imag(const ScalarWithExceptions & ) { return 0; }$/;"	f
imag	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    imag() const {$/;"	f	class:Eigen::TensorBase
imag	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline typename DerType::Scalar imag(const AutoDiffScalar<DerType>&)    { return 0.; }$/;"	f	namespace:Eigen
imag_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl$/;"	s	namespace:Eigen::internal
imag_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
imag_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_impl<std::complex<T> >$/;"	s	namespace:Eigen::internal
imag_impl	Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
imag_ref	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref	Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
imag_ref_retval	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
imag_retval	Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
image	Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU
image_retval	Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
image_retval_base	Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base
image_retval_base	Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal
impl	Eigen/src/Core/functors/NullaryFunctors.h	/^  const linspaced_op_impl<Scalar,PacketType,NumTraits<Scalar>::IsInteger> impl;$/;"	m	struct:Eigen::internal::linspaced_op
impl	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<ArgType, Device> & impl() const { return m_argImpl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_argImpl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  const TensorEvaluator<ArgType, Device>& impl() { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
impl	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  const TensorEvaluator<ArgType, Device>& impl() const { return m_impl; }$/;"	f	struct:Eigen::TensorEvaluator
import_input_file_range_one_product_size	bench/analyze-blocking-sizes.cpp	/^  void import_input_file_range_one_product_size($/;"	f	struct:preprocessed_inputfile_t	file:
in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex in_col_strides() const { return m_in_col_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex in_col_strides() const { return m_in_col_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
in_plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex in_plane_strides() const { return m_in_plane_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex in_row_strides() const { return m_in_row_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex in_row_strides() const { return m_in_row_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
incbeta_cfe	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct incbeta_cfe {$/;"	s	namespace:Eigen::internal
incbps	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double incbps(double a, double b, double x) {$/;"	f	struct:Eigen::internal::betainc_helper
incbps	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float incbps(float a, float b, float x) {$/;"	f	struct:Eigen::internal::betainc_helper
incbsa	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE float incbsa(float aa, float bb,$/;"	f	struct:Eigen::internal::betainc_helper
incrRefCount	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  void incrRefCount() { ++m_refcount; }$/;"	f	class:Eigen::internal::TensorLazyBaseEvaluator
incrementToNonZero	Eigen/src/SparseCore/SparseView.h	/^        void incrementToNonZero()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
increment_if_fixed_size	unsupported/test/polynomialsolver.cpp	/^struct increment_if_fixed_size$/;"	s	namespace:Eigen::internal	file:
increment_if_fixed_size	unsupported/test/polynomialutils.cpp	/^struct increment_if_fixed_size$/;"	s	namespace:Eigen::internal	file:
index	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index index() const           { return m_iter.index(); }$/;"	f	class:Eigen::InnerIterator
index	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::internal::inner_iterator_selector
index	Eigen/src/Core/Diagonal.h	/^    inline Index index() const$/;"	f	class:Eigen::Diagonal
index	Eigen/src/Core/Redux.h	/^    index = Start * redux_traits<Func, Derived>::PacketSize,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon490
index	Eigen/src/SparseCore/AmbiVector.h	/^      StorageIndex index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
index	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
index	Eigen/src/SparseCore/CompressedStorage.h	/^    inline StorageIndex& index(Index i) { eigen_internal_assert(m_indices!=0); return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	Eigen/src/SparseCore/CompressedStorage.h	/^    inline const StorageIndex& index(Index i) const { eigen_internal_assert(m_indices!=0); return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	Eigen/src/SparseCore/SparseBlock.h	/^  inline StorageIndex index() const { return EvalIterator::index() - convert_index<StorageIndex>(IsRowMajor ? m_block.startCol() : m_block.startRow()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
index	Eigen/src/SparseCore/SparseBlock.h	/^  inline StorageIndex index() const { return convert_index<StorageIndex>(m_outerPos - (IsRowMajor ? m_eval.m_block.startCol() : m_eval.m_block.startRow())); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
index	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
index	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE StorageIndex index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
index	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline StorageIndex index() const  { return m_sparseIter.index(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
index	Eigen/src/SparseCore/SparseTriangularView.h	/^      inline StorageIndex index() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
index	Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE StorageIndex index() const { return m_inner; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
index	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index index() const { return m_matrix.rowIndex()[m_idrow]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
index	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index index() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
index	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index index() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index index() const { return m_id; }$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
index	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index index() const {return m_mat.m_indices[m_id]; }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
indexPtr	Eigen/src/SparseCore/CompressedStorage.h	/^    StorageIndex* indexPtr() { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
indexPtr	Eigen/src/SparseCore/CompressedStorage.h	/^    const StorageIndex* indexPtr() const { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
index_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_known_statically(DenseIndex i) {$/;"	f	namespace:Eigen::internal
index_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_known_statically_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_known_statically_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_known_statically_impl {$/;"	s	namespace:Eigen::internal
index_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_known_statically_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_known_statically_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_known_statically_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_pair_first_statically_eq	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_pair_first_statically_eq(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_pair_first_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_first_statically_eq_impl {$/;"	s	namespace:Eigen::internal
index_pair_first_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_first_statically_eq_impl<IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_pair_first_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_first_statically_eq_impl<const IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_pair_second_statically_eq	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_pair_second_statically_eq(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_pair_second_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_second_statically_eq_impl {$/;"	s	namespace:Eigen::internal
index_pair_second_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_second_statically_eq_impl<IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_pair_second_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_pair_second_statically_eq_impl<const IndexPairList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_eq	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_statically_eq(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_eq_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_eq_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_eq_impl {$/;"	s	namespace:Eigen::internal
index_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_eq_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_eq_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_eq_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_gt	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_statically_gt(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_statically_gt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_gt_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_gt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_gt_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_gt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_gt_impl {$/;"	s	namespace:Eigen::internal
index_statically_gt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_gt_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_gt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_gt_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_lt	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_statically_lt(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_statically_lt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_lt_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_lt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_lt_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_lt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_lt_impl {$/;"	s	namespace:Eigen::internal
index_statically_lt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_lt_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_lt_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_lt_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_ne	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool index_statically_ne(DenseIndex i, DenseIndex value) {$/;"	f	namespace:Eigen::internal
index_statically_ne_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_ne_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_ne_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct index_statically_ne_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
index_statically_ne_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_ne_impl {$/;"	s	namespace:Eigen::internal
index_statically_ne_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_ne_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_statically_ne_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct index_statically_ne_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
index_tuples	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    index_tuples() const {$/;"	f	class:Eigen::TensorBase
indexing	doc/examples/nullary_indexing.cpp	/^indexing(const Eigen::MatrixBase<ArgType>& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)$/;"	f
indexing_functor	doc/examples/nullary_indexing.cpp	/^  indexing_functor(const ArgType& arg, const RowIndexType& row_indices, const ColIndexType& col_indices)$/;"	f	class:indexing_functor
indexing_functor	doc/examples/nullary_indexing.cpp	/^class indexing_functor {$/;"	c	file:
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	demos/opengl/icosphere.cpp	/^const std::vector<int>& IcoSphere::indices(int level) const$/;"	f	class:IcoSphere
indices	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  const Indices& indices() const { return m_indices; }$/;"	f	class:Eigen::TensorContractionOp
indices	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    const Indices& indices() const { return m_indices; }$/;"	f	class:Eigen::TensorConvolutionOp
indices	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  typedef indices_ indices;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_element
indices_statically_known_to_increase	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bool indices_statically_known_to_increase() {$/;"	f	namespace:Eigen::internal
indices_statically_known_to_increase_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct indices_statically_known_to_increase_impl<DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
indices_statically_known_to_increase_impl	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^struct indices_statically_known_to_increase_impl<const DimensionList<Index, Rank> > {$/;"	s	namespace:Eigen::internal
indices_statically_known_to_increase_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct indices_statically_known_to_increase_impl<IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
indices_statically_known_to_increase_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  struct indices_statically_known_to_increase_impl<const IndexList<FirstType, OtherTypes...> > {$/;"	s	namespace:Eigen::internal
indices_statically_known_to_increase_impl	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct indices_statically_known_to_increase_impl {$/;"	s	namespace:Eigen::internal
infinity	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half infinity() {$/;"	f	struct:Eigen::NumTraits
infinity	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half infinity() { return Eigen::half_impl::raw_uint16_to_half(0x7c00); }$/;"	f	struct:std::numeric_limits
infinity	Eigen/src/Core/util/Meta.h	/^  static T infinity() { assert(false && "Infinity not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
infinity	Eigen/src/Core/util/Meta.h	/^  static double infinity() { return CUDART_INF; }$/;"	f	struct:Eigen::internal::device::numeric_limits
infinity	Eigen/src/Core/util/Meta.h	/^  static float infinity() { return CUDART_INF_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
infinity	unsupported/test/mpreal/mpreal.h	/^        inline static const mpfr::mpreal infinity()         { return mpfr::const_infinity();     }$/;"	f	class:std::numeric_limits
inflate	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    inflate(const Strides& strides) const {$/;"	f	class:Eigen::TensorBase
info	Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT
info	Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT
info	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase
info	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver
info	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur
info	Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver
info	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::GeneralizedEigenSolver
info	Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo info() const$/;"	f	class:Eigen::RealQZ
info	Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur
info	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
info	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::DiagonalPreconditioner
info	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::IdentityPreconditioner
info	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    ComputationInfo info() { return Success; }$/;"	f	class:Eigen::LeastSquareDiagonalPreconditioner
info	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteCholesky
info	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT
info	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase
info	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase
info	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl
info	Eigen/src/QR/ColPivHouseholderQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ColPivHouseholderQR
info	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  ComputationInfo info() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
info	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SPQR
info	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase
info	Eigen/src/SparseLU/SparseLU.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseLU
info	Eigen/src/SparseQR/SparseQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseQR
info	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase
info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU
info	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
info	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LevenbergMarquardt
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT
init	Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::internal::BlockImpl_dense
init	Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor
init	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase
init	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector
init	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase
init	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU
init	doc/examples/TutorialInplaceLU.cpp	/^  init() { std::cout << "[" << "init" << "]" << std::endl; }$/;"	f	struct:init
init	doc/examples/TutorialInplaceLU.cpp	/^struct init {$/;"	s	file:
init	test/exceptions.cpp	/^    void init() {$/;"	f	class:ScalarWithExceptions
init	unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename Iter> void init(Iter begin, Iter end) { init(begin, end, 0, 0); }$/;"	f	class:Eigen::KdBVH
init	unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename OIter, typename BIter> void init(OIter begin, OIter end, BIter boxBegin, BIter boxEnd)$/;"	f	class:Eigen::KdBVH
init	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void init()$/;"	f	class:Eigen::IterationController
init	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void init()$/;"	f	class:Eigen::IterScaling
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacketType& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits
initAssignment	Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix
initFactorization	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase
initFrancisQRStep	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur
initMatrix_identity	bench/BenchUtil.h	/^template<typename MatrixType> void initMatrix_identity(MatrixType& mat)$/;"	f
initMatrix_random	bench/BenchUtil.h	/^template<typename MatrixType> void initMatrix_random(MatrixType& mat)$/;"	f
initNavTree	doc/eigen_navtree_hacks.js	/^function initNavTree(toroot,relpath)$/;"	f
initParallel	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void initParallel(Index rows, Index cols, Index depth, Index num_threads)$/;"	f	class:Eigen::internal::gemm_blocking_space
initParallel	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void initParallel(Index, Index, Index, Index)$/;"	f	class:Eigen::internal::gemm_blocking_space
initParallel	Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen
initParallelSession	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession(Index num_threads) const$/;"	f	struct:Eigen::internal::gemm_functor
initPoints	test/denseLM.cpp	/^  void initPoints(VectorType& uv_ref, VectorType& x)$/;"	f	struct:DenseLM
initPoints	test/sparseLM.cpp	/^  void initPoints(VectorType& uv_ref, VectorType& x)$/;"	f	struct:sparseGaussianTest
initResultRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	263;"	d
initResultRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	282;"	d
initSPD	test/sparse_solvers.cpp	/^initSPD(double density,$/;"	f
initSparse	test/sparse.h	/^initSparse(double density,$/;"	f
init_info	bench/tensors/benchmark_main.cc	/^  static void __attribute__((constructor)) init_info() {$/;"	f	file:
init_matrix	bench/btl/generic_bench/init/init_matrix.hh	/^BTL_DONT_INLINE void init_matrix(Vector &  A, int size){$/;"	f
init_matrix_symm	bench/btl/generic_bench/init/init_matrix.hh	/^BTL_DONT_INLINE void init_matrix_symm(Matrix&  A, int size){$/;"	f
init_obj	doc/examples/TutorialInplaceLU.cpp	/^init init_obj;$/;"	v
init_row	bench/btl/generic_bench/init/init_matrix.hh	/^BTL_DONT_INLINE void init_row(Vector & X, int size, int row){$/;"	f
init_rows_cols	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static IndexType init_rows_cols  \/* returns true if OK, or false otherwise *\/$/;"	f	namespace:internal
init_scoring	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring$/;"	f	namespace:internal
init_vector	bench/btl/generic_bench/init/init_vector.hh	/^void init_vector(Vector & X, int size){$/;"	f
initial	bench/btl/generic_bench/timers/STL_timer.hh	/^  time_t initial, final;$/;"	m	class:STL_Timer
initialize	bench/btl/actions/action_aat_product.hh	/^  inline void initialize( void ){$/;"	f	class:Action_aat_product
initialize	bench/btl/actions/action_ata_product.hh	/^  inline void initialize( void ){$/;"	f	class:Action_ata_product
initialize	bench/btl/actions/action_atv_product.hh	/^  inline void initialize( void ){$/;"	f	class:Action_atv_product
initialize	bench/btl/actions/action_axpby.hh	/^  inline void initialize( void ){$/;"	f	class:Action_axpby
initialize	bench/btl/actions/action_axpy.hh	/^  inline void initialize( void ){$/;"	f	class:Action_axpy
initialize	bench/btl/actions/action_cholesky.hh	/^  inline void initialize( void ){$/;"	f	class:Action_cholesky
initialize	bench/btl/actions/action_ger.hh	/^  BTL_DONT_INLINE  void initialize( void ){$/;"	f	class:Action_ger
initialize	bench/btl/actions/action_hessenberg.hh	/^  inline void initialize( void ){$/;"	f	class:Action_hessenberg
initialize	bench/btl/actions/action_hessenberg.hh	/^  inline void initialize( void ){$/;"	f	class:Action_tridiagonalization
initialize	bench/btl/actions/action_lu_decomp.hh	/^  inline void initialize( void ){$/;"	f	class:Action_lu_decomp
initialize	bench/btl/actions/action_matrix_matrix_product.hh	/^  inline void initialize( void ){$/;"	f	class:Action_matrix_matrix_product
initialize	bench/btl/actions/action_matrix_vector_product.hh	/^  BTL_DONT_INLINE  void initialize( void ){$/;"	f	class:Action_matrix_vector_product
initialize	bench/btl/actions/action_partial_lu.hh	/^  inline void initialize( void ){$/;"	f	class:Action_partial_lu
initialize	bench/btl/actions/action_rot.hh	/^  BTL_DONT_INLINE  void initialize( void ){$/;"	f	class:Action_rot
initialize	bench/btl/actions/action_symv.hh	/^  BTL_DONT_INLINE  void initialize( void ){$/;"	f	class:Action_symv
initialize	bench/btl/actions/action_syr2.hh	/^  BTL_DONT_INLINE  void initialize( void ){$/;"	f	class:Action_syr2
initialize	bench/btl/actions/action_trisolve.hh	/^  inline void initialize( void ){$/;"	f	class:Action_trisolve
initialize	bench/btl/actions/action_trisolve_matrix.hh	/^  inline void initialize( void ){$/;"	f	class:Action_trisolve_matrix
initialize	bench/btl/actions/action_trmm.hh	/^  inline void initialize( void ){$/;"	f	class:Action_trmm
initialize	bench/tensors/tensor_benchmarks.h	/^  void initialize() {$/;"	f	class:BenchmarkSuite
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::ArgMaxTupleReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::ArgMinTupleReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::MaxReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::MeanReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::MinReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::ProdReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {$/;"	f	struct:Eigen::internal::SumReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool initialize() const {$/;"	f	struct:Eigen::internal::AndReducer
initialize	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool initialize() const {$/;"	f	struct:Eigen::internal::OrReducer
initialize	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPower<MatrixType>::initialize()$/;"	f	class:Eigen::MatrixPower
initialize	unsupported/test/cxx11_tensor_reduction.cpp	/^  float initialize() const { return 0; }$/;"	f	struct:UserReducer
initializeDeviceProp	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static void initializeDeviceProp() {$/;"	f	namespace:Eigen
initializeGL	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::initializeGL()$/;"	f	class:RenderingWidget
initializePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {$/;"	f	struct:Eigen::internal::MaxReducer
initializePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {$/;"	f	struct:Eigen::internal::MeanReducer
initializePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {$/;"	f	struct:Eigen::internal::MinReducer
initializePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {$/;"	f	struct:Eigen::internal::ProdReducer
initializePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {$/;"	f	struct:Eigen::internal::SumReducer
initialize_tensor	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^void initialize_tensor(TensorEvaluator<Derived, DefaultDevice>& tensor,$/;"	f	namespace:Eigen::internal
initperfvalues	Eigen/src/SparseLU/SparseLU.h	/^    void initperfvalues()$/;"	f	class:Eigen::SparseLU
inner	Eigen/src/Core/AssignEvaluator.h	/^    inner = Index % DstXprType::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling::__anon511
inner	Eigen/src/Core/AssignEvaluator.h	/^    inner = Index % DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon512
inner	Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon488
inner	Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon490
inner	Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride
inner	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const TensorEvaluator<ArgType, Device>& inner() const {$/;"	f	struct:Eigen::TensorEvaluator
innerBlocks	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index innerBlocks() const { return m_innerBSize; }$/;"	f	class:Eigen::BlockSparseMatrix
innerInd	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon865
innerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* innerIndexPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* innerIndexPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerIndexPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* innerIndexPtr() { return derived().innerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerIndexPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* innerIndexPtr() const { return derived().innerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerIndexPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* innerIndexPtr()   { return Base::m_innerIndices; }$/;"	f	class:Eigen::SparseMapBase
innerIndexPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::SparseMapBase
innerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* innerIndexPtr() { return derived().nestedExpression().innerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerIndexPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* innerIndexPtr() const { return derived().nestedExpression().innerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE StorageIndex* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const StorageIndex* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerIndexPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline StorageIndex *innerIndexPtr() {return m_indices; }$/;"	f	class:Eigen::BlockSparseMatrix
innerIndexPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline const StorageIndex *innerIndexPtr() const {return m_indices; }$/;"	f	class:Eigen::BlockSparseMatrix
innerNonZeroPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* innerNonZeroPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerNonZeroPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* innerNonZeroPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
innerNonZeroPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* innerNonZeroPtr() { return derived().innerNonZeroPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeroPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return derived().innerNonZeroPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeroPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* innerNonZeroPtr() { return Base::m_innerNonZeros; }$/;"	f	class:Eigen::SparseMapBase
innerNonZeroPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMapBase
innerNonZeroPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* innerNonZeroPtr() { return derived().nestedExpression().innerNonZeroPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerNonZeroPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return derived().nestedExpression().innerNonZeroPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
innerNonZeroPtr	Eigen/src/SparseCore/SparseVector.h	/^    inline StorageIndex* innerNonZeroPtr() { return 0; }$/;"	f	class:Eigen::SparseVector
innerNonZeroPtr	Eigen/src/SparseCore/SparseVector.h	/^    inline const StorageIndex* innerNonZeroPtr() const { return 0; }$/;"	f	class:Eigen::SparseVector
innerNonZeros	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Eigen::Map<IndexVector> innerNonZeros() { return Eigen::Map<IndexVector>(innerNonZeroPtr(), isCompressed()?0:derived().outerSize()); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeros	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const  Eigen::Map<const IndexVector> innerNonZeros() const { return Eigen::Map<const IndexVector>(innerNonZeroPtr(), isCompressed()?0:derived().outerSize()); }$/;"	f	class:Eigen::SparseCompressedBase
innerNonZeros	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index innerNonZeros(Index j) const { return m_data[j].size(); }$/;"	f	class:Eigen::DynamicSparseMatrix
innerSize	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index innerSize() const   { return m_dstExpr.innerSize(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
innerSize	Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase
innerSize	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index innerSize() const { return m_xpr.innerSize(); }$/;"	f	class:Eigen::internal::redux_evaluator
innerSize	Eigen/src/SparseCore/SparseMap.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMapBase
innerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
innerSize	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase
innerSize	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector
innerSize	Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView
innerSize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index innerSize() const {$/;"	f	class:Eigen::SkylineMatrix
innerSize	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Index innerSize() const {$/;"	f	class:Eigen::SkylineMatrixBase
innerSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index innerSize() const$/;"	f	class:Eigen::BlockSparseMatrix
innerSize	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::DynamicSparseMatrix
innerStride	Eigen/src/Core/Array.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array
innerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper
innerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper
innerStride	Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
innerStride	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
innerStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
innerStride	Eigen/src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal
innerStride	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
innerStride	Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map
innerStride	Eigen/src/Core/Matrix.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix
innerStride	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue
innerStride	Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::RefBase
innerStride	Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const$/;"	f	class:Eigen::Reverse
innerStride	Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView
innerStride	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl
innerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase
innerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TriangularViewImpl
innerToBlock	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index innerToBlock(Index inner) const$/;"	f	class:Eigen::BlockSparseMatrix
innerVector	Eigen/src/SparseCore/SparseBlock.h	/^const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase
innerVector	Eigen/src/SparseCore/SparseBlock.h	/^typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase
inner_iterator_selector	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector(const EvaluatorType &eval, const Index &outerId, const Index &\/*innerSize*\/)$/;"	f	class:Eigen::internal::inner_iterator_selector
inner_iterator_selector	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector(const EvaluatorType &eval, const Index &outerId, const Index &innerSize)$/;"	f	class:Eigen::internal::inner_iterator_selector
inner_iterator_selector	Eigen/src/Core/CoreIterators.h	/^class inner_iterator_selector<XprType, IndexBased>$/;"	c	namespace:Eigen::internal
inner_iterator_selector	Eigen/src/Core/CoreIterators.h	/^class inner_iterator_selector<XprType, IteratorBased>$/;"	c	namespace:Eigen::internal
inner_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
innervec	test/sparse_block.cpp	/^innervec(T& A, Index i)$/;"	f
inplace	test/inplace_decomposition.cpp	/^template<typename DecType,typename MatrixType> void inplace(bool square = false, bool SPD = false)$/;"	f
inplace_decomposition	Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits
inplace_transpose_selector	Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false,MatchPacketSize> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true,false> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true,true> { \/\/ PacketSize x PacketSize$/;"	s	namespace:Eigen::internal
inputExpression	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    inputExpression() const { return m_input_xpr; }$/;"	f	class:Eigen::TensorConvolutionOp
inputfile_entry_t	bench/analyze-blocking-sizes.cpp	/^struct inputfile_entry_t$/;"	s	file:
inputfile_t	bench/analyze-blocking-sizes.cpp	/^  inputfile_t(const string& fname)$/;"	f	struct:inputfile_t
inputfile_t	bench/analyze-blocking-sizes.cpp	/^struct inputfile_t$/;"	s	file:
inputs	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Eigen::DenseFunctor
inputs	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Eigen::SparseFunctor
inputs	unsupported/test/NonLinearOptimization.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Functor
inputs	unsupported/test/NumericalDiff.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Functor
inputs	unsupported/test/autodiff.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:TestFunc1
inputs	unsupported/test/forward_adolc.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:TestFunc1
insert	Eigen/src/SparseCore/SparseMatrix.h	/^typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert	Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector
insert	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector
insert	Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque
insert	Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque
insert	Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list
insert	Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list
insert	Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector
insert	Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector
insert	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    EIGEN_DONT_INLINE Scalar & insert(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
insert	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
insertBack	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBack	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector
insertBack	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
insertBackByOuterInner	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInner	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInner	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DynamicSparseMatrix
insertBackByOuterInnerUnordered	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInnerUnordered	Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackUncompressed	Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_STRONG_INLINE Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBackUnordered	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackUnordered(Index i)$/;"	f	class:Eigen::SparseVector
insertByOuterInner	Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix
insertCoefficient	doc/special_examples/Tutorial_sparse_example_details.cpp	/^void insertCoefficient(int id, int i, int j, double w, std::vector<T>& coeffs,$/;"	f
insertCompressed	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertUncompressed	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_StorageIndex>::Scalar& SparseMatrix<_Scalar,_Options,_StorageIndex>::insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
instances	test/exceptions.cpp	/^    static int instances;$/;"	m	class:ScalarWithExceptions	file:
instances	test/exceptions.cpp	/^int ScalarWithExceptions::instances = 0;$/;"	m	class:ScalarWithExceptions	file:
int64	test/rand.cpp	/^typedef long long int64;$/;"	t	file:
integer	blas/f2c/datatypes.h	/^typedef int integer;$/;"	t
integer_type_tests	test/integer_types.cpp	/^template<typename MatrixType> void integer_type_tests(const MatrixType& m)$/;"	f
integratorFunctor	unsupported/test/autodiff.cpp	/^    integratorFunctor(const Scalar gain) : _gain(gain) {}$/;"	f	struct:integratorFunctor
integratorFunctor	unsupported/test/autodiff.cpp	/^    integratorFunctor(const integratorFunctor& f) : _gain(f._gain) {}$/;"	f	struct:integratorFunctor
integratorFunctor	unsupported/test/autodiff.cpp	/^struct integratorFunctor$/;"	s	file:
internal	Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/AssignEvaluator.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ConditionEstimator.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CoreEvaluators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CoreIterators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseTernaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/MathFunctionsImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/NumTraits.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Product.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ProductEvaluators.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Ref.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AVX512/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/Half.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/NEON/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/TypeCasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/ZVector/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/ZVector/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/AssignmentFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/BinaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/NullaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/StlFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/TernaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/functors/UnaryFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Constants.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Macros.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/InverseImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/PartialPivLU_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^namespace internal {$/;"	n
internal	Eigen/src/OrderingMethods/Ordering.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/HouseholderQR_LAPACKE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SVD/BDCSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseAssign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseColEtree.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseCompressedBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseMap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseRef.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseTranspose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLUImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseQR/SparseQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/RealSvd2x2.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	bench/bench_norm.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal	blas/BandTriangularSolver.h	/^namespace internal {$/;"	n
internal	blas/GeneralRank1Update.h	/^namespace internal {$/;"	n
internal	blas/PackedSelfadjointProduct.h	/^namespace internal {$/;"	n
internal	blas/PackedTriangularMatrixVector.h	/^namespace internal {$/;"	n
internal	blas/PackedTriangularSolverVector.h	/^namespace internal {$/;"	n
internal	blas/Rank2Update.h	/^namespace internal {$/;"	n
internal	blas/level1_cplx_impl.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	doc/examples/matrixfree_cg.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal	test/boostmultiprec.cpp	/^  namespace internal {$/;"	n	namespace:Eigen	file:
internal	test/evaluators.cpp	/^  namespace internal {$/;"	n	namespace:Eigen	file:
internal	test/main.h	/^      namespace internal$/;"	n	namespace:Eigen
internal	test/packetmath.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSycl.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclConvertToDeviceExpression.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExprConstructor.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclLeafCount.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorSyclPlaceHolderExpr.h	/^namespace internal {$/;"	n	namespace:Eigen::TensorSycl
internal	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/util/CXX11Workarounds.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/BVH/KdBVH.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/LevenbergMarquardt/LMcovar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/LevenbergMarquardt/LMpar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/LevenbergMarquardt/LMqrsolv.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^namespace internal { $/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/covar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/Polynomials/Companion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^namespace internal $/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	unsupported/test/mpreal/mpreal.h	/^namespace internal{$/;"	n	namespace:mpfr
internal	unsupported/test/polynomialsolver.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal	unsupported/test/polynomialutils.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
intersectObject	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectObject(const Object1 &obj) { return intersector.intersectObjectObject(obj, stored); }$/;"	f	struct:Eigen::internal::intersector_helper1
intersectObject	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectObject(const Object2 &obj) { return intersector.intersectObjectObject(stored, obj); }$/;"	f	struct:Eigen::internal::intersector_helper2
intersectObject	unsupported/test/BVH.cpp	/^  bool intersectObject(const BallType &b) {$/;"	f	struct:BallPointStuff
intersectObjectObject	unsupported/test/BVH.cpp	/^  bool intersectObjectObject(const BallType &b, const VectorType &v){$/;"	f	struct:BallPointStuff
intersectObjectObject	unsupported/test/BVH.cpp	/^  bool intersectObjectObject(const BallType &b1, const BallType &b2){$/;"	f	struct:BallPointStuff
intersectObjectVolume	unsupported/test/BVH.cpp	/^  bool intersectObjectVolume(const BallType &b, const BoxType &r) { ++calls; return r.squaredExteriorDistance(b.center) < SQR(b.radius); }$/;"	f	struct:BallPointStuff
intersectVolume	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectVolume(const Volume1 &vol) { return intersector.intersectVolumeObject(vol, stored); }$/;"	f	struct:Eigen::internal::intersector_helper1
intersectVolume	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectVolume(const Volume2 &vol) { return intersector.intersectObjectVolume(stored, vol); }$/;"	f	struct:Eigen::internal::intersector_helper2
intersectVolume	unsupported/test/BVH.cpp	/^  bool intersectVolume(const BoxType &r) { ++calls; return r.contains(p); }$/;"	f	struct:BallPointStuff
intersectVolumeObject	unsupported/test/BVH.cpp	/^  bool intersectVolumeObject(const BoxType &r, const BallType &b) { ++calls; return r.squaredExteriorDistance(b.center) < SQR(b.radius); }$/;"	f	struct:BallPointStuff
intersectVolumeObject	unsupported/test/BVH.cpp	/^  bool intersectVolumeObject(const BoxType &r, const VectorType &v) { ++calls; return r.contains(v); }$/;"	f	struct:BallPointStuff
intersectVolumeVolume	unsupported/test/BVH.cpp	/^  bool intersectVolumeVolume(const BoxType &r1, const BoxType &r2) { ++calls; return !(r1.intersection(r2)).isNull(); }$/;"	f	struct:BallPointStuff
intersect_helper	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^bool intersect_helper(const BVH &tree, Intersector &intersector, typename BVH::Index root)$/;"	f	namespace:Eigen::internal
intersection	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
intersection	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane
intersection	Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionParameter	Eigen/src/Geometry/ParametrizedLine.h	/^EIGEN_DEVICE_FUNC inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionPoint	Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersector	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Intersector &intersector;$/;"	m	struct:Eigen::internal::intersector_helper1
intersector	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Intersector &intersector;$/;"	m	struct:Eigen::internal::intersector_helper2
intersector_helper1	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  intersector_helper1(const Object2 &inStored, Intersector &in) : stored(inStored), intersector(in) {}$/;"	f	struct:Eigen::internal::intersector_helper1
intersector_helper1	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct intersector_helper1$/;"	s	namespace:Eigen::internal
intersector_helper2	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  intersector_helper2(const Object1 &inStored, Intersector &in) : stored(inStored), intersector(in) {}$/;"	f	struct:Eigen::internal::intersector_helper2
intersector_helper2	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct intersector_helper2$/;"	s	namespace:Eigen::internal
intersects	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool intersects(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
intone	bench/bench_gemm.cpp	/^static int intone = 1;$/;"	v	file:
intone	bench/btl/libs/BLAS/blas_interface.hh	/^static int intone = 1;$/;"	v
inv	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv( Scalar * dst,const Complex * src,int nfft) $/;"	f	struct:Eigen::internal::fftw_impl
inv	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(Complex * dst,const Complex  *src,int nfft)$/;"	f	struct:Eigen::internal::fftw_impl
inv	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(complex_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
inv	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(scalar_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
inv	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv( Scalar * dst,const Complex * src,int nfft) $/;"	f	struct:Eigen::internal::kissfft_impl
inv	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv(Complex * dst,const Complex  *src,int nfft)$/;"	f	struct:Eigen::internal::kissfft_impl
inv2	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv2( complex_type * dst,complex_type * src,int n0,int n1) {$/;"	f	struct:Eigen::internal::fftw_plan
inv2	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv2(Complex * dst, const Complex * src, int n0,int n1)$/;"	f	struct:Eigen::internal::fftw_impl
inv2	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv2( Complex * dst,const Complex *src,int n0,int n1)$/;"	f	struct:Eigen::internal::kissfft_impl
inv_cond	doc/examples/function_taking_ref.cpp	/^float inv_cond(const Ref<const MatrixXf>& a)$/;"	f
inverse	Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase
inverse	Eigen/src/Core/PermutationMatrix.h	/^    inline InverseReturnType inverse() const$/;"	f	class:Eigen::PermutationBase
inverse	Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase
inverse	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase
inverse	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D inverse() const { return Rotation2D(-m_angle); }$/;"	f	class:Eigen::Rotation2D
inverse	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling
inverse	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform
inverse	Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence
inverse	Eigen/src/LU/FullPivLU.h	/^    inline const Inverse<FullPivLU> inverse() const$/;"	f	class:Eigen::FullPivLU
inverse	Eigen/src/LU/InverseImpl.h	/^inline const Inverse<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase
inverse	Eigen/src/LU/PartialPivLU.h	/^    inline const Inverse<PartialPivLU> inverse() const$/;"	f	class:Eigen::PartialPivLU
inverse	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline const Inverse<ColPivHouseholderQR> inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR
inverse	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline const Inverse<FullPivHouseholderQR> inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR
inverse	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f
inverse	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^Matrix3d inverse;$/;"	v
inverse	doc/snippets/MatrixBase_computeInverseWithCheck.cpp	/^Matrix3d inverse;$/;"	v
inverse	test/inverse.cpp	/^template<typename MatrixType> void inverse(const MatrixType& m)$/;"	f
inverse	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    inverse() const {$/;"	f	class:Eigen::TensorBase
inverse	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles inverse() const$/;"	f	class:Eigen::EulerAngles
inverse_general_4x4	test/prec_inverse_4x4.cpp	/^template<typename MatrixType> void inverse_general_4x4(int repeat)$/;"	f
inverse_permutation_4x4	test/prec_inverse_4x4.cpp	/^template<typename MatrixType> void inverse_permutation_4x4()$/;"	f
invertible	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^bool invertible;$/;"	v
invertible	doc/snippets/MatrixBase_computeInverseWithCheck.cpp	/^bool invertible;$/;"	v
invokation_name	bench/analyze-blocking-sizes.cpp	/^  virtual const char* invokation_name() const { abort(); return nullptr; }$/;"	f	struct:action_t
iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<StorageIndex,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase
iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase
isApprox	Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApprox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox
isApprox	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis
isApprox	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane
isApprox	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const ParametrizedLine& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase
isApprox	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D
isApprox	Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling
isApprox	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform
isApprox	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC bool isApprox(const Translation& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation
isApprox	Eigen/src/SparseCore/SparseFuzzy.h	/^bool SparseMatrixBase<Derived>::isApprox(const SparseMatrixBase<OtherDerived>& other, const RealScalar &prec) const$/;"	f	class:Eigen::SparseMatrixBase
isApprox	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApproxAbs	test/packetmath.cpp	/^bool isApproxAbs(const Scalar& a, const Scalar& b, const typename NumTraits<Scalar>::Real& refvalue)$/;"	f
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApproxToConstant	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase
isApprox_selector	Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApprox_selector	Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isCompressed	Eigen/src/SparseCore/SparseBlock.h	/^    bool isCompressed() const { return m_matrix.innerNonZeroPtr()==0; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
isCompressed	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline bool isCompressed() const { return innerNonZeroPtr()==0; }$/;"	f	class:Eigen::SparseCompressedBase
isCompressed	Eigen/src/SparseCore/SparseMap.h	/^    bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMapBase
isCompressed	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline bool isCompressed() const {return true;}$/;"	f	class:Eigen::BlockSparseMatrix
isConstant	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase
isDeviceSuitable	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  bool isDeviceSuitable() const { return true; }$/;"	f	struct:Eigen::SyclDevice
isDiagonal	Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isDynGroup	unsupported/test/cxx11_tensor_symmetry.cpp	/^bool isDynGroup(DynamicSGroup const& dummy)$/;"	f
isDynGroup	unsupported/test/cxx11_tensor_symmetry.cpp	/^bool isDynGroup(StaticSGroup<Sym...> const& dummy)$/;"	f
isEmpty	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox
isEqualFuzzy	unsupported/test/mpreal/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
isEqualFuzzy	unsupported/test/mpreal/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b, const mpreal& eps)$/;"	f	namespace:mpfr
isEqualUlps	unsupported/test/mpreal/mpreal.h	/^inline bool isEqualUlps(const mpreal& a, const mpreal& b, int maxUlps)$/;"	f	namespace:mpfr
isEquiv	bench/btl/generic_bench/btl.hh	/^    bool isEquiv(const BtlString& str) const$/;"	f	class:BtlString
isFinite	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isFinite() const$/;"	f
isFolderValid	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool isFolderValid() { return bool(m_folder_id); }$/;"	f	class:Eigen::MatrixMarketIterator
isHorizontal	Eigen/src/Core/VectorwiseOp.h	/^      isHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon640
isId	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      bool isId() const$/;"	f	struct:Eigen::DynamicSGroup::GroupElement
isIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase
isInf	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isInf() const$/;"	f
isInjective	Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU
isInjective	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInjective	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isInjective() const { return m_cpqr.isInjective(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isInjective	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isInvertible	Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU
isInvertible	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInvertible	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isInvertible() const { return m_cpqr.isInvertible(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isInvertible	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR
isLeftPaddingCompileTimeZero	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool isLeftPaddingCompileTimeZero($/;"	f	struct:Eigen::TensorEvaluator
isLowerTriangular	Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isMinusInf	test/main.h	/^template<typename T> bool isMinusInf(const T& x)$/;"	f	namespace:Eigen
isMuchSmallerThan	Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal
isMuchSmallerThan_object_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isNaN	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^isNaN() const$/;"	f
isNegative	Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT
isNotNaN	test/main.h	/^template<typename T> bool isNotNaN(const T& x)$/;"	f	namespace:Eigen
isNull	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox
isOfNormalIndex	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    struct isOfNormalIndex{$/;"	s	class:Eigen::Tensor
isOnes	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase
isOrthogonal	Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase
isPaddingAtIndexForDim	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool isPaddingAtIndexForDim($/;"	f	struct:Eigen::TensorEvaluator
isPlusInf	test/main.h	/^template<typename T> bool isPlusInf(const T& x)$/;"	f	namespace:Eigen
isPositive	Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT
isPowerOfTwo	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE static bool isPowerOfTwo(Index x) {$/;"	f	struct:Eigen::TensorEvaluator
isRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase
isRValue	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    bool isRValue() const {$/;"	f	class:Eigen::SkylineMatrixBase
isRightPaddingCompileTimeZero	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool isRightPaddingCompileTimeZero($/;"	f	struct:Eigen::TensorEvaluator
isSurjective	Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU
isSurjective	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isSurjective	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline bool isSurjective() const { return m_cpqr.isSurjective(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
isSurjective	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isSymmetric	Eigen/src/SparseLU/SparseLU.h	/^    void isSymmetric(bool sym)$/;"	f	class:Eigen::SparseLU
isUnitary	Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isUpperTriangular	Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isVector	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase
isVertical	Eigen/src/Core/VectorwiseOp.h	/^      isVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon640
isZero	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isZero(const RealScalar& prec) const$/;"	f	class:Eigen::DenseBase
is_aligned	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    is_aligned =$/;"	e	enum:Eigen::internal::compute_tensor_flags::__anon157
is_arithmetic	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512> {$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512d> {$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct is_arithmetic<__m512i> {$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct is_arithmetic<half> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<double2> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<float4>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct is_arithmetic<half2> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_array	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      static const bool is_array = internal::is_base_of<array<Index, NumIndices>, CustomIndices>::value;$/;"	m	struct:Eigen::Tensor::isOfNormalIndex
is_base_of	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  struct is_base_of$/;"	s	namespace:Eigen::internal
is_bounded	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_bounded = false;$/;"	m	struct:std::numeric_limits
is_bounded	unsupported/test/mpreal/mpreal.h	/^        static const bool is_bounded        = true;$/;"	m	class:std::numeric_limits
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<const type2index<idx> > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<const type2index<idx>& > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<const type2indexpair<f, s> > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<const type2indexpair<f, s>& > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<type2index<idx> > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<type2index<idx>& > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<type2indexpair<f, s> > {$/;"	s	namespace:Eigen::internal
is_compile_time_constant	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct is_compile_time_constant<type2indexpair<f, s>& > {$/;"	s	namespace:Eigen::internal
is_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_convertible	Eigen/src/Core/util/Meta.h	/^struct is_convertible$/;"	s	namespace:Eigen::internal
is_convertible_impl	Eigen/src/Core/util/Meta.h	/^struct is_convertible_impl$/;"	s	namespace:Eigen::internal
is_cubic	bench/analyze-blocking-sizes.cpp	/^  bool is_cubic() const { return k == m && m == n; }$/;"	f	struct:size_triple_t
is_dynamic_size_storage	Eigen/src/Core/Matrix.h	/^      is_dynamic_size_storage = _MaxRows==Dynamic || _MaxCols==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon438
is_dynamic_size_storage	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    is_dynamic_size_storage = 1,$/;"	e	enum:Eigen::internal::compute_tensor_flags::__anon157
is_exact	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_exact = false;$/;"	m	struct:std::numeric_limits
is_exact	unsupported/test/mpreal/mpreal.h	/^        static const bool is_exact          = false;$/;"	m	class:std::numeric_limits
is_exp_known_type	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<> struct is_exp_known_type<double> : true_type {};$/;"	s	namespace:Eigen::internal
is_exp_known_type	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<> struct is_exp_known_type<float> : true_type {};$/;"	s	namespace:Eigen::internal
is_exp_known_type	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<> struct is_exp_known_type<long double> : true_type {};$/;"	s	namespace:Eigen::internal
is_exp_known_type	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<typename T> struct is_exp_known_type : false_type {};$/;"	s	namespace:Eigen::internal
is_iec559	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_iec559 = false;$/;"	m	struct:std::numeric_limits
is_iec559	unsupported/test/mpreal/mpreal.h	/^        static const bool is_iec559         = true;        \/\/ = IEEE 754$/;"	m	class:std::numeric_limits
is_imag	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static bool is_imag      = value && flags_cmp_ == (NegationFlag | ConjugationFlag);$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
is_input_scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct is_input_scalar {$/;"	s	namespace:Eigen::internal
is_input_scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct is_input_scalar<Sizes<> > {$/;"	s	namespace:Eigen::internal
is_input_scalar	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct is_input_scalar<Sizes<Indices...> > {$/;"	s	namespace:Eigen::internal
is_int	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      static const bool is_int = NumTraits<CustomIndices>::IsInteger;$/;"	m	struct:Eigen::Tensor::isOfNormalIndex
is_integer	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_integer = false;$/;"	m	struct:std::numeric_limits
is_integer	unsupported/test/mpreal/mpreal.h	/^        static const bool is_integer        = false;$/;"	m	class:std::numeric_limits
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<bool>            { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<char>            { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed char>     { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed int>      { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed long>     { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed short>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_integral	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_integral        { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_large	Eigen/src/Core/GeneralProduct.h	/^    is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon288
is_last_subset	bench/analyze-blocking-sizes.cpp	/^bool is_last_subset(const vector<size_t>& subset, size_t set_size)$/;"	f
is_malloc_allowed	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal
is_malloc_allowed_impl	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal
is_modulo	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_modulo = false;$/;"	m	struct:std::numeric_limits
is_modulo	unsupported/test/mpreal/mpreal.h	/^        static const bool is_modulo         = false;$/;"	m	class:std::numeric_limits
is_number_of_subsets_feasible	bench/analyze-blocking-sizes.cpp	/^bool is_number_of_subsets_feasible(size_t n, size_t p)$/;"	f
is_real	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static bool is_real      = value && flags_cmp_ == ConjugationFlag;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
is_ref_compatible	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct is_ref_compatible$/;"	s	namespace:Eigen::internal
is_ref_compatible_impl	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct is_ref_compatible_impl$/;"	s	namespace:Eigen::internal
is_row_major	Eigen/src/Core/ProductEvaluators.h	/^  template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};$/;"	s	struct:Eigen::internal::generic_product_impl
is_same	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_same	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_same_gf	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename b> struct is_same_gf : is_same<a, b> { constexpr static int global_flags = 0; };$/;"	s	namespace:Eigen::internal
is_signed	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_signed = true;$/;"	m	struct:std::numeric_limits
is_signed	unsupported/test/mpreal/mpreal.h	/^        static const bool is_signed         = true;$/;"	m	class:std::numeric_limits
is_sorted	test/sparse_permutations.cpp	/^bool is_sorted(const T& mat) {$/;"	f
is_specialized	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool is_specialized = true;$/;"	m	struct:std::numeric_limits
is_specialized	unsupported/test/mpreal/mpreal.h	/^        static const bool is_specialized    = true;$/;"	m	class:std::numeric_limits
is_zero	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static bool is_zero      = value && flags_cmp_ == NegationFlag;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
isfinite	Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isfinite)(const T &x) { return internal::isfinite_impl(x); }$/;"	f	namespace:Eigen::numext
isfinite	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isfinite)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isfinite	Eigen/src/Core/arch/CUDA/Half.h	/^bool (isfinite)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isfinite	test/boostmultiprec.cpp	64;"	d	file:
isfinite	test/fastmath.cpp	/^  template<typename T> bool (isfinite)(T x) { return _finite(x); }$/;"	f	namespace:std
isfinite	test/main.h	74;"	d
isfinite	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    (isfinite)() const {$/;"	f	class:Eigen::TensorBase
isfinite	unsupported/test/mpreal/mpreal.h	/^inline bool (isfinite) (const mpreal& op){    return (mpfr_number_p (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isfinite_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isfinite_impl	Eigen/src/Core/MathFunctions.h	/^isfinite_impl(const T& x)$/;"	f	namespace:Eigen::internal
isfinite_impl	Eigen/src/Core/MathFunctions.h	/^isfinite_impl(const T&) { return true; }$/;"	f	namespace:Eigen::internal
isinf	Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isinf)   (const T &x) { return internal::isinf_impl(x); }$/;"	f	namespace:Eigen::numext
isinf	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isinf)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isinf	Eigen/src/Core/arch/CUDA/Half.h	/^bool (isinf)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isinf	test/boostmultiprec.cpp	63;"	d	file:
isinf	test/fastmath.cpp	/^  template<typename T> bool (isinf)(T x) { return _fpclass(x)==_FPCLASS_NINF || _fpclass(x)==_FPCLASS_PINF; }$/;"	f	namespace:std
isinf	test/main.h	73;"	d
isinf	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    (isinf)() const {$/;"	f	class:Eigen::TensorBase
isinf	unsupported/test/mpreal/mpreal.h	/^inline bool (isinf)    (const mpreal& op){    return (mpfr_inf_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isinf_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isinf_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const double& x)      { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const float& x)       { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isinf_impl(const long double& x) { return isinf_msvc_helper(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^isinf_impl(const T& x)$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^isinf_impl(const T&) { return false; }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const double& x)      { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const float& x)       { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isinf_impl(const long double& x) { return __builtin_isinf(x); }$/;"	f	namespace:Eigen::internal
isinf_msvc_helper	Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool isinf_msvc_helper(T x)$/;"	f	namespace:Eigen::internal
isint	unsupported/test/mpreal/mpreal.h	/^inline bool isint    (const mpreal& op){    return (mpfr_integer_p(op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isnan	Eigen/src/Core/MathFunctions.h	/^template<typename T> EIGEN_DEVICE_FUNC bool (isnan)   (const T &x) { return internal::isnan_impl(x); }$/;"	f	namespace:Eigen::numext
isnan	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isnan)(const half& a) {$/;"	f	namespace:Eigen::half_impl
isnan	Eigen/src/Core/arch/CUDA/Half.h	/^bool (isnan)(const Eigen::half& h) {$/;"	f	namespace:Eigen::numext
isnan	test/boostmultiprec.cpp	62;"	d	file:
isnan	test/fastmath.cpp	/^  template<typename T> bool (isnan)(T x) { return _isnan(x); }$/;"	f	namespace:std
isnan	test/main.h	72;"	d
isnan	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    (isnan)() const {$/;"	f	class:Eigen::TensorBase
isnan	unsupported/test/mpreal/mpreal.h	/^inline bool (isnan)    (const mpreal& op){    return (mpfr_nan_p    (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
isnan_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC bool isnan_impl(const std::complex<T>& x)$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const double& x)      { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const float& x)       { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^EIGEN_DEVICE_FUNC inline bool isnan_impl(const long double& x) { return _isnan(x)!=0; }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^isnan_impl(const T& x)$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^isnan_impl(const T&) { return false; }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const double& x)      { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const float& x)       { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
isnan_impl	Eigen/src/Core/MathFunctions.h	/^template<> EIGEN_TMP_NOOPT_ATTRIB bool isnan_impl(const long double& x) { return __builtin_isnan(x); }$/;"	f	namespace:Eigen::internal
isosamples	bench/btl/data/gnuplot_common_settings.hh	/^set isosamples 10, 10$/;"	v
isregular	unsupported/test/mpreal/mpreal.h	/^inline bool isregular(const mpreal& op){    return (mpfr_regular_p(op.mpfr_srcptr()));}$/;"	f	namespace:mpfr
iszero	unsupported/test/mpreal/mpreal.h	/^inline bool iszero   (const mpreal& op){    return (mpfr_zero_p   (op.mpfr_srcptr()) != 0 );    }$/;"	f	namespace:mpfr
itb	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockInnerIterator itb; \/\/ Iterator through the blocks$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
iter	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index iter;$/;"	m	class:Eigen::HybridNonLinearSolver
iter	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index iter;$/;"	m	class:Eigen::LevenbergMarquardt
iteration	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t iteration() const { return m_nit; }$/;"	f	class:Eigen::IterationController
iterations	Eigen/src/Eigenvalues/RealQZ.h	/^      Index iterations() const$/;"	f	class:Eigen::RealQZ
iterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index iterations() const$/;"	f	class:Eigen::IterativeSolverBase
iterations	bench/btl/generic_bench/timers/STL_timer.hh	/^  vector<long> iterations;$/;"	m	class:STL_Timer
iterations	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index iterations() { return m_iter; }$/;"	f	class:Eigen::LevenbergMarquardt
iters_before_test	demos/mandelbrot/mandelbrot.cpp	/^template<> struct iters_before_test<double> { enum { ret = 16 }; };$/;"	s	file:
iters_before_test	demos/mandelbrot/mandelbrot.cpp	/^template<typename T> struct iters_before_test { enum { ret = 8 }; };$/;"	s	file:
j	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^       << ") is at position (" << i << "," << j << ")\\n\\n";$/;"	v
j	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  std::ptrdiff_t i, j;$/;"	v
jacobi	test/jacobi.cpp	/^void jacobi(const MatrixType& m = MatrixType())$/;"	f
jacobiSvd	Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
jacobian	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline JacobianType& jacobian() { return m_jacobian; }$/;"	f	class:Eigen::AutoDiffVector
jacobian	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline const JacobianType& jacobian() const { return m_jacobian; }$/;"	f	class:Eigen::AutoDiffVector
jacobian	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    JacobianType& jacobian() {return m_fjac; }$/;"	f	class:Eigen::LevenbergMarquardt
jacobisvd	test/jacobisvd.cpp	/^void jacobisvd(const MatrixType& a = MatrixType(), bool pickrandom = true)$/;"	f
jacobisvd_method	test/jacobisvd.cpp	/^void jacobisvd_method()$/;"	f
jacobisvd_verify_assert	test/jacobisvd.cpp	/^template<typename MatrixType> void jacobisvd_verify_assert(const MatrixType& m)$/;"	f
jeval	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool jeval;$/;"	m	class:Eigen::HybridNonLinearSolver
k	bench/analyze-blocking-sizes.cpp	/^  uint16_t k, m, n;$/;"	m	struct:size_triple_t	file:
k	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index k;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
kBusy	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^    kBusy,$/;"	e	enum:Eigen::RunQueue::__anon188
kCudaScratchSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static const int kCudaScratchSize = 1024;$/;"	m	namespace:Eigen
kDeviceCyclesPerComputeCycle	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static const int kDeviceCyclesPerComputeCycle = 1;$/;"	m	class:Eigen::TensorCostModel
kEmpty	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^    kEmpty,$/;"	e	enum:Eigen::RunQueue::__anon188
kEpochBits	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kEpochBits = 32;$/;"	m	class:Eigen::EventCount
kEpochInc	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kEpochInc = 1ull << kEpochShift;$/;"	m	class:Eigen::EventCount
kEpochMask	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kEpochMask = ((1ull << kEpochBits) - 1) << kEpochShift;$/;"	m	class:Eigen::EventCount
kEpochShift	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kEpochShift = 32;$/;"	m	class:Eigen::EventCount
kMask	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  static const unsigned kMask = kSize - 1;$/;"	m	class:Eigen::RunQueue
kMask2	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  static const unsigned kMask2 = (kSize << 1) - 1;$/;"	m	class:Eigen::RunQueue
kNotSignaled	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^      kNotSignaled,$/;"	e	enum:Eigen::EventCount::Waiter::__anon187
kPerThreadCycles	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static const int kPerThreadCycles = 100000;$/;"	m	class:Eigen::TensorCostModel
kQueueSize	unsupported/test/cxx11_eventcount.cpp	/^  static const int kQueueSize = 10;$/;"	m	struct:TestQueue	file:
kQueueSize	unsupported/test/cxx11_eventcount.cpp	/^const int TestQueue::kQueueSize;$/;"	m	class:TestQueue	file:
kReady	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^    kReady,$/;"	e	enum:Eigen::RunQueue::__anon188
kSignaled	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^      kSignaled,$/;"	e	enum:Eigen::EventCount::Waiter::__anon187
kStackBits	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kStackBits = 16;$/;"	m	class:Eigen::EventCount
kStackMask	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kStackMask = (1ull << kStackBits) - 1;$/;"	m	class:Eigen::EventCount
kStartupCycles	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static const int kStartupCycles = 100000;$/;"	m	class:Eigen::TensorCostModel
kTaskSize	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static const int kTaskSize = 40000;$/;"	m	class:Eigen::TensorCostModel
kWaiterBits	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kWaiterBits = 16;$/;"	m	class:Eigen::EventCount
kWaiterInc	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kWaiterInc = 1ull << kWaiterBits;$/;"	m	class:Eigen::EventCount
kWaiterMask	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kWaiterMask = ((1ull << kWaiterBits) - 1)$/;"	m	class:Eigen::EventCount
kWaiterShift	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  static const uint64_t kWaiterShift = 16;$/;"	m	class:Eigen::EventCount
kWaiting	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^      kWaiting,$/;"	e	enum:Eigen::EventCount::Waiter::__anon187
k_	bench/tensors/tensor_benchmarks.h	/^  TensorIndex k_;$/;"	m	class:BenchmarkSuite
k_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index k_;$/;"	m	class:Eigen::TensorEvaluator::Context
k_block_idx	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index k_block_idx;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
k_start	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index k_start;$/;"	m	struct:Eigen::internal::packLhsArg
kc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking
kc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Index kc() const { return kc_; }$/;"	f	class:Eigen::internal::TensorContractionBlocking
kc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index kc;$/;"	m	struct:Eigen::internal::packLhsArg
kc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index kc;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
kc_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  Index kc_;$/;"	m	class:Eigen::internal::TensorContractionBlocking
keep_diag	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT
keep_diag	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase
ker	doc/snippets/FullPivLU_kernel.cpp	/^MatrixXf ker = m.fullPivLu().kernel();$/;"	v
kernel	Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU
kernel	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void kernel(Index m, Index n, Index k) {$/;"	f	class:Eigen::TensorEvaluator::Context
kernelExpression	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    kernelExpression() const { return m_kernel_xpr; }$/;"	f	class:Eigen::TensorConvolutionOp
kernel_notifications	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  MaxSizeVector<Notification*>* kernel_notifications;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
kernel_retval	Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
kernel_retval_base	Eigen/src/misc/Kernel.h	/^  explicit kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base
kernel_retval_base	Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal
keyPressEvent	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::keyPressEvent(QKeyEvent * e)$/;"	f	class:RenderingWidget
kill_extra_precision	test/geo_alignedbox.cpp	/^void kill_extra_precision(T& x) { eigen_assert((void*)(&x) != (void*)0); }$/;"	f
kiss_cpx_fft	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^struct kiss_cpx_fft$/;"	s	namespace:Eigen::internal
kissfft_impl	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^struct kissfft_impl$/;"	s	namespace:Eigen::internal
knots	unsupported/Eigen/src/Splines/Spline.h	/^    const KnotVectorType& knots() const { return m_knots; }$/;"	f	class:Eigen::Spline
kroneckerProduct	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^KroneckerProduct<A,B> kroneckerProduct(const MatrixBase<A>& a, const MatrixBase<B>& b)$/;"	f	namespace:Eigen
kroneckerProduct	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^KroneckerProductSparse<A,B> kroneckerProduct(const EigenBase<A>& a, const EigenBase<B>& b)$/;"	f	namespace:Eigen
kv_pair_less	bench/sparse_setter.cpp	/^bool kv_pair_less(const std::pair<T1,T2>& x, const std::pair<T1,T2>& y){$/;"	f
l	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  int64_t   l[2];$/;"	m	union:Eigen::internal::__anon720
l	doc/snippets/class_FullPivLU.cpp	/^Matrix5x5 l = Matrix5x5::Identity();$/;"	v
l1CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen
l2CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen
l3CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l3CacheSize()$/;"	f	namespace:Eigen
labels	bench/dense_solvers.cpp	/^std::vector<std::string> labels;$/;"	v
lambda	doc/snippets/ComplexEigenSolver_compute.cpp	/^complex<float> lambda = ces.eigenvalues()[0];$/;"	v
lambda	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^complex<double> lambda = es.eigenvalues()[0];$/;"	v
lambda	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^double lambda = es.eigenvalues()[0];$/;"	v
lambda	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^double lambda = es.eigenvalues()[0];$/;"	v
lanczos1_functor	unsupported/test/NonLinearOptimization.cpp	/^    lanczos1_functor(void) : Functor<double>(6,24) {}$/;"	f	struct:lanczos1_functor
lanczos1_functor	unsupported/test/NonLinearOptimization.cpp	/^struct lanczos1_functor : Functor<double>$/;"	s	file:
lanczos1_functor	unsupported/test/levenberg_marquardt.cpp	/^    lanczos1_functor(void) : DenseFunctor<double>(6,24) {}$/;"	f	struct:lanczos1_functor
lanczos1_functor	unsupported/test/levenberg_marquardt.cpp	/^struct lanczos1_functor : DenseFunctor<double>$/;"	s	file:
lapackNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar lapackNorm(T& v)$/;"	f
lapack_complex_double	Eigen/src/misc/lapacke.h	96;"	d
lapack_complex_double_imag	Eigen/src/misc/lapacke.h	104;"	d
lapack_complex_double_real	Eigen/src/misc/lapacke.h	100;"	d
lapack_complex_float	Eigen/src/misc/lapacke.h	80;"	d
lapack_complex_float_imag	Eigen/src/misc/lapacke.h	88;"	d
lapack_complex_float_real	Eigen/src/misc/lapacke.h	84;"	d
lapack_int	Eigen/src/misc/lapacke.h	53;"	d
lapack_logical	Eigen/src/misc/lapacke.h	57;"	d
lastCoeff	Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
lastErrorMessage	Eigen/src/SparseLU/SparseLU.h	/^    std::string lastErrorMessage() const$/;"	f	class:Eigen::SparseLU
lastErrorMessage	Eigen/src/SparseQR/SparseQR.h	/^    std::string lastErrorMessage() const { return m_lastError; }$/;"	f	class:Eigen::SparseQR
lastLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE size_t lastLevelCacheSize() const {$/;"	f	struct:Eigen::GpuDevice
lastLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t lastLevelCacheSize() const {$/;"	f	struct:Eigen::DefaultDevice
lastLevelCacheSize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE size_t lastLevelCacheSize() const {$/;"	f	struct:Eigen::ThreadPoolDevice
lastname	scripts/eigen_gen_credits.cpp	/^string lastname(const string& name)$/;"	f
lastpos	demos/mandelbrot/mandelbrot.h	/^    QPoint lastpos;$/;"	m	class:MandelbrotWidget
lazyAssign	Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
lazyAssign	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
lazyAssign	Eigen/src/Core/TriangularMatrix.h	/^void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
lazyAssign	Eigen/src/Core/TriangularMatrix.h	/^void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
lazyProduct	Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
lazy_gemm	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^void lazy_gemm(const MatA &A, const MatB &B, MatC &C)$/;"	f
lazyprod	test/evaluators.cpp	/^  lazyprod(const Lhs& lhs, const Rhs& rhs)$/;"	f	namespace:Eigen
lazyproduct	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> lazyproduct;$/;"	t	struct:Eigen::internal::generic_product_impl
lcol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	301;"	d
lcol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	377;"	d
lda	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon865::__anon866
ldexp	unsupported/test/mpreal/mpreal.h	/^inline const mpreal ldexp(const mpreal& v, mp_exp_t exp)$/;"	f	namespace:mpfr
ldlt	Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase
ldlt	Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView
ldlt_inplace	Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
least_square_conjugate_gradient	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^void least_square_conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
left	bench/btl/libs/BLAS/blas_interface.hh	/^static char left = 'L';$/;"	v
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols(Index n = N) const$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols(Index n = N)$/;"	f
left_dim_mapper_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef array<Index, LDims> left_dim_mapper_t;$/;"	t	struct:Eigen::TensorEvaluator
left_dim_mapper_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef array<Index, LDims> left_dim_mapper_t;$/;"	t	struct:Eigen::TensorEvaluator
left_impl	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  const TensorEvaluator<LeftArgType, Device>& left_impl() const { return m_leftImpl; }$/;"	f	struct:Eigen::TensorEvaluator
left_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<LeftArgType, Device>& left_impl() const { return m_leftImpl; }$/;"	f	struct:Eigen::TensorEvaluator
left_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, LDims - ContractDims> left_nocontract_t;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
left_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, LDims - ContractDims> left_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
left_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef array<Index, LDims - ContractDims> left_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
left_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef array<Index, LDims - ContractDims> left_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
length	Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
length	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType length ;  \/* number of principal columns in this row *\/$/;"	m	struct:internal::Colamd_Row
length	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType length ;  \/* number of rows in this column *\/$/;"	m	struct:internal::colamd_col
lerp	demos/opengl/camera.h	/^    Frame lerp(float alpha, const Frame& other) const$/;"	f	class:Frame
lerp	demos/opengl/quaternion_demo.cpp	/^template<> EulerAngles<float> lerp(float t, const EulerAngles<float>& a, const EulerAngles<float>& b)$/;"	f
lerp	demos/opengl/quaternion_demo.cpp	/^template<> Quaternionf lerp(float t, const Quaternionf& a, const Quaternionf& b)$/;"	f
lerp	demos/opengl/quaternion_demo.cpp	/^template<typename T> T lerp(float t, const T& a, const T& b)$/;"	f
lerpFrame	demos/opengl/quaternion_demo.cpp	/^inline static Frame lerpFrame(float alpha, const Frame& a, const Frame& b)$/;"	f	file:
lesser_equal_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct lesser_equal_op {$/;"	s	namespace:Eigen::internal
lesser_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct lesser_op        { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a < b)   { return a < b;   } };$/;"	s	namespace:Eigen::internal
lesser_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct lesser_op {$/;"	s	namespace:Eigen::internal
level3_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking
level3_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
lgamma	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^lgamma() const$/;"	f
lgamma	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    lgamma() const {$/;"	f	class:Eigen::TensorBase
lgamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half lgamma(const Eigen::half& a) {$/;"	f	namespace:Eigen::numext
lgamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    lgamma(const Scalar& x) {$/;"	f	namespace:Eigen::numext
lgamma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal lgamma (const mpreal& v, int *signp = 0, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
lgamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct lgamma_impl {$/;"	s	namespace:Eigen::internal
lgamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct lgamma_impl<double> {$/;"	s	namespace:Eigen::internal
lgamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct lgamma_impl<float> {$/;"	s	namespace:Eigen::internal
lgamma_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct lgamma_retval {$/;"	s	namespace:Eigen::internal
lhs	Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp
lhs	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC const LhsNestedCleaned& lhs() const { return m_lhs; }$/;"	f	class:Eigen::Product
lhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const LhsMapper& lhs;$/;"	m	struct:Eigen::internal::packLhsArg
lhs	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const {$/;"	f	class:Eigen::internal::SkylineProduct
lhsExpr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<LHSExpr, Dev> > lhsExpr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
lhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    lhsExpression() const { return *((typename internal::remove_all<typename LhsXprType::Nested>::type*)&m_lhs_xpr); }$/;"	f	class:Eigen::TensorAssignOp
lhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    lhsExpression() const { return m_lhs_xpr; }$/;"	f	class:Eigen::TensorConcatenationOp
lhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  lhsExpression() const { return m_lhs_xpr; }$/;"	f	class:Eigen::TensorContractionOp
lhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  lhsExpression() const { return m_lhs_xpr; }$/;"	f	class:Eigen::TensorCustomBinaryOp
lhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    lhsExpression() const { return m_lhs_xpr; }$/;"	f	class:Eigen::TensorCwiseBinaryOp
lhs_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    LhsMapper& lhs_;$/;"	m	class:Eigen::TensorEvaluator::Context
lhs_element	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	325;"	d
lhs_element	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	379;"	d
lhs_length	Eigen/src/Core/products/Parallelizer.h	/^  Index lhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo
lhs_notifications	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const MaxSizeVector<Notification*>* lhs_notifications;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
lhs_start	Eigen/src/Core/products/Parallelizer.h	/^  Index lhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo
li2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal li2 (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
linear	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linear	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linearExt	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform
linearExt	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform
linearStructure	test/linearstructure.cpp	/^template<typename MatrixType> void linearStructure(const MatrixType& m)$/;"	f
linearizedIndex	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index linearizedIndex(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::Tensor
linearizedIndex	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Index linearizedIndex(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::TensorFixedSize
lines	test/geo_hyperplane.cpp	/^template<typename Scalar> void lines()$/;"	f
linspaced_op	Eigen/src/Core/functors/NullaryFunctors.h	/^  linspaced_op(const Scalar& low, const Scalar& high, Index num_steps)$/;"	f	struct:Eigen::internal::linspaced_op
linspaced_op	Eigen/src/Core/functors/NullaryFunctors.h	/^template <typename Scalar, typename PacketType> struct linspaced_op$/;"	s	namespace:Eigen::internal
linspaced_op_impl	Eigen/src/Core/functors/NullaryFunctors.h	/^  linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :$/;"	f	struct:Eigen::internal::linspaced_op_impl
linspaced_op_impl	Eigen/src/Core/functors/NullaryFunctors.h	/^struct linspaced_op_impl<Scalar,Packet,\/*IsInteger*\/false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	Eigen/src/Core/functors/NullaryFunctors.h	/^struct linspaced_op_impl<Scalar,Packet,\/*IsInteger*\/true>$/;"	s	namespace:Eigen::internal
list	Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
list_base	Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list
llt	Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase
llt	Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView
llt_inplace	Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	Eigen/src/Cholesky/LLT.h	/^static Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal
lm_param	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar lm_param(void) { return m_par; }$/;"	f	class:Eigen::LevenbergMarquardt
lm_param	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar lm_param(void) { return par; }$/;"	f	class:Eigen::LevenbergMarquardt
lmder1	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType>::lmder1($/;"	f	class:Eigen::LevenbergMarquardt
lmder1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmder1($/;"	f	class:Eigen::LevenbergMarquardt
lmder_functor	unsupported/test/NonLinearOptimization.cpp	/^    lmder_functor(void): Functor<double>(3,15) {}$/;"	f	struct:lmder_functor
lmder_functor	unsupported/test/NonLinearOptimization.cpp	/^struct lmder_functor : Functor<double>$/;"	s	file:
lmder_functor	unsupported/test/levenberg_marquardt.cpp	/^    lmder_functor(void): DenseFunctor<double>(3,15) {}$/;"	f	struct:lmder_functor
lmder_functor	unsupported/test/levenberg_marquardt.cpp	/^struct lmder_functor : DenseFunctor<double>$/;"	s	file:
lmdif1	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType>::lmdif1($/;"	f	class:Eigen::LevenbergMarquardt
lmdif1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmdif1($/;"	f	class:Eigen::LevenbergMarquardt
lmdif_functor	unsupported/test/NonLinearOptimization.cpp	/^    lmdif_functor(void) : Functor<double>(3,15) {}$/;"	f	struct:lmdif_functor
lmdif_functor	unsupported/test/NonLinearOptimization.cpp	/^struct lmdif_functor : Functor<double>$/;"	s	file:
lmdif_functor	unsupported/test/levenberg_marquardt.cpp	/^    lmdif_functor(void) : DenseFunctor<double>(3,15) {}$/;"	f	struct:lmdif_functor
lmdif_functor	unsupported/test/levenberg_marquardt.cpp	/^struct lmdif_functor : DenseFunctor<double>$/;"	s	file:
lmpar	unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^void lmpar($/;"	f	namespace:Eigen::internal
lmpar2	unsupported/Eigen/src/LevenbergMarquardt/LMpar.h	/^    void lmpar2($/;"	f	namespace:Eigen::internal
lmpar2	unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^void lmpar2($/;"	f	namespace:Eigen::internal
lmqrsolv	unsupported/Eigen/src/LevenbergMarquardt/LMqrsolv.h	/^void lmqrsolv($/;"	f	namespace:Eigen::internal
lmstr1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmstr1($/;"	f	class:Eigen::LevenbergMarquardt
lmstr_functor	unsupported/test/NonLinearOptimization.cpp	/^    lmstr_functor(void) : Functor<double>(3,15) {}$/;"	f	struct:lmstr_functor
lmstr_functor	unsupported/test/NonLinearOptimization.cpp	/^struct lmstr_functor : Functor<double>$/;"	s	file:
lngamma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal lngamma (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(lngamma);    }$/;"	f	namespace:mpfr
load	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet load(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
load	test/packetmath.cpp	/^  inline Packet load(const T* from) const { return internal::pload<Packet>(from); }$/;"	f	struct:packet_helper
load	test/packetmath.cpp	/^  inline T load(const T* from) const { return *from; }$/;"	f	struct:packet_helper
load	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketT load(Index i) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
loadConstant	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^Eigen::half loadConstant(const Eigen::half* address) {$/;"	f	namespace:Eigen::__anon110
loadConstant	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^T loadConstant(const T* address) {$/;"	f	namespace:Eigen::__anon110
loadConstant	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^double loadConstant(const double* address) {$/;"	f	namespace:Eigen::__anon110
loadConstant	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^float loadConstant(const float* address) {$/;"	f	namespace:Eigen::__anon110
loadData	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	328;"	d
loadData	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	381;"	d
loadHalfPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
loadHalfPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
loadHalfPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
loadHalfPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE HalfPacket loadHalfPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::BaseTensorContractionMapper
loadHalfPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE Packet loadHalfPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::BaseTensorContractionMapper
loadLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhsUnaligned	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhsUnaligned(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadLhsUnaligned	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhsUnaligned(const LhsScalar* a, LhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadMarket	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool loadMarket(SparseMatrixType& mat, const std::string& filename)$/;"	f	namespace:Eigen
loadMarketVector	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool loadMarketVector(VectorType& vec, const std::string& filename)$/;"	f	namespace:Eigen
loadMatrix	demos/opengl/gpuhelper.h	/^    static void loadMatrix(const Matrix<double,4,4, _Flags, 4,4>& mat) { glLoadMatrixd(mat.data()); }$/;"	f	struct:GlMatrixHelper
loadMatrix	demos/opengl/gpuhelper.h	/^    static void loadMatrix(const Matrix<double,4,4, _Flags, 4,4>& mat) { glLoadMatrixd(mat.transpose().eval().data()); }$/;"	f	struct:GlMatrixHelper
loadMatrix	demos/opengl/gpuhelper.h	/^    static void loadMatrix(const Matrix<float, 4,4, _Flags, 4,4>&  mat) { glLoadMatrixf(mat.data()); }$/;"	f	struct:GlMatrixHelper
loadMatrix	demos/opengl/gpuhelper.h	/^    static void loadMatrix(const Matrix<float, 4,4, _Flags, 4,4>&  mat) { glLoadMatrixf(mat.transpose().eval().data()); }$/;"	f	struct:GlMatrixHelper
loadMatrix	demos/opengl/gpuhelper.h	/^void GpuHelper::loadMatrix($/;"	f	class:GpuHelper
loadMatrix	demos/opengl/gpuhelper.h	/^void GpuHelper::loadMatrix(const Eigen::Matrix<Scalar,4,4, _Flags, 4,4>& mat, GLenum matrixTarget)$/;"	f	class:GpuHelper
loadPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
loadPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
loadPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
loadPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
loadPacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE Packet loadPacket(Index i, Index j) const {$/;"	f	class:Eigen::internal::BaseTensorContractionMapper
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, DoublePacketType& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, ResPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhsQuad	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhsQuad(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
localRotate	demos/opengl/camera.cpp	/^void Camera::localRotate(const Quaternionf& q)$/;"	f	class:Camera
localTranslate	demos/opengl/camera.cpp	/^void Camera::localTranslate(const Vector3f& t)$/;"	f	class:Camera
log	Eigen/src/Core/MathFunctions.h	/^T log(const T &x) {$/;"	f	namespace:Eigen::numext
log	Eigen/src/Core/MathFunctions.h	/^double log(const double &x) { return ::log(x); }$/;"	f	namespace:Eigen::numext
log	Eigen/src/Core/MathFunctions.h	/^float log(const float &x) { return ::logf(x); }$/;"	f	namespace:Eigen::numext
log	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log(const half& a) {$/;"	f	namespace:Eigen::half_impl
log	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f
log	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    log() const {$/;"	f	class:Eigen::TensorBase
log	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^const MatrixLogarithmReturnValue<Derived> MatrixBase<Derived>::log() const$/;"	f	class:Eigen::MatrixBase
log	unsupported/test/mpreal/mpreal.h	/^inline const mpreal log   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(log  );    }$/;"	f	namespace:mpfr
log10	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log10(const half& a) {$/;"	f	namespace:Eigen::half_impl
log10	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log10() const$/;"	f
log10	unsupported/test/mpreal/mpreal.h	/^inline const mpreal log10 (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(log10);    }$/;"	f	namespace:mpfr
log1p	Eigen/src/Core/MathFunctions.h	/^  EIGEN_DEVICE_FUNC inline Scalar log1p(const Scalar& x) {$/;"	f	namespace:Eigen::internal::std_fallback
log1p	Eigen/src/Core/MathFunctions.h	/^double log1p(const double &x) { return ::log1p(x); }$/;"	f	namespace:Eigen::numext
log1p	Eigen/src/Core/MathFunctions.h	/^float log1p(const float &x) { return ::log1pf(x); }$/;"	f	namespace:Eigen::numext
log1p	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(log1p, Scalar) log1p(const Scalar& x)$/;"	f	namespace:Eigen::numext
log1p	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log1p(const half& a) {$/;"	f	namespace:Eigen::half_impl
log1p	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log1p() const$/;"	f
log1p	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    log1p() const {$/;"	f	class:Eigen::TensorBase
log1p	unsupported/test/mpreal/mpreal.h	/^inline const mpreal log1p   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(log1p  );    }$/;"	f	namespace:mpfr
log1p_impl	Eigen/src/Core/MathFunctions.h	/^struct log1p_impl {$/;"	s	namespace:Eigen::internal
log1p_retval	Eigen/src/Core/MathFunctions.h	/^struct log1p_retval$/;"	s	namespace:Eigen::internal
log2	Eigen/src/Core/MathFunctions.h	/^inline int log2(int x)$/;"	f	namespace:Eigen::numext
log2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal log2  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(log2 );    }$/;"	f	namespace:mpfr
log2_pot	bench/analyze-blocking-sizes.cpp	/^uint8_t log2_pot(size_t x) {$/;"	f
logAbsDeterminant	Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
logAbsDeterminant	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^CompleteOrthogonalDecomposition<MatrixType>::logAbsDeterminant() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
logAbsDeterminant	Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
logAbsDeterminant	Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR
logAbsDeterminant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar logAbsDeterminant() const$/;"	f	class:Eigen::SparseLU
logDeterminant	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Scalar logDeterminant() const$/;"	f	class:Eigen::CholmodBase
logb	unsupported/test/mpreal/mpreal.h	/^inline const mpreal logb  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   return log2 (abs(x),r);                    }$/;"	f	namespace:mpfr
logh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half logh(const Eigen::half& a) {$/;"	f
logical	blas/f2c/datatypes.h	/^typedef int logical;$/;"	t
logical_and_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct logical_and_op   { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a && b)  { return a && b;  } };$/;"	s	namespace:Eigen::internal
logical_and_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct logical_and_op {$/;"	s	namespace:Eigen::internal
logical_or_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct logical_or_op    { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a || b)  { return a || b;  } };$/;"	s	namespace:Eigen::internal
logical_or_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct logical_or_op {$/;"	s	namespace:Eigen::internal
lookup_function	debug/gdb/printers.py	/^def lookup_function(val):$/;"	f
loop_on_k	bench/product_threshold.cpp	/^struct loop_on_k$/;"	s	file:
loop_on_k	bench/product_threshold.cpp	/^struct loop_on_k<M,N,END> { static void run(){} };$/;"	s	file:
loop_on_m	bench/product_threshold.cpp	/^struct loop_on_m$/;"	s	file:
loop_on_m	bench/product_threshold.cpp	/^struct loop_on_m<END,N,K> { static void run(){} };$/;"	s	file:
loop_on_n	bench/product_threshold.cpp	/^struct loop_on_n$/;"	s	file:
loop_on_n	bench/product_threshold.cpp	/^struct loop_on_n<M,END,K,Scalar,Mode> { static void run(){} };$/;"	s	file:
low	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  LOW low;$/;"	m	struct:Eigen::internal::TensorUInt128
lower	bench/bench_gemm.cpp	/^static char lower = 'L';$/;"	v	file:
lower	bench/btl/libs/BLAS/blas_interface.hh	/^static char lower = 'L';$/;"	v
lower	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE LOW lower() const {$/;"	f	struct:Eigen::internal::TensorUInt128
lower	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& lower(Index i) {$/;"	f	class:Eigen::SkylineStorage
lower	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& lower(Index i) const {$/;"	f	class:Eigen::SkylineStorage
lowerNonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index lowerNonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
lowerNonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index lowerNonZeros(Index j) const {$/;"	f	class:Eigen::SkylineMatrix
lowerProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index& lowerProfile(Index i) {$/;"	f	class:Eigen::SkylineStorage
lowerProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Index& lowerProfile(Index i) const {$/;"	f	class:Eigen::SkylineStorage
lowerProfileSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index lowerProfileSize() const {$/;"	f	class:Eigen::SkylineStorage
lowerSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index lowerSize() const {$/;"	f	class:Eigen::SkylineStorage
lower_efficiency	bench/analyze-blocking-sizes.cpp	/^  static bool lower_efficiency(const results_entry_t& e1, const results_entry_t& e2) {$/;"	f	struct:evaluate_defaults_action_t
lower_efficiency	bench/analyze-blocking-sizes.cpp	/^bool lower_efficiency(const preprocessed_inputfile_entry_t& e1, const preprocessed_inputfile_entry_t& e2)$/;"	f
lowest	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half lowest() {$/;"	f	struct:Eigen::NumTraits
lowest	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half lowest() { return Eigen::half_impl::raw_uint16_to_half(0xfbff); }$/;"	f	struct:std::numeric_limits
lowest	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static inline Real lowest() { return n; }$/;"	f	struct:Eigen::NumTraits
lowest	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal lowest   (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return -mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits
lpNorm	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase
lpNorm	Eigen/src/Core/VectorwiseOp.h	/^    const typename LpNormReturnType<p>::Type lpNorm() const$/;"	f	class:Eigen::VectorwiseOp
lpNorm	test/array_for_matrix.cpp	/^template<typename VectorType> void lpNorm(const VectorType& v)$/;"	f
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lsame_	blas/f2c/lsame.c	/^logical lsame_(char *ca, char *cb, ftnlen ca_len, ftnlen cb_len)$/;"	f
lsub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector lsub; \/\/ Compressed row indices of L rectangular supernodes. $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
lu	Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
lu_decomp	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void lu_decomp(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:blas_interface
lu_decomp	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void lu_decomp(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:eigen2_interface
lu_decomp	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void lu_decomp(const gene_matrix & X, gene_matrix & C, int  \/*N*\/){$/;"	f	class:eigen3_interface
lu_invertible	test/lu.cpp	/^template<typename MatrixType> void lu_invertible()$/;"	f
lu_non_invertible	test/lu.cpp	/^template<typename MatrixType> void lu_non_invertible()$/;"	f
lu_partial_piv	test/lu.cpp	/^template<typename MatrixType> void lu_partial_piv()$/;"	f
lu_verify_assert	test/lu.cpp	/^template<typename MatrixType> void lu_verify_assert()$/;"	f
lusup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  lusup; \/\/ nonzero values of L ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
m	bench/analyze-blocking-sizes.cpp	/^  uint16_t k, m, n;$/;"	m	struct:size_triple_t	file:
m	doc/snippets/AngleAxis_mimic_euler.cpp	/^Matrix3f m;$/;"	v
m	doc/snippets/ColPivHouseholderQR_solve.cpp	/^Matrix3f m = Matrix3f::Random();$/;"	v
m	doc/snippets/DirectionWise_replicate.cpp	/^MatrixXi m = MatrixXi::Random(2,3);$/;"	v
m	doc/snippets/FullPivHouseholderQR_solve.cpp	/^Matrix3f m = Matrix3f::Random();$/;"	v
m	doc/snippets/FullPivLU_image.cpp	/^Matrix3d m;$/;"	v
m	doc/snippets/FullPivLU_kernel.cpp	/^MatrixXf m = MatrixXf::Random(3,5);$/;"	v
m	doc/snippets/FullPivLU_solve.cpp	/^Matrix<float,2,3> m = Matrix<float,2,3>::Random();$/;"	v
m	doc/snippets/HouseholderQR_solve.cpp	/^Matrix3x3 m = Matrix3x3::Random();$/;"	v
m	doc/snippets/JacobiSVD_basic.cpp	/^MatrixXf m = MatrixXf::Random(3,2);$/;"	v
m	doc/snippets/Jacobi_makeJacobi.cpp	/^Matrix2f m = Matrix2f::Random();$/;"	v
m	doc/snippets/MatrixBase_adjoint.cpp	/^Matrix2cf m = Matrix2cf::Random();$/;"	v
m	doc/snippets/MatrixBase_block_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_block_int_int_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_bottomLeftCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_bottomRightCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_col.cpp	/^Matrix3d m = Matrix3d::Identity();$/;"	v
m	doc/snippets/MatrixBase_colwise.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_computeInverseAndDetWithCheck.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_computeInverseWithCheck.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_diagonal.cpp	/^Matrix3i m = Matrix3i::Random();$/;"	v
m	doc/snippets/MatrixBase_diagonal_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_diagonal_template_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_eval.cpp	/^Matrix2f m;$/;"	v
m	doc/snippets/MatrixBase_fixedBlock_int_int.cpp	/^Matrix4d m = Vector4d(1,2,3,4).asDiagonal();$/;"	v
m	doc/snippets/MatrixBase_inverse.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_isDiagonal.cpp	/^Matrix3d m = 10000 * Matrix3d::Identity();$/;"	v
m	doc/snippets/MatrixBase_isIdentity.cpp	/^Matrix3d m = Matrix3d::Identity();$/;"	v
m	doc/snippets/MatrixBase_isOnes.cpp	/^Matrix3d m = Matrix3d::Ones();$/;"	v
m	doc/snippets/MatrixBase_isUnitary.cpp	/^Matrix3d m = Matrix3d::Identity();$/;"	v
m	doc/snippets/MatrixBase_isZero.cpp	/^Matrix3d m = Matrix3d::Zero();$/;"	v
m	doc/snippets/MatrixBase_prod.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_replicate.cpp	/^MatrixXi m = MatrixXi::Random(2,3);$/;"	v
m	doc/snippets/MatrixBase_reverse.cpp	/^MatrixXi m = MatrixXi::Random(3,4);$/;"	v
m	doc/snippets/MatrixBase_row.cpp	/^Matrix3d m = Matrix3d::Identity();$/;"	v
m	doc/snippets/MatrixBase_rowwise.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/MatrixBase_selfadjointView.cpp	/^Matrix3i m = Matrix3i::Random();$/;"	v
m	doc/snippets/MatrixBase_setIdentity.cpp	/^Matrix4i m = Matrix4i::Zero();$/;"	v
m	doc/snippets/MatrixBase_setOnes.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_setRandom.cpp	/^Matrix4i m = Matrix4i::Zero();$/;"	v
m	doc/snippets/MatrixBase_setZero.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_block_int_int_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_bottomLeftCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_bottomRightCorner.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_bottomRightCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_topLeftCorner.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_topLeftCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_topRightCorner.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_template_int_int_topRightCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_topLeftCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_topRightCorner_int_int.cpp	/^Matrix4i m = Matrix4i::Random();$/;"	v
m	doc/snippets/MatrixBase_transpose.cpp	/^Matrix2i m = Matrix2i::Random();$/;"	v
m	doc/snippets/MatrixBase_triangularView.cpp	/^Matrix3i m = Matrix3i::Random();$/;"	v
m	doc/snippets/Matrix_setConstant_int_int.cpp	/^MatrixXf m;$/;"	v
m	doc/snippets/Matrix_setIdentity_int_int.cpp	/^MatrixXf m;$/;"	v
m	doc/snippets/Matrix_setOnes_int_int.cpp	/^MatrixXf m;$/;"	v
m	doc/snippets/Matrix_setRandom_int_int.cpp	/^MatrixXf m;$/;"	v
m	doc/snippets/Matrix_setZero_int_int.cpp	/^MatrixXf m;$/;"	v
m	doc/snippets/PartialRedux_count.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_maxCoeff.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_minCoeff.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_norm.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_prod.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_squaredNorm.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/PartialRedux_sum.cpp	/^Matrix3d m = Matrix3d::Random();$/;"	v
m	doc/snippets/Triangular_solve.cpp	/^Matrix3d m = Matrix3d::Zero();$/;"	v
m	doc/snippets/Tutorial_commainit_01.cpp	/^Matrix3f m;$/;"	v
m	doc/snippets/Tutorial_commainit_01.cpp	/^std::cout << m;$/;"	v
m	doc/snippets/Tutorial_commainit_01b.cpp	/^Matrix3f m;$/;"	v
m	doc/snippets/Tutorial_commainit_01b.cpp	/^std::cout << m;$/;"	v
m	doc/snippets/Tutorial_commainit_02.cpp	/^cout << m;$/;"	v
m	doc/snippets/Vectorwise_reverse.cpp	/^MatrixXi m = MatrixXi::Random(3,4);$/;"	v
m	doc/snippets/class_FullPivLU.cpp	/^Matrix5x3 m = Matrix5x3::Random();$/;"	v
m	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  Matrix3f m = Matrix3f::Random();$/;"	v
m	test/unalignedassert.cpp	/^  Matrix3d m; \/\/ good: m's size isn't a multiple of 16 bytes, so m doesn't have to be 16-byte aligned,$/;"	m	struct:TestNew2	file:
m	test/unalignedassert.cpp	/^  Matrix4f m;$/;"	m	struct:TestNew5	file:
m	test/unalignedassert.cpp	/^  Matrix<float,2,2,DontAlign> m; \/\/ good: no alignment requested$/;"	m	struct:TestNew6	file:
m	test/unalignedassert.cpp	/^  MatrixXd m; \/\/ good: m will allocate its own array, taking care of alignment.$/;"	m	struct:TestNew1	file:
m	test/unalignedassert.cpp	/^  Vector2d m;$/;"	m	struct:Depends	file:
m	test/unalignedassert.cpp	/^  Vector2d m;$/;"	m	struct:TestNew4	file:
m	test/unalignedassert.cpp	/^  Vector2f m; \/\/ good: m's size isn't a multiple of 16 bytes, so m doesn't have to be 16-byte aligned$/;"	m	struct:TestNew3	file:
m	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index m;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
m	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index m; $/;"	m	class:Eigen::LevenbergMarquardt
m	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index m;$/;"	m	class:Eigen::LevenbergMarquardt
m1	doc/snippets/IOFormat.cpp	/^Matrix3d m1;$/;"	v
m1	doc/snippets/MatrixBase_set.cpp	/^Matrix3i m1;$/;"	v
m2	doc/snippets/MatrixBase_set.cpp	/^Matrix3i m2 = Matrix3i::Identity();$/;"	v
mAnimate	demos/opengl/quaternion_demo.h	/^    bool mAnimate;$/;"	m	class:RenderingWidget
mCamera	demos/opengl/quaternion_demo.h	/^    Camera mCamera;$/;"	m	class:RenderingWidget
mCenters	demos/opengl/quaternion_demo.cpp	/^    std::vector<Vector3f> mCenters;$/;"	m	class:FancySpheres	file:
mColorBufferId	demos/opengl/gpuhelper.h	/^    GLuint mColorBufferId;$/;"	m	class:GpuHelper
mCurrentMatrixTarget	demos/opengl/gpuhelper.h	/^    GLenum mCurrentMatrixTarget;$/;"	m	class:GpuHelper
mCurrentTrackingMode	demos/opengl/quaternion_demo.h	/^    TrackMode mCurrentTrackingMode;$/;"	m	class:RenderingWidget
mFarDist	demos/opengl/camera.h	/^    float mFarDist;$/;"	m	class:Camera
mFovY	demos/opengl/camera.h	/^    float mFovY;$/;"	m	class:Camera
mFrame	demos/opengl/camera.h	/^    Frame mFrame;$/;"	m	class:Camera
mIcoSphere	demos/opengl/quaternion_demo.cpp	/^    IcoSphere mIcoSphere;$/;"	m	class:FancySpheres	file:
mIndices	demos/opengl/icosphere.h	/^    std::vector<std::vector<int>*> mIndices;$/;"	m	class:IcoSphere
mIndices	demos/opengl/quaternion_demo.h	/^    std::vector<int> mIndices;$/;"	m	class:RenderingWidget
mInitFrame	demos/opengl/quaternion_demo.h	/^    Frame mInitFrame;$/;"	m	class:RenderingWidget
mInitialized	demos/opengl/gpuhelper.h	/^    bool mInitialized;$/;"	m	class:GpuHelper
mLastPoint3D	demos/opengl/trackball.h	/^    Eigen::Vector3f mLastPoint3D;$/;"	m	class:Trackball
mLastPointOk	demos/opengl/trackball.h	/^    bool mLastPointOk;$/;"	m	class:Trackball
mLerpMode	demos/opengl/quaternion_demo.h	/^    LerpMode mLerpMode;$/;"	m	class:RenderingWidget
mListIds	demos/opengl/icosphere.h	/^    std::vector<int> mListIds;$/;"	m	class:IcoSphere
mMode	demos/opengl/trackball.h	/^    Mode mMode;$/;"	m	class:Trackball
mMouseCoords	demos/opengl/quaternion_demo.h	/^    Vector2i mMouseCoords;$/;"	m	class:RenderingWidget
mNavMode	demos/opengl/quaternion_demo.h	/^    NavMode mNavMode;$/;"	m	class:RenderingWidget
mNearDist	demos/opengl/camera.h	/^    float mNearDist;$/;"	m	class:Camera
mNormals	demos/opengl/quaternion_demo.h	/^    std::vector<Vector3f> mNormals;$/;"	m	class:RenderingWidget
mProjIsUptodate	demos/opengl/camera.h	/^    mutable bool mProjIsUptodate;$/;"	m	class:Camera
mProjectionMatrix	demos/opengl/camera.h	/^    mutable Eigen::Matrix4f mProjectionMatrix;$/;"	m	class:Camera
mRadii	demos/opengl/quaternion_demo.cpp	/^    std::vector<float> mRadii;$/;"	m	class:FancySpheres	file:
mRenderingWidget	demos/opengl/quaternion_demo.h	/^    RenderingWidget* mRenderingWidget;$/;"	m	class:QuaternionDemo
mRotationMode	demos/opengl/quaternion_demo.h	/^    RotationMode mRotationMode;$/;"	m	class:RenderingWidget
mTarget	demos/opengl/camera.h	/^    Eigen::Vector3f mTarget;$/;"	m	class:Camera
mTrackball	demos/opengl/quaternion_demo.h	/^    Trackball mTrackball;$/;"	m	class:RenderingWidget
mVertices	demos/opengl/icosphere.h	/^    std::vector<Eigen::Vector3f> mVertices;$/;"	m	class:IcoSphere
mVertices	demos/opengl/quaternion_demo.h	/^    std::vector<Vector3f> mVertices;$/;"	m	class:RenderingWidget
mViewIsUptodate	demos/opengl/camera.h	/^    mutable bool mViewIsUptodate;$/;"	m	class:Camera
mViewMatrix	demos/opengl/camera.h	/^    mutable Eigen::Affine3f mViewMatrix;$/;"	m	class:Camera
mVpHeight	demos/opengl/camera.h	/^    uint mVpWidth, mVpHeight;$/;"	m	class:Camera
mVpHeight	demos/opengl/gpuhelper.h	/^    int mVpWidth, mVpHeight;$/;"	m	class:GpuHelper
mVpWidth	demos/opengl/camera.h	/^    uint mVpWidth, mVpHeight;$/;"	m	class:Camera
mVpWidth	demos/opengl/gpuhelper.h	/^    int mVpWidth, mVpHeight;$/;"	m	class:GpuHelper
mVpX	demos/opengl/camera.h	/^    uint mVpX, mVpY;$/;"	m	class:Camera
mVpY	demos/opengl/camera.h	/^    uint mVpX, mVpY;$/;"	m	class:Camera
m_	bench/tensors/tensor_benchmarks.h	/^  TensorIndex m_;$/;"	m	class:BenchmarkSuite
m_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index m_;$/;"	m	class:Eigen::TensorEvaluator::Context
m_A	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typename Lhs::Nested m_A;$/;"	m	class:Eigen::KroneckerProductBase
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    const DerivedNested m_A;$/;"	m	class:Eigen::MatrixFunctionReturnValue
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  const DerivedNested m_A;$/;"	m	class:Eigen::MatrixLogarithmReturnValue
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const Derived& m_A;$/;"	m	class:Eigen::MatrixComplexPowerReturnValue
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const Derived& m_A;$/;"	m	class:Eigen::MatrixPowerReturnValue
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const MatrixType& m_A;$/;"	m	class:Eigen::MatrixPowerAtomic
m_A	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    typename MatrixType::Nested m_A;$/;"	m	class:Eigen::MatrixPower
m_B	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    typename Rhs::Nested m_B;$/;"	m	class:Eigen::KroneckerProductBase
m_E	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable StorageIndex *m_E; \/\/ The permutation applied to columns$/;"	m	class:Eigen::SPQR
m_H	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_H;  \/\/The householder vectors$/;"	m	class:Eigen::SPQR
m_H	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_H; \/\/ Hessenberg matrix $/;"	m	class:Eigen::DGMRES
m_HPinv	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable StorageIndex *m_HPinv; \/\/ The row permutation of H$/;"	m	class:Eigen::SPQR
m_HTau	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_dense *m_HTau; \/\/ The Householder coefficients$/;"	m	class:Eigen::SPQR
m_Hes	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_Hes; \/\/ Initial hessenberg matrix wihout Givens rotations applied$/;"	m	class:Eigen::DGMRES
m_L	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    FactorType m_L;              \/\/ The lower part stored in CSC$/;"	m	class:Eigen::IncompleteCholesky
m_LDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky
m_Lstore	Eigen/src/SparseLU/SparseLU.h	/^    SCMatrix m_Lstore; \/\/ The lower triangular matrix (supernodal)$/;"	m	class:Eigen::SparseLU
m_MU	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_MU; \/\/ matrix operator applied to m_U (for next cycles)$/;"	m	class:Eigen::DGMRES
m_P	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT
m_P	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Pinv	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT
m_Pinv	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Q	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_Q	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_Q;               \/\/ The orthogonal reflectors$/;"	m	class:Eigen::SparseQR
m_R	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable MatrixType m_R; \/\/ The sparse matrix R in Eigen format$/;"	m	class:Eigen::SPQR
m_R	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_R;               \/\/ The triangular factor matrix$/;"	m	class:Eigen::SparseQR
m_S	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_T	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_T	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_T; \/* T=U^T*M^{-1}*A*U *\/$/;"	m	class:Eigen::DGMRES
m_T	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    ComplexMatrix m_T, m_U;$/;"	m	class:Eigen::MatrixPower
m_U	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_U; \/\/ Vectors that form the basis of the invariant subspace $/;"	m	class:Eigen::DGMRES
m_U	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    ComplexMatrix m_T, m_U;$/;"	m	class:Eigen::MatrixPower
m_Ustore	Eigen/src/SparseLU/SparseLU.h	/^    MappedSparseMatrix<Scalar,ColMajor,StorageIndex> m_Ustore; \/\/ The upper triangular matrix$/;"	m	class:Eigen::SparseLU
m_V	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable DenseMatrix m_V; \/\/ Krylov basis vectors$/;"	m	class:Eigen::DGMRES
m_Z	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_accumulator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  Op m_accumulator;$/;"	m	struct:Eigen::TensorEvaluator
m_accumulator	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Op m_accumulator;$/;"	m	class:Eigen::TensorScanOp
m_actualAlpha	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor
m_adjoint	Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_algoswap	Eigen/src/SVD/BDCSVD.h	/^  int m_algoswap;$/;"	m	class:Eigen::BDCSVD
m_allocatedElements	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	Eigen/src/SparseCore/CompressedStorage.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage
m_allocatedSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::SkylineStorage
m_allow_tol	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_allow_tol; \/\/ Allow to use some tolerance during numerical factorization.$/;"	m	class:Eigen::SPQR
m_alpha	demos/opengl/quaternion_demo.h	/^    float m_alpha;$/;"	m	class:RenderingWidget
m_alphas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_alphas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_analysisIsOk	Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase
m_analysisIsOk	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    bool m_analysisIsOk; $/;"	m	class:Eigen::IncompleteCholesky
m_analysisIsOk	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_analysisIsOk	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_analysisIsOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase
m_analysisIsOk	Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_analysisIsOk	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SPQR
m_analysisIsOk	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_analysisIsOk	Eigen/src/SparseLU/SparseLU.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SparseLU
m_analysisIsOk	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase
m_analysisIsOk	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU
m_analysisIsok	Eigen/src/SparseQR/SparseQR.h	/^    bool m_analysisIsok;$/;"	m	class:Eigen::SparseQR
m_angle	Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_angles	demos/opengl/quaternion_demo.cpp	/^  Vector3 m_angles;$/;"	m	class:EulerAngles	file:
m_angles	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Vector3 m_angles;$/;"	m	class:Eigen::EulerAngles
m_arg	Eigen/src/Core/CoreEvaluators.h	/^  const ArgType& m_arg;$/;"	m	class:Eigen::internal::EvalToTemp
m_arg	Eigen/src/Core/CoreEvaluators.h	/^  const ArgTypeNested m_arg;$/;"	m	struct:Eigen::internal::unary_evaluator
m_arg	Eigen/src/Core/CoreEvaluators.h	/^  typename internal::add_const_on_value_type<ArgTypeNested>::type m_arg;$/;"	m	struct:Eigen::internal::evaluator
m_arg	Eigen/src/SparseCore/SparseTriangularView.h	/^  const ArgType& m_arg;$/;"	m	struct:Eigen::internal::unary_evaluator
m_arg	doc/examples/nullary_indexing.cpp	/^  const ArgType &m_arg;$/;"	m	class:indexing_functor	file:
m_arg1	Eigen/src/Core/CwiseTernaryOp.h	/^  Arg1Nested m_arg1;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg1Impl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg1> m_arg1Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_arg1Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<Arg1Type, Device> m_arg1Impl;$/;"	m	struct:Eigen::TensorEvaluator
m_arg1_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename Arg1XprType::Nested m_arg1_xpr;$/;"	m	class:Eigen::TensorCwiseTernaryOp
m_arg2	Eigen/src/Core/CwiseTernaryOp.h	/^  Arg2Nested m_arg2;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg2Impl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg2> m_arg2Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_arg2Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<Arg2Type, Device> m_arg2Impl;$/;"	m	struct:Eigen::TensorEvaluator
m_arg2_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename Arg2XprType::Nested m_arg2_xpr;$/;"	m	class:Eigen::TensorCwiseTernaryOp
m_arg3	Eigen/src/Core/CwiseTernaryOp.h	/^  Arg3Nested m_arg3;$/;"	m	class:Eigen::CwiseTernaryOp
m_arg3Impl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Arg3> m_arg3Impl;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_arg3Impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<Arg3Type, Device> m_arg3Impl;$/;"	m	struct:Eigen::TensorEvaluator
m_arg3_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename Arg3XprType::Nested m_arg3_xpr;$/;"	m	class:Eigen::TensorCwiseTernaryOp
m_argImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::evaluator
m_argImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::evaluator_wrapper_base
m_argImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ArgTypeNestedCleaned> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/SparseCore/SparseBlock.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/SparseCore/SparseTranspose.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/SparseCore/SparseTriangularView.h	/^  evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	Eigen/src/SparseCore/SparseView.h	/^    evaluator<ArgType> m_argImpl;$/;"	m	struct:Eigen::internal::unary_evaluator
m_argImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<ArgType, Device> m_argImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_axis	Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_axis	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    const Axis m_axis;$/;"	m	class:Eigen::TensorConcatenationOp
m_axis	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    const Axis m_axis;$/;"	m	struct:Eigen::TensorEvaluator
m_axis	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Index m_axis;$/;"	m	class:Eigen::TensorScanOp
m_base_mapper	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  ParentMapper m_base_mapper;$/;"	m	class:Eigen::internal::TensorContractionSubMapper
m_bests	bench/BenchTimer.h	/^  Vector2d m_bests;$/;"	m	class:Eigen::BenchTimer
m_betas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType m_betas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_bidiagonal	Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_bl_diag	unsupported/Eigen/src/Polynomials/Companion.h	/^      BottomLeftDiagonal         m_bl_diag;$/;"	m	class:Eigen::internal::companion
m_block	Eigen/src/SparseCore/SparseBlock.h	/^    const XprType &m_block;$/;"	m	struct:Eigen::internal::unary_evaluator
m_block	Eigen/src/SparseCore/SparseBlock.h	/^  const XprType& m_block;$/;"	m	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
m_blockA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking
m_blockB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking
m_blockCols	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockCols	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::BlockImpl
m_blockPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    StorageIndex *m_blockPtr; \/\/ Pointer to the beginning of each block in m_values, size m_nonzeroblocks ... null for fixed-size blocks$/;"	m	class:Eigen::BlockSparseMatrix
m_blockRows	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockRows	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::BlockImpl
m_blockSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_blockSize; \/\/ Size of a block for fixed-size blocks, otherwise -1$/;"	m	class:Eigen::BlockSparseMatrix
m_block_idx	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index m_block_idx;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
m_block_total_size_max	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  std::size_t m_block_total_size_max;$/;"	m	struct:Eigen::TensorEvaluator
m_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor
m_blocks	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index m_blocks;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
m_broadcast	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    const Broadcast m_broadcast;$/;"	m	class:Eigen::TensorBroadcastingOp
m_broadcast	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  const Broadcast m_broadcast;$/;"	m	struct:Eigen::TensorEvaluator
m_buf	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  Scalar* m_buf;$/;"	m	struct:Eigen::TensorEvaluator
m_buffer	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector
m_buffer	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    PointerType m_buffer;$/;"	m	class:Eigen::TensorEvalToOp
m_buffer	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  DevicePointer m_buffer;$/;"	m	struct:Eigen::TensorEvaluator
m_buffer	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typename MakePointer<CoeffReturnType>::Type m_buffer;$/;"	m	struct:Eigen::TensorEvaluator
m_c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_cR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_cR; \/\/ The sparse R factor in cholmod format$/;"	m	class:Eigen::SPQR
m_cachedIndex	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_cachedIndex; \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cachedValue	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_callback	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void (*m_callback)(const IterationController&);$/;"	m	class:Eigen::IterationController
m_cc	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_common m_cc; \/\/ Workspace and parameters$/;"	m	class:Eigen::SPQR
m_cholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase
m_cholmodFactor	Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase
m_clkid	bench/btl/generic_bench/timers/portable_timer.hh	/^  int m_clkid;$/;"	m	class:Portable_Timer
m_coeff	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typename DiagonalCoeffType::Scalar m_coeff;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_coeffs	Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix
m_coeffs	Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_coeffs	Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence
m_col	Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer
m_col	Eigen/src/SparseCore/SparseUtil.h	/^  StorageIndex m_row, m_col;$/;"	m	class:Eigen::Triplet
m_col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_col; \/\/ Number of columns$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_col	test/sparse_solver.h	/^  Index m_col;$/;"	m	struct:prune_column
m_colFactor	Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate
m_colIndices	doc/examples/nullary_indexing.cpp	/^  const ColIndexType &m_colIndices;$/;"	m	class:indexing_functor	file:
m_colInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_colInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_colInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_colInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_colNormsDirect	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colNormsDirect;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colNormsUpdated	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colNormsUpdated;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colPaddingLeft	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_colPaddingLeft;$/;"	m	struct:Eigen::TensorEvaluator
m_colPaddingLeft	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_colPaddingLeft;$/;"	m	struct:Eigen::TensorEvaluator
m_colStartIndex	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index* m_colStartIndex;$/;"	m	class:Eigen::SkylineMatrix
m_colStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_colStride;$/;"	m	struct:Eigen::TensorEvaluator
m_colStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_colStride;$/;"	m	struct:Eigen::TensorEvaluator
m_col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_col_inflate_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_col_inflate_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_col_inflate_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_col_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_col_inflate_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_col_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_col_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_col_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_col_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_col_to_sup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_col_to_sup; \/\/ col_to_sup[j] is the supernode number to which column j belongs$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_cols	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ArgType::ColsAtCompileTime> m_cols;$/;"	m	struct:Eigen::internal::unary_evaluator
m_cols	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols;$/;"	m	struct:Eigen::internal::unary_evaluator
m_cols	Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp
m_cols	Eigen/src/Core/DenseStorage.h	/^    Index m_cols;$/;"	m	class:Eigen::DenseStorage
m_cols	Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase
m_cols	Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_cols	Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_cols	Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_colsPermutation	Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colsTranspositions	Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_colsTranspositions	Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR
m_cols_permutation	Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR
m_cols_transpositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_comm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase
m_compU	Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_compV	Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_computationOptions	Eigen/src/SVD/SVDBase.h	/^  unsigned int m_computationOptions;$/;"	m	class:Eigen::SVDBase
m_computeFullU	Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::SVDBase
m_computeFullV	Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::SVDBase
m_computeQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_computeQZ;$/;"	m	class:Eigen::RealQZ
m_computeThinU	Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::SVDBase
m_computeThinV	Eigen/src/SVD/SVDBase.h	/^  bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::SVDBase
m_computed	Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_computed;$/;"	m	class:Eigen::BDCSVD
m_condImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<IfArgType, Device> m_condImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_condition	Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select
m_condition	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename IfXprType::Nested m_condition;$/;"	m	class:Eigen::TensorSelectOp
m_conditionImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ConditionMatrixType> m_conditionImpl;$/;"	m	struct:Eigen::internal::evaluator
m_conditionNumber	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    RealScalar m_conditionNumber;$/;"	m	class:Eigen::MatrixPower
m_containsDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^      bool m_containsDiag;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_contract_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const contract_t m_contract_strides;$/;"	m	class:Eigen::internal::SimpleTensorContractionMapper
m_control	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackControl m_control;$/;"	m	class:Eigen::UmfPackLU
m_cpqr	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  ColPivHouseholderQR<MatrixType> m_cpqr;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_ctrls	unsupported/Eigen/src/Splines/Spline.h	/^    ControlPointVectorType  m_ctrls; \/*!< Control points. *\/$/;"	m	class:Eigen::Spline
m_cudaInputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_cudaInputStrides;$/;"	m	class:Eigen::internal::IndexMapper
m_cudaOutputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_cudaOutputStrides;$/;"	m	class:Eigen::internal::IndexMapper
m_currentBlockRows	Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer
m_currentEl	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_currentEl;   \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_curs_id	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    struct dirent *m_curs_id; $/;"	m	class:Eigen::MatrixMarketIterator	typeref:struct:Eigen::MatrixMarketIterator::dirent
m_data	Eigen/src/Core/CoreEvaluators.h	/^  PointerType m_data;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_data	Eigen/src/Core/CoreEvaluators.h	/^  const Scalar *m_data;$/;"	m	struct:Eigen::internal::evaluator
m_data	Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage
m_data	Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage
m_data	Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize)+(ForceAlignment?EIGEN_MAX_ALIGN_BYTES:0),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0,EIGEN_PLAIN_ENUM_MIN(AlignedMax,PacketSize)> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase
m_data	Eigen/src/Core/util/BlasUtil.h	/^  Scalar *m_data;$/;"	m	class:Eigen::internal::BlasLinearMapper
m_data	Eigen/src/Core/util/BlasUtil.h	/^  Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper
m_data	Eigen/src/Core/util/BlasUtil.h	/^  Scalar* m_data;$/;"	m	class:Eigen::internal::BlasVectorMapper
m_data	Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix
m_data	Eigen/src/SparseCore/SparseVector.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseVector
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const Scalar* m_data;$/;"	m	struct:Eigen::internal::CoeffLoader
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typename internal::traits<Derived>::template MakePointer<Scalar>::Type m_data;$/;"	m	struct:Eigen::TensorEvaluator
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  typename internal::traits<Derived>::template MakePointer<const Scalar>::Type m_data;$/;"	m	struct:Eigen::TensorEvaluator
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  CoeffReturnType* m_data;$/;"	m	struct:Eigen::TensorEvaluator
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    typename MakePointer_<Scalar>::Type m_data;$/;"	m	class:Eigen::TensorMap
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_ALIGN_MAX T m_data[MinSize];$/;"	m	class:Eigen::TensorStorage
m_data	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  T *m_data;$/;"	m	class:Eigen::TensorStorage
m_data	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    SkylineStorage<Scalar> m_data;$/;"	m	class:Eigen::SkylineMatrix
m_data	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    std::vector<internal::CompressedStorage<Scalar,StorageIndex> > m_data;$/;"	m	class:Eigen::DynamicSparseMatrix
m_deallocate	Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_dec	Eigen/src/Core/Solve.h	/^  const Decomposition &m_dec;$/;"	m	class:Eigen::Solve
m_dec	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const Decomposition &m_dec;$/;"	m	class:Eigen::SolveWithGuess
m_dec	Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base
m_dec	Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_delta	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_delta;$/;"	m	class:Eigen::LevenbergMarquardt
m_derivatives	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    DerType m_derivatives;$/;"	m	class:Eigen::AutoDiffScalar
m_dest	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor
m_detPermC	Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_detPermR	Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_det_p	Eigen/src/LU/PartialPivLU.h	/^    signed char m_det_p;$/;"	m	class:Eigen::PartialPivLU
m_det_pq	Eigen/src/LU/FullPivLU.h	/^    signed char m_det_pq;$/;"	m	class:Eigen::FullPivLU
m_det_pq	Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR
m_det_pq	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  const GpuDevice& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    const DeviceType& m_device;$/;"	m	class:Eigen::TensorDevice
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_device	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Device& m_device;$/;"	m	struct:Eigen::TensorEvaluator
m_devicePropInitialized	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static bool m_devicePropInitialized = false;$/;"	m	namespace:Eigen
m_deviceProperties	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static cudaDeviceProp* m_deviceProperties;$/;"	m	namespace:Eigen
m_diag	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase
m_diag	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_fvec, m_qtf, m_diag; $/;"	m	class:Eigen::LevenbergMarquardt
m_diag	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_diag;$/;"	m	class:Eigen::SkylineStorage
m_diagCoeffImpl	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<DiagonalCoeffType> m_diagCoeffImpl;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_diagCoeffNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    DiagCoeffNested m_diagCoeffNested;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_diagCoeffNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  DiagCoeffNested m_diagCoeffNested;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_diagImpl	Eigen/src/Core/ProductEvaluators.h	/^  evaluator<DiagonalType> m_diagImpl;$/;"	m	struct:Eigen::internal::diagonal_product_evaluator_base
m_diagSize	Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_diagSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_diagSize;$/;"	m	class:Eigen::SkylineStorage
m_diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix
m_diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper
m_diagpivotthresh	Eigen/src/SparseLU/SparseLU.h	/^    RealScalar m_diagpivotthresh; \/\/ Specifies the threshold used for a diagonal entry to be an acceptable pivot$/;"	m	class:Eigen::SparseLU
m_dim	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    const internal::DimensionId<DimId> m_dim;$/;"	m	class:Eigen::TensorChippingOp
m_dim	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  const internal::DimensionId<DimId> m_dim;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    Dimensions m_dimensions;$/;"	m	class:Eigen::TensorMap
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  DSizes<Index, NumDims> m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  NewDimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  Dimensions m_dimensions;$/;"	m	class:Eigen::TensorStorage
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  FixedDimensions m_dimensions;$/;"	m	class:Eigen::TensorStorage
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  const Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
m_dimensions	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Dimensions m_dimensions;$/;"	m	struct:Eigen::TensorEvaluator
m_dims	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  Dimensions m_dims;$/;"	m	struct:Eigen::TensorEvaluator
m_dims	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const NewDimensions m_dims;$/;"	m	class:Eigen::TensorReshapingOp
m_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    const Dims m_dims;$/;"	m	class:Eigen::TensorReductionOp
m_dims	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  Dimensions m_dims;$/;"	m	class:Eigen::internal::TensorLazyEvaluatorReadOnly
m_dims	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    const Strides m_dims;$/;"	m	class:Eigen::TensorStridingOp
m_direction	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_divisor	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_divisor;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_divisor	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  const Scalar m_divisor;$/;"	m	struct:Eigen::internal::scalar_mod_op
m_dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Array<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_droptol	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT
m_dst	Eigen/src/Core/AssignEvaluator.h	/^  DstEvaluatorType& m_dst;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_dstExpr	Eigen/src/Core/AssignEvaluator.h	/^  DstXprType& m_dstExpr;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_dummy	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixType m_dummy; \/\/ used to default initialize the Ref<> object$/;"	m	class:Eigen::internal::generic_matrix_wrapper
m_dummy	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_dummy;$/;"	m	class:Eigen::UmfPackLU
m_dummy	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  Scalar m_dummy;$/;"	m	class:Eigen::internal::TensorLazyEvaluatorReadOnly
m_eigenvectorsOk	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver
m_eigenvectorsOk	Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver
m_eigenvectorsOk	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eigenvectorsOk	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  bool m_eigenvectorsOk;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_eivalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivalues	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver
m_eivalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivalues	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  Matrix<Scalar, Dynamic, 1> m_eivalues;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_eivec	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivec	Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver
m_eivec	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_eivec	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivec	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  Matrix<Scalar, Dynamic, Dynamic> m_eivec;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    std::vector<GroupElement> m_elements;$/;"	m	class:Eigen::DynamicSGroup
m_else	Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select
m_else	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename ElseXprType::Nested m_else;$/;"	m	class:Eigen::TensorSelectOp
m_elseImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ElseMatrixType> m_elseImpl;$/;"	m	struct:Eigen::internal::evaluator
m_elseImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<ElseArgType, Device> m_elseImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_empty	Eigen/src/SparseCore/SparseDenseProduct.h	/^    bool m_empty;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_end	Eigen/src/Core/CoreIterators.h	/^  const Index m_end;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_end	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_end;$/;"	m	class:Eigen::internal::AmbiVector
m_end	Eigen/src/SparseCore/SparseBlock.h	/^  Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
m_end	Eigen/src/SparseCore/SparseBlock.h	/^  Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_end	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_end;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_end	Eigen/src/SparseCore/SparseView.h	/^        const Index m_end;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_end	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_end	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_end	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_end; \/\/ starting inner index of the next block$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_end	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::BlockSparseMatrix::BlockInnerIterator
m_endidrow	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_endidrow;                       \/\/ End index of row indices of the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_endidval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_endidval;                 \/\/ End of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_epsfcn	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_epsfcn; \/\/$/;"	m	class:Eigen::LevenbergMarquardt
m_epsilon	Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_epsilon	Eigen/src/SparseCore/SparseView.h	/^  RealScalar m_epsilon;$/;"	m	class:Eigen::SparseView
m_error	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase
m_etree	Eigen/src/SparseLU/SparseLU.h	/^    IndexVector m_etree; \/\/ Column elimination tree $/;"	m	class:Eigen::SparseLU
m_etree	Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_etree;            \/\/ Column elimination tree$/;"	m	class:Eigen::SparseQR
m_eval	Eigen/src/Core/CoreIterators.h	/^  EvaluatorType m_eval;$/;"	m	class:Eigen::InnerIterator
m_eval	Eigen/src/Core/CoreIterators.h	/^  const EvaluatorType& m_eval;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_eval	Eigen/src/SparseCore/SparseBlock.h	/^  const unary_evaluator& m_eval;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_evaluator	Eigen/src/Core/Redux.h	/^  internal::evaluator<XprType> m_evaluator;$/;"	m	class:Eigen::internal::redux_evaluator
m_evaluator	Eigen/src/Core/Visitor.h	/^  internal::evaluator<XprType> m_evaluator;$/;"	m	class:Eigen::internal::visitor_evaluator
m_evaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  internal::TensorLazyBaseEvaluator<Dimensions, Scalar>* m_evaluator;$/;"	m	class:Eigen::TensorRef
m_exclusive	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const bool m_exclusive;$/;"	m	class:Eigen::TensorScanOp
m_exclusive	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const bool m_exclusive;$/;"	m	struct:Eigen::TensorEvaluator
m_expr	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const XprType &m_expr;$/;"	m	struct:Eigen::internal::binary_evaluator
m_expr	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    typename XprType::Nested m_expr;$/;"	m	class:Eigen::TensorCustomUnaryOp
m_expr	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    typename XprType::Nested m_expr;$/;"	m	class:Eigen::TensorReductionOp
m_expr	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typename XprType::Nested m_expr;$/;"	m	class:Eigen::TensorScanOp
m_expression	Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper
m_expression	Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper
m_expression	Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess
m_expression	Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue
m_expression	Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias
m_expression	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::TensorDevice
m_expression	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  const ArgType m_expression;$/;"	m	struct:Eigen::TensorEvaluator
m_extractedDataAreDirty	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase
m_extractedDataAreDirty	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU
m_f	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    StemFunction *m_f;$/;"	m	class:Eigen::MatrixFunctionReturnValue
m_f	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    StemFunction* m_f;$/;"	m	class:Eigen::internal::MatrixFunctionAtomic
m_fT	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    ComplexMatrix m_fT;$/;"	m	class:Eigen::MatrixPower
m_fact_errorCode	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_fact_errorCode;$/;"	m	class:Eigen::UmfPackLU
m_factor	Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling
m_factor	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_factor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_factor; \/\/$/;"	m	class:Eigen::LevenbergMarquardt
m_factorizationIsOk	Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase
m_factorizationIsOk	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    bool m_factorizationIsOk; $/;"	m	class:Eigen::IncompleteCholesky
m_factorizationIsOk	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_factorizationIsOk	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_factorizationIsOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase
m_factorizationIsOk	Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_factorizationIsOk	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SPQR
m_factorizationIsOk	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_factorizationIsOk	Eigen/src/SparseLU/SparseLU.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SparseLU
m_factorizationIsOk	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase
m_factorizationIsOk	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU
m_factorizationIsok	Eigen/src/SparseQR/SparseQR.h	/^    bool m_factorizationIsok;$/;"	m	class:Eigen::SparseQR
m_fastColStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastColStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastColStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastColStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInflateColStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInflateColStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInflateRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInflateRowStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInputColStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInputColStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInputColsEff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInputColsEff;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInputColsEff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInputColsEff;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInputPlaneStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInputPlaneStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastInputRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastInputRowStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOtherStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOtherStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOtherStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOtherStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputDepth	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOutputDepth;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputDepth	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOutputDepth;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputPlanes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOutputPlanes;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputPlanesRows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOutputPlanesRows;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputRows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastOutputRows;$/;"	m	struct:Eigen::TensorEvaluator
m_fastOutputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  array<internal::TensorIntDivisor<Index>, NumDims> m_fastOutputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_fastPatchStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  internal::TensorIntDivisor<Index> m_fastPatchStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastPatchStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastPatchStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  internal::TensorIntDivisor<Index> m_fastRowStride;$/;"	m	struct:Eigen::TensorEvaluator
m_fastStrides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  array<internal::TensorIntDivisor<Index>, NumDims> m_fastStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_fft	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const FFT m_fft;$/;"	m	class:Eigen::TensorFFTOp
m_fft	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const FFT& m_fft;$/;"	m	struct:Eigen::TensorEvaluator
m_fillfactor	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT
m_firstRowElt	Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_firstRowElt;      \/\/ First element in each row$/;"	m	class:Eigen::SparseQR
m_fjac	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    JacobianType m_fjac; $/;"	m	class:Eigen::LevenbergMarquardt
m_flags	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int m_flags;$/;"	m	class:Eigen::SkylineInplaceLU
m_flip	Eigen/src/Core/functors/NullaryFunctors.h	/^  const bool m_flip;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_fnorm	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_fnorm; \/\/ Norm of the current vector function$/;"	m	class:Eigen::LevenbergMarquardt
m_folder	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    std::string m_folder;$/;"	m	class:Eigen::MatrixMarketIterator
m_folder_id	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    DIR * m_folder_id;$/;"	m	class:Eigen::MatrixMarketIterator
m_force	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable bool m_force; \/\/ Force the use of deflation at each restart$/;"	m	class:Eigen::DGMRES
m_format	Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat
m_frequency	bench/BenchTimer.h	/^  double m_frequency;$/;"	m	class:Eigen::BenchTimer
m_ftol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_ftol; \/\/Tolerance in the norm of the vector function$/;"	m	class:Eigen::LevenbergMarquardt
m_func	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    const CustomBinaryFunc m_func;$/;"	m	class:Eigen::TensorCustomBinaryOp
m_func	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    const CustomUnaryFunc m_func;$/;"	m	class:Eigen::TensorCustomUnaryOp
m_functor	Eigen/src/Core/AssignEvaluator.h	/^  const Functor &m_functor;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_functor	Eigen/src/Core/CoreEvaluators.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::binary_evaluator
m_functor	Eigen/src/Core/CoreEvaluators.h	/^  const MemberOp m_functor;$/;"	m	struct:Eigen::internal::evaluator
m_functor	Eigen/src/Core/CoreEvaluators.h	/^  const NullaryOp m_functor;$/;"	m	struct:Eigen::internal::evaluator
m_functor	Eigen/src/Core/CoreEvaluators.h	/^  const TernaryOp m_functor;$/;"	m	struct:Eigen::internal::ternary_evaluator
m_functor	Eigen/src/Core/CoreEvaluators.h	/^  const UnaryOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_functor	Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp
m_functor	Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp
m_functor	Eigen/src/Core/CwiseTernaryOp.h	/^  const TernaryOp m_functor;$/;"	m	class:Eigen::CwiseTernaryOp
m_functor	Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp
m_functor	Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView
m_functor	Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr
m_functor	Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::binary_evaluator
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	struct:Eigen::internal::unary_evaluator
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::TensorEvaluator
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const NullaryOp m_functor;$/;"	m	struct:Eigen::TensorEvaluator
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TernaryOp m_functor;$/;"	m	struct:Eigen::TensorEvaluator
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const UnaryOp m_functor;$/;"	m	struct:Eigen::TensorEvaluator
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::TensorCwiseBinaryOp
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::TensorCwiseNullaryOp
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const TernaryOp m_functor;$/;"	m	class:Eigen::TensorCwiseTernaryOp
m_functor	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::TensorCwiseUnaryOp
m_functor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FunctorType &m_functor;$/;"	m	class:Eigen::LevenbergMarquardt
m_fvec	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_fvec, m_qtf, m_diag; $/;"	m	class:Eigen::LevenbergMarquardt
m_generator	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    const Generator m_generator;$/;"	m	class:Eigen::TensorGeneratorOp
m_generator	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  Generator m_generator;$/;"	m	struct:Eigen::TensorEvaluator
m_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    std::vector<Generator> m_generators;$/;"	m	class:Eigen::DynamicSGroup
m_globalFlags	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    int m_globalFlags;$/;"	m	class:Eigen::DynamicSGroup
m_global_iter	Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_global_iter;$/;"	m	class:Eigen::RealQZ
m_glu	Eigen/src/SparseLU/SparseLU.h	/^    typename Base::GlobalLU_t m_glu; $/;"	m	class:Eigen::SparseLU
m_glu	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typename SparseLUImpl<Scalar, StorageIndex>::GlobalLU_t& m_glu;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_gnorm	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_gnorm; \/\/Norm of the gradient of the error $/;"	m	class:Eigen::LevenbergMarquardt
m_gtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_gtol; \/\/tolerance of the norm of the error gradient$/;"	m	class:Eigen::LevenbergMarquardt
m_guess	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const GuessType     &m_guess;$/;"	m	class:Eigen::SolveWithGuess
m_hCoeffs	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition
m_hCoeffs	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization
m_hCoeffs	Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR
m_hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR
m_hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_hCoeffs	Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR
m_hasCopy	Eigen/src/SparseCore/SparseRef.h	/^    bool m_hasCopy;$/;"	m	class:Eigen::Ref
m_hasRhs	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_hasRhs; \/\/ The right hand side exists$/;"	m	class:Eigen::MatrixMarketIterator
m_hashmaps	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    HashMapType* m_hashmaps;$/;"	m	class:Eigen::RandomSetter
m_hasrefX	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_hasrefX; \/\/ A reference solution is provided$/;"	m	class:Eigen::MatrixMarketIterator
m_hcoeffs	Eigen/src/SparseQR/SparseQR.h	/^    ScalarVector m_hcoeffs;         \/\/ The Householder coefficients$/;"	m	class:Eigen::SparseQR
m_hess	Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur
m_hess	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
m_hess	Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur
m_high	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_high;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_horiz_offset	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const Index m_horiz_offset;$/;"	m	class:Eigen::internal::TensorContractionSubMapper
m_householder	Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_i_size	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  Index m_i_size;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_i_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  left_nocontract_t m_i_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_id	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_id;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_id	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_id;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_id	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    StorageIndex m_id;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_id	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_id	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_id	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_id; \/\/ current inner index in the block$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_id	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::BlockSparseMatrix::BlockInnerIterator
m_idrow	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idrow;                          \/\/ Index to browse the row indices $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_idval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idval;                          \/\/ Index to browse the values in the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_ij_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const nocontract_t m_ij_strides;$/;"	m	class:Eigen::internal::SimpleTensorContractionMapper
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  TensorEvaluator<const TensorReductionOp<ReduceOp, Dims, const TensorIndexTupleOp<ArgType> >, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  const TensorEvaluator& m_impl;$/;"	m	struct:Eigen::PacketConverter
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const Derived& m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorEvaluator<Expr, Device> m_impl;$/;"	m	class:Eigen::internal::TensorLazyEvaluatorReadOnly
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_impl	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  TensorEvaluator<ArgType, Device> m_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_in_col_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_in_col_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_in_col_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_in_col_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_in_col_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_in_plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_in_plane_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_in_plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_in_plane_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_in_row_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_in_row_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_in_row_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_in_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_in_row_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_index	Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamicindex<Index, XprType::DiagIndex> m_index;$/;"	m	struct:Eigen::internal::evaluator
m_index	Eigen/src/Core/Diagonal.h	/^    const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal
m_index	Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_indexPtr	Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_indexPtr; \/\/ Pointer to the adjacenccy list of each row\/column$/;"	m	class:Eigen::MetisOrdering
m_indexStride	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumKernelDims> m_indexStride;$/;"	m	struct:Eigen::TensorEvaluator
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper
m_indices	Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions
m_indices	Eigen/src/Core/Transpositions.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper
m_indices	Eigen/src/SparseCore/CompressedStorage.h	/^    StorageIndex* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage
m_indices	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const StorageIndex* m_indices;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_indices	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const StorageIndex* m_indices;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_indices	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    const Indices m_indices;$/;"	m	class:Eigen::TensorContractionOp
m_indices	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    const Indices m_indices;$/;"	m	class:Eigen::TensorConvolutionOp
m_indices	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  Indices m_indices;$/;"	m	struct:Eigen::TensorEvaluator
m_indices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices m_indices;$/;"	m	class:Eigen::TensorSlicingOp
m_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    std::array<Index, NumIndices> m_indices;$/;"	m	class:Eigen::internal::tensor_symmetry_value_setter
m_indices	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    StorageIndex *m_indices; \/\/Inner block indices, size m_nonzerosblocks ... OK$/;"	m	class:Eigen::BlockSparseMatrix
m_inf	doc/examples/class_CwiseUnaryOp.cpp	/^  Scalar m_inf, m_sup;$/;"	m	struct:CwiseClampOp	file:
m_info	Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LDLT
m_info	Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT
m_info	Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase
m_info	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur
m_info	Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::EigenSolver
m_info	Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo m_info;$/;"	m	class:Eigen::RealQZ
m_info	Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur
m_info	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_info	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteCholesky
m_info	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT
m_info	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase
m_info	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase
m_info	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl
m_info	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SPQR
m_info	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_info	Eigen/src/SparseLU/SparseLU.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseLU
m_info	Eigen/src/SparseQR/SparseQR.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseQR
m_info	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase
m_info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU
m_info	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  ComputationInfo m_info;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_info	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::IterScaling
m_info	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    ComputationInfo m_info; $/;"	m	class:Eigen::LevenbergMarquardt
m_initialShift	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    RealScalar m_initialShift;   \/\/ The initial shift parameter$/;"	m	class:Eigen::IncompleteCholesky
m_initisOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase
m_inner	Eigen/src/Core/CoreIterators.h	/^  Index m_inner;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_inner	Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride
m_inner	Eigen/src/SparseCore/SparseView.h	/^        Index m_inner;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_innerBSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_innerBSize; \/\/ Number of block rows$/;"	m	class:Eigen::BlockSparseMatrix
m_innerDim	Eigen/src/Core/ProductEvaluators.h	/^  Index m_innerDim;$/;"	m	struct:Eigen::internal::product_evaluator
m_innerIndex	Eigen/src/SparseCore/SparseBlock.h	/^  const Index m_innerIndex;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_innerIndices	Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_innerIndices; \/\/ Adjacency list $/;"	m	class:Eigen::MetisOrdering
m_innerIndices	Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_innerIndices;$/;"	m	class:Eigen::SparseMapBase
m_innerNonZeros	Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_innerNonZeros;$/;"	m	class:Eigen::SparseMapBase
m_innerNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    StorageIndex* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix
m_innerOffset	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    StorageIndex *m_innerOffset; \/\/ Starting index of each inner block (size m_innerBSize+1)$/;"	m	class:Eigen::BlockSparseMatrix
m_innerSize	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    StorageIndex m_innerSize;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_innerSize	Eigen/src/SparseCore/SparseMap.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::SparseMapBase
m_innerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix
m_innerSize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SkylineMatrix
m_innerSize	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::DynamicSparseMatrix
m_innerStride	Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamic<Index, XprType::InnerStrideAtCompileTime> m_innerStride;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_inputCols	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_inputCols;$/;"	m	struct:Eigen::TensorEvaluator
m_inputCols	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_inputCols;$/;"	m	struct:Eigen::TensorEvaluator
m_inputDepth	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_inputDepth;$/;"	m	struct:Eigen::TensorEvaluator
m_inputDepth	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_inputDepth;$/;"	m	struct:Eigen::TensorEvaluator
m_inputImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  TensorEvaluator<InputArgType, Device> m_inputImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_inputImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  TensorEvaluator<InputArgType, GpuDevice> m_inputImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_inputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  Index m_inputOffset;$/;"	m	struct:Eigen::TensorEvaluator
m_inputPlanes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_inputPlanes;$/;"	m	struct:Eigen::TensorEvaluator
m_inputRows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_inputRows;$/;"	m	struct:Eigen::TensorEvaluator
m_inputRows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_inputRows;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStride	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  Index m_inputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStride	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_inputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	class:Eigen::internal::IndexMapper
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  array<Index, NumDims-1> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_inputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  array<Index, NumDims> m_inputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_input_cols_eff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_input_cols_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_input_cols_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_input_cols_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_input_planes_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_input_planes_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_input_rows_eff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_input_rows_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_input_rows_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_input_rows_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_input_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    typename InputXprType::Nested m_input_xpr;$/;"	m	class:Eigen::TensorConvolutionOp
m_inputs	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  const int m_inputs, m_values;$/;"	m	struct:Eigen::DenseFunctor
m_inputs	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  const int m_inputs, m_values;$/;"	m	struct:Eigen::SparseFunctor
m_inputs	unsupported/test/NonLinearOptimization.cpp	/^  const int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_inputs	unsupported/test/NumericalDiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_inputs	unsupported/test/autodiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_inputs	unsupported/test/forward_adolc.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_invdiag	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner
m_inverse	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  bool m_inverse;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_invp	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<StorageIndex,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase
m_iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Array<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_iparm	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl
m_isAllocated	Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_isDeflAllocated	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable bool m_isDeflAllocated;$/;"	m	class:Eigen::DGMRES
m_isDeflInitialized	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable bool m_isDeflInitialized;$/;"	m	class:Eigen::DGMRES
m_isDense	Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_isEtreeOk	Eigen/src/SparseQR/SparseQR.h	/^    bool m_isEtreeOk;               \/\/ whether the elimination tree match the initial input matrix$/;"	m	class:Eigen::SparseQR
m_isInitialized	Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT
m_isInitialized	Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT
m_isInitialized	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver
m_isInitialized	Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur
m_isInitialized	Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver
m_isInitialized	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition
m_isInitialized	Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_isInitialized;$/;"	m	class:Eigen::RealQZ
m_isInitialized	Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur
m_isInitialized	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_isInitialized	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization
m_isInitialized	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner
m_isInitialized	Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_isInitialized	Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU
m_isInitialized	Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_isInitialized	Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_isInitialized	Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR
m_isInitialized	Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_isInitialized	Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_isInitialized	Eigen/src/SparseCore/SparseSolverBase.h	/^    mutable bool m_isInitialized;$/;"	m	class:Eigen::SparseSolverBase
m_isInitialized	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  bool m_isInitialized;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_isInitialized	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    bool m_isInitialized; $/;"	m	class:Eigen::IterScaling
m_isInitialized	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    bool m_isInitialized; \/\/ Check whether the minimization step has been called$/;"	m	class:Eigen::LevenbergMarquardt
m_isQSorted	Eigen/src/SparseQR/SparseQR.h	/^    bool m_isQSorted;               \/\/ whether Q is sorted or not$/;"	m	class:Eigen::SparseQR
m_isRUpToDate	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable bool m_isRUpToDate;$/;"	m	class:Eigen::SPQR
m_isRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase
m_isRValue	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SkylineMatrixBase
m_isTranspose	Eigen/src/SVD/BDCSVD.h	/^  bool m_isTranspose, m_compU, m_compV;$/;"	m	class:Eigen::BDCSVD
m_isvalid	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_isvalid; $/;"	m	class:Eigen::MatrixMarketIterator
m_it	Eigen/src/SparseCore/SparseBlock.h	/^  EvalIterator m_it;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_iter	Eigen/src/Core/CoreIterators.h	/^  IteratorType m_iter;$/;"	m	class:Eigen::InnerIterator
m_iter	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index m_iter; \/\/ Number of iterations performed$/;"	m	class:Eigen::LevenbergMarquardt
m_iterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable Index m_iterations;$/;"	m	class:Eigen::IterativeSolverBase
m_j_size	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  Index m_j_size;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_j_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  right_nocontract_t m_j_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_jacobian	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    JacobianType m_jacobian;$/;"	m	class:Eigen::AutoDiffVector
m_jcol	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_jcol	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_jsuper_ref	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index& m_jsuper_ref;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_k_size	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  Index m_k_size;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_k_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  contract_t m_k_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_k_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const contract_t m_k_strides;$/;"	m	class:Eigen::internal::SimpleTensorContractionMapper
m_kc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_kc;$/;"	m	class:Eigen::internal::level3_blocking
m_kernel	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  const Scalar* m_kernel;$/;"	m	struct:Eigen::TensorEvaluator
m_kernelArg	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  KernelArgType m_kernelArg;$/;"	m	struct:Eigen::TensorEvaluator
m_kernelImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  TensorEvaluator<KernelArgType, Device> m_kernelImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_kernelImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  TensorEvaluator<KernelArgType, GpuDevice> m_kernelImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_kernelStride	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumKernelDims> m_kernelStride;$/;"	m	struct:Eigen::TensorEvaluator
m_kernel_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^    typename KernelXprType::Nested m_kernel_xpr;$/;"	m	class:Eigen::TensorConvolutionOp
m_keyBitsOffset	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    unsigned char m_keyBitsOffset;$/;"	m	class:Eigen::RandomSetter
m_knots	unsupported/Eigen/src/Splines/Spline.h	/^    KnotVectorType m_knots; \/*!< Knot vector. *\/$/;"	m	class:Eigen::Spline
m_l	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase
m_l	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU
m_l1	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l1;$/;"	m	struct:Eigen::internal::CacheSizes
m_l1_norm	Eigen/src/Cholesky/LDLT.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::LDLT
m_l1_norm	Eigen/src/Cholesky/LLT.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::LLT
m_l1_norm	Eigen/src/LU/FullPivLU.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::FullPivLU
m_l1_norm	Eigen/src/LU/PartialPivLU.h	/^    RealScalar m_l1_norm;$/;"	m	class:Eigen::PartialPivLU
m_l2	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l2;$/;"	m	struct:Eigen::internal::CacheSizes
m_l3	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  std::ptrdiff_t m_l3;$/;"	m	struct:Eigen::internal::CacheSizes
m_lambdaN	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable RealScalar m_lambdaN; \/\/Modulus of the largest eigenvalue of A$/;"	m	class:Eigen::DGMRES
m_lastError	Eigen/src/SparseLU/SparseLU.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseLU
m_lastError	Eigen/src/SparseQR/SparseQR.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseQR
m_left	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd m_left; \/\/ Left scaling vector$/;"	m	class:Eigen::IterScaling
m_leftImpl	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  TensorEvaluator<LeftArgType, Device> m_leftImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_leftImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    TensorEvaluator<LeftArgType, Device> m_leftImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_leftImpl	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  TensorEvaluator<EvalLeftArgType, Device> m_leftImpl;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_leftImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<LeftArgType, Device> m_leftImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_leftStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    array<Index, NumDims> m_leftStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_left_contracting_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  contract_t m_left_contracting_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_left_nocontract_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  left_nocontract_t m_left_nocontract_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_length	Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence
m_lhs	Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_lhs	Eigen/src/Core/Product.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::Product
m_lhs	Eigen/src/Core/ProductEvaluators.h	/^  typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhs	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_lhs	Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_lhs	Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_lhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  const LhsArg m_lhs;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_lhs	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typename Rhs::PlainObject m_lhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhs	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::internal::SkylineProduct
m_lhsEval	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const LhsEvaluator &m_lhsEval;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_lhsEval	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<Lhs> &m_lhsEval;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_lhsImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Lhs> m_lhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_lhsImpl	Eigen/src/Core/ProductEvaluators.h	/^  LhsEtorType m_lhsImpl;$/;"	m	struct:Eigen::internal::product_evaluator
m_lhsImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<Lhs> m_lhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_lhsImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<LhsArg> m_lhsImpl;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_lhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_lhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_lhsXprImpl	Eigen/src/SparseCore/SparseDenseProduct.h	/^  evaluator<ActualLhs> m_lhsXprImpl;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_lhs_inner_dim_contiguous	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  bool m_lhs_inner_dim_contiguous;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_lhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    typename internal::remove_all<typename LhsXprType::Nested>::type& m_lhs_xpr;$/;"	m	class:Eigen::TensorAssignOp
m_lhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typename LhsXprType::Nested m_lhs_xpr;$/;"	m	class:Eigen::TensorConcatenationOp
m_lhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    typename LhsXprType::Nested m_lhs_xpr;$/;"	m	class:Eigen::TensorContractionOp
m_lhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    typename LhsXprType::Nested m_lhs_xpr;$/;"	m	class:Eigen::TensorCustomBinaryOp
m_lhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename LhsXprType::Nested m_lhs_xpr;$/;"	m	class:Eigen::TensorCwiseBinaryOp
m_linear_offset	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, InnerPanel ? Dynamic : 0> m_linear_offset;$/;"	m	struct:Eigen::internal::unary_evaluator
m_llCurrent	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector
m_llSize	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llSize;$/;"	m	class:Eigen::internal::AmbiVector
m_llStart	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_llStart;$/;"	m	class:Eigen::internal::AmbiVector
m_local_kernel	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  bool m_local_kernel;$/;"	m	struct:Eigen::TensorEvaluator
m_low	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lower	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_lower;$/;"	m	class:Eigen::SkylineStorage
m_lowerProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index* m_lowerProfile;$/;"	m	class:Eigen::SkylineStorage
m_lowerProfileSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_lowerProfileSize;$/;"	m	class:Eigen::SkylineStorage
m_lowerSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_lowerSize;$/;"	m	class:Eigen::SkylineStorage
m_lu	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT
m_lu	Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU
m_lu	Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU
m_lu	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLU
m_lu	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    MatrixType& m_lu;$/;"	m	class:Eigen::SkylineInplaceLU
m_luImpl	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  SparseLUImpl<Scalar, StorageIndex>& m_luImpl;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_luT	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable PartialPivLU<DenseMatrix> m_luT; \/\/ LU factorization of m_T$/;"	m	class:Eigen::DGMRES
m_mapL	Eigen/src/SparseLU/SparseLU.h	/^  const MappedSupernodalType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixLReturnType
m_mapL	Eigen/src/SparseLU/SparseLU.h	/^  const MatrixLType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_mapU	Eigen/src/SparseLU/SparseLU.h	/^  const MatrixUType& m_mapU;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_marker	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  StorageIndex* m_marker;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_mat	Eigen/src/SparseLU/SparseLU.h	/^    NCMatrix m_mat; \/\/ The input (permuted ) matrix $/;"	m	class:Eigen::SparseLU
m_mat	test/constructor.cpp	/^  MatrixType m_mat;$/;"	m	struct:Wrapper	file:
m_mat	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const BlockSparseMatrix& m_mat;$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_mat	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const BlockSparseMatrix<_Scalar, _BlockAtCompileTime, _Options, StorageIndex>& m_mat;$/;"	m	class:Eigen::BlockSparseMatrix::BlockInnerIterator
m_mat	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    MatrixType m_mat; \/\/ Current matrix  $/;"	m	class:Eigen::MatrixMarketIterator
m_matImpl	Eigen/src/Core/ProductEvaluators.h	/^  evaluator<MatrixType>   m_matImpl;$/;"	m	struct:Eigen::internal::diagonal_product_evaluator_base
m_matIsLoaded	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_matIsLoaded; \/\/ Determine if the matrix has already been loaded from the file$/;"	m	class:Eigen::MatrixMarketIterator
m_matT	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matT	Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver
m_matT	Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur
m_matU	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matU	Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur
m_matUisUptodate	Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur
m_matUisUptodate	Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur
m_matX	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver
m_matname	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    std::string m_matname; \/\/ Matrix Name$/;"	m	class:Eigen::MatrixMarketIterator
m_matrix	Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT
m_matrix	Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT
m_matrix	Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::CwiseUnaryView
m_matrix	Eigen/src/Core/Diagonal.h	/^    typename internal::ref_selector<MatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::Diagonal
m_matrix	Eigen/src/Core/IO.h	/^    typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat
m_matrix	Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate
m_matrix	Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse
m_matrix	Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView
m_matrix	Eigen/src/Core/Transpose.h	/^    typename internal::ref_selector<MatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::Transpose
m_matrix	Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView
m_matrix	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp
m_matrix	Eigen/src/Core/VectorwiseOp.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr
m_matrix	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition
m_matrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization
m_matrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
m_matrix	Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous
m_matrix	Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ActualMatrixType m_matrix;$/;"	m	class:Eigen::internal::generic_matrix_wrapper
m_matrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl
m_matrix	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_matrix	Eigen/src/SparseCore/SparseBlock.h	/^    typename internal::ref_selector<SparseMatrixType>::non_const_type m_matrix;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_matrix	Eigen/src/SparseCore/SparseBlock.h	/^    typename internal::ref_selector<XprType>::non_const_type m_matrix;$/;"	m	class:Eigen::BlockImpl
m_matrix	Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Derived *m_matrix;$/;"	m	struct:Eigen::internal::evaluator
m_matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView
m_matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_matrix	Eigen/src/SparseCore/SparseVector.h	/^  const SparseVectorType *m_matrix;$/;"	m	struct:Eigen::internal::evaluator
m_matrix	Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView
m_matrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const MappedSuperNodalMatrix& m_matrix; \/\/ Supernodal lower triangular matrix $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_matrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase
m_matrix	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::IterScaling
m_matrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const SkylineMatrix& m_matrix;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_matrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const SkylineMatrix& m_matrix;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_matrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  const SparseMatrixType *m_matrix;$/;"	m	struct:Eigen::internal::evaluator
m_matrixU	Eigen/src/SVD/SVDBase.h	/^  MatrixUType m_matrixU;$/;"	m	class:Eigen::SVDBase
m_matrixV	Eigen/src/SVD/SVDBase.h	/^  MatrixVType m_matrixV;$/;"	m	class:Eigen::SVDBase
m_matrixWrapper	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixWrapper m_matrixWrapper;$/;"	m	class:Eigen::IterativeSolverBase
m_max	Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_maxIndex	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  const typename TensorEvaluator::Index m_maxIndex;$/;"	m	struct:Eigen::PacketConverter
m_maxIterations	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_maxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase
m_maxIterationsPerRow	Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterationsPerRow = 30;$/;"	m	class:Eigen::ComplexSchur
m_maxIterationsPerRow	Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterationsPerRow = 40;$/;"	m	class:Eigen::RealSchur
m_maxIters	Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::ComplexSchur
m_maxIters	Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_maxIters;$/;"	m	class:Eigen::RealQZ
m_maxIters	Eigen/src/Eigenvalues/RealSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::RealSchur
m_maxNeig	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable Index m_maxNeig; \/\/ Maximum number of eigenvalues to deflate$/;"	m	class:Eigen::DGMRES
m_maxfev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index m_maxfev; \/\/ Maximum number of function evaluation$/;"	m	class:Eigen::LevenbergMarquardt
m_maxiter	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t m_maxiter;     \/\/\/< Max. number of iterations$/;"	m	class:Eigen::IterationController
m_maxits	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    int m_maxits; \/\/ Maximum number of iterations allowed$/;"	m	class:Eigen::IterScaling
m_maxpivot	Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_maxpivot	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_maxpivot	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_mc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_mc;$/;"	m	class:Eigen::internal::level3_blocking
m_means	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  array<T, NumDims> m_means;$/;"	m	class:Eigen::internal::GaussianGenerator
m_min	Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_minus_sin_2_PI_div_n_LUT	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const RealScalar m_minus_sin_2_PI_div_n_LUT[32] = {$/;"	m	struct:Eigen::TensorEvaluator
m_mode	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_mode;$/;"	m	class:Eigen::internal::AmbiVector
m_monic	unsupported/Eigen/src/Polynomials/Companion.h	/^      RightColumn                m_monic;$/;"	m	class:Eigen::internal::companion
m_msglvl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    StorageIndex m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_multiplier	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_multiplier;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_nRec	Eigen/src/SVD/BDCSVD.h	/^  Index m_nRec;$/;"	m	class:Eigen::BDCSVD
m_naiveU	Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_naiveU, m_naiveV;$/;"	m	class:Eigen::BDCSVD
m_naiveV	Eigen/src/SVD/BDCSVD.h	/^  MatrixXr m_naiveU, m_naiveV;$/;"	m	class:Eigen::BDCSVD
m_nbrConverged	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  size_t m_nbrConverged;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_nbrIterations	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  size_t m_nbrIterations;$/;"	m	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
m_nc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_nc;$/;"	m	class:Eigen::internal::level3_blocking
m_neig	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable StorageIndex m_neig; \/\/Number of eigenvalues to extract at each restart$/;"	m	class:Eigen::DGMRES
m_nfev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index m_nfev;$/;"	m	class:Eigen::LevenbergMarquardt
m_nit	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t m_nit;         \/\/\/< iteration number$/;"	m	class:Eigen::IterationController
m_njev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index m_njev; $/;"	m	class:Eigen::LevenbergMarquardt
m_nnzL	Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nnzU	Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nocontract_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const nocontract_t m_nocontract_strides;$/;"	m	class:Eigen::internal::SimpleTensorContractionMapper
m_noise	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    int m_noise;          \/\/\/< if noise > 0 iterations are printed$/;"	m	class:Eigen::IterationController
m_nonZerosPerCol	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorI m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_nonzeroSingularValues	Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_nonzero_pivots	Eigen/src/LU/FullPivLU.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_nonzero_pivots	Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR
m_nonzero_pivots	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR
m_nonzeropivots	Eigen/src/SparseQR/SparseQR.h	/^    Index m_nonzeropivots;          \/\/ Number of non zero pivots found$/;"	m	class:Eigen::SparseQR
m_nonzeros	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_nonzeros; \/\/ Total nonzeros elements$/;"	m	class:Eigen::BlockSparseMatrix
m_nonzerosblocks	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_nonzerosblocks; \/\/ Total nonzeros blocks (lower than  m_innerBSize x m_outerBSize)$/;"	m	class:Eigen::BlockSparseMatrix
m_normOfS	Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_normOfT	Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_nsuper	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_nsuper; \/\/ Number of supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_nulls	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index m_nulls;$/;"	m	class:Eigen::MatrixPower
m_numIndices	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    std::size_t m_numIndices;$/;"	m	class:Eigen::DynamicSGroup
m_numIters	Eigen/src/SVD/BDCSVD.h	/^  int m_numIters;$/;"	m	class:Eigen::BDCSVD
m_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU
m_nzval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* m_nzval; \/\/array of nonzero values packed by column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_nzval_colptr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_nzval_colptr; \/\/nzval_colptr[j] Stores the location in nzval[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_object	Eigen/src/Core/Ref.h	/^    TPlainObjectType m_object;$/;"	m	class:Eigen::Ref
m_object_bytes	Eigen/src/SparseCore/SparseRef.h	/^    char m_object_bytes[sizeof(TPlainObjectType)];$/;"	m	class:Eigen::Ref
m_offset	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    const Index m_offset;$/;"	m	class:Eigen::TensorChippingOp
m_offset	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const Index m_offset; \/\/ Position of this column in the block$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_offsets	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  DSizes<Index, NumDims> m_offsets; \/\/ offset in a flattened shape$/;"	m	struct:Eigen::TensorEvaluator
m_offsets	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  const StartIndices m_offsets;$/;"	m	struct:Eigen::TensorEvaluator
m_op	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  const ArgType m_op;$/;"	m	struct:Eigen::TensorEvaluator
m_op	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  const XprType m_op;$/;"	m	struct:Eigen::TensorEvaluator
m_op	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  const XprType& m_op;$/;"	m	struct:Eigen::TensorEvaluator
m_op	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  const ArgType m_op;$/;"	m	struct:Eigen::TensorEvaluator
m_ordering	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_ordering; \/\/ Ordering method to use, see SPQR's manual$/;"	m	class:Eigen::SPQR
m_orig_impl	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  TensorEvaluator<const TensorIndexTupleOp<ArgType>, Device> m_orig_impl;$/;"	m	struct:Eigen::TensorEvaluator
m_origin	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_originalMatrix	Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base
m_other	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op
m_other	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const Derived& m_other; $/;"	m	struct:Eigen::SPQR_QProduct
m_other	Eigen/src/SparseQR/SparseQR.h	/^  const Derived& m_other;$/;"	m	struct:Eigen::SparseQR_QProduct
m_otherInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_otherInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_otherStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_otherStride;$/;"	m	struct:Eigen::TensorEvaluator
m_otherStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_otherStride;$/;"	m	struct:Eigen::TensorEvaluator
m_outer	Eigen/src/Core/CoreIterators.h	/^  const Index m_outer;$/;"	m	class:Eigen::internal::inner_iterator_selector
m_outer	Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride
m_outer	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const OuterType m_outer;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_outer	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const OuterType m_outer;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_outer	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
m_outer	Eigen/src/SparseCore/SparseView.h	/^        const Index m_outer;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_outer	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_outer;                    \/\/ Current column $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_outer	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_outer	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_outer	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::BlockSparseMatrix::BlockInnerIterator
m_outer	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_outer	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::DynamicSparseMatrix::InnerIterator
m_outer	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
m_outerB	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const Index m_outerB;$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_outerBSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_outerBSize; \/\/ Number of block columns$/;"	m	class:Eigen::BlockSparseMatrix
m_outerIndex	Eigen/src/SparseCore/SparseMap.h	/^    IndexPointer  m_outerIndex;$/;"	m	class:Eigen::SparseMapBase
m_outerIndex	Eigen/src/SparseCore/SparseMatrix.h	/^    StorageIndex* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix
m_outerIndex	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    StorageIndex *m_outerIndex; \/\/ Starting pointer of each block column in m_indices (size m_outerBSize)... OK$/;"	m	class:Eigen::BlockSparseMatrix
m_outerOffset	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    StorageIndex *m_outerOffset; \/\/ Starting index of each outer block (size m_outerBSize+1)$/;"	m	class:Eigen::BlockSparseMatrix
m_outerPackets	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Index m_outerPackets;$/;"	m	class:Eigen::RandomSetter
m_outerPos	Eigen/src/SparseCore/SparseBlock.h	/^  Index m_outerPos;$/;"	m	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
m_outerSize	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::BlockImpl
m_outerSize	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_outerSize	Eigen/src/SparseCore/SparseMap.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::SparseMapBase
m_outerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix
m_outerSize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SkylineMatrix
m_outerStart	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::BlockImpl
m_outerStart	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::internal::sparse_matrix_block_impl
m_outerStride	Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_outerStride	Eigen/src/Core/CoreEvaluators.h	/^                                                    : RowsAtCompileTime> m_outerStride;$/;"	m	struct:Eigen::internal::evaluator
m_outerStride	Eigen/src/Core/CoreEvaluators.h	/^  const internal::variable_if_dynamic<Index, XprType::OuterStrideAtCompileTime> m_outerStride;$/;"	m	struct:Eigen::internal::mapbase_evaluator
m_output	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  CoeffReturnType* m_output;$/;"	m	struct:Eigen::TensorEvaluator
m_outputCols	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_outputCols;$/;"	m	struct:Eigen::TensorEvaluator
m_outputCols	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_outputCols;$/;"	m	struct:Eigen::TensorEvaluator
m_outputPerm_c	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_outputPerm_c; \/\/ The final column permutation$/;"	m	class:Eigen::SparseQR
m_outputPlanes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_outputPlanes;$/;"	m	struct:Eigen::TensorEvaluator
m_outputPlanesRows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_outputPlanesRows;$/;"	m	struct:Eigen::TensorEvaluator
m_outputRows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_outputRows;$/;"	m	struct:Eigen::TensorEvaluator
m_outputRows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_outputRows;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStride	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_outputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	class:Eigen::internal::IndexMapper
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  array<Index, NumDims+1> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  array<Index, NumOutputDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_outputStrides	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  array<Index, NumDims> m_outputStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_p	Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU
m_p	Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU
m_p	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase
m_p	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU
m_p	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    RealScalar m_p;$/;"	m	class:Eigen::MatrixPowerAtomic
m_p	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const ComplexScalar m_p;$/;"	m	class:Eigen::MatrixComplexPowerReturnValue
m_p	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const RealScalar m_p;$/;"	m	class:Eigen::MatrixPowerParenthesesReturnValue
m_p	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const RealScalar m_p;$/;"	m	class:Eigen::MatrixPowerReturnValue
m_padding	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  PaddingDimensions m_padding;$/;"	m	struct:Eigen::TensorEvaluator
m_paddingValue	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Scalar m_paddingValue;$/;"	m	struct:Eigen::TensorEvaluator
m_paddingValue	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  Scalar m_paddingValue;$/;"	m	struct:Eigen::TensorEvaluator
m_paddingValue	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Scalar m_paddingValue;$/;"	m	struct:Eigen::TensorEvaluator
m_padding_bottom	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_padding_bottom;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_bottom	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_bottom;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_bottom_z	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_bottom_z;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_dims	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    const PaddingDimensions m_padding_dims;$/;"	m	class:Eigen::TensorPaddingOp
m_padding_explicit	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const bool m_padding_explicit;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_explicit	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const bool m_padding_explicit;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_left	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_padding_left;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_left	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_left;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_right	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_padding_right;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_right	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_right;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_top	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_padding_top;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_top	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_top;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_top_z	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_padding_top_z;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_type	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const PaddingType m_padding_type;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_type	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const PaddingType m_padding_type;$/;"	m	class:Eigen::TensorVolumePatchOp
m_padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const Scalar m_padding_value;$/;"	m	class:Eigen::TensorImagePatchOp
m_padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    const Scalar m_padding_value;$/;"	m	class:Eigen::TensorPaddingOp
m_padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const Scalar m_padding_value;$/;"	m	class:Eigen::TensorVolumePatchOp
m_par	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_par;$/;"	m	class:Eigen::LevenbergMarquardt
m_parent	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorI m_parent;                                 \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase
m_pastixdata	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase
m_patchInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_patchInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_patchStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_patchStride;$/;"	m	struct:Eigen::TensorEvaluator
m_patchStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_patchStride;$/;"	m	struct:Eigen::TensorEvaluator
m_patchStrides	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  array<Index, NumDims-1> m_patchStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_patch_cols	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_patch_cols;$/;"	m	class:Eigen::TensorImagePatchOp
m_patch_cols	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_patch_cols;$/;"	m	class:Eigen::TensorVolumePatchOp
m_patch_cols_eff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_patch_cols_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_patch_cols_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_patch_cols_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_patch_dims	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    const PatchDim m_patch_dims;$/;"	m	class:Eigen::TensorPatchOp
m_patch_planes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_patch_planes;$/;"	m	class:Eigen::TensorVolumePatchOp
m_patch_planes_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_patch_planes_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_patch_rows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_patch_rows;$/;"	m	class:Eigen::TensorImagePatchOp
m_patch_rows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_patch_rows;$/;"	m	class:Eigen::TensorVolumePatchOp
m_patch_rows_eff	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_patch_rows_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_patch_rows_eff	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_patch_rows_eff;$/;"	m	struct:Eigen::TensorEvaluator
m_perfv	Eigen/src/SparseLU/SparseLU.h	/^    internal::perfvalues m_perfv;$/;"	m	class:Eigen::SparseLU
m_perm	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    PermutationType m_perm; $/;"	m	class:Eigen::IncompleteCholesky
m_perm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<StorageIndex,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase
m_perm	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl
m_perm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_perm_c	Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_c; \/\/ Column permutation $/;"	m	class:Eigen::SparseLU
m_perm_c	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_perm_c;       \/\/ Fill-reducing  Column  permutation$/;"	m	class:Eigen::SparseQR
m_perm_r	Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_r ; \/\/ Row permutation$/;"	m	class:Eigen::SparseLU
m_permutation	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    PermutationType m_permutation;$/;"	m	class:Eigen::LevenbergMarquardt
m_pivotperm	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_pivotperm;    \/\/ The permutation for rank revealing$/;"	m	class:Eigen::SparseQR
m_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ::fftw_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftwf_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftwl_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_planeInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_planeInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_planePaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_planePaddingTop;$/;"	m	struct:Eigen::TensorEvaluator
m_plane_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_plane_inflate_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_plane_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_plane_inflate_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_plane_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_plane_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_plans	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanMap m_plans;$/;"	m	struct:Eigen::internal::fftw_impl
m_plans	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  PlanMap m_plans;$/;"	m	struct:Eigen::internal::kissfft_impl
m_pmat	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_pmat;            \/\/ Temporary matrix$/;"	m	class:Eigen::SparseQR
m_pow	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    MatrixPower<MatrixType>& m_pow;$/;"	m	class:Eigen::MatrixPowerParenthesesReturnValue
m_precision	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR
m_precision	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::SkylineInplaceLU
m_preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase
m_prescribedThreshold	Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_prescribedThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_prescribedThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_prescribedThreshold	Eigen/src/SVD/SVDBase.h	/^  RealScalar m_prescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_preservedStrides	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  array<Index, NumPreservedStrides> m_preservedStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_pt	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl
m_ptr	Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_ptr	Eigen/src/Core/util/Memory.h	/^  T* m_ptr;$/;"	m	class:Eigen::internal::scoped_array
m_q	Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU
m_q	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase
m_q	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU
m_qr	Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR
m_qr	Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR
m_qr	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_qr	Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR
m_qr	Eigen/src/SVD/JacobiSVD.h	/^  QRType m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQReturnType
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQTransposeReturnType
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQR_QProduct
m_qr_precond_morecols	Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD
m_qr_precond_morerows	Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD
m_qtf	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_fvec, m_qtf, m_diag; $/;"	m	class:Eigen::LevenbergMarquardt
m_queue	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  mutable cl::sycl::queue m_queue;$/;"	m	struct:Eigen::SyclDevice
m_r	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable Index m_r; \/\/ Current number of deflated eigenvalues, size of m_U$/;"	m	class:Eigen::DGMRES
m_rank	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index m_rank; \/\/ The rank of the matrix$/;"	m	class:Eigen::SPQR
m_rank	Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_rank	Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_rank	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index m_rank;$/;"	m	class:Eigen::MatrixPower
m_realQZ	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    RealQZ<MatrixType> m_realQZ;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_realSchur	Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver
m_realTwiddles	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::map<int, std::vector<Complex> > m_realTwiddles;$/;"	m	struct:Eigen::internal::kissfft_impl
m_reduce_dims	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    const Dims m_reduce_dims;$/;"	m	class:Eigen::TensorTupleReducerOp
m_reduce_op	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    const ReduceOp m_reduce_op;$/;"	m	class:Eigen::TensorTupleReducerOp
m_reduced	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  array<bool, NumInputDims> m_reduced;$/;"	m	struct:Eigen::TensorEvaluator
m_reducedDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  array<Index, NumReducedDims> m_reducedDims;$/;"	m	struct:Eigen::TensorEvaluator
m_reducedStrides	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  array<Index, NumReducedDims> m_reducedStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_reducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    const Op m_reducer;$/;"	m	class:Eigen::TensorReductionOp
m_reducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  Op m_reducer;$/;"	m	struct:Eigen::TensorEvaluator
m_ref	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  TensorRef<Derived> m_ref;$/;"	m	struct:Eigen::TensorEvaluator
m_refX	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    VectorType m_refX; \/\/ The reference solution, if exists$/;"	m	class:Eigen::MatrixMarketIterator
m_refcount	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  int m_refcount;$/;"	m	class:Eigen::internal::TensorLazyBaseEvaluator
m_reference	Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView
m_res	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_res;         \/\/\/< last computed residual$/;"	m	class:Eigen::IterationController
m_resadd	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resminreach, m_resadd;$/;"	m	class:Eigen::IterationController
m_resmax	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resmax;      \/\/\/< maximum residual$/;"	m	class:Eigen::IterationController
m_resminreach	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resminreach, m_resadd;$/;"	m	class:Eigen::IterationController
m_restart	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable Index m_restart; \/\/ Maximum size of the Krylov subspace$/;"	m	class:Eigen::DGMRES
m_restart	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  Index m_restart;$/;"	m	class:Eigen::GMRES
m_result	Eigen/src/Core/CoreEvaluators.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	Eigen/src/Core/Inverse.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::unary_evaluator
m_result	Eigen/src/Core/ProductEvaluators.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_result	Eigen/src/Core/ReturnByValue.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	Eigen/src/Core/Solve.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::evaluator
m_result	Eigen/src/SparseCore/SparsePermutation.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_result	Eigen/src/SparseCore/SparseProduct.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::unary_evaluator
m_result	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  PlainObject m_result;$/;"	m	struct:Eigen::internal::product_evaluator
m_result	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  Scalar* m_result;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_result	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  CoeffReturnType* m_result;$/;"	m	struct:Eigen::TensorEvaluator
m_result	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typename MakePointer_<CoeffReturnType>::Type m_result;$/;"	m	struct:Eigen::TensorEvaluator
m_returnOne	Eigen/src/SparseCore/SparseTriangularView.h	/^      bool m_returnOne;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_return_dim	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    const int m_return_dim;$/;"	m	class:Eigen::TensorTupleReducerOp
m_return_dim	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  const int m_return_dim;$/;"	m	struct:Eigen::TensorEvaluator
m_reverse	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  ReverseDimensions m_reverse;$/;"	m	struct:Eigen::TensorEvaluator
m_reverse_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    const ReverseDimensions m_reverse_dims;$/;"	m	class:Eigen::TensorReverseOp
m_rfactor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    JacobianType m_rfactor; \/\/ The triangular matrix R from the QR of the jacobian matrix m_fjac$/;"	m	class:Eigen::LevenbergMarquardt
m_rhs	Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_rhs	Eigen/src/Core/Product.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::Product
m_rhs	Eigen/src/Core/ProductEvaluators.h	/^  typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhs	Eigen/src/Core/Solve.h	/^  const RhsType       &m_rhs;$/;"	m	class:Eigen::Solve
m_rhs	Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_rhs	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_rhs	Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_rhs	Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_rhs	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  const RhsType       &m_rhs;$/;"	m	class:Eigen::SolveWithGuess
m_rhs	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typename Lhs::PlainObject m_rhs;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhs	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::SkylineProduct
m_rhs	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    VectorType m_rhs;  \/\/ Current vector$/;"	m	class:Eigen::MatrixMarketIterator
m_rhsEval	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<Rhs> &m_rhsEval;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_rhsEval	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const evaluator<RhsArg> &m_rhsEval;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_rhsImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<Rhs> m_rhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_rhsImpl	Eigen/src/Core/ProductEvaluators.h	/^  RhsEtorType m_rhsImpl;$/;"	m	struct:Eigen::internal::product_evaluator
m_rhsImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<Rhs> m_rhsImpl;$/;"	m	struct:Eigen::internal::binary_evaluator
m_rhsImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  evaluator<RhsArg> m_rhsImpl;$/;"	m	struct:Eigen::internal::sparse_conjunction_evaluator
m_rhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_rhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
m_rhsXprImpl	Eigen/src/SparseCore/SparseDenseProduct.h	/^  evaluator<ActualRhs> m_rhsXprImpl;$/;"	m	struct:Eigen::internal::sparse_dense_outer_product_evaluator
m_rhs_inner_dim_contiguous	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  bool m_rhs_inner_dim_contiguous;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_rhs_inner_dim_reordered	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  bool m_rhs_inner_dim_reordered;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_rhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    const typename internal::remove_all<typename RhsXprType::Nested>::type& m_rhs_xpr;$/;"	m	class:Eigen::TensorAssignOp
m_rhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    typename RhsXprType::Nested m_rhs_xpr;$/;"	m	class:Eigen::TensorConcatenationOp
m_rhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^    typename RhsXprType::Nested m_rhs_xpr;$/;"	m	class:Eigen::TensorContractionOp
m_rhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^    typename RhsXprType::Nested m_rhs_xpr;$/;"	m	class:Eigen::TensorCustomBinaryOp
m_rhs_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename RhsXprType::Nested m_rhs_xpr;$/;"	m	class:Eigen::TensorCwiseBinaryOp
m_rhsn	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_rhsn;        \/\/\/< Right hand side norm$/;"	m	class:Eigen::IterationController
m_right	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd m_right; \/\/ m_right scaling vector$/;"	m	class:Eigen::IterScaling
m_rightImpl	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  TensorEvaluator<RightArgType, Device> m_rightImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_rightImpl	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    TensorEvaluator<RightArgType, Device> m_rightImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_rightImpl	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  TensorEvaluator<EvalRightArgType, Device> m_rightImpl;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_rightImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<RightArgType, Device> m_rightImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_rightStrides	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    array<Index, NumDims> m_rightStrides;$/;"	m	struct:Eigen::TensorEvaluator
m_right_contracting_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  contract_t m_right_contracting_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_right_nocontract_strides	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  right_nocontract_t m_right_nocontract_strides;$/;"	m	struct:Eigen::TensorContractionEvaluatorBase
m_roots	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    RootsType               m_roots;$/;"	m	class:Eigen::PolynomialSolverBase
m_row	Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer
m_row	Eigen/src/SparseCore/SparseUtil.h	/^  StorageIndex m_row, m_col;$/;"	m	class:Eigen::Triplet
m_row	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_row; \/\/ Number of rows$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowFactor	Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate
m_rowIndices	doc/examples/nullary_indexing.cpp	/^  const RowIndexType &m_rowIndices;$/;"	m	class:indexing_functor	file:
m_rowInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_rowInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_rowInputStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_rowInputStride;$/;"	m	struct:Eigen::TensorEvaluator
m_rowPaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_rowPaddingTop;$/;"	m	struct:Eigen::TensorEvaluator
m_rowPaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_rowPaddingTop;$/;"	m	struct:Eigen::TensorEvaluator
m_rowStartIndex	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index* m_rowStartIndex;$/;"	m	class:Eigen::SkylineMatrix
m_rowStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_rowStride;$/;"	m	struct:Eigen::TensorEvaluator
m_row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_row_inflate_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_row_inflate_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_row_inflate_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_row_inflate_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    const DenseIndex m_row_strides;$/;"	m	class:Eigen::TensorImagePatchOp
m_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index m_row_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    const DenseIndex m_row_strides;$/;"	m	class:Eigen::TensorVolumePatchOp
m_row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index m_row_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_rowind	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_rowind; \/\/ Array of compressed row indices of rectangular supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowind_colptr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_rowind_colptr; \/\/rowind_colptr[j] stores the location in rowind[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rows	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix
m_rows	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_rows	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ArgType::RowsAtCompileTime> m_rows;$/;"	m	struct:Eigen::internal::unary_evaluator
m_rows	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows;$/;"	m	struct:Eigen::internal::unary_evaluator
m_rows	Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp
m_rows	Eigen/src/Core/DenseStorage.h	/^    Index m_rows;$/;"	m	class:Eigen::DenseStorage
m_rows	Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase
m_rows	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index m_rows;$/;"	m	class:Eigen::SPQR
m_rows	Eigen/src/SVD/SVDBase.h	/^  Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::SVDBase
m_rowsTranspositions	Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_rowsTranspositions	Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU
m_rowsTranspositions	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntDiagSizeVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_rows_transpositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_scale	Eigen/src/Core/ProductEvaluators.h	/^    Scalar m_scale;$/;"	m	struct:Eigen::internal::generic_product_impl::adds
m_scale	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    VectorRx m_scale;            \/\/ The vector for scaling the matrix $/;"	m	class:Eigen::IncompleteCholesky
m_scaledMatrix	Eigen/src/SVD/JacobiSVD.h	/^    MatrixType m_scaledMatrix;$/;"	m	class:Eigen::JacobiSVD
m_schur	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver
m_scratchBuf	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_scratchBuf;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_selectedActionNames	bench/btl/generic_bench/btl.hh	/^  std::vector<BtlString> m_selectedActionNames;$/;"	m	class:BtlConfig
m_shift	Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence
m_shiftOffset	Eigen/src/CholmodSupport/CholmodSupport.h	/^    double m_shiftOffset[2];$/;"	m	class:Eigen::CholmodBase
m_shiftOffset	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_shiftScale	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_shuffle	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    const Shuffle m_shuffle;$/;"	m	class:Eigen::TensorShufflingOp
m_sign	Eigen/src/Cholesky/LDLT.h	/^    internal::SignMatrix m_sign;$/;"	m	class:Eigen::LDLT
m_sin_PI_div_n_LUT	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  const RealScalar m_sin_PI_div_n_LUT[32] = {$/;"	m	struct:Eigen::TensorEvaluator
m_singularValues	Eigen/src/SVD/SVDBase.h	/^  SingularValuesType m_singularValues;$/;"	m	class:Eigen::SVDBase
m_size	Eigen/src/Core/util/Memory.h	/^    std::size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_size	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase
m_size	Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl
m_size	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_size;$/;"	m	class:Eigen::internal::AmbiVector
m_size	Eigen/src/SparseCore/CompressedStorage.h	/^    Index m_size;$/;"	m	class:Eigen::internal::CompressedStorage
m_size	Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector
m_size	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  Index m_size;$/;"	m	struct:Eigen::TensorEvaluator
m_size	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  const Index m_size;$/;"	m	struct:Eigen::TensorEvaluator
m_size1	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Index m_size1;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_sizeA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Index m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizes	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const Sizes m_sizes;$/;"	m	class:Eigen::TensorSlicingOp
m_sluA	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase
m_sluB	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_sluBerr	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluCscale	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluEqued	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase
m_sluEtree	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase
m_sluFerr	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluL	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluOptions	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase
m_sluRscale	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluStat	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase
m_sluU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluX	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_smv	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^    mutable RealScalar m_smv; \/\/ Smaller multiple of the remaining number of steps allowed$/;"	m	class:Eigen::DGMRES
m_sparseIter	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseXprIter m_sparseIter;$/;"	m	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
m_sparseXprEval	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<SparseXprType> m_sparseXprEval;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_sparseXprImpl	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  evaluator<SparseXprType> m_sparseXprImpl;$/;"	m	struct:Eigen::internal::sparse_diagonal_product_evaluator
m_spblockmat	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const BlockSparseMatrixT& m_spblockmat;$/;"	m	class:Eigen::BlockSparseMatrixView
m_spblockmat	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const BlockSparseMatrixT& m_spblockmat;$/;"	m	class:Eigen::BlockVectorReturn
m_spblockmat	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const BlockSparseMatrixT& m_spblockmat;$/;"	m	class:Eigen::BlockVectorView
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr; $/;"	m	struct:Eigen::SPQR_QProduct
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQReturnType
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQTransposeReturnType
m_squarings	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    int m_squarings;$/;"	m	struct:Eigen::internal::MatrixExponentialScalingOp
m_src	Eigen/src/Core/AssignEvaluator.h	/^  const SrcEvaluatorType& m_src;$/;"	m	class:Eigen::internal::generic_dense_assignment_kernel
m_src	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    const typename internal::ref_selector<Derived>::type m_src;$/;"	m	struct:Eigen::MatrixExponentialReturnValue
m_src	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    const DerivedNested m_src;$/;"	m	class:Eigen::MatrixSquareRootReturnValue
m_stageRadix	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<int> m_stageRadix;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_stageRemainder	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<int> m_stageRemainder;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_start	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex m_start;$/;"	m	class:Eigen::internal::AmbiVector
m_start	Eigen/src/SparseCore/SparseCompressedBase.h	/^    Index m_start;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_start	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index m_start;$/;"	m	struct:Eigen::internal::packLhsArg
m_start	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_start	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_start	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index m_start; \/\/ starting inner index of this block$/;"	m	class:Eigen::BlockSparseMatrix::InnerIterator
m_startCol	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startCol	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;$/;"	m	struct:Eigen::internal::unary_evaluator
m_startCol	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::BlockImpl
m_startIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices m_startIndices;$/;"	m	class:Eigen::TensorStridingSlicingOp
m_startIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  DSizes<Index, NumDims> m_startIndices; \/\/ clamped startIndices$/;"	m	struct:Eigen::TensorEvaluator
m_startRow	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startRow	Eigen/src/Core/CoreEvaluators.h	/^  const variable_if_dynamic<Index, (ArgType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;$/;"	m	struct:Eigen::internal::unary_evaluator
m_startRow	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::BlockImpl
m_start_time	bench/btl/generic_bench/timers/portable_timer.hh	/^  double m_stop_time, m_start_time;$/;"	m	class:Portable_Timer
m_startidval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_startidval;               \/\/ Start of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_starts	bench/BenchTimer.h	/^  Vector2d m_starts;$/;"	m	class:Eigen::BenchTimer
m_state	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  mutable uint64_t m_state;$/;"	m	class:Eigen::internal::NormalRandomGenerator
m_state	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  mutable uint64_t m_state;$/;"	m	class:Eigen::internal::UniformRandomGenerator
m_staticA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX char m_staticA[SizeA * sizeof(LhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN_MAX char m_staticB[SizeB * sizeof(RhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_status	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    mutable int m_status;$/;"	m	class:Eigen::SkylineInplaceLU
m_step	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_stopIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StopIndices m_stopIndices;$/;"	m	class:Eigen::TensorStridingSlicingOp
m_stop_time	bench/btl/generic_bench/timers/portable_timer.hh	/^  double m_stop_time, m_start_time;$/;"	m	class:Portable_Timer
m_storage	Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase
m_storage	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    TensorStorage<Scalar, Dimensions, Options> m_storage;$/;"	m	class:Eigen::Tensor
m_storage	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^  TensorStorage<Scalar, Dimensions, Options> m_storage;$/;"	m	class:Eigen::TensorFixedSize
m_stride	Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map
m_stride	Eigen/src/Core/Ref.h	/^  StrideBase m_stride;$/;"	m	class:Eigen::RefBase
m_stride	Eigen/src/Core/util/BlasUtil.h	/^  const Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper
m_stride	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  Index m_stride;$/;"	m	struct:Eigen::TensorEvaluator
m_stride	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  Index m_stride;$/;"	m	struct:Eigen::TensorEvaluator
m_stride_div	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  Index m_stride_div;$/;"	m	struct:Eigen::TensorEvaluator
m_stride_mod	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  Index m_stride_mod;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  StrideDims m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  array<Index, NumDims> m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  array<Index, NumDims> m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    const Strides m_strides;$/;"	m	class:Eigen::TensorInflationOp
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  const Strides m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const Strides m_strides;$/;"	m	class:Eigen::TensorStridingSlicingOp
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  const Strides m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_strides	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  array<Index, NumDims> m_strides;$/;"	m	struct:Eigen::TensorEvaluator
m_structureIsUptodate	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU
m_subdiag	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_subs	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix
m_subs	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_succeeded	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    bool m_succeeded;$/;"	m	class:Eigen::SkylineInplaceLU
m_sup	doc/examples/class_CwiseUnaryOp.cpp	/^  Scalar m_inf, m_sup;$/;"	m	struct:CwiseClampOp	file:
m_sup_to_col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* m_sup_to_col; \/\/sup_to_col[s] points to the starting column of the s-th supernode$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_supers	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix
m_supers	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_supno	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_supno;                    \/\/ Current SuperNode number$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_sve	Eigen/src/SparseCore/SparseView.h	/^        const unary_evaluator &m_sve;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_sym	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    int m_sym; \/\/ Symmetry of the matrix$/;"	m	class:Eigen::MatrixMarketIterator
m_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU
m_symmetricmode	Eigen/src/SparseLU/SparseLU.h	/^    bool m_symmetricmode;$/;"	m	class:Eigen::SparseLU
m_symmetry	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    Symmetry_ m_symmetry;$/;"	m	class:Eigen::internal::tensor_symmetry_value_setter
m_temp	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition
m_temp	Eigen/src/Geometry/Homogeneous.h	/^  PlainObject m_temp;$/;"	m	struct:Eigen::internal::unary_evaluator
m_temp	Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR
m_temp	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  RowVectorType m_temp;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_temp	Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR
m_temp	Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR
m_temporary	Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT
m_tensor	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  CoeffLoader<Tensor, Tensor::RawAccess> m_tensor;$/;"	m	class:Eigen::internal::SimpleTensorContractionMapper
m_tensor	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const Tensor m_tensor;$/;"	m	struct:Eigen::internal::CoeffLoader
m_tensor	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    Tensor_& m_tensor;$/;"	m	class:Eigen::internal::tensor_symmetry_value_setter
m_then	Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select
m_then	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename ThenXprType::Nested m_then;$/;"	m	class:Eigen::TensorSelectOp
m_thenImpl	Eigen/src/Core/CoreEvaluators.h	/^  evaluator<ThenMatrixType> m_thenImpl;$/;"	m	struct:Eigen::internal::evaluator
m_thenImpl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  TensorEvaluator<ThenArgType, Device> m_thenImpl;$/;"	m	struct:Eigen::TensorEvaluator
m_threshold	Eigen/src/SparseQR/SparseQR.h	/^    RealScalar m_threshold;         \/\/ Threshold to determine null Householder reflections$/;"	m	class:Eigen::SparseQR
m_time_action	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  double m_time_action;$/;"	m	class:Portable_Perf_Analyzer
m_timeline	demos/opengl/quaternion_demo.h	/^    TimeLine m_timeline;$/;"	m	class:RenderingWidget
m_timer	demos/opengl/quaternion_demo.h	/^    QTimer m_timer;$/;"	m	class:RenderingWidget
m_times	bench/BenchTimer.h	/^  Vector2d m_times;$/;"	m	class:Eigen::BenchTimer
m_tmp	Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver
m_tmp	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_tmp;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_tmp	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    MatrixType m_tmp;$/;"	m	class:Eigen::MatrixPower
m_tmpBuf1	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_tmpBuf1;$/;"	m	struct:Eigen::internal::kissfft_impl
m_tmpBuf2	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_tmpBuf2;$/;"	m	struct:Eigen::internal::kissfft_impl
m_tol	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    double m_tol; $/;"	m	class:Eigen::IterScaling
m_tolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase
m_tolerance	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    RealScalar m_tolerance; \/\/ treat columns with 2-norm below this tolerance as zero$/;"	m	class:Eigen::SPQR
m_totals	bench/BenchTimer.h	/^  Vector2d m_totals;$/;"	m	class:Eigen::BenchTimer
m_trans	Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence
m_transpose	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  bool m_transpose; $/;"	m	struct:Eigen::SPQR_QProduct
m_transpose	Eigen/src/SparseQR/SparseQR.h	/^  bool m_transpose; \/\/ TODO this actually means adjoint$/;"	m	struct:Eigen::SparseQR_QProduct
m_transpositions	Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT
m_transpositions	Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose
m_triangularMatrix	Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_twiddles	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_twiddles;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_two_sigmas	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  array<T, NumDims> m_two_sigmas;$/;"	m	class:Eigen::internal::GaussianGenerator
m_type	Eigen/src/PardisoSupport/PardisoSupport.h	/^    StorageIndex m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_u	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase
m_u	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU
m_umfpackInfo	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable UmfpackInfo m_umfpackInfo;$/;"	m	class:Eigen::UmfPackLU
m_unaryOp	Eigen/src/Core/CoreEvaluators.h	/^  const UnaryOp m_unaryOp;$/;"	m	struct:Eigen::internal::unary_evaluator
m_upper	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_upper;$/;"	m	class:Eigen::SkylineStorage
m_upperProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index* m_upperProfile;$/;"	m	class:Eigen::SkylineStorage
m_upperProfileSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_upperProfileSize;$/;"	m	class:Eigen::SkylineStorage
m_upperSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_upperSize;$/;"	m	class:Eigen::SkylineStorage
m_useDefaultThreshold	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SPQR
m_useDefaultThreshold	Eigen/src/SparseQR/SparseQR.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SparseQR
m_useExternalScaling	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    bool m_useExternalScaling;$/;"	m	class:Eigen::LevenbergMarquardt
m_usePrescribedThreshold	Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_usePrescribedThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_usePrescribedThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_usePrescribedThreshold	Eigen/src/SVD/SVDBase.h	/^  bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::SVDBase
m_use_divisor	Eigen/src/Core/functors/NullaryFunctors.h	/^  const bool m_use_divisor;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_val	Eigen/src/Core/arch/NEON/PacketMath.h	/^  T m_val;$/;"	m	struct:Eigen::internal::eigen_packet_wrapper
m_val	Eigen/src/Core/arch/SSE/PacketMath.h	/^  T m_val;$/;"	m	struct:Eigen::internal::eigen_packet_wrapper
m_value	Eigen/src/Core/functors/BinaryFunctors.h	/^  first_argument_type m_value;$/;"	m	struct:Eigen::internal::bind1st_op
m_value	Eigen/src/Core/functors/BinaryFunctors.h	/^  second_argument_type m_value;$/;"	m	struct:Eigen::internal::bind2nd_op
m_value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::binary_evaluator::InnerIterator
m_value	Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_value	Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet
m_value	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    Scalar m_value;$/;"	m	class:Eigen::AutoDiffScalar
m_values	Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage
m_values	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseCompressedBase::InnerIterator
m_values	Eigen/src/SparseCore/SparseCompressedBase.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseCompressedBase::ReverseInnerIterator
m_values	Eigen/src/SparseCore/SparseMap.h	/^    ScalarPointer m_values;$/;"	m	class:Eigen::SparseMapBase
m_values	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    ValueType m_values;$/;"	m	class:Eigen::AutoDiffVector
m_values	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  const int m_inputs, m_values;$/;"	m	struct:Eigen::DenseFunctor
m_values	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  const int m_inputs, m_values;$/;"	m	struct:Eigen::SparseFunctor
m_values	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Scalar *m_values; \/\/Values stored block column after block column (size m_nonzeros)$/;"	m	class:Eigen::BlockSparseMatrix
m_values	unsupported/test/NonLinearOptimization.cpp	/^  const int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_values	unsupported/test/NumericalDiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_values	unsupported/test/autodiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_values	unsupported/test/forward_adolc.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_valuesOkay	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_valuesOkay, m_vectorsOkay;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_vec	doc/examples/make_circulant2.cpp	/^  const ArgType &m_vec;$/;"	m	class:circulant_functor	file:
m_vec	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    VectorType& m_vec;$/;"	m	class:Eigen::BlockVectorReturn
m_vec	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    const VectorType& m_vec;$/;"	m	class:Eigen::BlockVectorView
m_vector	Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_vectors	Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence
m_vectorsOkay	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_valuesOkay, m_vectorsOkay;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_vert_offset	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  const Index m_vert_offset;$/;"	m	class:Eigen::internal::TensorContractionSubMapper
m_view	Eigen/src/SparseCore/SparseView.h	/^        const XprType &m_view;$/;"	m	class:Eigen::internal::unary_evaluator::InnerIterator
m_view	Eigen/src/SparseCore/SparseView.h	/^    const XprType &m_view;$/;"	m	struct:Eigen::internal::unary_evaluator
m_wa1	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_wa1, m_wa2, m_wa3, m_wa4; \/\/Temporary vectors$/;"	m	class:Eigen::LevenbergMarquardt
m_wa2	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_wa1, m_wa2, m_wa3, m_wa4; \/\/Temporary vectors$/;"	m	class:Eigen::LevenbergMarquardt
m_wa3	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_wa1, m_wa2, m_wa3, m_wa4; \/\/Temporary vectors$/;"	m	class:Eigen::LevenbergMarquardt
m_wa4	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    FVectorType m_wa1, m_wa2, m_wa3, m_wa4; \/\/Temporary vectors$/;"	m	class:Eigen::LevenbergMarquardt
m_workspace	Eigen/src/Eigenvalues/RealQZ.h	/^      Matrix<Scalar,Dynamic,1> m_workspace;$/;"	m	class:Eigen::RealQZ
m_workspace	Eigen/src/SVD/BDCSVD.h	/^  ArrayXr m_workspace;$/;"	m	class:Eigen::BDCSVD
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspaceI	Eigen/src/SVD/BDCSVD.h	/^  ArrayXi m_workspaceI;$/;"	m	class:Eigen::BDCSVD
m_workspaceVector	Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur
m_worsts	bench/BenchTimer.h	/^  Vector2d m_worsts;$/;"	m	class:Eigen::BenchTimer
m_wrapper	Eigen/src/Core/CoreEvaluators.h	/^  const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper;$/;"	m	struct:Eigen::internal::evaluator
m_wrapper	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const internal::nullary_wrapper<CoeffReturnType,NullaryOp> m_wrapper;$/;"	m	struct:Eigen::TensorEvaluator
m_written	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool m_written;$/;"	m	class:Eigen::IterationController
m_x	test/denseLM.cpp	/^  VectorType m_x, m_y; \/\/Data Points$/;"	m	struct:DenseLM	file:
m_x	test/sparseLM.cpp	/^  VectorType m_x, m_y; \/\/Data points$/;"	m	struct:sparseGaussianTest	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[14];$/;"	m	struct:misra1a_functor	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[236];$/;"	m	struct:hahn1_functor	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[54];$/;"	m	struct:chwirut2_functor	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^const double chwirut2_functor::m_x[54] = { 0.500E0, 1.000E0, 1.750E0, 3.750E0, 5.750E0, 0.875E0, 2.250E0, 3.250E0, 5.250E0, 0.750E0, 1.750E0, 2.750E0, 4.750E0, 0.625E0, 1.250E0, 2.250E0, 4.250E0, .500E0, 3.000E0, .750E0, 3.000E0, 1.500E0, 6.000E0, 3.000E0, 6.000E0, 1.500E0, 3.000E0, .500E0, 2.000E0, 4.000E0, .750E0, 2.000E0, 5.000E0, .750E0, 2.250E0, 3.750E0, 5.750E0, 3.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .500E0, 6.000E0, 3.000E0, .500E0, 2.750E0, .500E0, 1.750E0};$/;"	m	class:chwirut2_functor	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^const double hahn1_functor::m_x[236] = { 24.41E0 , 34.82E0 , 44.09E0 , 45.07E0 , 54.98E0 , 65.51E0 , 70.53E0 , 75.70E0 , 89.57E0 , 91.14E0 , 96.40E0 , 97.19E0 , 114.26E0 , 120.25E0 , 127.08E0 , 133.55E0 , 133.61E0 , 158.67E0 , 172.74E0 , 171.31E0 , 202.14E0 , 220.55E0 , 221.05E0 , 221.39E0 , 250.99E0 , 268.99E0 , 271.80E0 , 271.97E0 , 321.31E0 , 321.69E0 , 330.14E0 , 333.03E0 , 333.47E0 , 340.77E0 , 345.65E0 , 373.11E0 , 373.79E0 , 411.82E0 , 419.51E0 , 421.59E0 , 422.02E0 , 422.47E0 , 422.61E0 , 441.75E0 , 447.41E0 , 448.7E0  , 472.89E0 , 476.69E0 , 522.47E0 , 522.62E0 , 524.43E0 , 546.75E0 , 549.53E0 , 575.29E0 , 576.00E0 , 625.55E0 , 20.15E0 , 28.78E0 , 29.57E0 , 37.41E0 , 39.12E0 , 50.24E0 , 61.38E0 , 66.25E0 , 73.42E0 , 95.52E0 , 107.32E0 , 122.04E0 , 134.03E0 , 163.19E0 , 163.48E0 , 175.70E0 , 179.86E0 , 211.27E0 , 217.78E0 , 219.14E0 , 262.52E0 , 268.01E0 , 268.62E0 , 336.25E0 , 337.23E0 , 339.33E0 , 427.38E0 , 428.58E0 , 432.68E0 , 528.99E0 , 531.08E0 , 628.34E0 , 253.24E0 , 273.13E0 , 273.66E0 ,$/;"	m	class:hahn1_functor	file:
m_x	unsupported/test/NonLinearOptimization.cpp	/^const double misra1a_functor::m_x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1a_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^    static const double m_x[14];$/;"	m	struct:misra1a_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^    static const double m_x[236];$/;"	m	struct:hahn1_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^    static const double m_x[54];$/;"	m	struct:chwirut2_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^const double chwirut2_functor::m_x[54] = { 0.500E0, 1.000E0, 1.750E0, 3.750E0, 5.750E0, 0.875E0, 2.250E0, 3.250E0, 5.250E0, 0.750E0, 1.750E0, 2.750E0, 4.750E0, 0.625E0, 1.250E0, 2.250E0, 4.250E0, .500E0, 3.000E0, .750E0, 3.000E0, 1.500E0, 6.000E0, 3.000E0, 6.000E0, 1.500E0, 3.000E0, .500E0, 2.000E0, 4.000E0, .750E0, 2.000E0, 5.000E0, .750E0, 2.250E0, 3.750E0, 5.750E0, 3.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .500E0, 6.000E0, 3.000E0, .500E0, 2.750E0, .500E0, 1.750E0};$/;"	m	class:chwirut2_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^const double hahn1_functor::m_x[236] = { 24.41E0 , 34.82E0 , 44.09E0 , 45.07E0 , 54.98E0 , 65.51E0 , 70.53E0 , 75.70E0 , 89.57E0 , 91.14E0 , 96.40E0 , 97.19E0 , 114.26E0 , 120.25E0 , 127.08E0 , 133.55E0 , 133.61E0 , 158.67E0 , 172.74E0 , 171.31E0 , 202.14E0 , 220.55E0 , 221.05E0 , 221.39E0 , 250.99E0 , 268.99E0 , 271.80E0 , 271.97E0 , 321.31E0 , 321.69E0 , 330.14E0 , 333.03E0 , 333.47E0 , 340.77E0 , 345.65E0 , 373.11E0 , 373.79E0 , 411.82E0 , 419.51E0 , 421.59E0 , 422.02E0 , 422.47E0 , 422.61E0 , 441.75E0 , 447.41E0 , 448.7E0  , 472.89E0 , 476.69E0 , 522.47E0 , 522.62E0 , 524.43E0 , 546.75E0 , 549.53E0 , 575.29E0 , 576.00E0 , 625.55E0 , 20.15E0 , 28.78E0 , 29.57E0 , 37.41E0 , 39.12E0 , 50.24E0 , 61.38E0 , 66.25E0 , 73.42E0 , 95.52E0 , 107.32E0 , 122.04E0 , 134.03E0 , 163.19E0 , 163.48E0 , 175.70E0 , 179.86E0 , 211.27E0 , 217.78E0 , 219.14E0 , 262.52E0 , 268.01E0 , 268.62E0 , 336.25E0 , 337.23E0 , 339.33E0 , 427.38E0 , 428.58E0 , 432.68E0 , 528.99E0 , 531.08E0 , 628.34E0 , 253.24E0 , 273.13E0 , 273.66E0 ,$/;"	m	class:hahn1_functor	file:
m_x	unsupported/test/levenberg_marquardt.cpp	/^const double misra1a_functor::m_x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1a_functor	file:
m_xpr	Eigen/src/Core/Block.h	/^    XprTypeNested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_xpr	Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;           \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer
m_xpr	Eigen/src/Core/CwiseUnaryOp.h	/^    XprTypeNested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp
m_xpr	Eigen/src/Core/Inverse.h	/^  XprTypeNested m_xpr;$/;"	m	class:Eigen::Inverse
m_xpr	Eigen/src/Core/Redux.h	/^  const XprType &m_xpr;$/;"	m	class:Eigen::internal::redux_evaluator
m_xpr	Eigen/src/Core/Visitor.h	/^  const XprType &m_xpr;$/;"	m	class:Eigen::internal::visitor_evaluator
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorIndexTupleOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorTupleReducerOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorBroadcastingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorChippingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorConversionOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorEvalToOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorCwiseNullaryOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorCwiseUnaryOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorFFTOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorForcedEvalOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorGeneratorOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorImagePatchOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorInflationOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorLayoutSwapOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorReshapingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorSlicingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorStridingSlicingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorPaddingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorPatchOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorReverseOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorShufflingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorStridingOp
m_xpr	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::TensorVolumePatchOp
m_xpr_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  const Dims& m_xpr_dims;$/;"	m	struct:Eigen::TensorEvaluator
m_xtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar m_xtol; \/\/ $/;"	m	class:Eigen::LevenbergMarquardt
m_y	test/denseLM.cpp	/^  VectorType m_x, m_y; \/\/Data Points$/;"	m	struct:DenseLM	file:
m_y	test/sparseLM.cpp	/^  VectorType m_x, m_y; \/\/Data points$/;"	m	struct:sparseGaussianTest	file:
m_y	unsupported/test/NonLinearOptimization.cpp	/^    static const double m_y[14];$/;"	m	struct:misra1a_functor	file:
m_y	unsupported/test/NonLinearOptimization.cpp	/^    static const double m_y[54];$/;"	m	struct:chwirut2_functor	file:
m_y	unsupported/test/NonLinearOptimization.cpp	/^const double chwirut2_functor::m_y[54] = { 92.9000E0 ,57.1000E0 ,31.0500E0 ,11.5875E0 ,8.0250E0 ,63.6000E0 ,21.4000E0 ,14.2500E0 ,8.4750E0 ,63.8000E0 ,26.8000E0 ,16.4625E0 ,7.1250E0 ,67.3000E0 ,41.0000E0 ,21.1500E0 ,8.1750E0 ,81.5000E0 ,13.1200E0 ,59.9000E0 ,14.6200E0 ,32.9000E0 ,5.4400E0 ,12.5600E0 ,5.4400E0 ,32.0000E0 ,13.9500E0 ,75.8000E0 ,20.0000E0 ,10.4200E0 ,59.5000E0 ,21.6700E0 ,8.5500E0 ,62.0000E0 ,20.2000E0 ,7.7600E0 ,3.7500E0 ,11.8100E0 ,54.7000E0 ,23.7000E0 ,11.5500E0 ,61.3000E0 ,17.7000E0 ,8.7400E0 ,59.2000E0 ,16.3000E0 ,8.6200E0 ,81.0000E0 ,4.8700E0 ,14.6200E0 ,81.7000E0 ,17.1700E0 ,81.3000E0 ,28.9000E0  };$/;"	m	class:chwirut2_functor	file:
m_y	unsupported/test/NonLinearOptimization.cpp	/^const double misra1a_functor::m_y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1a_functor	file:
m_y	unsupported/test/levenberg_marquardt.cpp	/^    static const double m_y[14];$/;"	m	struct:misra1a_functor	file:
m_y	unsupported/test/levenberg_marquardt.cpp	/^    static const double m_y[54];$/;"	m	struct:chwirut2_functor	file:
m_y	unsupported/test/levenberg_marquardt.cpp	/^const double chwirut2_functor::m_y[54] = { 92.9000E0 ,57.1000E0 ,31.0500E0 ,11.5875E0 ,8.0250E0 ,63.6000E0 ,21.4000E0 ,14.2500E0 ,8.4750E0 ,63.8000E0 ,26.8000E0 ,16.4625E0 ,7.1250E0 ,67.3000E0 ,41.0000E0 ,21.1500E0 ,8.1750E0 ,81.5000E0 ,13.1200E0 ,59.9000E0 ,14.6200E0 ,32.9000E0 ,5.4400E0 ,12.5600E0 ,5.4400E0 ,32.0000E0 ,13.9500E0 ,75.8000E0 ,20.0000E0 ,10.4200E0 ,59.5000E0 ,21.6700E0 ,8.5500E0 ,62.0000E0 ,20.2000E0 ,7.7600E0 ,3.7500E0 ,11.8100E0 ,54.7000E0 ,23.7000E0 ,11.5500E0 ,61.3000E0 ,17.7000E0 ,8.7400E0 ,59.2000E0 ,16.3000E0 ,8.6200E0 ,81.0000E0 ,4.8700E0 ,14.6200E0 ,81.7000E0 ,17.1700E0 ,81.3000E0 ,28.9000E0  };$/;"	m	class:chwirut2_functor	file:
m_y	unsupported/test/levenberg_marquardt.cpp	/^const double misra1a_functor::m_y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1a_functor	file:
m_zCoeffs	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  HCoeffsType m_zCoeffs;$/;"	m	class:Eigen::CompleteOrthogonalDecomposition
m_zero	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector
m_zero	Eigen/src/SparseCore/SparseCompressedBase.h	/^  const Scalar m_zero;$/;"	m	struct:Eigen::internal::evaluator
m_zero_nnz	Eigen/src/SparseCore/SparseMap.h	/^    Array<StorageIndex,2,1>  m_zero_nnz;$/;"	m	class:Eigen::SparseMapBase
machep	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar machep() { assert(false && "machep not supported for this type"); return 0.0; }$/;"	f	struct:Eigen::internal::cephes_helper
machep	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double machep() {$/;"	f	struct:Eigen::internal::cephes_helper
machep	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float machep() {$/;"	f	struct:Eigen::internal::cephes_helper
machine_epsilon	unsupported/test/mpreal/mpreal.h	/^inline mpreal machine_epsilon(const mpreal& x)$/;"	f	namespace:mpfr
machine_epsilon	unsupported/test/mpreal/mpreal.h	/^inline mpreal machine_epsilon(mp_prec_t prec)$/;"	f	namespace:mpfr
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacketType& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacketType& a, const RhsPacketType& b, AccPacketType& c, AccPacketType& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits
mag2	unsupported/doc/examples/FFT.cpp	/^T mag2(T a)$/;"	f
mag2	unsupported/doc/examples/FFT.cpp	/^T mag2(const std::vector<T> & vec)$/;"	f
mag2	unsupported/doc/examples/FFT.cpp	/^T mag2(const std::vector<std::complex<T> > & vec)$/;"	f
mag2	unsupported/doc/examples/FFT.cpp	/^T mag2(std::complex<T> a)$/;"	f
magic	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  uint32_t magic;$/;"	m	class:Eigen::internal::TensorIntDivisor
main	bench/analyze-blocking-sizes.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/basicbenchmark.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/benchBlasGemm.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/benchCholesky.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/benchEigenSolver.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/benchFFT.cpp	/^int main(int argc,char ** argv)$/;"	f
main	bench/benchGeometry.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/benchVecAdd.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/bench_gemm.cpp	/^int main(int argc, char ** argv)$/;"	f
main	bench/bench_norm.cpp	/^int main(int argc, char** argv)$/;"	f
main	bench/bench_reverse.cpp	/^int main(int argc, char* argv[])$/;"	f
main	bench/bench_sum.cpp	/^int main() $/;"	f
main	bench/benchmark.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/benchmarkSlice.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/benchmarkX.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/benchmarkXcwise.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/btl/data/mean.cxx	/^int main( int argc , char *argv[] )$/;"	f
main	bench/btl/data/regularize.cxx	/^int main( int argc , char *argv[] )$/;"	f
main	bench/btl/data/smooth.cxx	/^int main( int argc , char *argv[] )$/;"	f
main	bench/btl/libs/BLAS/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/STL/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/blaze/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/blitz/btl_blitz.cpp	/^int main()$/;"	f
main	bench/btl/libs/blitz/btl_tiny_blitz.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen2/btl_tiny_eigen2.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen2/main_adv.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen2/main_linear.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen2/main_matmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen2/main_vecmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen3/btl_tiny_eigen3.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen3/main_adv.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen3/main_linear.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen3/main_matmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/eigen3/main_vecmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/gmm/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/mtl4/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/tensors/main_linear.cpp	/^int main()$/;"	f
main	bench/btl/libs/tensors/main_matmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/tensors/main_vecmat.cpp	/^int main()$/;"	f
main	bench/btl/libs/tvmet/main.cpp	/^int main()$/;"	f
main	bench/btl/libs/ublas/main.cpp	/^int main()$/;"	f
main	bench/check_cache_queries.cpp	/^int main()$/;"	f
main	bench/dense_solvers.cpp	/^int main()$/;"	f
main	bench/eig33.cpp	/^int main()$/;"	f
main	bench/geometry.cpp	/^int main(int argc, char ** argv)$/;"	f
main	bench/perf_monitoring/gemm/gemm.cpp	/^int main(int argc, char **argv)$/;"	f
main	bench/perf_monitoring/gemm/lazy_gemm.cpp	/^int main(int argc, char **argv)$/;"	f
main	bench/product_threshold.cpp	/^int main()$/;"	f
main	bench/quat_slerp.cpp	/^int main()$/;"	f
main	bench/quatmul.cpp	/^int main()$/;"	f
main	bench/sparse_cholesky.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_dense_product.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_lu.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_product.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_randomsetter.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_setter.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_transpose.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/sparse_trisolver.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/spbench/sp_solver.cpp	/^int main(int argc, char **args)$/;"	f
main	bench/spbench/spbenchsolver.cpp	/^int main(int argc, char ** args)$/;"	f
main	bench/spbench/test_sparseLU.cpp	/^int main(int argc, char **args)$/;"	f
main	bench/spmv.cpp	/^int main(int argc, char *argv[])$/;"	f
main	bench/tensors/benchmark_main.cc	/^int main(int argc, char* argv[]) {$/;"	f
main	bench/vdw_new.cpp	/^int main() $/;"	f
main	demos/mandelbrot/mandelbrot.cpp	/^int main(int argc, char *argv[])$/;"	f
main	demos/mix_eigen_and_c/example.c	/^int main()$/;"	f
main	demos/opengl/quaternion_demo.cpp	/^int main(int argc, char *argv[])$/;"	f
main	doc/examples/CustomizingEigen_Inheritance.cpp	/^int main()$/;"	f
main	doc/examples/Cwise_erf.cpp	/^int main()$/;"	f
main	doc/examples/Cwise_erfc.cpp	/^int main()$/;"	f
main	doc/examples/Cwise_lgamma.cpp	/^int main()$/;"	f
main	doc/examples/DenseBase_middleCols_int.cpp	/^int main(void)$/;"	f
main	doc/examples/DenseBase_middleRows_int.cpp	/^int main(void)$/;"	f
main	doc/examples/DenseBase_template_int_middleCols.cpp	/^int main(void)$/;"	f
main	doc/examples/DenseBase_template_int_middleRows.cpp	/^int main(void)$/;"	f
main	doc/examples/QuickStart_example.cpp	/^int main()$/;"	f
main	doc/examples/QuickStart_example2_dynamic.cpp	/^int main()$/;"	f
main	doc/examples/QuickStart_example2_fixed.cpp	/^int main()$/;"	f
main	doc/examples/TemplateKeyword_flexible.cpp	/^int main()$/;"	f
main	doc/examples/TemplateKeyword_simple.cpp	/^int main()$/;"	f
main	doc/examples/TutorialInplaceLU.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgComputeTwice.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgExComputeSolveError.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgExSolveColPivHouseholderQR.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgExSolveLDLT.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgInverseDeterminant.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgRankRevealing.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgSVDSolve.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgSelfAdjointEigenSolver.cpp	/^int main()$/;"	f
main	doc/examples/TutorialLinAlgSetThreshold.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_accessors.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_addition.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_cwise_other.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_interop.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_interop_matrix.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ArrayClass_mult.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_BlockOperations_block_assignment.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_BlockOperations_colrow.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_BlockOperations_corner.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_BlockOperations_print_block.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_BlockOperations_vector.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_PartialLU_solve.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_broadcast_1nn.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_broadcast_simple.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_broadcast_simple_rowwise.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_colwise.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_maxnorm.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_reductions_bool.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_reductions_norm.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_reductions_operatornorm.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_rowwise.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_ReductionsVisitorsBroadcasting_visitors.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_simple_example_dynamic_size.cpp	/^int main()$/;"	f
main	doc/examples/Tutorial_simple_example_fixed_size.cpp	/^int main()$/;"	f
main	doc/examples/class_Block.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_CwiseBinaryOp.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_CwiseUnaryOp.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_CwiseUnaryOp_ptrfun.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_FixedBlock.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_FixedVectorBlock.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/class_VectorBlock.cpp	/^int main(int, char**)$/;"	f
main	doc/examples/function_taking_eigenbase.cpp	/^int main()$/;"	f
main	doc/examples/function_taking_ref.cpp	/^int main()$/;"	f
main	doc/examples/make_circulant2.cpp	/^int main()$/;"	f
main	doc/examples/matrixfree_cg.cpp	/^int main()$/;"	f
main	doc/examples/nullary_indexing.cpp	/^int main()$/;"	f
main	doc/examples/tut_arithmetic_add_sub.cpp	/^int main()$/;"	f
main	doc/examples/tut_arithmetic_dot_cross.cpp	/^int main()$/;"	f
main	doc/examples/tut_arithmetic_matrix_mul.cpp	/^int main()$/;"	f
main	doc/examples/tut_arithmetic_redux_basic.cpp	/^int main()$/;"	f
main	doc/examples/tut_arithmetic_scalar_mul_div.cpp	/^int main()$/;"	f
main	doc/examples/tut_matrix_coefficient_accessors.cpp	/^int main()$/;"	f
main	doc/examples/tut_matrix_resize.cpp	/^int main()$/;"	f
main	doc/examples/tut_matrix_resize_fixed_size.cpp	/^int main()$/;"	f
main	doc/special_examples/Tutorial_sparse_example.cpp	/^int main(int argc, char** argv)$/;"	f
main	doc/special_examples/random_cpp11.cpp	/^int main() {$/;"	f
main	doc/tutorial.cpp	/^int main(int argc, char *argv[])$/;"	f
main	failtest/bdcsvd_int.cpp	/^int main()$/;"	f
main	failtest/block_nonconst_ctor_on_const_xpr_0.cpp	/^int main() {}$/;"	f
main	failtest/block_nonconst_ctor_on_const_xpr_1.cpp	/^int main() {}$/;"	f
main	failtest/block_nonconst_ctor_on_const_xpr_2.cpp	/^int main() {}$/;"	f
main	failtest/block_on_const_type_actually_const_0.cpp	/^int main() {}$/;"	f
main	failtest/block_on_const_type_actually_const_1.cpp	/^int main() {}$/;"	f
main	failtest/colpivqr_int.cpp	/^int main()$/;"	f
main	failtest/const_qualified_block_method_retval_0.cpp	/^int main() {}$/;"	f
main	failtest/const_qualified_block_method_retval_1.cpp	/^int main() {}$/;"	f
main	failtest/const_qualified_diagonal_method_retval.cpp	/^int main() {}$/;"	f
main	failtest/const_qualified_transpose_method_retval.cpp	/^int main() {}$/;"	f
main	failtest/cwiseunaryview_nonconst_ctor_on_const_xpr.cpp	/^int main() {}$/;"	f
main	failtest/cwiseunaryview_on_const_type_actually_const.cpp	/^int main() {}$/;"	f
main	failtest/diagonal_nonconst_ctor_on_const_xpr.cpp	/^int main() {}$/;"	f
main	failtest/diagonal_on_const_type_actually_const.cpp	/^int main() {}$/;"	f
main	failtest/eigensolver_cplx.cpp	/^int main()$/;"	f
main	failtest/eigensolver_int.cpp	/^int main()$/;"	f
main	failtest/fullpivlu_int.cpp	/^int main()$/;"	f
main	failtest/fullpivqr_int.cpp	/^int main()$/;"	f
main	failtest/jacobisvd_int.cpp	/^int main()$/;"	f
main	failtest/ldlt_int.cpp	/^int main()$/;"	f
main	failtest/llt_int.cpp	/^int main()$/;"	f
main	failtest/map_nonconst_ctor_on_const_ptr_0.cpp	/^int main() {}$/;"	f
main	failtest/map_nonconst_ctor_on_const_ptr_1.cpp	/^int main() {}$/;"	f
main	failtest/map_nonconst_ctor_on_const_ptr_2.cpp	/^int main() {}$/;"	f
main	failtest/map_nonconst_ctor_on_const_ptr_3.cpp	/^int main() {}$/;"	f
main	failtest/map_nonconst_ctor_on_const_ptr_4.cpp	/^int main() {}$/;"	f
main	failtest/map_on_const_type_actually_const_0.cpp	/^int main() {}$/;"	f
main	failtest/map_on_const_type_actually_const_1.cpp	/^int main() {}$/;"	f
main	failtest/partialpivlu_int.cpp	/^int main()$/;"	f
main	failtest/qr_int.cpp	/^int main()$/;"	f
main	failtest/ref_1.cpp	/^int main()$/;"	f
main	failtest/ref_2.cpp	/^int main()$/;"	f
main	failtest/ref_3.cpp	/^int main()$/;"	f
main	failtest/ref_4.cpp	/^int main()$/;"	f
main	failtest/ref_5.cpp	/^int main()$/;"	f
main	failtest/selfadjointview_nonconst_ctor_on_const_xpr.cpp	/^int main() {}$/;"	f
main	failtest/selfadjointview_on_const_type_actually_const.cpp	/^int main() {}$/;"	f
main	failtest/sparse_ref_1.cpp	/^int main()$/;"	f
main	failtest/sparse_ref_2.cpp	/^int main()$/;"	f
main	failtest/sparse_ref_3.cpp	/^int main()$/;"	f
main	failtest/sparse_ref_4.cpp	/^int main()$/;"	f
main	failtest/sparse_ref_5.cpp	/^int main()$/;"	f
main	failtest/sparse_storage_mismatch.cpp	/^int main()$/;"	f
main	failtest/swap_1.cpp	/^int main()$/;"	f
main	failtest/swap_2.cpp	/^int main()$/;"	f
main	failtest/ternary_1.cpp	/^int main(int argc,char **)$/;"	f
main	failtest/ternary_2.cpp	/^int main(int argc,char **)$/;"	f
main	failtest/transpose_nonconst_ctor_on_const_xpr.cpp	/^int main() {}$/;"	f
main	failtest/transpose_on_const_type_actually_const.cpp	/^int main() {}$/;"	f
main	failtest/triangularview_nonconst_ctor_on_const_xpr.cpp	/^int main() {}$/;"	f
main	failtest/triangularview_on_const_type_actually_const.cpp	/^int main() {}$/;"	f
main	scripts/eigen_gen_credits.cpp	/^int main()$/;"	f
main	test/bug1213_main.cpp	/^int main()$/;"	f
main	test/main.h	/^int main(int argc, char *argv[])$/;"	f
main	test/mpl2only.cpp	/^int main()$/;"	f
main	unsupported/bench/bench_svd.cpp	/^int main(int argc, char* argv[])$/;"	f
main	unsupported/doc/examples/BVH_Example.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/EulerAngles.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/FFT.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixExponential.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixFunction.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixLogarithm.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixPower.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixPower_optimal.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixSine.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixSinh.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/MatrixSquareRoot.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/PolynomialSolver1.cpp	/^int main()$/;"	f
main	unsupported/doc/examples/PolynomialUtils1.cpp	/^int main()$/;"	f
majorDeviceVersion	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int majorDeviceVersion() const {$/;"	f	struct:Eigen::GpuDevice
majorDeviceVersion	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int majorDeviceVersion() const {$/;"	f	struct:Eigen::DefaultDevice
majorDeviceVersion	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int majorDeviceVersion() const {$/;"	f	struct:Eigen::SyclDevice
majorDeviceVersion	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int majorDeviceVersion() const {$/;"	f	struct:Eigen::ThreadPoolDevice
makeAffine	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC void makeAffine()$/;"	f	class:Eigen::Transform
makeCirculant	doc/examples/make_circulant2.cpp	/^makeCirculant(const Eigen::MatrixBase<ArgType>& arg)$/;"	f
makeCompressed	Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r)$/;"	f	class:Eigen::JacobiRotation
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation
makeHouseholder	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase
makeHouseholderInPlace	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase
makeJacobi	Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)$/;"	f	class:Eigen::JacobiRotation
makeJacobi	Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, Index p, Index q)$/;"	f	class:Eigen::JacobiRotation
make_backup	bench/perf_monitoring/gemm/run.sh	/^function make_backup$/;"	f
make_block_householder_triangular_factor	Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
make_coherent	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^void make_coherent(const A& a, const B&b)$/;"	f	namespace:Eigen::internal
make_coherent_impl	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl {$/;"	s	namespace:Eigen::internal
make_coherent_impl	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<A, Matrix<B_Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols> > {$/;"	s	namespace:Eigen::internal
make_coherent_impl	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>, B> {$/;"	s	namespace:Eigen::internal
make_coherent_impl	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>,$/;"	s	namespace:Eigen::internal
make_first_subset	bench/analyze-blocking-sizes.cpp	/^void make_first_subset(size_t subset_size, vector<size_t>& out_subset, size_t set_size)$/;"	f
make_index_list	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^constexpr IndexList<FirstType, OtherTypes...> make_index_list(FirstType val1, OtherTypes... other_vals) {$/;"	f	namespace:Eigen
make_tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractAccessor.h	/^  -> decltype(utility::tuple::make_tuple( eval.device().template get_sycl_accessor<AcM,$/;"	f	struct:Eigen::TensorSycl::internal::AccessorConstructor
make_tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^Tuple<Args...> make_tuple(Args... args) {$/;"	f	namespace:utility::tuple
make_twiddles	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void make_twiddles(int nfft,bool inverse)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
make_type_list	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct make_type_list {$/;"	s	namespace:Eigen::internal
make_type_list	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<> struct make_type_list<> {$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<char>             { typedef unsigned char type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed __int64>   { typedef unsigned __int64 type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed char>      { typedef unsigned char type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed int>       { typedef unsigned int type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed long>      { typedef unsigned long type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed short>     { typedef unsigned short type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned __int64> { typedef unsigned __int64 type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned char>    { typedef unsigned char type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned int>     { typedef unsigned int type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned long>    { typedef unsigned long type; };$/;"	s	namespace:Eigen::internal
make_unsigned	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned short>   { typedef unsigned short type; };$/;"	s	namespace:Eigen::internal
make_vector	blas/common.h	/^Map<Matrix<T,Dynamic,1> > make_vector(T* data, int size)$/;"	f
make_vector	blas/common.h	/^Map<Matrix<T,Dynamic,1>, 0, InnerStride<Dynamic> > make_vector(T* data, int size, int incr)$/;"	f
make_vector	blas/common.h	/^Map<const Matrix<T,Dynamic,1> > make_vector(const T* data, int size)$/;"	f
make_vector	blas/common.h	/^Map<const Matrix<T,Dynamic,1>, 0, InnerStride<Dynamic> > make_vector(const T* data, int size, int incr)$/;"	f
manageErrorCode	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error) const$/;"	f	class:Eigen::PardisoImpl
manage_caching_sizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1, std::ptrdiff_t* l2, std::ptrdiff_t* l3)$/;"	f	namespace:Eigen::internal
manage_caching_sizes_helper	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal
manage_multi_threading	Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal
mapCudaInputKernelToTensorInputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaInputKernelToTensorInputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i, Index j) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaInputKernelToTensorInputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputKernelToTensorInputOffset(Index i, Index j, Index k) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaInputPlaneToTensorInputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaInputPlaneToTensorInputOffset(Index p) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaOutputKernelToTensorOutputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaOutputKernelToTensorOutputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i, Index j) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaOutputKernelToTensorOutputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputKernelToTensorOutputOffset(Index i, Index j, Index k) const {$/;"	f	class:Eigen::internal::IndexMapper
mapCudaOutputPlaneToTensorOutputOffset	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Index mapCudaOutputPlaneToTensorOutputOffset(Index p) const {$/;"	f	class:Eigen::internal::IndexMapper
mapQuaternion	test/geo_quaternion.cpp	/^template<typename Scalar> void mapQuaternion(void){$/;"	f
mapToSphere	demos/opengl/trackball.cpp	/^bool Trackball::mapToSphere(const Vector2i& p2, Vector3f& v3)$/;"	f	class:Trackball
map_class_matrix	test/mapped_matrix.cpp	/^template<typename MatrixType> void map_class_matrix(const MatrixType& m)$/;"	f
map_class_matrix	test/mapstride.cpp	/^template<int Alignment,typename MatrixType> void map_class_matrix(const MatrixType& _m)$/;"	f
map_class_vector	test/mapped_matrix.cpp	/^template<typename VectorType> void map_class_vector(const VectorType& m)$/;"	f
map_class_vector	test/mapstride.cpp	/^template<int Alignment,typename VectorType> void map_class_vector(const VectorType& m)$/;"	f
map_not_aligned_on_scalar	test/mapped_matrix.cpp	/^void map_not_aligned_on_scalar()$/;"	f
map_size	bench/product_threshold.cpp	/^template<>  struct map_size<10> { enum { ret = 20 }; };$/;"	s	file:
map_size	bench/product_threshold.cpp	/^template<>  struct map_size<11> { enum { ret = 50 }; };$/;"	s	file:
map_size	bench/product_threshold.cpp	/^template<>  struct map_size<12> { enum { ret = 100 }; };$/;"	s	file:
map_size	bench/product_threshold.cpp	/^template<>  struct map_size<13> { enum { ret = 300 }; };$/;"	s	file:
map_size	bench/product_threshold.cpp	/^template<int S> struct map_size { enum { ret = S }; };$/;"	s	file:
map_static_methods	test/mapped_matrix.cpp	/^template<typename VectorType> void map_static_methods(const VectorType& m)$/;"	f
map_superlu	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal
mapbase_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit mapbase_evaluator(const XprType& map)$/;"	f	struct:Eigen::internal::mapbase_evaluator
mapbase_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct mapbase_evaluator : evaluator_base<Derived>$/;"	s	namespace:Eigen::internal
mapstaticmethods	test/mapstaticmethods.cpp	/^void mapstaticmethods(const PlainObjectType& m)$/;"	f
mapstaticmethods_impl	test/mapstaticmethods.cpp	/^struct mapstaticmethods_impl {};$/;"	s	file:
mapstaticmethods_impl	test/mapstaticmethods.cpp	/^struct mapstaticmethods_impl<PlainObjectType, false, IsVector>$/;"	s	file:
mapstaticmethods_impl	test/mapstaticmethods.cpp	/^struct mapstaticmethods_impl<PlainObjectType, true, false>$/;"	s	file:
mapstaticmethods_impl	test/mapstaticmethods.cpp	/^struct mapstaticmethods_impl<PlainObjectType, true, true>$/;"	s	file:
mark	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType mark ;  \/* for computing set differences and marking dead rows*\/$/;"	m	union:internal::Colamd_Row::__anon873
markAsRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
markAsRValue	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Derived& markAsRValue() {$/;"	f	class:Eigen::SkylineMatrixBase
mat	doc/snippets/Tutorial_AdvancedInitialization_CommaTemporary.cpp	/^MatrixXf mat = MatrixXf::Random(2, 3);$/;"	v
matA	doc/snippets/TopicAliasing_mult1.cpp	/^cout << matA;$/;"	v
matA	doc/snippets/TopicAliasing_mult3.cpp	/^cout << matA;$/;"	v
matA	doc/snippets/Tutorial_AdvancedInitialization_Block.cpp	/^matB << matA, matA\/10, matA\/10, matA;$/;"	v
matB	doc/snippets/TopicAliasing_mult2.cpp	/^cout << matB;$/;"	v
matPrefix	Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
matSuffix	Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
mat_mat_scalar_scalar_product	test/product_extra.cpp	/^void mat_mat_scalar_scalar_product()$/;"	f
match	Eigen/src/Core/Ref.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits
match	Eigen/src/SparseCore/SparseRef.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits
matlab_cplx_cplx	bench/bench_gemm.cpp	/^void matlab_cplx_cplx(const M& ar, const M& ai, const M& br, const M& bi, M& cr, M& ci)$/;"	f
matlab_cplx_real	bench/bench_gemm.cpp	/^void matlab_cplx_real(const M& ar, const M& ai, const M& b, M& cr, M& ci)$/;"	f
matlab_real_cplx	bench/bench_gemm.cpp	/^void matlab_real_cplx(const M& a, const M& br, const M& bi, M& cr, M& ci)$/;"	f
matname	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline std::string& matname() { return m_matname; }$/;"	f	class:Eigen::MatrixMarketIterator
matrix	Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return MatrixWrapper<Derived>(derived()); }$/;"	f	class:Eigen::ArrayBase
matrix	Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return MatrixWrapper<const Derived>(derived()); }$/;"	f	class:Eigen::ArrayBase
matrix	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
matrix	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType& matrix() const$/;"	f	class:Eigen::IterativeSolverBase
matrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType& matrix() const$/;"	f	class:Eigen::internal::generic_matrix_wrapper
matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const NestedExpression& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename internal::remove_reference<MatrixTypeNested>::type& matrix() { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	blas/common.h	/^matrix(T* data, int rows, int cols, int stride)$/;"	f
matrix	blas/common.h	/^matrix(const T* data, int rows, int cols, int stride)$/;"	f
matrix	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline MatrixType& matrix() $/;"	f	class:Eigen::MatrixMarketIterator
matrixFunction	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::matrixFunction(typename internal::stem_function<typename internal::traits<Derived>::Scalar>::type f) const$/;"	f	class:Eigen::MatrixBase
matrixH	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixL	Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT
matrixL	Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT
matrixL	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const FactorType& matrixL() const { eigen_assert("m_factorizationIsOk"); return m_L; }$/;"	f	class:Eigen::IncompleteCholesky
matrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT
matrixL	Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixLReturnType<SCMatrix> matrixL() const$/;"	f	class:Eigen::SparseLU
matrixL	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU
matrixL	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU
matrixLDLT	Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT
matrixLLT	Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT
matrixLU	Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU
matrixLU	Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU
matrixQ	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixQ	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixQ() const {$/;"	f	class:Eigen::RealQZ
matrixQ	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization
matrixQ	Eigen/src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQ	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  HouseholderSequenceType matrixQ(void) const { return m_cpqr.householderQ(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixQ	Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQ	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQRMatrixQReturnType<SPQR> matrixQ() const$/;"	f	class:Eigen::SPQR
matrixQ	Eigen/src/SparseQR/SparseQR.h	/^    SparseQRMatrixQReturnType<SparseQR> matrixQ() const $/;"	f	class:Eigen::SparseQR
matrixQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQR	Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR
matrixQTZ	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const MatrixType& matrixQTZ() const { return m_cpqr.matrixQR(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixR	Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    const MatrixType matrixR() const$/;"	f	class:Eigen::SPQR
matrixR	Eigen/src/SparseQR/SparseQR.h	/^    const QRMatrixType& matrixR() const { return m_R; }$/;"	f	class:Eigen::SparseQR
matrixR	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    JacobianType& matrixR() {return m_rfactor; }$/;"	f	class:Eigen::LevenbergMarquardt
matrixRedux	test/redux.cpp	/^template<typename MatrixType> void matrixRedux(const MatrixType& m)$/;"	f
matrixS	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixS() const {$/;"	f	class:Eigen::RealQZ
matrixT	Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur
matrixT	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixT() const {$/;"	f	class:Eigen::RealQZ
matrixT	Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur
matrixT	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization
matrixT	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const MatrixType& matrixT() const { return m_cpqr.matrixQR(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrixU	Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT
matrixU	Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT
matrixU	Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur
matrixU	Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur
matrixU	Eigen/src/SVD/SVDBase.h	/^  const MatrixUType& matrixU() const$/;"	f	class:Eigen::SVDBase
matrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT
matrixU	Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,StorageIndex> > matrixU() const$/;"	f	class:Eigen::SparseLU
matrixU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU
matrixU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU
matrixV	Eigen/src/SVD/SVDBase.h	/^  const MatrixVType& matrixV() const$/;"	f	class:Eigen::SVDBase
matrixVisitor	test/visitor.cpp	/^template<typename MatrixType> void matrixVisitor(const MatrixType& p)$/;"	f
matrixZ	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixZ() const {$/;"	f	class:Eigen::RealQZ
matrixZ	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  MatrixType matrixZ() const {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
matrix_exp_compute	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_compute(const ArgType& arg, ResultType &result, false_type) \/\/ default$/;"	f	namespace:Eigen::internal
matrix_exp_compute	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_compute(const ArgType& arg, ResultType &result, true_type) \/\/ natively supported scalar type$/;"	f	namespace:Eigen::internal
matrix_exp_computeUV	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct matrix_exp_computeUV$/;"	s	namespace:Eigen::internal
matrix_exp_computeUV	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct matrix_exp_computeUV<MatrixType, double>$/;"	s	namespace:Eigen::internal
matrix_exp_computeUV	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct matrix_exp_computeUV<MatrixType, float>$/;"	s	namespace:Eigen::internal
matrix_exp_computeUV	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct matrix_exp_computeUV<MatrixType, long double>$/;"	s	namespace:Eigen::internal
matrix_exp_pade13	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade13(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_exp_pade17	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade17(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_exp_pade3	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade3(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_exp_pade5	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade5(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_exp_pade7	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade7(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_exp_pade9	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void matrix_exp_pade9(const MatA& A, MatU& U, MatV& V)$/;"	f	namespace:Eigen::internal
matrix_from_stl	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:c_interface_base
matrix_from_stl	bench/btl/libs/STL/STL_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:STL_interface
matrix_from_stl	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:blaze_interface
matrix_from_stl	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:blitz_interface
matrix_from_stl	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tiny_blitz_interface
matrix_from_stl	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static BTL_DONT_INLINE void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:eigen2_interface
matrix_from_stl	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static BTL_DONT_INLINE void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:eigen3_interface
matrix_from_stl	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:gmm_interface
matrix_from_stl	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:mtl4_interface
matrix_from_stl	bench/btl/libs/tensors/tensor_interface.hh	/^  static BTL_DONT_INLINE void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tensor_interface
matrix_from_stl	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tvmet_interface
matrix_from_stl	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_from_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:ublas_interface
matrix_function_compute	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^struct matrix_function_compute$/;"	s	namespace:Eigen::internal
matrix_function_compute	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^struct matrix_function_compute<MatrixType, 0>$/;"	s	namespace:Eigen::internal
matrix_function_compute	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^struct matrix_function_compute<MatrixType, 1>$/;"	s	namespace:Eigen::internal
matrix_function_compute_above_diagonal	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_above_diagonal(const MatrixType& T, const VectorType& blockStart, const VectorType& clusterSize, MatrixType& fT)$/;"	f	namespace:Eigen::internal
matrix_function_compute_block_atomic	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_block_atomic(const MatrixType& T, AtomicType& atomic, const VectorType& blockStart, const VectorType& clusterSize, MatrixType& fT)$/;"	f	namespace:Eigen::internal
matrix_function_compute_block_start	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_block_start(const VectorType& clusterSize, VectorType& blockStart)$/;"	f	namespace:Eigen::internal
matrix_function_compute_cluster_size	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_cluster_size(const ListOfClusters& clusters, Matrix<Index, Dynamic, 1>& clusterSize)$/;"	f	namespace:Eigen::internal
matrix_function_compute_map	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_map(const EivalsType& eivals, const ListOfClusters& clusters, VectorType& eivalToCluster)$/;"	f	namespace:Eigen::internal
matrix_function_compute_mu	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^typename NumTraits<typename MatrixType::Scalar>::Real matrix_function_compute_mu(const MatrixType& A)$/;"	f	namespace:Eigen::internal
matrix_function_compute_permutation	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_compute_permutation(const DynVectorType& blockStart, const DynVectorType& eivalToCluster, VectorType& permutation)$/;"	f	namespace:Eigen::internal
matrix_function_find_cluster	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^typename ListOfClusters::iterator matrix_function_find_cluster(Index key, ListOfClusters& clusters)$/;"	f	namespace:Eigen::internal
matrix_function_partition_eigenvalues	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_partition_eigenvalues(const EivalsType& eivals, std::list<Cluster>& clusters)$/;"	f	namespace:Eigen::internal
matrix_function_permute_schur	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void matrix_function_permute_schur(VectorType& permutation, MatrixType& U, MatrixType& T)$/;"	f	namespace:Eigen::internal
matrix_function_separation	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^static const float matrix_function_separation = 0.1f;$/;"	m	namespace:Eigen::internal
matrix_function_solve_triangular_sylvester	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^MatrixType matrix_function_solve_triangular_sylvester(const MatrixType& A, const MatrixType& B, const MatrixType& C)$/;"	f	namespace:Eigen::internal
matrix_l1_norm	test/cholesky.cpp	/^typename MatrixType::RealScalar matrix_l1_norm(const MatrixType& m) {$/;"	f
matrix_l1_norm	test/lu.cpp	/^typename MatrixType::RealScalar matrix_l1_norm(const MatrixType& m) {$/;"	f
matrix_log_compute_2x2	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void matrix_log_compute_2x2(const MatrixType& A, MatrixType& result)$/;"	f	namespace:Eigen::internal
matrix_log_compute_big	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void matrix_log_compute_big(const MatrixType& A, MatrixType& result)$/;"	f	namespace:Eigen::internal
matrix_log_compute_pade	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void matrix_log_compute_pade(MatrixType& result, const MatrixType& T, int degree)$/;"	f	namespace:Eigen::internal
matrix_log_get_pade_degree	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^inline int matrix_log_get_pade_degree(double normTminusI)$/;"	f	namespace:Eigen::internal
matrix_log_get_pade_degree	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^inline int matrix_log_get_pade_degree(float normTminusI)$/;"	f	namespace:Eigen::internal
matrix_log_get_pade_degree	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^inline int matrix_log_get_pade_degree(long double normTminusI)$/;"	f	namespace:Eigen::internal
matrix_log_max_pade_degree	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^struct matrix_log_max_pade_degree $/;"	s	namespace:Eigen::internal
matrix_log_min_pade_degree	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^struct matrix_log_min_pade_degree $/;"	s	namespace:Eigen::internal
matrix_matrix_product	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void matrix_matrix_product(gene_matrix & A, gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:blas_interface
matrix_matrix_product	bench/btl/libs/STL/STL_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N)$/;"	f	class:STL_interface
matrix_matrix_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:blaze_interface
matrix_matrix_product	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N)$/;"	f	class:blitz_interface
matrix_matrix_product	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:tiny_blitz_interface
matrix_matrix_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:eigen2_interface
matrix_matrix_product	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
matrix_matrix_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:gmm_interface
matrix_matrix_product	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:mtl4_interface
matrix_matrix_product	bench/btl/libs/tensors/tensor_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int  \/*N*\/){$/;"	f	class:tensor_interface
matrix_matrix_product	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:tvmet_interface
matrix_matrix_product	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_matrix_product(gene_matrix & A, gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:ublas_interface
matrix_matrix_product_sliced	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  static inline real matrix_matrix_product_sliced(gene_matrix & A, int row, int col_start, int col_end, gene_matrix & B, int row_shift, int col )$/;"	f	class:blitz_LU_solve_interface
matrix_matrix_product_sliced	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  static inline real matrix_matrix_product_sliced(gene_matrix & A, int row, int col_start, int col_end, gene_matrix & B, int row_shift, int col )$/;"	f	class:blitz_LU_solve_interface
matrix_matrix_product_sliced	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  static inline real matrix_matrix_product_sliced(gene_matrix & A, int row, int col_start, int col_end, gene_matrix & B, int row_shift, int col )$/;"	f	class:blitz_LU_solve_interface
matrix_matrix_product_slow	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_matrix_product_slow(gene_matrix & A, gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:ublas_interface
matrix_sqrt_compute	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^struct matrix_sqrt_compute$/;"	s	namespace:Eigen::internal
matrix_sqrt_compute	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^struct matrix_sqrt_compute<MatrixType, 0>$/;"	s	namespace:Eigen::internal
matrix_sqrt_compute	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^struct matrix_sqrt_compute<MatrixType, 1>$/;"	s	namespace:Eigen::internal
matrix_sqrt_quasi_triangular	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular(const MatrixType &arg, ResultType &result)$/;"	f	namespace:Eigen
matrix_sqrt_quasi_triangular_1x1_off_diagonal_block	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_1x1_off_diagonal_block(const MatrixType& T, typename MatrixType::Index i, typename MatrixType::Index j, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_1x2_off_diagonal_block	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_1x2_off_diagonal_block(const MatrixType& T, typename MatrixType::Index i, typename MatrixType::Index j, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_2x1_off_diagonal_block	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_2x1_off_diagonal_block(const MatrixType& T, typename MatrixType::Index i, typename MatrixType::Index j, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_2x2_diagonal_block	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_2x2_diagonal_block(const MatrixType& T, typename MatrixType::Index i, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_2x2_off_diagonal_block	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_2x2_off_diagonal_block(const MatrixType& T, typename MatrixType::Index i, typename MatrixType::Index j, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_diagonal	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_diagonal(const MatrixType& T, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_off_diagonal	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_off_diagonal(const MatrixType& T, ResultType& sqrtT)$/;"	f	namespace:Eigen::internal
matrix_sqrt_quasi_triangular_solve_auxiliary_equation	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_quasi_triangular_solve_auxiliary_equation(MatrixType& X, const MatrixType& A, const MatrixType& B, const MatrixType& C)$/;"	f	namespace:Eigen::internal
matrix_sqrt_triangular	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void matrix_sqrt_triangular(const MatrixType &arg, ResultType &result)$/;"	f	namespace:Eigen
matrix_swap_impl	Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrix_swap_impl	Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_to_stl	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:c_interface_base
matrix_to_stl	bench/btl/libs/STL/STL_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:STL_interface
matrix_to_stl	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:blaze_interface
matrix_to_stl	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:blitz_interface
matrix_to_stl	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tiny_blitz_interface
matrix_to_stl	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static BTL_DONT_INLINE  void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:eigen2_interface
matrix_to_stl	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static BTL_DONT_INLINE  void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:eigen3_interface
matrix_to_stl	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:gmm_interface
matrix_to_stl	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:mtl4_interface
matrix_to_stl	bench/btl/libs/tensors/tensor_interface.hh	/^  static BTL_DONT_INLINE  void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tensor_interface
matrix_to_stl	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:tvmet_interface
matrix_to_stl	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_to_stl(gene_matrix & A, stl_matrix & A_stl){$/;"	f	class:ublas_interface
matrix_type_times_scalar_type	Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
matrix_vector_product	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blas_interface
matrix_vector_product	bench/btl/libs/STL/STL_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:STL_interface
matrix_vector_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blaze_interface
matrix_vector_product	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:blitz_interface
matrix_vector_product	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:tiny_blitz_interface
matrix_vector_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void matrix_vector_product(const gene_matrix & A, const gene_vector & B, gene_vector & X, int N){$/;"	f	class:eigen2_interface
matrix_vector_product	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void matrix_vector_product(const gene_matrix & A, const gene_vector & B, gene_vector & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
matrix_vector_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:gmm_interface
matrix_vector_product	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:mtl4_interface
matrix_vector_product	bench/btl/libs/tensors/tensor_interface.hh	/^  static inline void matrix_vector_product(const gene_matrix & A, const gene_vector & B, gene_vector & X, int  \/*N*\/){$/;"	f	class:tensor_interface
matrix_vector_product	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:tvmet_interface
matrix_vector_product	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_vector_product(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:ublas_interface
matrix_vector_product_sliced	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  static inline real matrix_vector_product_sliced(const gene_matrix & A, gene_vector B, int row, int col_start, int col_end)$/;"	f	class:blitz_LU_solve_interface
matrix_vector_product_sliced	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  static inline real matrix_vector_product_sliced(const gene_matrix & A, gene_vector B, int row, int col_start, int col_end)$/;"	f	class:blitz_LU_solve_interface
matrix_vector_product_sliced	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  static inline real matrix_vector_product_sliced(const gene_matrix & A, gene_vector B, int row, int col_start, int col_end)$/;"	f	class:blitz_LU_solve_interface
matrix_vector_product_slow	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void matrix_vector_product_slow(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:ublas_interface
max	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half (max)() { return Eigen::half_impl::raw_uint16_to_half(0x7bff); }$/;"	f	class:std::numeric_limits::Eigen
max	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (max)(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
max	Eigen/src/Core/util/Meta.h	/^  static T (max)() { assert(false && "Highest not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static double (max)() { return DBL_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static float (max)() { return CUDART_MAX_NORMAL_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static int (max)() { return INT_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static long (max)() { return LONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static long long (max)() { return LLONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static unsigned int (max)() { return UINT_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static unsigned long (max)() { return ULONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Core/util/Meta.h	/^  static unsigned long long (max)() { return ULLONG_MAX; }$/;"	f	struct:Eigen::internal::device::numeric_limits
max	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^max$/;"	f
max	blas/f2c/datatypes.h	20;"	d
max	test/boostmultiprec.cpp	61;"	d	file:
max	test/main.h	71;"	d
max	test/sparse.h	24;"	d
max	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (max)(const AutoDiffScalar<DerType>& x, const AutoDiffScalar<DerType>& y) {$/;"	f	namespace:Eigen
max	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (max)(const AutoDiffScalar<DerType>& x, const T& y) {$/;"	f	namespace:Eigen
max	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (max)(const T& x, const AutoDiffScalar<DerType>& y) {$/;"	f	namespace:Eigen
max	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal (max)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::maxval(precision);  }$/;"	f	class:std::numeric_limits::mpfr
max	unsupported/test/mpreal/mpreal.h	/^inline const mpreal (max)(const mpreal& x, const mpreal& y){    return (x>y?x:y);       }$/;"	f	namespace:mpfr
maxBlocks	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int maxBlocks() const {$/;"	f	struct:Eigen::GpuDevice
maxCoeff	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase
maxCoeff	Eigen/src/Core/VectorwiseOp.h	/^    const MaxCoeffReturnType maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp
maxCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
maxCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* rowPtr, IndexType* colPtr) const$/;"	f	class:Eigen::DenseBase
maxCudaThreadsPerBlock	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int maxCudaThreadsPerBlock() const {$/;"	f	struct:Eigen::GpuDevice
maxCudaThreadsPerMultiProcessor	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int maxCudaThreadsPerMultiProcessor() const {$/;"	f	struct:Eigen::GpuDevice
maxIterarions	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t maxIterarions() const { return m_maxiter; }$/;"	f	class:Eigen::IterationController
maxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase
maxOfV	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  int maxOfV = v.maxCoeff(&i);$/;"	v
maxOneTwoPlusOne	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t maxOneTwoPlusOne = ((One > Two) ? One : Two) + 1;$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
maxPivot	Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU
maxPivot	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR
maxPivot	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline RealScalar maxPivot() const { return m_cpqr.maxPivot(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
maxPivot	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR
maxResidual	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double maxResidual() const { return m_resmax; }$/;"	f	class:Eigen::IterationController
max_blocks_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  int max_blocks_;$/;"	m	struct:Eigen::GpuDevice
max_clock_speed	bench/benchmark-blocking-sizes.cpp	/^float max_clock_speed = 0.0f;$/;"	v
max_coeff_visitor	Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
max_digits10	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int max_digits10 = 5;  \/\/ according to http:\/\/half.sourceforge.net\/structstd_1_1numeric__limits_3_01half__float_1_1half_01_4.html$/;"	m	struct:std::numeric_limits
max_digits10	unsupported/test/mpreal/mpreal.h	/^        inline static int max_digits10(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits
max_digits10	unsupported/test/mpreal/mpreal.h	/^        static const int max_digits10 = 16;$/;"	m	class:std::numeric_limits
max_exponent	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int max_exponent = 16;$/;"	m	struct:std::numeric_limits
max_exponent	unsupported/test/mpreal/mpreal.h	/^        static const int max_exponent = MPFR_EMAX_DEFAULT;$/;"	m	class:std::numeric_limits
max_exponent10	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int max_exponent10 = 4;$/;"	m	struct:std::numeric_limits
max_exponent10	unsupported/test/mpreal/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int max_exponent10 = (int) (MPFR_EMAX_DEFAULT * 0.3010299956639811);$/;"	m	class:std::numeric_limits
max_feasible_subset_size	bench/analyze-blocking-sizes.cpp	/^size_t max_feasible_subset_size(size_t n)$/;"	f
max_iter	demos/mandelbrot/mandelbrot.h	/^    int id, max_iter;$/;"	m	class:MandelbrotThread
max_m	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index max_m;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
max_n_1	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^template <> struct max_n_1<0> {$/;"	s	namespace:Eigen
max_n_1	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^template <size_t n> struct max_n_1 {$/;"	s	namespace:Eigen
max_size	Eigen/src/Core/Matrix.h	/^      max_size = is_dynamic_size_storage ? Dynamic : _MaxRows*_MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon438
max_static_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t max_static_elements = 16;$/;"	m	struct:Eigen::internal::tensor_symmetry_pre_analysis
max_static_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t max_static_generators = 4;$/;"	m	struct:Eigen::internal::tensor_symmetry_pre_analysis
maxfev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index maxfev() const {return m_maxfev; }$/;"	f	class:Eigen::LevenbergMarquardt
maxfev	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index maxfev;   \/\/ maximum number of function evaluation$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
maxfev	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Index maxfev;   \/\/ maximum number of function evaluation$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
maxi	Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)$/;"	f	namespace:Eigen::numext
maximum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    maximum() const {$/;"	f	class:Eigen::TensorBase
maximum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    maximum(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
maxsize	bench/benchmark-blocking-sizes.cpp	/^const size_t maxsize = 2048;$/;"	v
maxsuper	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index maxsuper; \/\/ The maximum size for a supernode in complete LU$/;"	m	struct:Eigen::internal::perfvalues
maxval	unsupported/test/mpreal/mpreal.h	/^inline mpreal maxval(mp_prec_t prec)$/;"	f	namespace:mpfr
mc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking
mc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Index mc() const { return mc_; }$/;"	f	class:Eigen::internal::TensorContractionBlocking
mc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index mc;$/;"	m	struct:Eigen::internal::packLhsArg
mc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index mc;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
mc_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  Index mc_;$/;"	m	class:Eigen::internal::TensorContractionBlocking
mconcat	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename b, typename... cs> struct mconcat<a, b, cs...> : concat<a, typename mconcat<b, cs...>::type> {};$/;"	s	namespace:Eigen::internal
mconcat	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename b>                 struct mconcat<a, b>        : concat<a, b> {};$/;"	s	namespace:Eigen::internal
mconcat	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a>                             struct mconcat<a>           { typedef a type; };$/;"	s	namespace:Eigen::internal
md	doc/snippets/MatrixBase_cast.cpp	/^Matrix2d md = Matrix2d::Identity() * 0.45;$/;"	v
mean	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase
mean	Eigen/src/Core/VectorwiseOp.h	/^    const MeanReturnType mean() const$/;"	f	class:Eigen::VectorwiseOp
mean	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    mean() const {$/;"	f	class:Eigen::TensorBase
mean	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    mean(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
mean_calc	bench/btl/data/mean.cxx	/^double mean_calc(const vector<int> & tab_sizes, const vector<double> & tab_mflops, const int size_min, const int size_max){$/;"	f
measurement_repetitions	bench/benchmark-blocking-sizes.cpp	/^const int measurement_repetitions = 3;$/;"	v
memInit	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,StorageIndex>::memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
memXpand	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,StorageIndex>::memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)$/;"	f	class:Eigen::internal::SparseLUImpl
mem_expand	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  void mem_expand(IndexVector& lsub, Index& nextl, Index chmark)$/;"	f	struct:Eigen::internal::column_dfs_traits
mem_expand	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  void mem_expand(IndexVector& \/*glu.lsub*\/, Index \/*nextl*\/, Index \/*chmark*\/) {}$/;"	f	struct:Eigen::internal::panel_dfs_traits
member_lpnorm	Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC member_lpnorm() {}$/;"	f	struct:Eigen::internal::member_lpnorm
member_lpnorm	Eigen/src/Core/VectorwiseOp.h	/^struct member_lpnorm {$/;"	s	namespace:Eigen::internal
member_redux	Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC explicit member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux
member_redux	Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
memcpy	bench/tensors/tensor_benchmarks.h	/^  void memcpy(int num_iters) {$/;"	f	class:BenchmarkSuite
memcpy	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpy(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::GpuDevice
memcpy	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpy(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::DefaultDevice
memcpy	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpy(void *dst, const void *src, size_t n) const {$/;"	f	struct:Eigen::SyclDevice
memcpy	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void memcpy(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::ThreadPoolDevice
memcpyDeviceToHost	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE void memcpyDeviceToHost(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::GpuDevice
memcpyDeviceToHost	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpyDeviceToHost(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::DefaultDevice
memcpyDeviceToHost	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template<typename T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpyDeviceToHost(T *dst, const T *src, size_t n) const {$/;"	f	struct:Eigen::SyclDevice
memcpyDeviceToHost	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void memcpyDeviceToHost(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::ThreadPoolDevice
memcpyHostToDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE void memcpyHostToDevice(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::GpuDevice
memcpyHostToDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpyHostToDevice(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::DefaultDevice
memcpyHostToDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  template<typename T> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memcpyHostToDevice(T *dst, const T *src, size_t n) const {$/;"	f	struct:Eigen::SyclDevice
memcpyHostToDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void memcpyHostToDevice(void* dst, const void* src, size_t n) const {$/;"	f	struct:Eigen::ThreadPoolDevice
memoryleak	test/exceptions.cpp	/^void memoryleak()$/;"	f
memset	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memset(void* buffer, int c, size_t n) const {$/;"	f	struct:Eigen::GpuDevice
memset	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memset(void* buffer, int c, size_t n) const {$/;"	f	struct:Eigen::DefaultDevice
memset	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void memset(void *buffer, int c, size_t n) const {$/;"	f	struct:Eigen::SyclDevice
memset	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE void memset(void* buffer, int c, size_t n) const {$/;"	f	struct:Eigen::ThreadPoolDevice
merge	bench/perf_monitoring/gemm/run.sh	/^function merge$/;"	f
merged	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
meta_floor_log2	Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2 {};$/;"	s	namespace:Eigen::internal
meta_floor_log2	Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_bogus>$/;"	s	namespace:Eigen::internal
meta_floor_log2	Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_down>$/;"	s	namespace:Eigen::internal
meta_floor_log2	Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_move_up>$/;"	s	namespace:Eigen::internal
meta_floor_log2	Eigen/src/Core/MathFunctions.h	/^struct meta_floor_log2<n, lower, upper, meta_floor_log2_terminate>$/;"	s	namespace:Eigen::internal
meta_floor_log2_bogus	Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon317
meta_floor_log2_move_down	Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon317
meta_floor_log2_move_up	Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon317
meta_floor_log2_selector	Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct meta_floor_log2_selector$/;"	s	namespace:Eigen::internal
meta_floor_log2_terminate	Eigen/src/Core/MathFunctions.h	/^  meta_floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon317
meta_least_common_multiple	Eigen/src/Core/util/Meta.h	/^struct meta_least_common_multiple$/;"	s	namespace:Eigen
meta_least_common_multiple	Eigen/src/Core/util/Meta.h	/^struct meta_least_common_multiple<A,B,K,true>$/;"	s	namespace:Eigen
meta_no	Eigen/src/Core/util/Meta.h	/^struct meta_no  { char a[2]; };$/;"	s	namespace:Eigen::internal
meta_sqrt	Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
meta_yes	Eigen/src/Core/util/Meta.h	/^struct meta_yes { char a[1]; };$/;"	s	namespace:Eigen::internal
mf	doc/snippets/MatrixBase_cast.cpp	/^Matrix2f mf = Matrix2f::Identity();$/;"	v
middle	Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::meta_floor_log2_selector::__anon318
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N) const$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N)$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index n) const$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index n)$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N) const$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N)$/;"	f
min	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half (min)() { return Eigen::half_impl::raw_uint16_to_half(0x400); }$/;"	f	class:std::numeric_limits::Eigen
min	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (min)(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
min	Eigen/src/Core/util/Meta.h	/^  static T (min)() { assert(false && "Lowest not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static double (min)() { return DBL_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static float (min)() { return FLT_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static int (min)() { return INT_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static long (min)() { return LONG_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static long long (min)() { return LLONG_MIN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static unsigned int (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static unsigned long (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Core/util/Meta.h	/^  static unsigned long long (min)() { return 0; }$/;"	f	struct:Eigen::internal::device::numeric_limits
min	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^min$/;"	f
min	blas/f2c/datatypes.h	19;"	d
min	test/boostmultiprec.cpp	60;"	d	file:
min	test/main.h	70;"	d
min	test/sparse.h	20;"	d
min	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (min)(const AutoDiffScalar<DerType>& x, const AutoDiffScalar<DerType>& y) {$/;"	f	namespace:Eigen
min	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (min)(const AutoDiffScalar<DerType>& x, const T& y) {$/;"	f	namespace:Eigen
min	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<typename Eigen::internal::remove_all<DerType>::type::PlainObject> (min)(const T& x, const AutoDiffScalar<DerType>& y) {$/;"	f	namespace:Eigen
min	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal (min)    (mp_prec_t precision = mpfr::mpreal::get_default_prec()) {  return  mpfr::minval(precision);  }$/;"	f	class:std::numeric_limits::mpfr
min	unsupported/test/mpreal/mpreal.h	/^inline const mpreal (min)(const mpreal& x, const mpreal& y){    return (x<y?x:y);       }$/;"	f	namespace:mpfr
minCoeff	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase
minCoeff	Eigen/src/Core/VectorwiseOp.h	/^    const MinCoeffReturnType minCoeff() const$/;"	f	class:Eigen::VectorwiseOp
minCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
minCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* rowId, IndexType* colId) const$/;"	f	class:Eigen::DenseBase
minOfM	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  float minOfM = m.minCoeff(&i,&j);$/;"	v
min_accurate_time	bench/benchmark-blocking-sizes.cpp	/^const float min_accurate_time = 1e-2f;$/;"	v
min_coeff_visitor	Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
min_exponent	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int min_exponent = -13;$/;"	m	struct:std::numeric_limits
min_exponent	unsupported/test/mpreal/mpreal.h	/^        static const int min_exponent = MPFR_EMIN_DEFAULT;$/;"	m	class:std::numeric_limits
min_exponent10	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int min_exponent10 = -4;$/;"	m	struct:std::numeric_limits
min_exponent10	unsupported/test/mpreal/mpreal.h	/^        MPREAL_PERMISSIVE_EXPR static const int min_exponent10 = (int) (MPFR_EMIN_DEFAULT * 0.3010299956639811);$/;"	m	class:std::numeric_limits
min_max	test/array.cpp	/^template<typename ArrayType> void min_max(const ArrayType& m)$/;"	f
min_working_set_size	bench/benchmark-blocking-sizes.cpp	/^size_t min_working_set_size = 0;$/;"	v
mini	Eigen/src/Core/MathFunctions.h	/^EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)$/;"	f	namespace:Eigen::numext
minimize	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType>::minimize(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimize	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimize(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeInit	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType>::minimizeInit(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeInit	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeInit(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOneStep	unsupported/Eigen/src/LevenbergMarquardt/LMonestep.h	/^LevenbergMarquardt<FunctorType>::minimizeOneStep(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOneStep	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOneStep(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorage	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorage(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorageInit	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageInit(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorageOneStep	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageOneStep(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimize_helper	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar minimize_helper(const BVH &tree, Minimizer &minimizer, typename BVH::Index root, typename Minimizer::Scalar minimum)$/;"	f	namespace:Eigen::internal
minimizer	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Minimizer &minimizer;$/;"	m	struct:Eigen::internal::minimizer_helper1
minimizer	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Minimizer &minimizer;$/;"	m	struct:Eigen::internal::minimizer_helper2
minimizer_helper1	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  minimizer_helper1(const Object2 &inStored, Minimizer &m) : stored(inStored), minimizer(m) {}$/;"	f	struct:Eigen::internal::minimizer_helper1
minimizer_helper1	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct minimizer_helper1$/;"	s	namespace:Eigen::internal
minimizer_helper2	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  minimizer_helper2(const Object1 &inStored, Minimizer &m) : stored(inStored), minimizer(m) {}$/;"	f	struct:Eigen::internal::minimizer_helper2
minimizer_helper2	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct minimizer_helper2$/;"	s	namespace:Eigen::internal
minimum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    minimum() const {$/;"	f	class:Eigen::TensorBase
minimum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    minimum(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
minimumOnObject	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnObject(const Object1 &obj) { return minimizer.minimumOnObjectObject(obj, stored); }$/;"	f	struct:Eigen::internal::minimizer_helper1
minimumOnObject	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnObject(const Object2 &obj) { return minimizer.minimumOnObjectObject(stored, obj); }$/;"	f	struct:Eigen::internal::minimizer_helper2
minimumOnObject	unsupported/test/BVH.cpp	/^  double minimumOnObject(const BallType &b) { ++calls; return (std::max)(0., (b.center - p).squaredNorm() - SQR(b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectObject	unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnObjectObject(const Vector2d &v1, const Vector2d &v2) { ++calls; return (v1 - v2).squaredNorm(); }$/;"	f	struct:PointPointMinimizer
minimumOnObjectObject	unsupported/test/BVH.cpp	/^  double minimumOnObjectObject(const BallType &b, const VectorType &v){ ++calls; return SQR((std::max)(0., (b.center - v).norm() - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectObject	unsupported/test/BVH.cpp	/^  double minimumOnObjectObject(const BallType &b1, const BallType &b2){ ++calls; return SQR((std::max)(0., (b1.center - b2.center).norm() - b1.radius - b2.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectVolume	unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnObjectVolume(const Vector2d &v, const Box2d &r) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:PointPointMinimizer
minimumOnObjectVolume	unsupported/test/BVH.cpp	/^  double minimumOnObjectVolume(const BallType &b, const BoxType &r) { ++calls; return SQR((std::max)(0., r.exteriorDistance(b.center) - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnVolume	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnVolume(const Volume1 &vol) { return minimizer.minimumOnVolumeObject(vol, stored); }$/;"	f	struct:Eigen::internal::minimizer_helper1
minimumOnVolume	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnVolume(const Volume2 &vol) { return minimizer.minimumOnObjectVolume(stored, vol); }$/;"	f	struct:Eigen::internal::minimizer_helper2
minimumOnVolume	unsupported/test/BVH.cpp	/^  double minimumOnVolume(const BoxType &r) { ++calls; return r.squaredExteriorDistance(p); }$/;"	f	struct:BallPointStuff
minimumOnVolumeObject	unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnVolumeObject(const Box2d &r, const Vector2d &v) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:PointPointMinimizer
minimumOnVolumeObject	unsupported/test/BVH.cpp	/^  double minimumOnVolumeObject(const BoxType &r, const BallType &b) { ++calls; return SQR((std::max)(0., r.exteriorDistance(b.center) - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnVolumeObject	unsupported/test/BVH.cpp	/^  double minimumOnVolumeObject(const BoxType &r, const VectorType &v) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:BallPointStuff
minimumOnVolumeVolume	unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnVolumeVolume(const Box2d &r1, const Box2d &r2) { ++calls; return r1.squaredExteriorDistance(r2); }$/;"	f	struct:PointPointMinimizer
minimumOnVolumeVolume	unsupported/test/BVH.cpp	/^  double minimumOnVolumeVolume(const BoxType &r1, const BoxType &r2) { ++calls; return r1.squaredExteriorDistance(r2); }$/;"	f	struct:BallPointStuff
minimum_degree_ordering	Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,StorageIndex>& C, PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm)$/;"	f	namespace:Eigen::internal
minorDeviceVersion	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int minorDeviceVersion() const {$/;"	f	struct:Eigen::GpuDevice
minres	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        void minres(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
minsize	bench/benchmark-blocking-sizes.cpp	/^const size_t minsize = 16;$/;"	v
minval	unsupported/test/mpreal/mpreal.h	/^inline mpreal minval(mp_prec_t prec)$/;"	f	namespace:mpfr
misc	scripts/eigen_gen_credits.cpp	/^  string misc;$/;"	m	struct:contributor	file:
miscMatrices	test/miscmatrices.cpp	/^template<typename MatrixType> void miscMatrices(const MatrixType& m)$/;"	f
misra1a_functor	unsupported/test/NonLinearOptimization.cpp	/^    misra1a_functor(void) : Functor<double>(2,14) {}$/;"	f	struct:misra1a_functor
misra1a_functor	unsupported/test/NonLinearOptimization.cpp	/^struct misra1a_functor : Functor<double>$/;"	s	file:
misra1a_functor	unsupported/test/levenberg_marquardt.cpp	/^    misra1a_functor(void) : DenseFunctor<double>(2,14) {}$/;"	f	struct:misra1a_functor
misra1a_functor	unsupported/test/levenberg_marquardt.cpp	/^struct misra1a_functor : DenseFunctor<double>$/;"	s	file:
misra1d_functor	unsupported/test/NonLinearOptimization.cpp	/^    misra1d_functor(void) : Functor<double>(2,14) {}$/;"	f	struct:misra1d_functor
misra1d_functor	unsupported/test/NonLinearOptimization.cpp	/^struct misra1d_functor : Functor<double>$/;"	s	file:
misra1d_functor	unsupported/test/levenberg_marquardt.cpp	/^    misra1d_functor(void) : DenseFunctor<double>(2,14) {}$/;"	f	struct:misra1d_functor
misra1d_functor	unsupported/test/levenberg_marquardt.cpp	/^struct misra1d_functor : DenseFunctor<double>$/;"	s	file:
mixingtypes	test/mixingtypes.cpp	/^template<int SizeAtCompileType> void mixingtypes(int size = SizeAtCompileType)$/;"	f
mmtr	test/product_mmtr.cpp	/^template<typename Scalar> void mmtr(int size)$/;"	f
mod	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
model	test/denseLM.cpp	/^  VectorType model(const VectorType& uv, VectorType& x)$/;"	f	struct:DenseLM
model	test/sparseLM.cpp	/^  VectorType model(const VectorType& uv, VectorType& x)$/;"	f	struct:sparseGaussianTest
modf	unsupported/test/mpreal/mpreal.h	/^inline const mpreal modf(const mpreal& v, mpreal& n)$/;"	f	namespace:mpfr
mouseMoveEvent	demos/mandelbrot/mandelbrot.cpp	/^void MandelbrotWidget::mouseMoveEvent(QMouseEvent *event)$/;"	f	class:MandelbrotWidget
mouseMoveEvent	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::mouseMoveEvent(QMouseEvent* e)$/;"	f	class:RenderingWidget
mousePressEvent	demos/mandelbrot/mandelbrot.cpp	/^void MandelbrotWidget::mousePressEvent(QMouseEvent *event)$/;"	f	class:MandelbrotWidget
mousePressEvent	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::mousePressEvent(QMouseEvent* e)$/;"	f	class:RenderingWidget
mouseReleaseEvent	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::mouseReleaseEvent(QMouseEvent*)$/;"	f	class:RenderingWidget
move	Eigen/src/Core/DenseStorage.h	/^      , m_cols(std::move(other.m_cols))$/;"	f	class:Eigen::DenseStorage
move	Eigen/src/Core/DenseStorage.h	/^      , m_rows(std::move(other.m_rows))$/;"	f	class:Eigen::DenseStorage
move	Eigen/src/Core/PlainObjectBase.h	/^      : m_storage( std::move(other.m_storage) )$/;"	f	class:Eigen::PlainObjectBase
mp	unsupported/test/mpreal/mpreal.h	/^    mpfr_t mp;$/;"	m	class:mpfr::mpreal
mpCamera	demos/opengl/trackball.h	/^    Camera* mpCamera;$/;"	m	class:Trackball
mp_mat	doc/examples/matrixfree_cg.cpp	/^  const SparseMatrix<double> *mp_mat;$/;"	m	class:MatrixReplacement	file:
mp_matrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const ActualMatrixType *mp_matrix;$/;"	m	class:Eigen::internal::generic_matrix_wrapper
mp_matrix	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixRef mp_matrix;$/;"	m	class:Eigen::UmfPackLU
mp_target	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    SparseMatrixType* mp_target;$/;"	m	class:Eigen::RandomSetter
mpfr	unsupported/test/mpreal/mpreal.h	/^namespace mpfr {$/;"	n
mpfr_is_initialized	unsupported/test/mpreal/mpreal.h	96;"	d
mpfr_ptr	unsupported/test/mpreal/mpreal.h	/^inline ::mpfr_ptr     mpreal::mpfr_ptr()             { return mp; }$/;"	f	class:mpfr::mpreal
mpfr_ptr	unsupported/test/mpreal/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_ptr()    const    { return mp; }$/;"	f	class:mpfr::mpreal
mpfr_set_uninitialized	unsupported/test/mpreal/mpreal.h	97;"	d
mpfr_set_zero_fast	unsupported/test/mpreal/mpreal.h	132;"	d
mpfr_srcptr	unsupported/test/mpreal/mpreal.h	/^inline ::mpfr_srcptr  mpreal::mpfr_srcptr() const    { return mp; }$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^class mpreal {$/;"	c	namespace:mpfr
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal()$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const char* s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const long double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const long long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const mpf_t u)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const mpfr_t  u, bool shared)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const mpq_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const mpreal& u)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const mpz_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const std::string& s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const unsigned int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const unsigned long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(const unsigned long long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::mpreal(mpreal&& other)$/;"	f	class:mpfr::mpreal
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = (EIGEN_PLAIN_ENUM_MIN(16,NumberOfRegisters)\/2\/nr)*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 3*LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = Vectorizable ? 3*LhsPacketSize : default_mr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
ms_from	Eigen/src/Core/util/Meta.h	/^  static From ms_from;$/;"	m	struct:Eigen::internal::is_convertible_impl
ms_from	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  static MatrixType ms_from;$/;"	m	struct:Eigen::internal::is_ref_compatible_impl
msvc_workaround	test/jacobisvd.cpp	/^void msvc_workaround()$/;"	f
mtl4_interface	bench/btl/libs/mtl4/mtl4_interface.hh	/^class mtl4_interface {$/;"	c
mu	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^    std::mutex mu;$/;"	m	class:Eigen::EventCount::Waiter
mu_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  std::mutex mu_;$/;"	m	class:Eigen::Barrier
mu_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  std::mutex mu_;$/;"	m	class:Eigen::SimpleThreadPoolTempl
mul	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline GroupElement mul(Generator g1, Generator g2) const$/;"	f	class:Eigen::DynamicSGroup
mul	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline GroupElement mul(Generator g1, GroupElement g2) const$/;"	f	class:Eigen::DynamicSGroup
mul	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline GroupElement mul(GroupElement g1, Generator g2) const$/;"	f	class:Eigen::DynamicSGroup
mul	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^inline DynamicSGroup::GroupElement DynamicSGroup::mul(GroupElement g1, GroupElement g2) const$/;"	f	class:Eigen::DynamicSGroup
mul_2si	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mul_2ui	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mul_assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^struct mul_assign_op {$/;"	s	namespace:Eigen::internal
multMatrix	demos/opengl/gpuhelper.h	/^    static void multMatrix(const Matrix<double,4,4, _Flags, 4,4>& mat) { glMultMatrixd(mat.data()); }$/;"	f	struct:GlMatrixHelper
multMatrix	demos/opengl/gpuhelper.h	/^    static void multMatrix(const Matrix<double,4,4, _Flags, 4,4>& mat) { glMultMatrixd(mat.transpose().eval().data()); }$/;"	f	struct:GlMatrixHelper
multMatrix	demos/opengl/gpuhelper.h	/^    static void multMatrix(const Matrix<float, 4,4, _Flags, 4,4>&  mat) { glMultMatrixf(mat.data()); }$/;"	f	struct:GlMatrixHelper
multMatrix	demos/opengl/gpuhelper.h	/^    static void multMatrix(const Matrix<float, 4,4, _Flags, 4,4>&  mat) { glMultMatrixf(mat.transpose().eval().data()); }$/;"	f	struct:GlMatrixHelper
multMatrix	demos/opengl/gpuhelper.h	/^void GpuHelper::multMatrix(const Matrix<Scalar,4,4, _Flags, 4,4>& mat, GLenum matrixTarget)$/;"	f	class:GpuHelper
multiplied_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename apply_op_from_right<Multiply, current_generator, elements>::type multiplied_elements;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_generator
multiplier	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  UnsignedType multiplier;$/;"	m	struct:Eigen::internal::TensorIntDivisor
multiply_assign_using_evaluator	test/evaluators.cpp	/^  void multiply_assign_using_evaluator(const DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen
multiprecision	test/boostmultiprec.cpp	/^namespace multiprecision {$/;"	n	namespace:boost	file:
muluh	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE uint32_t muluh(const uint32_t a, const T b) {$/;"	f	namespace:Eigen::internal::__anon139
muluh	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE uint64_t muluh(const uint64_t a, const T b) {$/;"	f	namespace:Eigen::internal::__anon139
mutex_	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  std::mutex mutex_;$/;"	m	class:Eigen::RunQueue
my_exception	test/exceptions.cpp	/^  my_exception() {}$/;"	f	struct:my_exception
my_exception	test/exceptions.cpp	/^struct my_exception$/;"	s	file:
my_functor	unsupported/test/NumericalDiff.cpp	/^    my_functor(void): Functor<double>(3,15) {}$/;"	f	struct:my_functor
my_functor	unsupported/test/NumericalDiff.cpp	/^struct my_functor : Functor<double>$/;"	s	file:
my_matrix	doc/examples/matrixfree_cg.cpp	/^  const SparseMatrix<double> my_matrix() const { return *mp_mat; }$/;"	f	class:MatrixReplacement
n	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   n; \/\/ Number of columns in the matrix  $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
n	bench/analyze-blocking-sizes.cpp	/^  uint16_t k, m, n;$/;"	m	struct:size_triple_t	file:
n	doc/snippets/BiCGSTAB_simple.cpp	/^  int n = 10000;$/;"	v
n	doc/snippets/BiCGSTAB_step_by_step.cpp	/^  int n = 10000;$/;"	v
n	doc/snippets/Triangular_solve.cpp	/^     << m.triangularView<Eigen::Upper>().solve<Eigen::OnTheRight>(n);$/;"	v
n	doc/snippets/Triangular_solve.cpp	/^Matrix3d n = Matrix3d::Ones();$/;"	v
n	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index n;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
n	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index n;$/;"	m	class:Eigen::LevenbergMarquardt
n	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index n;$/;"	m	class:Eigen::HybridNonLinearSolver
n	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index n;$/;"	m	class:Eigen::LevenbergMarquardt
n32	bench/btl/generic_bench/timers/x86_timer.hh	/^    unsigned long int n32[2] ;$/;"	m	union:X86_Timer::__anon6
n32	bench/btl/generic_bench/timers/x86_timer.hh	/^    unsigned long int n32[2] ;$/;"	m	union:X86_Timer::__anon7
n64	bench/btl/generic_bench/timers/x86_timer.hh	/^    unsigned long long n64 ;$/;"	m	union:X86_Timer::__anon6
n64	bench/btl/generic_bench/timers/x86_timer.hh	/^    unsigned long long n64 ;$/;"	m	union:X86_Timer::__anon7
n_	bench/tensors/tensor_benchmarks.h	/^  TensorIndex n_;$/;"	m	class:BenchmarkSuite
n_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index n_;$/;"	m	class:Eigen::TensorEvaluator::Context
n_block_idx	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index n_block_idx;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
n_blocks	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index n_blocks;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
n_dims	doc/snippets/Tutorial_Map_using.cpp	/^const int n_dims = 5;$/;"	v
name	bench/btl/actions/action_aat_product.hh	/^  static inline std::string name( void )$/;"	f	class:Action_aat_product
name	bench/btl/actions/action_ata_product.hh	/^  static inline std::string name( void )$/;"	f	class:Action_ata_product
name	bench/btl/actions/action_atv_product.hh	/^  static inline std::string name() { return "atv_" + Interface::name(); }$/;"	f	class:Action_atv_product
name	bench/btl/actions/action_axpby.hh	/^  static inline std::string name( void )$/;"	f	class:Action_axpby
name	bench/btl/actions/action_axpy.hh	/^  static inline std::string name( void )$/;"	f	class:Action_axpy
name	bench/btl/actions/action_cholesky.hh	/^  static inline std::string name( void )$/;"	f	class:Action_cholesky
name	bench/btl/actions/action_ger.hh	/^  static inline std::string name( void )$/;"	f	class:Action_ger
name	bench/btl/actions/action_hessenberg.hh	/^  static inline std::string name( void ) { return "tridiagonalization_"+Interface::name(); }$/;"	f	class:Action_tridiagonalization
name	bench/btl/actions/action_hessenberg.hh	/^  static inline std::string name( void )$/;"	f	class:Action_hessenberg
name	bench/btl/actions/action_lu_decomp.hh	/^  static inline std::string name( void )$/;"	f	class:Action_lu_decomp
name	bench/btl/actions/action_lu_solve.hh	/^  static inline std::string name( void )$/;"	f	class:Action_lu_solve
name	bench/btl/actions/action_matrix_matrix_product.hh	/^  static inline std::string name( void )$/;"	f	class:Action_matrix_matrix_product
name	bench/btl/actions/action_matrix_matrix_product_bis.hh	/^  static inline std::string name( void )$/;"	f	class:Action_matrix_matrix_product_bis
name	bench/btl/actions/action_matrix_vector_product.hh	/^  static inline std::string name( void )$/;"	f	class:Action_matrix_vector_product
name	bench/btl/actions/action_partial_lu.hh	/^  static inline std::string name( void )$/;"	f	class:Action_partial_lu
name	bench/btl/actions/action_rot.hh	/^  static inline std::string name( void )$/;"	f	class:Action_rot
name	bench/btl/actions/action_symv.hh	/^  static inline std::string name( void )$/;"	f	class:Action_symv
name	bench/btl/actions/action_syr2.hh	/^  static inline std::string name( void )$/;"	f	class:Action_syr2
name	bench/btl/actions/action_trisolve.hh	/^  static inline std::string name( void )$/;"	f	class:Action_trisolve
name	bench/btl/actions/action_trisolve_matrix.hh	/^  static inline std::string name( void )$/;"	f	class:Action_trisolve_matrix
name	bench/btl/actions/action_trmm.hh	/^  static inline std::string name( void )$/;"	f	class:Action_trmm
name	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline std::string name()$/;"	f	class:blas_interface
name	bench/btl/libs/STL/STL_interface.hh	/^  static inline std::string name( void )$/;"	f	class:STL_interface
name	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline std::string name() { return "blaze"; }$/;"	f	class:blaze_interface
name	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline std::string name() { return "blitz"; }$/;"	f	class:blitz_interface
name	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline std::string name() { return "tiny_blitz"; }$/;"	f	class:tiny_blitz_interface
name	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline std::string name( void )$/;"	f	class:eigen2_interface
name	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline std::string name( void )$/;"	f	class:eigen3_interface
name	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline std::string name( void )$/;"	f	class:gmm_interface
name	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline std::string name() { return "mtl4"; }$/;"	f	class:mtl4_interface
name	bench/btl/libs/tensors/tensor_interface.hh	/^  static inline std::string name( void )$/;"	f	class:tensor_interface
name	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline std::string name() { return "tiny_tvmet"; }$/;"	f	class:tvmet_interface
name	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline std::string name( void ) { return "ublas"; }$/;"	f	class:ublas_interface
name	scripts/eigen_gen_credits.cpp	/^  string name;$/;"	m	struct:contributor	file:
name_	bench/tensors/benchmark.h	/^  const char* name_;$/;"	m	class:testing::Benchmark
nameof	bench/benchFFT.cpp	/^template <> string nameof<double>() {return "double";}$/;"	f
nameof	bench/benchFFT.cpp	/^template <> string nameof<float>() {return "float";}$/;"	f
nameof	bench/benchFFT.cpp	/^template <> string nameof<long double>() {return "long double";}$/;"	f
nbThreads	Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen
nb_load	test/unalignedcount.cpp	/^static int nb_load;$/;"	v	file:
nb_loadu	test/unalignedcount.cpp	/^static int nb_loadu;$/;"	v	file:
nb_of_subdiagonals	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index nb_of_subdiagonals;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
nb_of_superdiagonals	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index nb_of_superdiagonals;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
nb_op_base	bench/btl/actions/action_aat_product.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_aat_product
nb_op_base	bench/btl/actions/action_ata_product.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_ata_product
nb_op_base	bench/btl/actions/action_atv_product.hh	/^  double nb_op_base( void ) { return 2.0*_size*_size; }$/;"	f	class:Action_atv_product
nb_op_base	bench/btl/actions/action_axpby.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_axpby
nb_op_base	bench/btl/actions/action_axpy.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_axpy
nb_op_base	bench/btl/actions/action_cholesky.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_cholesky
nb_op_base	bench/btl/actions/action_ger.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_ger
nb_op_base	bench/btl/actions/action_hessenberg.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_hessenberg
nb_op_base	bench/btl/actions/action_hessenberg.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_tridiagonalization
nb_op_base	bench/btl/actions/action_lu_decomp.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_lu_decomp
nb_op_base	bench/btl/actions/action_lu_solve.hh	/^  static double nb_op_base(int size){$/;"	f	class:Action_lu_solve
nb_op_base	bench/btl/actions/action_matrix_matrix_product.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_matrix_matrix_product
nb_op_base	bench/btl/actions/action_matrix_matrix_product_bis.hh	/^  static double nb_op_base(int size){$/;"	f	class:Action_matrix_matrix_product_bis
nb_op_base	bench/btl/actions/action_matrix_vector_product.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_matrix_vector_product
nb_op_base	bench/btl/actions/action_partial_lu.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_partial_lu
nb_op_base	bench/btl/actions/action_rot.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_rot
nb_op_base	bench/btl/actions/action_symv.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_symv
nb_op_base	bench/btl/actions/action_syr2.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_syr2
nb_op_base	bench/btl/actions/action_trisolve.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_trisolve
nb_op_base	bench/btl/actions/action_trisolve_matrix.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_trisolve_matrix
nb_op_base	bench/btl/actions/action_trmm.hh	/^  double nb_op_base( void ){$/;"	f	class:Action_trmm
nb_store	test/unalignedcount.cpp	/^static int nb_store;$/;"	v	file:
nb_storeu	test/unalignedcount.cpp	/^static int nb_storeu;$/;"	v	file:
nb_temporaries	test/main.h	/^static long int nb_temporaries;$/;"	v
nb_temporaries	test/sparse_product.cpp	/^static long int nb_temporaries;$/;"	v	file:
nb_temporaries	test/sparse_ref.cpp	/^static long int nb_temporaries;$/;"	v	file:
nb_temporaries_on_assert	test/main.h	/^static long int nb_temporaries_on_assert = -1;$/;"	v
nb_transposed_copies	test/sparse_permutations.cpp	/^static long int nb_transposed_copies;$/;"	v	file:
nc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline Index nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking
nc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Index nc() const { return nc_; }$/;"	f	class:Eigen::internal::TensorContractionBlocking
nc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index nc;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
nc_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionBlocking.h	/^  Index nc_;$/;"	m	class:Eigen::internal::TensorContractionBlocking
ncfail	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index ncfail;$/;"	m	class:Eigen::HybridNonLinearSolver
ncsuc	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index ncsuc;$/;"	m	class:Eigen::HybridNonLinearSolver
need_to_pack	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const bool need_to_pack;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
negate	test/packetmath.cpp	/^template<typename T> T negate(const T& x) { return -x; }$/;"	f	namespace:Eigen::internal
negation_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct negation_op {$/;"	s	namespace:Eigen::internal
nentries	bench/sparse_randomsetter.cpp	/^static double nentries;$/;"	v	file:
nestByValue	Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase
nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct nested<TensorIndexTupleOp<XprType>, 1,$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct nested<TensorTupleReducerOp<ReduceOp, Dims, XprType>, 1,$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^struct nested<TensorAssignOp<LhsXprType, RhsXprType>, 1, typename eval<TensorAssignOp<LhsXprType, RhsXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct nested<TensorBroadcastingOp<Broadcast, XprType>, 1, typename eval<TensorBroadcastingOp<Broadcast, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct nested<TensorChippingOp<DimId, XprType>, 1, typename eval<TensorChippingOp<DimId, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^struct nested<TensorConcatenationOp<Axis, LhsXprType, RhsXprType>, 1, typename eval<TensorConcatenationOp<Axis, LhsXprType, RhsXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct nested<TensorContractionOp<Dimensions, LhsXprType, RhsXprType>, 1, typename eval<TensorContractionOp<Dimensions, LhsXprType, RhsXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct nested<TensorConversionOp<TargetType, XprType>, 1, typename eval<TensorConversionOp<TargetType, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct nested<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>, 1, typename eval<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct nested<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct nested<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^struct nested<TensorEvalToOp<XprType, MakePointer_>, 1, typename eval<TensorEvalToOp<XprType, MakePointer_> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct nested<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>, 1, typename eval<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct nested<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>, 1, typename eval<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct nested<TensorCwiseUnaryOp<UnaryOp, XprType>, 1, typename eval<TensorCwiseUnaryOp<UnaryOp, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct nested<TensorSelectOp<IfXprType, ThenXprType, ElseXprType>, 1, typename eval<TensorSelectOp<IfXprType, ThenXprType, ElseXprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^struct nested<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>, 1, typename eval<TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection> >::type> {$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^struct nested<TensorForcedEvalOp<XprType, MakePointer_>, 1, typename eval<TensorForcedEvalOp<XprType, MakePointer_> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^struct nested<TensorGeneratorOp<Generator, XprType>, 1, typename eval<TensorGeneratorOp<Generator, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^struct nested<TensorImagePatchOp<Rows, Cols, XprType>, 1, typename eval<TensorImagePatchOp<Rows, Cols, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^struct nested<TensorInflationOp<Strides, XprType>, 1, typename eval<TensorInflationOp<Strides, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^struct nested<TensorLayoutSwapOp<XprType>, 1, typename eval<TensorLayoutSwapOp<XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct nested<TensorReshapingOp<NewDimensions, XprType>, 1, typename eval<TensorReshapingOp<NewDimensions, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct nested<TensorSlicingOp<StartIndices, Sizes, XprType>, 1, typename eval<TensorSlicingOp<StartIndices, Sizes, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct nested<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>, 1, typename eval<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^struct nested<TensorPaddingOp<PaddingDimensions, XprType>, 1, typename eval<TensorPaddingOp<PaddingDimensions, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^struct nested<TensorPatchOp<PatchDim, XprType>, 1, typename eval<TensorPatchOp<PatchDim, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct nested<TensorReductionOp<Op, Dims, XprType, MakePointer_>, 1, typename eval<TensorReductionOp<Op, Dims, XprType, MakePointer_> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^struct nested<TensorReverseOp<ReverseDimensions, XprType>, 1,$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct nested<TensorScanOp<Op, XprType>, 1,$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^struct nested<TensorShufflingOp<Shuffle, XprType>, 1, typename eval<TensorShufflingOp<Shuffle, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^struct nested<TensorStridingOp<Strides, XprType>, 1, typename eval<TensorStridingOp<Strides, XprType> >::type>$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<TensorFixedSize<Scalar_, Dimensions, Options, IndexType_> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<TensorMap<PlainObjectType, Options, MakePointer> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<TensorRef<PlainObjectType> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<const Tensor<Scalar_, NumIndices_, Options_, IndexType_> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<const TensorMap<PlainObjectType, Options, MakePointer> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct nested<const TensorRef<PlainObjectType> >$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^template<typename T, int n=1, typename PlainObject = void> struct nested$/;"	s	namespace:Eigen::internal
nested	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^struct nested<TensorVolumePatchOp<Planes, Rows, Cols, XprType>, 1, typename eval<TensorVolumePatchOp<Planes, Rows, Cols, XprType> >::type>$/;"	s	namespace:Eigen::internal
nestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper
nestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper
nestedExpression	Eigen/src/Core/Block.h	/^    XprType& nestedExpression() { return m_xpr; }$/;"	f	class:Eigen::internal::BlockImpl_dense
nestedExpression	Eigen/src/Core/Block.h	/^    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const$/;"	f	class:Eigen::internal::BlockImpl_dense
nestedExpression	Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	Eigen/src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal
nestedExpression	Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC const XprTypeNestedCleaned& nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::Inverse
nestedExpression	Eigen/src/Core/Redux.h	/^  const XprType & nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::internal::redux_evaluator
nestedExpression	Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate
nestedExpression	Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse
nestedExpression	Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	Eigen/src/Core/Transpositions.h	/^    const TranspositionType& nestedExpression() const { return m_transpositions; }$/;"	f	class:Eigen::Transpose
nestedExpression	Eigen/src/Core/TriangularMatrix.h	/^    NestedExpression& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	Eigen/src/Core/TriangularMatrix.h	/^    const NestedExpression& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	Eigen/src/Core/VectorwiseOp.h	/^    typename MatrixType::Nested nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::PartialReduxExpr
nestedExpression	Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC const NestedExpression& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Homogeneous
nestedExpression	Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseMatrixType& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
nestedExpression	Eigen/src/SparseCore/SparseBlock.h	/^    inline XprType& nestedExpression() { return m_matrix; }$/;"	f	class:Eigen::BlockImpl
nestedExpression	Eigen/src/SparseCore/SparseBlock.h	/^    inline const SparseMatrixType& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
nestedExpression	Eigen/src/SparseCore/SparseBlock.h	/^    inline const XprType& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::BlockImpl
nestedExpression	Eigen/src/SparseCore/SparseView.h	/^  nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseView
nestedExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::TensorCwiseNullaryOp
nestedExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::TensorCwiseUnaryOp
nested_eval	Eigen/src/Core/ReturnByValue.h	/^struct nested_eval<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
new_Pivot_Vector	bench/btl/libs/blitz/blitz_LU_solve_interface.hh	/^  inline static void new_Pivot_Vector(Pivot_Vector & pivot,int N)$/;"	f	class:blitz_LU_solve_interface
new_Pivot_Vector	bench/btl/libs/gmm/gmm_LU_solve_interface.hh	/^  inline static void new_Pivot_Vector(Pivot_Vector & pivot,int N)$/;"	f	class:blitz_LU_solve_interface
new_Pivot_Vector	bench/btl/libs/mtl4/mtl4_LU_solve_interface.hh	/^  inline static void new_Pivot_Vector(Pivot_Vector & pivot,int N)$/;"	f	class:blitz_LU_solve_interface
new_coset_rep	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename Multiply<rep_element, g>::type new_coset_rep;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
new_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _ac4r::type new_elements;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
new_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _helper::type new_elements;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
new_elements	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename concat<elements, multiplied_elements>::type new_elements;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_generator
new_rep_pos	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int new_rep_pos = rep_pos + sub_group_elements::count;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
new_stop_condition	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static bool new_stop_condition = new_rep_pos >= new_elements::count;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
next	Eigen/src/SparseCore/AmbiVector.h	/^      StorageIndex next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
next	debug/gdb/printers.py	/^		def next(self):$/;"	m	class:EigenMatrixPrinter._iterator
next	debug/gdb/printers.py	/^		def next(self):$/;"	m	class:EigenQuaternionPrinter._iterator
next	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^    EIGEN_ALIGN_TO_BOUNDARY(128) std::atomic<Waiter*> next;$/;"	m	class:Eigen::EventCount::Waiter
next_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename skip<1, generators>::type next_generators;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements
next_generators	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename skip<1, remaining_generators>::type next_generators;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
next_subset	bench/analyze-blocking-sizes.cpp	/^void next_subset(vector<size_t>& inout_subset, size_t set_size)$/;"	f
nextabove	unsupported/test/mpreal/mpreal.h	/^inline const mpreal nextabove  (const mpreal& x)$/;"	f	namespace:mpfr
nextbelow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal nextbelow  (const mpreal& x)$/;"	f	namespace:mpfr
nexttoward	unsupported/test/mpreal/mpreal.h	/^inline const mpreal nexttoward (const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
nfev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index nfev() { return m_nfev; }$/;"	f	class:Eigen::LevenbergMarquardt
nfev	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nfev;$/;"	m	class:Eigen::HybridNonLinearSolver
nfev	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index nfev;$/;"	m	class:Eigen::LevenbergMarquardt
njev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    Index njev() { return m_njev; }$/;"	f	class:Eigen::LevenbergMarquardt
njev	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index njev;$/;"	m	class:Eigen::HybridNonLinearSolver
njev	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index njev;$/;"	m	class:Eigen::LevenbergMarquardt
nk_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index nk_;$/;"	m	class:Eigen::TensorEvaluator::Context
nlerp	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q nlerp(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
nm0_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index nm0_;$/;"	m	class:Eigen::TensorEvaluator::Context
nm_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index nm_;$/;"	m	class:Eigen::TensorEvaluator::Context
nn0_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index nn0_;$/;"	m	class:Eigen::TensorEvaluator::Context
nn_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const Index nn_;$/;"	m	class:Eigen::TensorEvaluator::Context
nnz	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon865::__anon866
no	Eigen/src/Core/util/Meta.h	/^  struct no  {int a[2];};$/;"	s	struct:Eigen::internal::is_convertible_impl
no	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct no  {int a[2];};$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
no	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    typedef char (&no)[2];$/;"	t	struct:Eigen::internal::is_base_of
no_assignment_operator	Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
no_more_assert	test/main.h	/^    static bool no_more_assert = false;$/;"	m	namespace:Eigen
noalias	Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase
node.expandToggle.onclick	doc/eigen_navtree_hacks.js	/^    node.expandToggle.href = "javascript:void(0)";$/;"	f
noiseLevel	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    int noiseLevel() const { return m_noise; }$/;"	f	class:Eigen::IterationController
nomalloc	test/nomalloc.cpp	/^template<typename MatrixType> void nomalloc(const MatrixType& m)$/;"	f
nonZeros	Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase
nonZeros	Eigen/src/SparseCore/AmbiVector.h	/^Index AmbiVector<_Scalar,_StorageIndex>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector
nonZeros	Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const { return Dynamic; }$/;"	f	class:Eigen::BlockImpl
nonZeros	Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::BlockImpl
nonZeros	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseCompressedBase
nonZeros	Eigen/src/SparseCore/SparseMap.h	/^    inline Index nonZeros() const { return m_zero_nnz[1]; }$/;"	f	class:Eigen::SparseMapBase
nonZeros	Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
nonZeros	Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return m_data.size(); }$/;"	f	class:Eigen::SparseVector
nonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index nonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
nonZeros	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index nonZeros() const {$/;"	f	class:Eigen::SkylineMatrixBase
nonZeros	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index nonZeros() const { return m_nonzeros; }$/;"	f	class:Eigen::BlockSparseMatrix
nonZeros	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Index nonZeros() const$/;"	f	class:Eigen::DynamicSparseMatrix
nonZeros	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Index nonZeros() const$/;"	f	class:Eigen::RandomSetter
nonZerosBlocks	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index nonZerosBlocks() const { return m_nonzerosblocks; }$/;"	f	class:Eigen::BlockSparseMatrix
nonZerosEstimate	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseCompressedBase.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::binary_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::sparse_conjunction_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  Index nonZerosEstimate() const { return m_sparseXprEval.nonZerosEstimate(); }$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  Index nonZerosEstimate() const { return m_sparseXprImpl.nonZerosEstimate(); }$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseTriangularView.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::unary_evaluator
nonZerosEstimate	Eigen/src/SparseCore/SparseVector.h	/^  inline Index nonZerosEstimate() const {$/;"	f	struct:Eigen::internal::evaluator
nonZerosEstimate	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  Index nonZerosEstimate() const { return m_matrix->nonZeros(); }$/;"	f	struct:Eigen::internal::evaluator
non_projective_only	test/geo_transformations.cpp	/^template<typename Scalar, int Mode, int Options> void non_projective_only()$/;"	f
noncopyable	Eigen/src/Core/util/Meta.h	/^  EIGEN_DEVICE_FUNC noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
noncopyable	Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
nonpot_block_size	bench/analyze-blocking-sizes.cpp	/^  size_triple_t nonpot_block_size;$/;"	m	struct:inputfile_entry_t	file:
nonunit	bench/bench_gemm.cpp	/^static char nonunit = 'N';$/;"	v	file:
nonunit	bench/btl/libs/BLAS/blas_interface.hh	/^static char nonunit = 'N';$/;"	v
nonzeroPivots	Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU
nonzeroPivots	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR
nonzeroPivots	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index nonzeroPivots() const { return m_cpqr.nonzeroPivots(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
nonzeroPivots	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR
nonzeroSingularValues	Eigen/src/SVD/SVDBase.h	/^  Index nonzeroSingularValues() const$/;"	f	class:Eigen::SVDBase
norm	Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase
norm	Eigen/src/Core/VectorwiseOp.h	/^    const NormReturnType norm() const$/;"	f	class:Eigen::VectorwiseOp
norm	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase
norm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase
norm1	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::numext
norm1_default_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_default_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
norm1_retval	Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
norm_diff	bench/btl/libs/STL/STL_interface.hh	/^  static inline real norm_diff(const stl_matrix & A, const stl_matrix & B)$/;"	f	class:STL_interface
norm_diff	bench/btl/libs/STL/STL_interface.hh	/^  static inline real norm_diff(const stl_vector & A, const stl_vector & B)$/;"	f	class:STL_interface
normal	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normalize	Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase
normalize	Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_DEVICE_FUNC void normalize() {$/;"	f	class:Eigen::VectorwiseOp
normalize	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase
normalized	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase
normalized	Eigen/src/Core/VectorwiseOp.h	/^    normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }$/;"	f	class:Eigen::VectorwiseOp
normalized	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase
not_equal_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct not_equal_op     { template<typename A, typename B> constexpr static inline auto run(A a, B b) -> decltype(a != b)  { return a != b;  } };$/;"	s	namespace:Eigen::internal
not_equal_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct not_equal_op {$/;"	s	namespace:Eigen::internal
not_equal_strict	Eigen/src/Core/util/Meta.h	/^bool not_equal_strict(const X& x,const Y& y) { return x != y; }$/;"	f	namespace:numext
not_equal_strict	Eigen/src/Core/util/Meta.h	/^bool not_equal_strict(const double& x,const double& y) { return std::not_equal_to<double>()(x,y); }$/;"	f	namespace:numext
not_equal_strict	Eigen/src/Core/util/Meta.h	/^bool not_equal_strict(const float& x,const float& y) { return std::not_equal_to<float>()(x,y); }$/;"	f	namespace:numext
not_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct not_op {$/;"	s	namespace:Eigen::internal
notified_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  bool notified_;$/;"	m	class:Eigen::Barrier
notrans	bench/bench_gemm.cpp	/^static char notrans = 'N';$/;"	v	file:
notrans	bench/btl/libs/BLAS/blas_interface.hh	/^static char notrans = 'N';$/;"	v
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon629
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon630
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon631
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon632
nr_etdfs	Eigen/src/SparseCore/SparseColEtree.h	/^void nr_etdfs (typename IndexVector::Scalar n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, typename IndexVector::Scalar postnum)$/;"	f	namespace:Eigen::internal
nrm2	blas/level1_real_impl.h	/^Scalar EIGEN_BLAS_FUNC(nrm2)(int *n, RealScalar *px, int *incx)$/;"	f
nrm2_	blas/level1_cplx_impl.h	/^RealScalar EIGEN_CAT(EIGEN_CAT(REAL_SCALAR_SUFFIX,SCALAR_SUFFIX),nrm2_)(int *n, RealScalar *px, int *incx)$/;"	f
nslow1	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nslow1, nslow2;$/;"	m	class:Eigen::HybridNonLinearSolver
nslow2	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nslow1, nslow2;$/;"	m	class:Eigen::HybridNonLinearSolver
nsuper	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index nsuper() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
null_function	bench/btl/generic_bench/init/init_function.hh	/^double null_function(int \/*index*\/)$/;"	f
null_function	bench/btl/generic_bench/init/init_function.hh	/^double null_function(int \/*index_i*\/, int \/*index_j*\/)$/;"	f
null_type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct null_type { };$/;"	s	namespace:Eigen::internal
nullaryExpr	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    nullaryExpr(const CustomNullaryOp& func) const {$/;"	f	class:Eigen::TensorBase
nullary_wrapper	Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper$/;"	s	namespace:Eigen::internal
nullary_wrapper	Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,false,false> {};$/;"	s	namespace:Eigen::internal
nullary_wrapper	Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,false,true>$/;"	s	namespace:Eigen::internal
nullary_wrapper	Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,false,true,false>$/;"	s	namespace:Eigen::internal
nullary_wrapper	Eigen/src/Core/CoreEvaluators.h	/^struct nullary_wrapper<Scalar,NullaryOp,true,false,false>$/;"	s	namespace:Eigen::internal
numThreads	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int numThreads($/;"	f	class:Eigen::TensorCostModel
numThreads	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE size_t numThreads() const {$/;"	f	struct:Eigen::GpuDevice
numThreads	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceDefault.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t numThreads() const {$/;"	f	struct:Eigen::DefaultDevice
numThreads	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  EIGEN_STRONG_INLINE int numThreads() const {$/;"	f	struct:Eigen::ThreadPoolDevice
num_blockAs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index num_blockAs;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
num_expansions	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   num_expansions; $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
num_threads	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const Index num_threads;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
num_threads_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const int num_threads_;$/;"	m	class:Eigen::TensorEvaluator::Context
num_threads_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  int num_threads_;$/;"	m	struct:Eigen::ThreadPoolDevice
number_of_subsets_limit	bench/analyze-blocking-sizes.cpp	/^const size_t number_of_subsets_limit = 100;$/;"	v
numeric_limits	Eigen/src/Core/arch/CUDA/Half.h	/^struct numeric_limits<Eigen::half> {$/;"	s	namespace:std
numeric_limits	Eigen/src/Core/arch/CUDA/Half.h	/^struct numeric_limits<const Eigen::half> : numeric_limits<Eigen::half> {};$/;"	s	namespace:std
numeric_limits	Eigen/src/Core/arch/CUDA/Half.h	/^struct numeric_limits<const volatile Eigen::half> : numeric_limits<Eigen::half> {};$/;"	s	namespace:std
numeric_limits	Eigen/src/Core/arch/CUDA/Half.h	/^struct numeric_limits<volatile Eigen::half> : numeric_limits<Eigen::half> {};$/;"	s	namespace:std
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<double>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<float>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<int>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<long long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned int>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned long long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<> struct numeric_limits<unsigned long>$/;"	s	namespace:Eigen::internal::device
numeric_limits	Eigen/src/Core/util/Meta.h	/^template<typename T> struct numeric_limits$/;"	s	namespace:Eigen::internal::device
numeric_limits	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^class numeric_limits<Eigen::AutoDiffScalar<T> >$/;"	c	namespace:std
numeric_limits	unsupported/test/mpreal/mpreal.h	/^    class numeric_limits<mpfr::mpreal>$/;"	c	namespace:std
numeric_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct numeric_list { constexpr static std::size_t count = sizeof...(nn); };$/;"	s	namespace:Eigen::internal
numeric_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct numeric_list<T, n, nn...> { constexpr static std::size_t count = sizeof...(nn) + 1; constexpr static T first_value = n; };$/;"	s	namespace:Eigen::internal
numext	Eigen/src/Core/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	Eigen/src/Core/arch/CUDA/Half.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	Eigen/src/Core/util/Meta.h	/^namespace numext {$/;"	n
numext	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^namespace numext {$/;"	n	namespace:Eigen
numext	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^namespace numext {$/;"	n	namespace:Eigen
nzlmax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlmax; \/\/ Current max size of lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzlumax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlumax; \/\/ Current max size of lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzumax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzumax; \/\/ Current max size of ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
o.node.getChildrenUL	doc/eigen_navtree_hacks.js	/^  o.node.childrenUL = document.createElement("ul");$/;"	f
object	bench/geometry.cpp	/^  T object;$/;"	m	struct:ToRotationMatrixWrapper	file:
object_count	test/ctorleak.cpp	/^  static Index object_count;$/;"	m	struct:Foo	file:
object_count	test/ctorleak.cpp	/^Index Foo::object_count = 0;$/;"	m	class:Foo	file:
object_limit	test/ctorleak.cpp	/^  static Index object_limit;$/;"	m	struct:Foo	file:
object_limit	test/ctorleak.cpp	/^Index Foo::object_limit = 0;$/;"	m	class:Foo	file:
objects	unsupported/Eigen/src/BVH/KdBVH.h	/^  ObjectList objects;$/;"	m	class:Eigen::KdBVH
offset	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	bench/btl/data/gnuplot_common_settings.hh	/^set x2label "" offset 0,0$/;"	v
offset	bench/btl/data/gnuplot_common_settings.hh	/^set xlabel "matrix size" offset 0,0$/;"	v
offset	bench/btl/data/gnuplot_common_settings.hh	/^set y2label "" offset 0,0$/;"	v
offset	bench/btl/data/gnuplot_common_settings.hh	/^set ylabel "MFLOPS" offset 0,0$/;"	v
offset	bench/btl/data/gnuplot_common_settings.hh	/^set zlabel "" offset 0,0$/;"	v
offset	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  const Index offset() const { return m_offset; }$/;"	f	class:Eigen::TensorChippingOp
offsetBuffer	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index offset) {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
offsetBuffer	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index offset) {$/;"	f	struct:Eigen::internal::CoeffLoader
offsetBuffer	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void offsetBuffer(typename Tensor::Index) {$/;"	f	struct:Eigen::internal::CoeffLoader
offset_	unsupported/test/cxx11_tensor_reduction.cpp	/^  const float offset_;$/;"	m	struct:UserReducer	file:
ok	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  inline bool ok() const {$/;"	f	struct:Eigen::GpuDevice
on_temporary_creation	test/main.h	/^inline void on_temporary_creation(long int size) {$/;"	f
on_temporary_creation	test/sparse_product.cpp	/^inline void on_temporary_creation() {$/;"	f
on_temporary_creation	test/sparse_ref.cpp	/^inline void on_temporary_creation() {$/;"	f
one	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      int one;$/;"	m	struct:Eigen::DynamicSGroup::Generator
ones	doc/snippets/ComplexEigenSolver_eigenvalues.cpp	/^MatrixXcf ones = MatrixXcf::Ones(3,3);$/;"	v
ones	doc/snippets/ComplexEigenSolver_eigenvectors.cpp	/^MatrixXcf ones = MatrixXcf::Ones(3,3);$/;"	v
ones	doc/snippets/EigenSolver_eigenvalues.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/EigenSolver_eigenvectors.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/MatrixBase_eigenvalues.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/MatrixBase_operatorNorm.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/SelfAdjointEigenSolver_eigenvalues.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/SelfAdjointEigenSolver_eigenvectors.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/SelfAdjointView_eigenvalues.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
ones	doc/snippets/SelfAdjointView_operatorNorm.cpp	/^MatrixXd ones = MatrixXd::Ones(3,3);$/;"	v
only_cubic_sizes	bench/analyze-blocking-sizes.cpp	/^bool only_cubic_sizes = false;$/;"	v
op	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const XprType& op() const {$/;"	f	struct:Eigen::TensorEvaluator
operator !	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^operator!() const$/;"	f
operator !=	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator !=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator != (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator !=	test/exceptions.cpp	/^    bool operator!=(const ScalarWithExceptions& other) const$/;"	f	class:ScalarWithExceptions
operator !=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator!=(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator !=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator!=(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator !=	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^bool operator!=(const Tuple<U, V>& x, const Tuple<U, V>& y) {$/;"	f	namespace:Eigen
operator !=	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^bool operator != (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator !=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator!=(const Scalar& a, const AutoDiffScalar& b) { return a != b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator!=(const Scalar& other) const  { return m_value != other; }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator!=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value != b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const double b            ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const int b               ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const long double b       ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const long int b          ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const mpreal& b           ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const unsigned int b      ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator !=	unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const unsigned long int b ){  return !(a == b);  }$/;"	f	namespace:mpfr
operator %	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator% (Scalar rhs) const {$/;"	f	class:Eigen::TensorBase
operator &&	Eigen/src/plugins/CommonCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator &&	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator&&(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator ()	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i) const { return op(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j) const { return op(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j) const {$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType i, IndexType j=0) const { return op(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar operator()(const NullaryOp& op, IndexType=0, IndexType=0) const { return op(); }$/;"	f	struct:Eigen::internal::nullary_wrapper
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/ProductEvaluators.h	/^    template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {$/;"	f	struct:Eigen::internal::generic_product_impl::adds
operator ()	Eigen/src/Core/ProductEvaluators.h	/^  struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::add
operator ()	Eigen/src/Core/ProductEvaluators.h	/^  struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::set
operator ()	Eigen/src/Core/ProductEvaluators.h	/^  struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	f	struct:Eigen::internal::generic_product_impl::sub
operator ()	Eigen/src/Core/Random.h	/^  inline const Scalar operator() () const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op
operator ()	Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
operator ()	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase
operator ()	Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC inline ResultType operator()(const XprType& mat) const$/;"	f	struct:Eigen::internal::member_lpnorm
operator ()	Eigen/src/Core/VectorwiseOp.h	/^  EIGEN_DEVICE_FUNC inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux
operator ()	Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor
operator ()	Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor
operator ()	Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	Eigen/src/Core/arch/CUDA/Complex.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<T> operator() (const std::complex<T>& a, const std::complex<T>& b) const {$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::size_t operator()(const Eigen::half& a) const {$/;"	f	struct:std::hash
operator ()	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Eigen::half operator() (const float& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Eigen::half operator() (const int& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float operator() (const Eigen::half& a) const {$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a ^ b; }$/;"	f	struct:Eigen::internal::scalar_boolean_xor_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return !(a<=b || b<=a);}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a!=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a<=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a<b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a==b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a>=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a>b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar &x, const Scalar &y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::maxi(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::mini(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const first_argument_type& a) const { return BinaryOp::operator()(a,m_value); }$/;"	f	struct:Eigen::internal::bind2nd_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const second_argument_type& b) const { return BinaryOp::operator()(m_value,b); }$/;"	f	struct:Eigen::internal::bind1st_op
operator ()	Eigen/src/Core/functors/BinaryFunctors.h	/^  inline result_type operator() (const Scalar& a, const Exponent& b) const { return numext::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_pow_op
operator ()	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() () const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op
operator ()	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op
operator ()	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const {$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType row, IndexType col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op
operator ()	Eigen/src/Core/functors/NullaryFunctors.h	/^  const Scalar operator() (IndexType i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a) const { return !a; }$/;"	f	struct:Eigen::internal::scalar_boolean_not_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::ceil(a); }$/;"	f	struct:Eigen::internal::scalar_ceil_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::floor(a); }$/;"	f	struct:Eigen::internal::scalar_floor_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::round(a); }$/;"	f	struct:Eigen::internal::scalar_round_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scal&, const result_type& a) const { return a; }$/;"	f	struct:Eigen::internal::abs_knowing_score
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using numext::arg; return arg(a); }$/;"	f	struct:Eigen::internal::scalar_arg_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a, const Score&) const { return numext::abs(a); }$/;"	f	struct:Eigen::internal::abs_knowing_score
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isfinite)(a); }$/;"	f	struct:Eigen::internal::scalar_isfinite_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isinf)(a); }$/;"	f	struct:Eigen::internal::scalar_isinf_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isnan)(a); }$/;"	f	struct:Eigen::internal::scalar_isnan_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return numext::cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD_MATH(log10) return log10(a); }$/;"	f	struct:Eigen::internal::scalar_log10_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(1)\/numext::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_rsqrt_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::atan(a); }$/;"	f	struct:Eigen::internal::scalar_atan_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::cosh(a); }$/;"	f	struct:Eigen::internal::scalar_cosh_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log1p(a); }$/;"	f	struct:Eigen::internal::scalar_log1p_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sinh(a); }$/;"	f	struct:Eigen::internal::scalar_sinh_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const$/;"	f	struct:Eigen::internal::scalar_sign_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::tanh(a); }$/;"	f	struct:Eigen::internal::scalar_tanh_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op
operator ()	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockA, const DataMapper& lhs, Index depth, Index rows, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_lhs
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockB, const DataMapper& rhs, Index depth, Index cols, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_rhs
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(const DataMapper& res, const LhsScalar* blockA, const RhsScalar* blockB,$/;"	f	class:Eigen::internal::gebp_kernel
operator ()	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor
operator ()	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* _res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha)$/;"	f	struct:Eigen::internal::tribb_kernel
operator ()	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs
operator ()	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {$/;"	f	class:Eigen::internal::blas_data_mapper
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar operator()(Index i) const {$/;"	f	class:Eigen::internal::BlasVectorMapper
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) const { return numext::conj(x); }$/;"	f	struct:Eigen::internal::conj_if
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
operator ()	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag
operator ()	Eigen/src/MetisSupport/MetisSupport.h	/^  void operator() (const MatrixType& A, PermutationType& matperm)$/;"	f	class:Eigen::MetisOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator() (const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::COLAMDOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& \/*mat*\/, PermutationType& perm)$/;"	f	class:Eigen::NaturalOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag
operator ()	Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
operator ()	blas/level1_cplx_impl.h	/^  inline RealScalar operator() (const Scalar& a) const { return numext::norm1(a); }$/;"	f	struct:scalar_norm1_op
operator ()	doc/examples/class_CwiseBinaryOp.cpp	/^  complex<Scalar> operator()(const Scalar& a, const Scalar& b) const { return complex<Scalar>(a,b); }$/;"	f	struct:MakeComplexOp
operator ()	doc/examples/class_CwiseUnaryOp.cpp	/^  const Scalar operator()(const Scalar& x) const { return x<m_inf ? m_inf : (x>m_sup ? m_sup : x); }$/;"	f	struct:CwiseClampOp
operator ()	doc/examples/make_circulant2.cpp	/^  const typename ArgType::Scalar& operator() (Index row, Index col) const {$/;"	f	class:circulant_functor
operator ()	doc/examples/nullary_indexing.cpp	/^  const typename ArgType::Scalar& operator() (Index row, Index col) const {$/;"	f	class:indexing_functor
operator ()	test/denseLM.cpp	/^  int operator()(const VectorType& uv, VectorType& fvec)$/;"	f	struct:DenseLM
operator ()	test/sparseLM.cpp	/^  int operator()(const VectorType& uv, VectorType& fvec)$/;"	f	struct:sparseGaussianTest
operator ()	test/sparse_solver.h	/^  bool operator()(Index, Index col, const Scalar&) const {$/;"	f	struct:prune_column
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator()()$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator()(CustomIndices& indices)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator()(Index index)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator()(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator()() const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator()(CustomIndices& indices) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator()(Index index) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator()(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    inline Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    inline const Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::Tensor
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar operator()(Index i) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar operator()(Index i, Index j) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE Scalar operator()(Index row) const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE Scalar operator()(Index row, Index col) const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int operator() (const int \/*kernelSize*\/) const {$/;"	f	struct:Eigen::GetKernelSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE int operator() (const int kernelSize) const {$/;"	f	struct:Eigen::GetKernelSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  T operator() (const T& val) const { return val; }$/;"	f	struct:Eigen::MakeComplex
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  std::complex<T> operator() (const T& val) const { return std::complex<T>(val, 0); }$/;"	f	struct:Eigen::MakeComplex
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  std::complex<T> operator() (const std::complex<T>& val) const { return val; }$/;"	f	struct:Eigen::MakeComplex
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  template <typename T> T operator() (const T& val) const { return val; }$/;"	f	struct:Eigen::PartOf
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  template <typename T> T operator() (const std::complex<T>& val) const { return val.imag(); }$/;"	f	struct:Eigen::PartOf
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  template <typename T> T operator() (const std::complex<T>& val) const { return val.real(); }$/;"	f	struct:Eigen::PartOf
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator()(Index firstIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()()$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index index)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()() const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index index) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::TensorFixedSize
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator()(const T& x) const {$/;"	f	struct:Eigen::internal::scalar_sigmoid_op
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC T operator()(const array<Index, NumDims>& coordinates) const {$/;"	f	class:Eigen::internal::GaussianGenerator
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a % m_divisor; }$/;"	f	struct:Eigen::internal::scalar_mod_op
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a, const Scalar& b) const { return a % b; }$/;"	f	struct:Eigen::internal::scalar_mod2_op
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  operator()(const Scalar& a, const Scalar& b) const {$/;"	f	struct:Eigen::internal::scalar_fmod_op
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()()$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index index)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(const array<Index, NumIndices>& indices)$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()() const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index firstIndex, Index secondIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i0, Index i1, Index i2, Index i3, Index i4) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index index) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(const array<Index, NumIndices>& indices) const$/;"	f	class:Eigen::TensorMap
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC bool operator ()(Index val) const { return val > 4*1024*1024; }$/;"	f	struct:Eigen::__anon91::MemcpyTriggerForSlicing
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC bool operator ()(Index val) const { return val > threshold_; }$/;"	f	struct:Eigen::__anon91::MemcpyTriggerForSlicing
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  T operator()(Index i) const {$/;"	f	class:Eigen::internal::NormalRandomGenerator
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  T operator()(Index i) const {$/;"	f	class:Eigen::internal::UniformRandomGenerator
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i0, Index i1, Index i2, Index i3)$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index firstIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index i0, Index i1) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index i0, Index i1, Index i2) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index i0, Index i1, Index i2, Index i3) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index i0, Index i1, Index i2, Index i3, Index i4) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE const Scalar operator()(Index index) const$/;"	f	class:Eigen::TensorRef
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  void operator()(Self& self, typename Self::CoeffReturnType *data) {$/;"	f	struct:Eigen::ScanLauncher
operator ()	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  void operator()(const Self& self, typename Self::CoeffReturnType* data) {$/;"	f	struct:Eigen::ScanLauncher
operator ()	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline internal::tensor_symmetry_value_setter<Tensor_, DynamicSGroup> operator()(Tensor_& tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices> const& indices) const$/;"	f	class:Eigen::DynamicSGroup
operator ()	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline internal::tensor_symmetry_value_setter<Tensor_, DynamicSGroup> operator()(Tensor_& tensor, typename Tensor_::Index firstIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::DynamicSGroup
operator ()	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    inline internal::tensor_symmetry_value_setter<Tensor_, StaticSGroup<Gen...>> operator()(Tensor_& tensor, std::array<typename Tensor_::Index, Tensor_::NumIndices> const& indices) const$/;"	f	class:Eigen::StaticSGroup
operator ()	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    inline internal::tensor_symmetry_value_setter<Tensor_, StaticSGroup<Gen...>> operator()(Tensor_& tensor, typename Tensor_::Index firstIndex, IndexTypes... otherIndices) const$/;"	f	class:Eigen::StaticSGroup
operator ()	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  void operator() (const InputType& x, ValueType* v) const$/;"	f	class:Eigen::AutoDiffJacobian
operator ()	unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _jac,$/;"	f	class:Eigen::AutoDiffJacobian
operator ()	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType operator() (Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator ()	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType operator() (Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator ()	unsupported/Eigen/src/BVH/KdBVH.h	/^    inline bool operator()(const VIPair &v1, const VIPair &v2) const { return v1.first[dim] < v2.first[dim]; }$/;"	f	struct:Eigen::KdBVH::VectorComparator
operator ()	unsupported/Eigen/src/BVH/KdBVH.h	/^  void operator()(const ObjectList &objects, BoxIter boxBegin, BoxIter boxEnd, VolumeList &outBoxes)$/;"	f	struct:Eigen::internal::get_boxes_helper
operator ()	unsupported/Eigen/src/BVH/KdBVH.h	/^  void operator()(const ObjectList &objects, int, int, VolumeList &outBoxes)$/;"	f	struct:Eigen::internal::get_boxes_helper
operator ()	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  inline const ComplexScalar operator() (const ComplexScalar& x) const$/;"	f	struct:Eigen::internal::MatrixExponentialScalingOp
operator ()	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  inline const RealScalar operator() (const RealScalar& x) const$/;"	f	struct:Eigen::internal::MatrixExponentialScalingOp
operator ()	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    const MatrixPowerParenthesesReturnValue<MatrixType> operator()(RealScalar p)$/;"	f	class:Eigen::MatrixPower
operator ()	unsupported/Eigen/src/Polynomials/Companion.h	/^    EIGEN_STRONG_INLINE const _Scalar operator()(Index row, Index col ) const$/;"	f	class:Eigen::internal::companion
operator ()	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^  bool operator()(const Triplet& a, const Triplet& b)$/;"	f	struct:Eigen::internal::TripletComp
operator ()	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Scalar& operator() (Index row, Index col)$/;"	f	class:Eigen::RandomSetter
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& n, const Scalar& x) const {$/;"	f	struct:Eigen::internal::scalar_polygamma_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& x, const Scalar& q) const {$/;"	f	struct:Eigen::internal::scalar_zeta_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& x) const {$/;"	f	struct:Eigen::internal::scalar_igamma_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& x) const {$/;"	f	struct:Eigen::internal::scalar_igammac_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& x, const Scalar& a, const Scalar& b) const {$/;"	f	struct:Eigen::internal::scalar_betainc_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const {$/;"	f	struct:Eigen::internal::scalar_digamma_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const {$/;"	f	struct:Eigen::internal::scalar_erf_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const {$/;"	f	struct:Eigen::internal::scalar_erfc_op
operator ()	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const {$/;"	f	struct:Eigen::internal::scalar_lgamma_op
operator ()	unsupported/Eigen/src/Splines/Spline.h	/^  typename Spline<_Scalar, _Dim, _Degree>::PointType Spline<_Scalar, _Dim, _Degree>::operator()(Scalar u) const$/;"	f	class:Eigen::Spline
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:Bennett5_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:BoxBOD_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH09_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH10_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH17_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:chwirut2_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:eckerle4_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:hahn1_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:lanczos1_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1a_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1d_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat42_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat43_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:thurber_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:hybrd_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmder_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmdif_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec)$/;"	f	struct:hybrj_functor
operator ()	unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec)$/;"	f	struct:lmstr_functor
operator ()	unsupported/test/NumericalDiff.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:my_functor
operator ()	unsupported/test/autodiff.cpp	/^    void operator() (const T1 &input, T2 *output, T3 *jacobian, const Scalar dt) const$/;"	f	struct:integratorFunctor
operator ()	unsupported/test/autodiff.cpp	/^    void operator() (const T1 &input, T2 *output, const Scalar dt) const$/;"	f	struct:integratorFunctor
operator ()	unsupported/test/autodiff.cpp	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _j) const$/;"	f	struct:TestFunc1
operator ()	unsupported/test/autodiff.cpp	/^  void operator() (const Matrix<T,InputsAtCompileTime,1>& x, Matrix<T,ValuesAtCompileTime,1>* _v) const$/;"	f	struct:TestFunc1
operator ()	unsupported/test/cxx11_tensor_generator.cpp	/^  float operator()(const array<Eigen::DenseIndex, 1>& coordinates) const {$/;"	f	struct:Generator1D
operator ()	unsupported/test/cxx11_tensor_generator.cpp	/^  float operator()(const array<Eigen::DenseIndex, 2>& coordinates) const {$/;"	f	struct:Generator2D
operator ()	unsupported/test/cxx11_tensor_random.cpp	/^  int operator()(Eigen::DenseIndex element_location, Eigen::DenseIndex \/*unused*\/ = 0) const {$/;"	f	struct:MyGenerator
operator ()	unsupported/test/forward_adolc.cpp	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _j) const$/;"	f	struct:TestFunc1
operator ()	unsupported/test/forward_adolc.cpp	/^  void operator() (const Matrix<T,InputsAtCompileTime,1>& x, Matrix<T,ValuesAtCompileTime,1>* _v) const$/;"	f	struct:TestFunc1
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:Bennett5_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:BoxBOD_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH09_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH10_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH17_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:chwirut2_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:eckerle4_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:hahn1_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:lanczos1_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1a_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1d_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat42_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat43_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:thurber_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmder_functor
operator ()	unsupported/test/levenberg_marquardt.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmdif_functor
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const$/;"	f	class:Eigen::MatrixBase
operator *	Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const InverseImpl<Other, PermutationStorage>& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const InverseImpl<Other,PermutationStorage>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::InverseImpl
operator *	Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const InverseType& trPerm)$/;"	f	class:Eigen::InverseImpl
operator *	Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<MatrixDerived> &matrix,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView
operator *	Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView
operator *	Eigen/src/Core/SelfAdjointView.h	/^    operator*(const Scalar& s, const SelfAdjointView& mat)$/;"	f	class:Eigen::SelfAdjointView
operator *	Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<MatrixDerived> &matrix,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionsDerived> &transpositions,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularViewImpl& rhs)$/;"	f	class:Eigen::TriangularViewImpl
operator *	Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularViewImpl
operator *	Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator *	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half operator * (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator *	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/AngleAxis.h	/^  EIGEN_DEVICE_FUNC inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/AngleAxis.h	/^  friend EIGEN_DEVICE_FUNC inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
operator *	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^operator*(const MatrixBase<Derived>& matrix, const UniformScaling<Scalar>& s)$/;"	f	namespace:Eigen
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  inline TransformTimeDiagonalReturnType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  operator* (const MatrixBase<Derived>& vec) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence
operator *	Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen
operator *	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation
operator *	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQReturnType
operator *	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const InverseImpl<PermutationType,PermutationStorage>& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const InverseImpl<PermutationType, PermutationStorage>& tperm)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
operator *	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
operator *	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator *	doc/examples/matrixfree_cg.cpp	/^  Eigen::Product<MatrixReplacement,Rhs,Eigen::AliasFreeProduct> operator*(const Eigen::MatrixBase<Rhs>& x) const {$/;"	f	class:MatrixReplacement
operator *	test/exceptions.cpp	/^    ScalarWithExceptions operator*(const ScalarWithExceptions& other) const$/;"	f	class:ScalarWithExceptions
operator *	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator* (Scalar lhs, const Derived& rhs) {$/;"	f	class:Eigen::TensorBase
operator *	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator* (Scalar rhs) const {$/;"	f	class:Eigen::TensorBase
operator *	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator*(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator *	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE friend TensorOpCost operator*($/;"	f	class:Eigen::TensorOpCost
operator *	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^TensorUInt128<uint64_t, uint64_t> operator * (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const Scalar& other, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  operator*(const Real& other) const$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  operator*(const Real& other, const AutoDiffScalar<_DerType>& a)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator*(const BaseScalar& other) const$/;"	f	class:Eigen::AutoDiffVector
operator *	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator*(const Scalar& other, const AutoDiffVector& v)$/;"	f	class:Eigen::AutoDiffVector
operator *	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^SkylineMatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const {$/;"	f	class:Eigen::SkylineMatrixBase
operator *	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseTimeDenseProduct<BlockSparseMatrix, VecType> operator*(const VecType& lhs) const$/;"	f	class:Eigen::BlockSparseMatrix
operator *	unsupported/test/mpreal/mpreal.h	/^    operator*(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) *= lhs;    }$/;"	f	namespace:mpfr
operator *	unsupported/test/mpreal/mpreal.h	/^    operator*(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) *= rhs;    }$/;"	f	namespace:mpfr
operator *	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator*(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator *=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator *=	Eigen/src/Core/MatrixBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator *=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator *=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() * other; }$/;"	f	class:Eigen::TriangularViewImpl
operator *=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator *=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half& operator *= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator *=	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator *=	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linearExt() *= s; return *this; }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator *=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    Derived& operator*=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorBase
operator *=	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost& operator*=(double rhs) {$/;"	f	class:Eigen::TensorOpCost
operator *=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator*=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator *=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator*=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator *=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline AutoDiffScalar<_DerType>& operator*=(const Scalar& other)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *=	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator*=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator *=	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator*=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffVector
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*= (const mpreal& v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const double v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const int v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const long double v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const long int v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const long long int  u)        {    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator *=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long long int u){    *this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator +	Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator +	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half operator + (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator +	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator+(const MatrixBase<DenseDerived> &a, const SparseMatrixBase<SparseDerived> &b)$/;"	f	namespace:Eigen
operator +	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator+(const SparseMatrixBase<SparseDerived> &a, const MatrixBase<DenseDerived> &b)$/;"	f	namespace:Eigen
operator +	test/exceptions.cpp	/^    ScalarWithExceptions operator+(const ScalarWithExceptions& other) const$/;"	f	class:ScalarWithExceptions
operator +	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator+ (Scalar lhs, const Derived& rhs) {$/;"	f	class:Eigen::TensorBase
operator +	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator+ (Scalar rhs) const {$/;"	f	class:Eigen::TensorBase
operator +	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator+(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator +	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE friend TensorOpCost operator+($/;"	f	class:Eigen::TensorOpCost
operator +	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^TensorUInt128<uint64_t, uint64_t> operator + (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline const AutoDiffScalar<DerType&> operator+(const Scalar& a, const AutoDiffScalar& b)$/;"	f	class:Eigen::AutoDiffScalar
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const AutoDiffScalar<DerType&> operator+(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator+(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  friend inline const AutoDiffScalar<DerType&> operator+(const Real& a, const AutoDiffScalar<_DerType>& b)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline const AutoDiffScalar<DerType&> operator+(const Real& other) const$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator+(const AutoDiffVector<OtherValueType,OtherJacobianType>& other) const$/;"	f	class:Eigen::AutoDiffVector
operator +	unsupported/test/mpreal/mpreal.h	/^    operator+(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) += lhs;    }$/;"	f	namespace:mpfr
operator +	unsupported/test/mpreal/mpreal.h	/^    operator+(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) += rhs;    }$/;"	f	namespace:mpfr
operator +	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator+()const    {    return mpreal(*this); }$/;"	f	class:mpfr::mpreal
operator +	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator+(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator ++	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()   { m_iter.operator++(); return *this; }$/;"	f	class:Eigen::InnerIterator
operator ++	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE inner_iterator_selector& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::internal::inner_iterator_selector
operator ++	Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator ++	Eigen/src/SparseCore/SparseBlock.h	/^  inline OuterVectorInnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
operator ++	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator ++	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator ++	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator ++	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { ++m_sparseIter; return *this; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
operator ++	Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator ++	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator ++	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void operator ++() { (*this)++; }$/;"	f	class:Eigen::IterationController
operator ++	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void operator ++(int) { m_nit++; m_written = false; m_resadd += m_res; }$/;"	f	class:Eigen::IterationController
operator ++	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerLowerIterator & operator++() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator ++	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerUpperIterator & operator++() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator ++	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline BlockInnerIterator& operator++() {m_id++; return *this; }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
operator ++	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
operator ++	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline MatrixMarketIterator& operator++()$/;"	f	class:Eigen::MatrixMarketIterator
operator ++	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator++ (int)$/;"	f	class:mpfr::mpreal
operator ++	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator++()$/;"	f	class:mpfr::mpreal
operator +=	Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator +=	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator +=	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator +=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator +=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& ArrayBase<Derived>::operator+=(const Scalar& other)$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator+=(const DenseBase<Other>& other) {$/;"	f	class:Eigen::TriangularViewImpl
operator +=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator +=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half& operator += (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator +=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator+=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	test/exceptions.cpp	/^    ScalarWithExceptions& operator+=(const ScalarWithExceptions& other)$/;"	f	class:ScalarWithExceptions
operator +=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    Derived& operator+=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorBase
operator +=	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TensorOpCost& operator+=($/;"	f	class:Eigen::TensorOpCost
operator +=	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    EIGEN_STRONG_INLINE TensorDevice& operator+=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorDevice
operator +=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator+=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator +=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator+=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator +=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline AutoDiffScalar<_DerType>& operator+=(const Real& other)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +=	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator+=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator +=	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerLowerIterator & operator+=(Index shift) {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator +=	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerUpperIterator & operator+=(Index shift) {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+= (const double u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+= (const long double u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const int u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const long int u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const long long int u)         {    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpf_t u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpq_t u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpz_t u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator +=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long long int u){    *this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator ,	Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
operator ,	Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
operator -	Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator -	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half operator - (const half& a) {$/;"	f	namespace:Eigen::half_impl
operator -	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half operator - (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator -	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator-(const MatrixBase<DenseDerived> &a, const SparseMatrixBase<SparseDerived> &b)$/;"	f	namespace:Eigen
operator -	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^operator-(const SparseMatrixBase<SparseDerived> &a, const MatrixBase<DenseDerived> &b)$/;"	f	namespace:Eigen
operator -	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return NegativeReturnType(derived()); }$/;"	f
operator -	test/exceptions.cpp	/^    ScalarWithExceptions operator-(const ScalarWithExceptions& other) const$/;"	f	class:ScalarWithExceptions
operator -	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator- (Scalar lhs, const Derived& rhs) {$/;"	f	class:Eigen::TensorBase
operator -	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator- (Scalar rhs) const {$/;"	f	class:Eigen::TensorBase
operator -	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator-() const {$/;"	f	class:Eigen::TensorBase
operator -	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator-(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator -	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^TensorUInt128<uint64_t, uint64_t> operator - (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const AutoDiffScalar<DerType&> operator-(const Scalar& b) const$/;"	f	class:Eigen::AutoDiffScalar
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-() const$/;"	f	class:Eigen::AutoDiffScalar
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-(const Scalar& a, const AutoDiffScalar& b)$/;"	f	class:Eigen::AutoDiffScalar
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-() const$/;"	f	class:Eigen::AutoDiffVector
operator -	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-(const AutoDiffVector<OtherValueType,OtherJacobianType>& other) const$/;"	f	class:Eigen::AutoDiffVector
operator -	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles operator -() const$/;"	f	class:Eigen::EulerAngles
operator -	unsupported/doc/examples/FFT.cpp	/^vector<T> operator-(const vector<T> & a,const vector<T> & b )$/;"	f
operator -	unsupported/test/mpreal/mpreal.h	/^    operator-(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^    operator-(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) -= rhs;    }$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator-()const$/;"	f	class:mpfr::mpreal
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator --	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
operator --	unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator-- (int)$/;"	f	class:mpfr::mpreal
operator --	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator--()$/;"	f	class:mpfr::mpreal
operator -=	Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator -=	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator -=	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator -=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator -=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& ArrayBase<Derived>::operator-=(const Scalar& other)$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator-=(const DenseBase<Other>& other) {$/;"	f	class:Eigen::TriangularViewImpl
operator -=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator -=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half& operator -= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator -=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator-=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^Derived& SparseMatrixBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	test/exceptions.cpp	/^    ScalarWithExceptions& operator-=(const ScalarWithExceptions& other)$/;"	f	class:ScalarWithExceptions
operator -=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    Derived& operator-=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorBase
operator -=	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    EIGEN_STRONG_INLINE TensorDevice& operator-=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorDevice
operator -=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator-=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator -=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator -=	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const double v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const int v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const long double v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const long int v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const long long int  u)        {    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator -=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long long int u){    *this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator /	Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator /	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator \/ (const half& a, Index b) {$/;"	f	namespace:Eigen::half_impl
operator /	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half operator \/ (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator /	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator /	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator\/ (Scalar lhs, const Derived& rhs) {$/;"	f	class:Eigen::TensorBase
operator /	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator\/ (Scalar rhs) const {$/;"	f	class:Eigen::TensorBase
operator /	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator\/(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator /	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator \/ (const T& numerator, const TensorIntDivisor<T, div_gt_one>& divisor) {$/;"	f	namespace:Eigen::internal
operator /	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^TensorUInt128<uint64_t, uint64_t> operator \/ (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator /	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator /	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator /	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const Scalar& other, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator /	unsupported/test/mpreal/mpreal.h	/^    operator\/(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^    operator\/(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) \/= rhs;    }$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator /=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator /=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() \/ other; }$/;"	f	class:Eigen::TriangularViewImpl
operator /=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator /=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ half& operator \/= (half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator /=	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator /=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    Derived& operator\/=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorBase
operator /=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator\/=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator /=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator\/=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const double v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const int v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long double v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long int v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long long int  u)        {    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator /=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long long int u){    *this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;    }$/;"	f	class:mpfr::mpreal
operator <	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator < (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator <	bench/btl/data/mean.cxx	/^  bool operator < ( const Lib_Mean &right) const $/;"	f	class:Lib_Mean
operator <	scripts/eigen_gen_credits.cpp	/^  bool operator < (const contributor& other)$/;"	f	struct:contributor
operator <	test/jacobisvd.cpp	/^bool operator<(const Bar&, const Bar&) { return true; }$/;"	f	namespace:Foo
operator <	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator<(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator <	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator<(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator <	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^bool operator < (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator <	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator< (const Scalar& a, const AutoDiffScalar& b) { return a <  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator< (const Scalar& other) const  { return m_value <  other; }$/;"	f	class:Eigen::AutoDiffScalar
operator <	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator< (const AutoDiffScalar<OtherDerType>& b) const  { return m_value <  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const double b            ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_d (a.mpfr_srcptr(),b) < 0 );    }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const int b               ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) < 0 );                 }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const long double b       ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(),b) < 0 );    }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const long int b          ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) < 0 );                 }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const mpreal& b           ){  return (mpfr_less_p(a.mpfr_srcptr(),b.mpfr_srcptr()) != 0 );               }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const unsigned int b      ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) < 0 );                 }$/;"	f	namespace:mpfr
operator <	unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const unsigned long int b ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) < 0 );                 }$/;"	f	namespace:mpfr
operator <<	Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator <<	Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase
operator <<	Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat
operator <<	Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet16uc & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4f & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_ALWAYS_INLINE std::ostream& operator << (std::ostream& os, const half& v) {$/;"	f	namespace:Eigen::half_impl
operator <<	Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet2ul & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/Core/arch/ZVector/PacketMath.h	/^inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)$/;"	f	namespace:Eigen::internal
operator <<	Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix
operator <<	Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase
operator <<	Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector
operator <<	bench/analyze-blocking-sizes.cpp	/^  friend ostream& operator<<(ostream& s, const results_entry_t& entry)$/;"	f	struct:evaluate_defaults_action_t
operator <<	bench/analyze-blocking-sizes.cpp	/^ostream& operator<<(ostream& s, const size_triple_t& t)$/;"	f
operator <<	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  friend std::ostream& operator<<(std::ostream& os, const TensorOpCost& tc) {$/;"	f	class:Eigen::TensorOpCost
operator <<	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^std::ostream& operator << (std::ostream& os, const TensorBase<T, ReadOnlyAccessors>& expr) {$/;"	f	namespace:Eigen
operator <<	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend  std::ostream & operator << (std::ostream & s, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator <<	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      friend std::ostream& operator<<(std::ostream& s, const EulerAngles<Scalar, System>& eulerAngles)$/;"	f	class:Eigen::EulerAngles
operator <<	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    friend std::ostream & operator <<(std::ostream & s, const SkylineMatrix & m) {$/;"	f	class:Eigen::SkylineMatrix
operator <<	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    friend std::ostream & operator <<(std::ostream & s, const SkylineMatrixBase& m) {$/;"	f	class:Eigen::SkylineMatrixBase
operator <<	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const BlockSparseMatrix& m)$/;"	f	class:Eigen::BlockSparseMatrix
operator <<	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator <<	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator <<	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator <<	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator <<	unsupported/test/mpreal/mpreal.h	/^inline std::ostream& operator<<(std::ostream& os, const mpreal& v)$/;"	f	namespace:mpfr
operator <<=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const int u)$/;"	f	class:mpfr::mpreal
operator <<=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const long int u)$/;"	f	class:mpfr::mpreal
operator <<=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator <<=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator <=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator <= (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator <=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator<=(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator <=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator<=(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator <=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator<=(const Scalar& a, const AutoDiffScalar& b) { return a <= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator<=(const Scalar& other) const  { return m_value <= other; }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator<=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value <= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const double b            ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_d (a.mpfr_srcptr(),b) <= 0 );   }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const int b               ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) <= 0 );                }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const long double b       ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(),b) <= 0 );   }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const long int b          ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) <= 0 );                }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const mpreal& b           ){  return (mpfr_lessequal_p(a.mpfr_srcptr(),b.mpfr_srcptr()) != 0 );          }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const unsigned int b      ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) <= 0 );                }$/;"	f	namespace:mpfr
operator <=	unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const unsigned long int b ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) <= 0 );                }$/;"	f	namespace:mpfr
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Scalar &value)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase
operator =	Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const Scalar &value)$/;"	f	class:Eigen::ArrayBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) $/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) { return *this; }$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable
operator =	Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions
operator =	Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
operator =	Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView &other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& operator=(const TriangularViewImpl& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	Eigen/src/Core/TriangularMatrix.h	/^TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	Eigen/src/Core/TriangularMatrix.h	/^TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularViewImpl
operator =	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator =	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC half& operator=(const half& other) {$/;"	f	struct:Eigen::half
operator =	Eigen/src/Core/arch/NEON/PacketMath.h	/^  eigen_packet_wrapper& operator=(const T &v) {$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator =	Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE eigen_packet_wrapper& operator=(const T &v) {$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator =	Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC Rotation2D& operator=(const  MatrixBase<Derived>& m)$/;"	f	class:Eigen::Rotation2D
operator =	Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
operator =	Eigen/src/SparseCore/SparseAssign.h	/^Derived& SparseMatrixBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseAssign.h	/^Derived& SparseMatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseAssign.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseAssign.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseBlock.h	/^    BlockImpl& operator=(const T&)$/;"	f	class:Eigen::BlockImpl
operator =	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const BlockType& other)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
operator =	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
operator =	Eigen/src/SparseCore/SparseCompressedBase.h	/^    InnerIterator& operator=(const InnerIterator& other)$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE SparseMatrix<Scalar,_Options,_StorageIndex>& SparseMatrix<Scalar,_Options,_StorageIndex>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcMode>& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcMode>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
operator =	demos/opengl/camera.cpp	/^Camera& Camera::operator=(const Camera& other)$/;"	f	class:Camera
operator =	demos/opengl/quaternion_demo.cpp	/^  EulerAngles& operator=(const Matrix3& m)$/;"	f	class:EulerAngles
operator =	demos/opengl/quaternion_demo.cpp	/^  EulerAngles& operator=(const QuaternionType& q)$/;"	f	class:EulerAngles
operator =	doc/examples/CustomizingEigen_Inheritance.cpp	/^    MyVectorType& operator=(const Eigen::MatrixBase <OtherDerived>& other)$/;"	f	class:MyVectorType
operator =	test/exceptions.cpp	/^    ScalarWithExceptions& operator=(const ScalarWithExceptions& other)$/;"	f	class:ScalarWithExceptions
operator =	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor& operator=(const OtherDerived& other)$/;"	f	class:Eigen::Tensor
operator =	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_STRONG_INLINE Tensor& operator=(const Tensor& other)$/;"	f	class:Eigen::Tensor
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_STRONG_INLINE TensorChippingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorChippingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_STRONG_INLINE TensorChippingOp& operator = (const TensorChippingOp& other)$/;"	f	class:Eigen::TensorChippingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    EIGEN_STRONG_INLINE TensorConcatenationOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorConcatenationOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    EIGEN_STRONG_INLINE TensorConcatenationOp& operator = (const TensorConcatenationOp& other)$/;"	f	class:Eigen::TensorConcatenationOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorDevice.h	/^    EIGEN_STRONG_INLINE TensorDevice& operator=(const OtherDerived& other) {$/;"	f	class:Eigen::TensorDevice
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC DSizes& operator = (const array<DenseIndex, NumDims>& other) {$/;"	f	struct:Eigen::DSizes
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  template <typename T> Sizes& operator = (const T& \/*other*\/) {$/;"	f	struct:Eigen::Sizes
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize& operator=(const OtherDerived& other)$/;"	f	class:Eigen::TensorFixedSize
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE TensorFixedSize& operator=(const TensorFixedSize& other)$/;"	f	class:Eigen::TensorFixedSize
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    EIGEN_STRONG_INLINE TensorLayoutSwapOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorLayoutSwapOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^    EIGEN_STRONG_INLINE TensorLayoutSwapOp& operator = (const TensorLayoutSwapOp& other)$/;"	f	class:Eigen::TensorLayoutSwapOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Self& operator=(const Self& other)$/;"	f	class:Eigen::TensorMap
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    Self& operator=(const OtherDerived& other)$/;"	f	class:Eigen::TensorMap
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  Tuple& operator= (const Tuple& rhs) {$/;"	f	struct:Eigen::Tuple
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorReshapingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorReshapingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorReshapingOp& operator = (const TensorReshapingOp& other)$/;"	f	class:Eigen::TensorReshapingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorSlicingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorSlicingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorSlicingOp& operator = (const TensorSlicingOp& other)$/;"	f	class:Eigen::TensorSlicingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorStridingSlicingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorStridingSlicingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    EIGEN_STRONG_INLINE TensorStridingSlicingOp& operator = (const TensorStridingSlicingOp& other)$/;"	f	class:Eigen::TensorStridingSlicingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE TensorRef& operator = (const Expression& expr) {$/;"	f	class:Eigen::TensorRef
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    TensorRef& operator = (const TensorRef& other) {$/;"	f	class:Eigen::TensorRef
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    EIGEN_STRONG_INLINE TensorReverseOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorReverseOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    EIGEN_STRONG_INLINE TensorReverseOp& operator = (const TensorReverseOp& other)$/;"	f	class:Eigen::TensorReverseOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    EIGEN_STRONG_INLINE TensorShufflingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorShufflingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    EIGEN_STRONG_INLINE TensorShufflingOp& operator = (const TensorShufflingOp& other)$/;"	f	class:Eigen::TensorShufflingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC Self& operator=(const Self& other)$/;"	f	class:Eigen::TensorStorage
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    EIGEN_STRONG_INLINE TensorStridingOp& operator = (const OtherDerived& other)$/;"	f	class:Eigen::TensorStridingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    EIGEN_STRONG_INLINE TensorStridingOp& operator = (const TensorStridingOp& other)$/;"	f	class:Eigen::TensorStridingOp
operator =	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  TensorUInt128& operator = (const TensorUInt128<OTHER_HIGH, OTHER_LOW>& other) {$/;"	f	struct:Eigen::internal::TensorUInt128
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroup& operator=(DynamicSGroup&& o) { m_numIndices = o.m_numIndices; std::swap(m_elements, o.m_elements); m_generators = o.m_generators; m_globalFlags = o.m_globalFlags; return *this; }$/;"	f	class:Eigen::DynamicSGroup
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroup& operator=(const DynamicSGroup& o) { m_numIndices = o.m_numIndices; m_elements = o.m_elements; m_generators = o.m_generators; m_globalFlags = o.m_globalFlags; return *this; }$/;"	f	class:Eigen::DynamicSGroup
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroupFromTemplateArgs<Gen...>& operator=(DynamicSGroupFromTemplateArgs<Gen...>&& o) { DynamicSGroup::operator=(o); return *this; }$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline DynamicSGroupFromTemplateArgs<Gen...>& operator=(const DynamicSGroupFromTemplateArgs<Gen...>& o) { DynamicSGroup::operator=(o); return *this; }$/;"	f	class:Eigen::DynamicSGroupFromTemplateArgs
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline SGroup<Gen...>& operator=(SGroup<Gen...>&& other) { Base::operator=(other); return *this; }$/;"	f	class:Eigen::SGroup
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline SGroup<Gen...>& operator=(const SGroup<Gen...>& other) { Base::operator=(other); return *this; }$/;"	f	class:Eigen::SGroup
operator =	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline tensor_symmetry_value_setter<Tensor_, Symmetry_, Flags>& operator=(Scalar const& value)$/;"	f	class:Eigen::internal::tensor_symmetry_value_setter
operator =	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator=(const AutoDiffScalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator =	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator =	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator =	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator=(const AutoDiffVector& other)$/;"	f	class:Eigen::AutoDiffVector
operator =	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator=(const AutoDiffVector<OtherValueType, OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator =	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles& operator=(const MatrixBase<Derived>& m) {$/;"	f	class:Eigen::EulerAngles
operator =	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      EulerAngles& operator=(const RotationBase<Derived, 3>& rot) {$/;"	f	class:Eigen::EulerAngles
operator =	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^            inline SkylineMatrix & operator=(const SkylineMatrixBase<OtherDerived>& other) {$/;"	f	class:Eigen::SkylineMatrix
operator =	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix & operator=(const SkylineMatrix & other) {$/;"	f	class:Eigen::SkylineMatrix
operator =	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^            inline Derived & operator=(const SkylineMatrixBase<OtherDerived>& other) {$/;"	f	class:Eigen::SkylineMatrixBase
operator =	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived & operator=(const Derived& other) {$/;"	f	class:Eigen::SkylineMatrixBase
operator =	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage & operator=(const SkylineStorage& other) {$/;"	f	class:Eigen::SkylineStorage
operator =	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    BlockSparseMatrix& operator=(BlockSparseMatrix other)$/;"	f	class:Eigen::BlockSparseMatrix
operator =	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline BlockSparseMatrix& operator=(const MatrixType& spmat)$/;"	f	class:Eigen::BlockSparseMatrix
operator =	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline DynamicSparseMatrix& operator=(const DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator= (const std::complex<real_t>& z)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const char* s)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const double v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const long double v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const long int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const long long int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpf_t v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const std::string& s)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned long long int v)$/;"	f	class:mpfr::mpreal
operator =	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(mpreal&& other)$/;"	f	class:mpfr::mpreal
operator ==	Eigen/src/Core/MatrixBase.h	/^    EIGEN_DEVICE_FUNC inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator ==	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator == (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator ==	test/exceptions.cpp	/^    bool operator==(const ScalarWithExceptions& other) const$/;"	f	class:ScalarWithExceptions
operator ==	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator==(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator ==	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator==(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator ==	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^bool operator==(const Tuple<U, V>& x, const Tuple<U, V>& y) {$/;"	f	namespace:Eigen
operator ==	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^bool operator == (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator ==	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^EIGEN_DEVICE_FUNC bool operator==(const array<T,N>& lhs, const array<T,N>& rhs) {$/;"	f	namespace:Eigen
operator ==	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator==(const Scalar& a, const AutoDiffScalar& b) { return a == b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator==(const Scalar& other) const  { return m_value == other; }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator==(const AutoDiffScalar<OtherDerType>& b) const  { return m_value == b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const double b            ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_d (a.mpfr_srcptr(),b) == 0 );   }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const int b               ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );                }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const long double b       ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(),b) == 0 );   }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const long int b          ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) == 0 );                }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const mpreal& b           ){  return (mpfr_equal_p(a.mpfr_srcptr(),b.mpfr_srcptr()) != 0 );              }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned int b      ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );                }$/;"	f	namespace:mpfr
operator ==	unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned long int b ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) == 0 );                }$/;"	f	namespace:mpfr
operator >	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator > (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator >	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator>(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator >	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator>(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator >	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator> (const Scalar& a, const AutoDiffScalar& b) { return a >  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator> (const Scalar& other) const  { return m_value >  other; }$/;"	f	class:Eigen::AutoDiffScalar
operator >	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator> (const AutoDiffScalar<OtherDerType>& b) const  { return m_value >  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const double b            ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_d (a.mpfr_srcptr(),b) > 0 );    }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const int b               ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) > 0 );                 }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const long double b       ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(),b) > 0 );    }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const long int b          ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) > 0 );                 }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const mpreal& b           ){  return (mpfr_greater_p(a.mpfr_srcptr(),b.mpfr_srcptr()) != 0 );            }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const unsigned int b      ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) > 0 );                 }$/;"	f	namespace:mpfr
operator >	unsupported/test/mpreal/mpreal.h	/^inline bool operator >  (const mpreal& a, const unsigned long int b ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) > 0 );                 }$/;"	f	namespace:mpfr
operator >=	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE __device__ bool operator >= (const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
operator >=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator>=(Scalar threshold) const {$/;"	f	class:Eigen::TensorBase
operator >=	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator>=(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator >=	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^bool operator >= (const TensorUInt128<HL, LL>& lhs, const TensorUInt128<HR, LR>& rhs)$/;"	f	namespace:Eigen::internal
operator >=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator>=(const Scalar& a, const AutoDiffScalar& b) { return a >= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator>=(const Scalar& other) const  { return m_value >= other; }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator>=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value >= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const double b            ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_d (a.mpfr_srcptr(),b) >= 0 );   }$/;"	f	namespace:mpfr
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const int b               ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) >= 0 );                }$/;"	f	namespace:mpfr
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const long double b       ){  return !isnan EIGEN_NOT_A_MACRO (a) && (b == b) && (mpfr_cmp_ld(a.mpfr_srcptr(),b) >= 0 );   }$/;"	f	namespace:mpfr
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const long int b          ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_si(a.mpfr_srcptr(),b) >= 0 );                }$/;"	f	namespace:mpfr
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const mpreal& b           ){  return (mpfr_greaterequal_p(a.mpfr_srcptr(),b.mpfr_srcptr()) != 0 );       }$/;"	f	namespace:mpfr
operator >=	unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const unsigned long int b ){  return !isnan EIGEN_NOT_A_MACRO (a) && (mpfr_cmp_ui(a.mpfr_srcptr(),b) >= 0 );                }$/;"	f	namespace:mpfr
operator >>	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator >>	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator >>	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator >>	unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator >>	unsupported/test/mpreal/mpreal.h	/^inline std::istream& operator>>(std::istream &is, mpreal& v)$/;"	f	namespace:mpfr
operator >>=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const int u)$/;"	f	class:mpfr::mpreal
operator >>=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const long int u)$/;"	f	class:mpfr::mpreal
operator >>=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator >>=	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator DenseIndex	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr operator DenseIndex() const { return n; }$/;"	f	struct:Eigen::type2index
operator Derived&	Eigen/src/SparseCore/SparseCompressedBase.h	/^  operator Derived&() { return m_matrix->const_cast_derived(); }$/;"	f	struct:Eigen::internal::evaluator
operator IndexPair<DenseIndex>	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  constexpr EIGEN_DEVICE_FUNC operator IndexPair<DenseIndex>() const {$/;"	f	struct:Eigen::type2indexpair
operator LOW	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE operator LOW() const {$/;"	f	struct:Eigen::internal::TensorUInt128
operator MatrixType&	test/constructor.cpp	/^  inline operator MatrixType& () { return m_mat; }$/;"	f	struct:Wrapper
operator QuaternionType	demos/opengl/quaternion_demo.cpp	/^  operator QuaternionType() { return QuaternionType(toRotationMatrix()); }$/;"	f	class:EulerAngles
operator QuaternionType	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      operator QuaternionType() const$/;"	f	class:Eigen::EulerAngles
operator SparseMatrixType&	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  operator SparseMatrixType&() { return m_matrix->const_cast_derived(); }$/;"	f	struct:Eigen::internal::evaluator
operator SparseVectorType&	Eigen/src/SparseCore/SparseVector.h	/^  operator SparseVectorType&() { return m_matrix->const_cast_derived(); }$/;"	f	struct:Eigen::internal::evaluator
operator T&	Eigen/src/Core/arch/NEON/PacketMath.h	/^  operator T&() { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator T&	Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE operator T&() { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator T&	Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator []	Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator []	Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator []	Eigen/src/Core/Transpositions.h	/^    inline StorageIndex& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	Eigen/src/Core/Transpositions.h	/^    inline const StorageIndex& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	Eigen/src/Core/util/Memory.h	/^  T& operator[](std::ptrdiff_t i) { return m_ptr[i]; }$/;"	f	class:Eigen::internal::scoped_array
operator []	Eigen/src/Core/util/Memory.h	/^  const T& operator[](std::ptrdiff_t i) const { return m_ptr[i]; }$/;"	f	class:Eigen::internal::scoped_array
operator []	Eigen/src/SparseCore/SparseMatrix.h	/^        StorageIndex operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector
operator []	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar& operator[](Index index)$/;"	f	class:Eigen::Tensor
operator []	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar& operator[](Index index) const$/;"	f	class:Eigen::Tensor
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  const Index operator[] (const Index i) const { return i; }$/;"	f	struct:Eigen::DimensionList
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t operator[] (const std::size_t index) const {$/;"	f	struct:Eigen::Sizes
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE Scalar& operator[](Index index)$/;"	f	class:Eigen::TensorFixedSize
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_STRONG_INLINE const Scalar& operator[](Index index) const$/;"	f	class:Eigen::TensorFixedSize
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC constexpr DenseIndex operator[] (const DenseIndex i) const {$/;"	f	struct:Eigen::IndexList
operator []	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC constexpr IndexPair<DenseIndex> operator[] (const DenseIndex i) const {$/;"	f	struct:Eigen::IndexPairList
operator []	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& operator[] (size_t index) { return values[index]; }$/;"	f	class:Eigen::array
operator []	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE T& operator[] (size_t) {$/;"	f	class:Eigen::array
operator []	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& operator[] (size_t index) const { return values[index]; }$/;"	f	class:Eigen::array
operator []	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  EIGEN_STRONG_INLINE const T& operator[] (size_t) const {$/;"	f	class:Eigen::array
operator []	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  T& operator[] (size_t i) {$/;"	f	class:Eigen::MaxSizeVector
operator []	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  const T& operator[] (size_t i) const {$/;"	f	class:Eigen::MaxSizeVector
operator []	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType operator[] (Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator []	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType operator[] (Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator ^	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator^(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ^	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator^(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operator bool	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE operator bool() const         { return m_iter; }$/;"	f	class:Eigen::InnerIterator
operator bool	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::internal::inner_iterator_selector
operator bool	Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator bool	Eigen/src/SparseCore/SparseBlock.h	/^  inline operator bool() const { return EvalIterator::operator bool() && EvalIterator::index() < m_end; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
operator bool	Eigen/src/SparseCore/SparseBlock.h	/^  inline operator bool() const { return m_outerPos < m_end; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
operator bool	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
operator bool	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id<m_innerSize; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE operator bool() const { return LhsIterator::operator bool() && (!m_empty); }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline operator bool() const  { return m_sparseIter; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseTriangularView.h	/^      EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator bool	Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
operator bool	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline operator bool() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator bool	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline operator bool() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator bool	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline operator bool() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator bool	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
operator bool	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline operator bool() const$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
operator bool	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline operator bool() const { return m_isvalid;}$/;"	f	class:Eigen::MatrixMarketIterator
operator bool	unsupported/test/mpreal/mpreal.h	/^    explicit operator bool               () const { return toBool();                 }$/;"	f	class:mpfr::mpreal
operator const Derived&	Eigen/src/SparseCore/SparseCompressedBase.h	/^  operator const Derived&() const { return *m_matrix; }$/;"	f	struct:Eigen::internal::evaluator
operator const ExpressionType&	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess
operator const ExpressionType&	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue
operator const MatrixType&	test/constructor.cpp	/^  inline operator const MatrixType& () const { return m_mat; }$/;"	f	struct:Wrapper
operator const Scalar	Eigen/src/Core/Product.h	/^  EIGEN_STRONG_INLINE operator const Scalar() const$/;"	f	class:Eigen::internal::dense_product_base
operator const SparseMatrixType&	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  operator const SparseMatrixType&() const { return *m_matrix; }$/;"	f	struct:Eigen::internal::evaluator
operator const SparseVectorType&	Eigen/src/SparseCore/SparseVector.h	/^  operator const SparseVectorType&() const { return *m_matrix; }$/;"	f	struct:Eigen::internal::evaluator
operator const T&	Eigen/src/Core/arch/NEON/PacketMath.h	/^  operator const T&() const { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator const T&	Eigen/src/Core/arch/SSE/PacketMath.h	/^  EIGEN_ALWAYS_INLINE operator const T&() const { return m_val; }$/;"	f	struct:Eigen::internal::eigen_packet_wrapper
operator const T&	Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator const T*	Eigen/src/Core/util/Memory.h	/^  operator const T*() const { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
operator const char*	bench/btl/generic_bench/btl.hh	/^    operator const char* () const { return c_str(); }$/;"	f	class:BtlString
operator double	unsupported/test/mpreal/mpreal.h	/^    explicit operator double             () const { return toDouble();               }$/;"	f	class:mpfr::mpreal
operator float	unsupported/test/mpreal/mpreal.h	/^    explicit operator float              () const { return toFloat();                }$/;"	f	class:mpfr::mpreal
operator int	unsupported/test/mpreal/mpreal.h	/^    explicit operator int                () const { return int(toLong());            }$/;"	f	class:mpfr::mpreal
operator long	unsupported/test/mpreal/mpreal.h	/^    explicit operator long               () const { return toLong();                 }$/;"	f	class:mpfr::mpreal
operator long double	unsupported/test/mpreal/mpreal.h	/^    explicit operator long double        () const { return toLDouble();              }$/;"	f	class:mpfr::mpreal
operator long long	unsupported/test/mpreal/mpreal.h	/^    explicit operator long long          () const { return toLLong();                }$/;"	f	class:mpfr::mpreal
operator uint64_t	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE operator uint64_t() const { return n; }$/;"	f	struct:Eigen::internal::static_val
operator unsigned	unsupported/test/mpreal/mpreal.h	/^    explicit operator unsigned           () const { return unsigned(toULong());      }$/;"	f	class:mpfr::mpreal
operator unsigned long	unsupported/test/mpreal/mpreal.h	/^    explicit operator unsigned long      () const { return toULong();                }$/;"	f	class:mpfr::mpreal
operator unsigned long long	unsupported/test/mpreal/mpreal.h	/^    explicit operator unsigned long long () const { return toULLong();               }$/;"	f	class:mpfr::mpreal
operator ||	Eigen/src/plugins/CommonCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ||	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    operator||(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
operatorInverseSqrt	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operatorInverseSqrt	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  Matrix<Scalar, Dynamic, Dynamic> operatorInverseSqrt() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
operatorNorm	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase
operatorNorm	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView
operatorSqrt	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operatorSqrt	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  Matrix<Scalar, Dynamic, Dynamic> operatorSqrt() const$/;"	f	class:Eigen::ArpackGeneralizedSelfAdjointEigenSolver
options	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase
order	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType order ; \/* pivot ordering of this column, if col is dead *\/$/;"	m	union:internal::colamd_col::__anon869
order_children	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  void order_children$/;"	f	namespace:internal
ordering	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, ConstCholMatrixPtr &pmat, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
orderingMethod	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int orderingMethod() const {$/;"	f	class:Eigen::SkylineInplaceLU
ordering_helper_at_plus_a	Eigen/src/OrderingMethods/Ordering.h	/^void ordering_helper_at_plus_a(const MatrixType& A, MatrixType& symmat)$/;"	f	namespace:Eigen::internal
orientation	demos/opengl/camera.h	/^    Eigen::Quaternionf orientation;$/;"	m	class:Frame
orientation	demos/opengl/camera.h	/^    inline const Eigen::Quaternionf& orientation(void) const { return mFrame.orientation; }$/;"	f	class:Camera
origin	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	bench/btl/data/gnuplot_common_settings.hh	/^set origin 0,0$/;"	v
originalMatrix	Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base
orthomethods	test/geo_orthomethods.cpp	/^template<typename Scalar, int Size> void orthomethods(int size=Size)$/;"	f
orthomethods_3	test/geo_orthomethods.cpp	/^template<typename Scalar> void orthomethods_3()$/;"	f
other	Eigen/src/Core/util/Memory.h	/^    typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind
other	Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind
other_matrix_type	test/swap.cpp	/^struct other_matrix_type$/;"	s	file:
other_matrix_type	test/swap.cpp	/^struct other_matrix_type<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	file:
others	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  IndexTuple<O...> others;$/;"	m	struct:Eigen::internal::IndexTuple
outer	Eigen/src/Core/AssignEvaluator.h	/^    outer = Index \/ DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling::__anon511
outer	Eigen/src/Core/AssignEvaluator.h	/^    outer = Index \/ DstXprType::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling::__anon512
outer	Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon488
outer	Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon490
outer	Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride
outer	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index outer()  const { return 0; }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
outer	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index outer()  const { return EvalIterator::outer() - (IsRowMajor ? m_block.startRow() : m_block.startCol()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
outer	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
outer	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_lhsIter.outer(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_rhsIter.outer(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
outer	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
outer	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const  { return m_sparseIter.outer(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
outer	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
outer	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index outer() const {return m_outer; }$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
outer	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
outer	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
outerBlocks	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index outerBlocks() const { return m_outerBSize; }$/;"	f	class:Eigen::BlockSparseMatrix
outerInd	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon865
outerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline StorageIndex* outerIndexPtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
outerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const StorageIndex* outerIndexPtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
outerIndexPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline StorageIndex* outerIndexPtr() { return derived().outerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
outerIndexPtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const StorageIndex* outerIndexPtr() const { return derived().outerIndexPtr(); }$/;"	f	class:Eigen::SparseCompressedBase
outerIndexPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline StorageIndex* outerIndexPtr()   { return Base::m_outerIndex; }$/;"	f	class:Eigen::SparseMapBase
outerIndexPtr	Eigen/src/SparseCore/SparseMap.h	/^    inline const StorageIndex* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMapBase
outerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline StorageIndex* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const StorageIndex* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline StorageIndex* outerIndexPtr() { return derived().nestedExpression().outerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
outerIndexPtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline const StorageIndex* outerIndexPtr() const { return derived().nestedExpression().outerIndexPtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
outerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    inline StorageIndex* outerIndexPtr() { return 0; }$/;"	f	class:Eigen::SparseVector
outerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    inline const StorageIndex* outerIndexPtr() const { return 0; }$/;"	f	class:Eigen::SparseVector
outerIndexPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline StorageIndex *outerIndexPtr() {return m_outerIndex; }$/;"	f	class:Eigen::BlockSparseMatrix
outerIndexPtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline const StorageIndex* outerIndexPtr() const {return m_outerIndex; }$/;"	f	class:Eigen::BlockSparseMatrix
outerSize	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index outerSize() const   { return m_dstExpr.outerSize(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
outerSize	Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase
outerSize	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index outerSize() const { return m_xpr.outerSize(); }$/;"	f	class:Eigen::internal::redux_evaluator
outerSize	Eigen/src/SparseCore/SparseMap.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMapBase
outerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
outerSize	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase
outerSize	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector
outerSize	Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView
outerSize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index outerSize() const {$/;"	f	class:Eigen::SkylineMatrix
outerSize	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Index outerSize() const {$/;"	f	class:Eigen::SkylineMatrixBase
outerSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index outerSize() const$/;"	f	class:Eigen::BlockSparseMatrixView
outerSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index outerSize() const$/;"	f	class:Eigen::BlockSparseMatrix
outerSize	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index outerSize() const { return convert_index(m_data.size()); }$/;"	f	class:Eigen::DynamicSparseMatrix
outerStride	Eigen/src/Core/Array.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array
outerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper
outerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper
outerStride	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index outerStride() const { return m_dstExpr.outerStride(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
outerStride	Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
outerStride	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
outerStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
outerStride	Eigen/src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal
outerStride	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
outerStride	Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map
outerStride	Eigen/src/Core/Matrix.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix
outerStride	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue
outerStride	Eigen/src/Core/Ref.h	/^  EIGEN_DEVICE_FUNC inline Index outerStride() const$/;"	f	class:Eigen::RefBase
outerStride	Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView
outerStride	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl
outerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TriangularViewImpl
outerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase
outerToBlock	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index outerToBlock(Index outer) const$/;"	f	class:Eigen::BlockSparseMatrix
outer_product_selector_run	Eigen/src/Core/ProductEvaluators.h	/^void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)$/;"	f	namespace:Eigen::internal
outer_product_selector_run	Eigen/src/Core/ProductEvaluators.h	/^void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)$/;"	f	namespace:Eigen::internal
outer_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
output	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  OutputMapper& output;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
output	unsupported/test/mpreal/mpreal.h	/^inline std::ostream& mpreal::output(std::ostream& os) const$/;"	f	class:mpfr::mpreal
outputCols	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index outputCols() const { return m_outputCols; }$/;"	f	struct:Eigen::TensorEvaluator
outputCols	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index outputCols() const { return m_outputCols; }$/;"	f	struct:Eigen::TensorEvaluator
outputPlanes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index outputPlanes() const { return m_outputPlanes; }$/;"	f	struct:Eigen::TensorEvaluator
outputRows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index outputRows() const { return m_outputRows; }$/;"	f	struct:Eigen::TensorEvaluator
outputRows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index outputRows() const { return m_outputRows; }$/;"	f	struct:Eigen::TensorEvaluator
output_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    OutputMapper output_;$/;"	m	class:Eigen::TensorEvaluator::Context
overwriteResults	bench/btl/generic_bench/btl.hh	/^  bool overwriteResults;$/;"	m	class:BtlConfig
p	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType p ;   \/* used as a row pointer in init_rows_cols () *\/$/;"	m	union:internal::Colamd_Row::__anon872
p	doc/snippets/Tutorial_Map_using.cpp	/^float *p = &m2(0);  \/\/ get the address storing the data for m2$/;"	v
p	unsupported/test/BVH.cpp	/^  VectorType p;$/;"	m	struct:BallPointStuff	file:
p0	doc/snippets/MatrixBase_all.cpp	/^Vector3f p0 = Vector3f::Random(), p1 = Vector3f::Random().cwiseAbs();$/;"	v
p1	doc/snippets/MatrixBase_all.cpp	/^Vector3f p0 = Vector3f::Random(), p1 = Vector3f::Random().cwiseAbs();$/;"	v
p16uc_COMPLEX32_REV	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV = vec_sld(p16uc_REVERSE32, p16uc_REVERSE32, 8);                                         \/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX32_REV2	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);                                            \/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX32_REV2	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_PSET64_HI, p16uc_PSET64_LO, 8);                                            \/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE32_HI	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE32_HI = { 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE32_HI	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE32_HI = { 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = p16uc_REVERSE32;$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_FORWARD =   { 0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_HALF64_0_16	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_HALF64_0_16 = vec_sld((Packet16uc)p4i_ZERO, vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 3), 8);      \/\/{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};$/;"	m	namespace:Eigen::internal
p16uc_HALF64_0_16	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_HALF64_0_16 = vec_sld(vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 0), (Packet16uc)p4i_ZERO, 8);      \/\/{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN  = vec_sld(p16uc_DUPLICATE32_HI, (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WEVEN	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET32_WEVEN  = vec_sld(p16uc_DUPLICATE32_HI, (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET32_WODD	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET32_WODD   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_HI	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET64_HI = (Packet16uc) vec_mergeh((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_HI	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET64_HI = { 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_LO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_PSET64_LO = (Packet16uc) vec_mergel((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_PSET64_LO	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_PSET64_LO = (Packet16uc) vec_mergel((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     \/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE32	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE32	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE64	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE64	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_HI	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_HI = p16uc_PSET64_HI + p16uc_HALF64_0_16;                                         \/\/{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_HI	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_HI = { 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_LO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_LO = p16uc_PSET64_LO + p16uc_HALF64_0_16;                                         \/\/{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};$/;"	m	namespace:Eigen::internal
p16uc_TRANSPOSE64_LO	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet16uc p16uc_TRANSPOSE64_LO = { 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ONE), reinterpret_cast<Packet4f>(p2d_ZERO), 8));$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ZERO), reinterpret_cast<Packet4f>(p2d_ONE), 8));$/;"	m	namespace:Eigen::internal
p2d_COUNTDOWN	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet16uc>(p2d_ZERO), reinterpret_cast<Packet16uc>(p2d_ONE), 8));$/;"	m	namespace:Eigen::internal
p2d_MZERO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_MZERO = { -0.0, -0.0 };$/;"	m	namespace:Eigen::internal
p2d_ONE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_ONE  = { 1.0, 1.0 };$/;"	m	namespace:Eigen::internal
p2d_ONE	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_ONE = { 1.0, 1.0 }; $/;"	m	namespace:Eigen::internal
p2d_ZERO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2d  p2d_ZERO = reinterpret_cast<Packet2d>(p4f_ZERO);$/;"	m	namespace:Eigen::internal
p2d_ZERO_	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet2d p2d_ZERO_ = { -0.0, -0.0 };$/;"	m	namespace:Eigen::internal
p2l_1023	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static Packet2l p2l_1023 = { 1023, 1023 };$/;"	m	namespace:Eigen::internal
p2l_ONE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2l  p2l_ONE  = { 1, 1 };$/;"	m	namespace:Eigen::internal
p2l_ZERO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet2l  p2l_ZERO = reinterpret_cast<Packet2l>(p4i_ZERO);$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^inline uint32x2_t p2ui_CONJ_XOR() {$/;"	f	namespace:Eigen::internal
p2ul_52	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^static Packet2ul p2ul_52 = { 52, 52 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^  static uint64x2_t p2ul_CONJ_XOR = vld1q_u64( p2ul_conj_XOR_DATA );$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^  static uint64x2_t p2ul_CONJ_XOR = {0x0, 0x8000000000000000};$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2d_MZERO, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_MZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR1	Eigen/src/Core/arch/ZVector/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2d_ZERO_, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2d_MZERO, (Packet4ui) p2l_ZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_MZERO, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_CONJ_XOR2	Eigen/src/Core/arch/ZVector/Complex.h	/^static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_ZERO_, 8);\/\/{ 0x8000000000000000, 0x0000000000000000 };$/;"	m	namespace:Eigen::internal
p2ul_conj_XOR_DATA	Eigen/src/Core/arch/NEON/Complex.h	/^  const uint64_t  p2ul_conj_XOR_DATA[] = { 0x0, 0x8000000000000000 };$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };$/;"	m	namespace:Eigen::internal
p4f_MZERO	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_MZERO = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1); \/\/{ 0x80000000, 0x80000000, 0x80000000, 0x80000000}$/;"	m	namespace:Eigen::internal
p4f_ONE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0); \/\/{ 1.0, 1.0, 1.0, 1.0}$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 0, 1, 2, 3 };$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	Eigen/src/Core/arch/ZVector/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 0, 1, 2, 3 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_MZERO);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^inline uint32x4_t p4ui_CONJ_XOR() {$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { using std::abs; return abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pabs(const Packet4d& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pabs(const Packet8f& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pabs(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f pabs(const Packet16f& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double2 pabs<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float4  pabs<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pabs<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) { return vabsq_f64(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs<Packet2d>(const Packet2d& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs<Packet4i>(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pack	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs
packLhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static void packLhs(const packLArg arg) {$/;"	f	struct:Eigen::TensorEvaluator
packLhsArg	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^struct packLhsArg {$/;"	s	namespace:Eigen::internal
packRhsAndKernel	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static void packRhsAndKernel(packRKArg arg) {$/;"	f	struct:Eigen::TensorEvaluator
packRhsAndKernelArg	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^struct packRhsAndKernelArg {$/;"	s	namespace:Eigen::internal
pack_lhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void pack_lhs(Index m, Index k) {$/;"	f	class:Eigen::TensorEvaluator::Context
pack_rhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void pack_rhs(Index n, Index k) {$/;"	f	class:Eigen::TensorEvaluator::Context
packedMatrix	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition
packedMatrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization
packed_lhs_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    std::vector<LhsScalar*> packed_lhs_[P - 1];$/;"	m	class:Eigen::TensorEvaluator::Context
packed_mem_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void* packed_mem_;$/;"	m	class:Eigen::TensorEvaluator::Context
packed_rank2_update_selector	blas/Rank2Update.h	/^struct packed_rank2_update_selector$/;"	s	namespace:internal
packed_rhs_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    std::vector<RhsScalar*> packed_rhs_[P - 1];$/;"	m	class:Eigen::TensorEvaluator::Context
packed_triangular_matrix_vector_product	blas/PackedTriangularMatrixVector.h	/^struct packed_triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor>$/;"	s	namespace:internal
packed_triangular_matrix_vector_product	blas/PackedTriangularMatrixVector.h	/^struct packed_triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor>$/;"	s	namespace:internal
packed_triangular_solve_vector	blas/PackedTriangularSolverVector.h	/^struct packed_triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:internal
packed_triangular_solve_vector	blas/PackedTriangularSolverVector.h	/^struct packed_triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:internal
packed_triangular_solve_vector	blas/PackedTriangularSolverVector.h	/^struct packed_triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:internal
packet	Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const $/;"	f	struct:Eigen::internal::unary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::binary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::ternary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::unary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const $/;"	f	struct:Eigen::internal::unary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::binary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::mapbase_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::ternary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::unary_evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(IndexType index) const$/;"	f	struct:Eigen::internal::evaluator
packet	Eigen/src/Core/CoreEvaluators.h	/^  PacketType packet(IndexType row, IndexType col) const$/;"	f	struct:Eigen::internal::evaluator
packet	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	Eigen/src/Core/GenericPacketMath.h	/^  Packet packet[N];$/;"	m	struct:Eigen::internal::PacketBlock
packet	Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase
packet	Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
packet	Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue
packet	Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
packet	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase
packet	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
packet	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet(Index idx) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	Eigen/src/Core/ProductEvaluators.h	/^  const PacketType packet(Index index) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	Eigen/src/Core/ProductEvaluators.h	/^  const PacketType packet(Index row, Index col) const$/;"	f	struct:Eigen::internal::product_evaluator
packet	Eigen/src/Core/Redux.h	/^  PacketType packet(Index index) const$/;"	f	class:Eigen::internal::redux_evaluator
packet	Eigen/src/Core/Redux.h	/^  PacketType packet(Index row, Index col) const$/;"	f	class:Eigen::internal::redux_evaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  EIGEN_DEVICE_FUNC PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const {$/;"	f	struct:Eigen::TensorContractionEvaluatorBase
packet	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^ typename Tensor::PacketReturnType packet(typename Tensor::Index index) const$/;"	f	struct:Eigen::internal::CoeffLoader
packet	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE TgtPacket packet(Index index) const {$/;"	f	struct:Eigen::PacketConverter
packet	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(const Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC PacketReturnType packet(const Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  EIGEN_DEVICE_FUNC PacketReturnType packet(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  EIGEN_DEVICE_FUNC PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  packet(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC PacketReturnType packet(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
packetByOuterInner	Eigen/src/Core/Redux.h	/^  PacketType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::internal::redux_evaluator
packetColMajor	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetColMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetColMajor	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetColMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetCount_	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    DenseIndex packetCount_;$/;"	m	struct:Eigen::internal::MeanReducer
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i) const { return op.template packetOp<T>(i); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const { return op.template packetOp<T>(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j) const {$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType i, IndexType j=0) const { return op.template packetOp<T>(i,j); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/CoreEvaluators.h	/^  template <typename T, typename IndexType> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T packetOp(const NullaryOp& op, IndexType=0, IndexType=0) const { return op.template packetOp<T>(); }$/;"	f	struct:Eigen::internal::nullary_wrapper
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::bind2nd_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op
packetOp	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& b) const$/;"	f	struct:Eigen::internal::bind1st_op
packetOp	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const PacketType packetOp() const { return internal::pset1<PacketType>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_arg_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::patan(a); }$/;"	f	struct:Eigen::internal::scalar_atan_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pceil(a); }$/;"	f	struct:Eigen::internal::scalar_ceil_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcosh(a); }$/;"	f	struct:Eigen::internal::scalar_cosh_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pfloor(a); }$/;"	f	struct:Eigen::internal::scalar_floor_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog10(a); }$/;"	f	struct:Eigen::internal::scalar_log10_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog1p(a); }$/;"	f	struct:Eigen::internal::scalar_log1p_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pround(a); }$/;"	f	struct:Eigen::internal::scalar_round_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::prsqrt(a); }$/;"	f	struct:Eigen::internal::scalar_rsqrt_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psinh(a); }$/;"	f	struct:Eigen::internal::scalar_sinh_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& x) const { return ptanh(x); }$/;"	f	struct:Eigen::internal::scalar_tanh_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op
packetOp	Eigen/src/Core/functors/UnaryFunctors.h	/^  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op
packetOp	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  Packet packetOp(const Packet& x) const {$/;"	f	struct:Eigen::internal::scalar_sigmoid_op
packetOp	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  Packet packetOp(Index i) const {$/;"	f	class:Eigen::internal::NormalRandomGenerator
packetOp	unsupported/Eigen/CXX11/src/Tensor/TensorRandom.h	/^  Packet packetOp(Index i) const {$/;"	f	class:Eigen::internal::UniformRandomGenerator
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& n, const Packet& x) const { return internal::ppolygamma(n, x); }$/;"	f	struct:Eigen::internal::scalar_polygamma_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^    EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& x, const Packet& q) const { return internal::pzeta(x, q); }$/;"	f	struct:Eigen::internal::scalar_zeta_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& x) const {$/;"	f	struct:Eigen::internal::scalar_igamma_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& x) const$/;"	f	struct:Eigen::internal::scalar_igammac_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& x, const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_betainc_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pdigamma(a); }$/;"	f	struct:Eigen::internal::scalar_digamma_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::perf(a); }$/;"	f	struct:Eigen::internal::scalar_erf_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::perfc(a); }$/;"	f	struct:Eigen::internal::scalar_erfc_op
packetOp	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plgamma(a); }$/;"	f	struct:Eigen::internal::scalar_lgamma_op
packetOp	unsupported/test/cxx11_tensor_random.cpp	/^  internal::packet_traits<int>::type packetOp($/;"	f	struct:MyGenerator
packetRowMajor	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetRowMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetRowMajor	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetRowMajor(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetWithPossibleZero	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetWithPossibleZero(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetWithPossibleZero	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetWithPossibleZero(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packetWithPossibleZero	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType packetWithPossibleZero(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
packet_access_bit	Eigen/src/Core/Matrix.h	/^      packet_access_bit = (packet_traits<_Scalar>::Vectorizable && (EIGEN_UNALIGNED_VECTORIZE || (actual_alignment>=required_alignment))) ? PacketAccessBit : 0$/;"	e	enum:Eigen::internal::traits::__anon438
packet_access_bit	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    packet_access_bit = packet_traits<Scalar>::Vectorizable && is_aligned ? PacketAccessBit : 0$/;"	e	enum:Eigen::internal::compute_tensor_flags::__anon157
packet_helper	test/packetmath.cpp	/^struct packet_helper$/;"	s	file:
packet_helper	test/packetmath.cpp	/^struct packet_helper<false,Packet>$/;"	s	file:
packet_impl	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
packet_impl	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	struct:Eigen::internal::diagonal_product_evaluator_base
packet_traits	Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits<const T> : packet_traits<T> { };$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct packet_traits<float> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct packet_traits<Eigen::half> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<double>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int32_t>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<float> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packetmath	test/packetmath.cpp	/^template<typename Scalar> void packetmath()$/;"	f
packetmath_complex	test/packetmath.cpp	/^template<typename Scalar> void packetmath_complex()$/;"	f
packetmath_notcomplex	test/packetmath.cpp	/^template<typename Scalar> void packetmath_notcomplex()$/;"	f
packetmath_real	test/packetmath.cpp	/^template<typename Scalar> void packetmath_real()$/;"	f
packetmath_scatter_gather	test/packetmath.cpp	/^template<typename Scalar> void packetmath_scatter_gather()$/;"	f
pacos	Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { using std::acos; return acos(a); }$/;"	f	namespace:Eigen::internal
pad	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    pad(const PaddingDimensions& padding) const {$/;"	f	class:Eigen::TensorBase
pad	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    pad(const PaddingDimensions& padding, const Scalar padding_value) const {$/;"	f	class:Eigen::TensorBase
pad_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    char pad_[128];$/;"	m	class:Eigen::TensorEvaluator::Context
padd	Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd padd<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf padd<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d padd<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f padd<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f padd<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d padd<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return a + b; }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 padd<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 padd<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 padd<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(padd<Packet2d>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return vaddq_f64(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a + b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a + b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^DoublePacket<Packet> padd(const DoublePacket<Packet> &a, const DoublePacket<Packet> &b)$/;"	f	namespace:Eigen::internal
padding	bench/tensors/tensor_benchmarks.h	/^ void padding(int num_iters) {$/;"	f	class:BenchmarkSuite
padding	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    const PaddingDimensions& padding() const { return m_padding_dims; }$/;"	f	class:Eigen::TensorPaddingOp
padding_bottom	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex padding_bottom() const { return m_padding_bottom; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_bottom	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_bottom() const { return m_padding_bottom; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_bottom_z	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_bottom_z() const { return m_padding_bottom_z; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_explicit	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    bool padding_explicit() const { return m_padding_explicit; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_explicit	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    bool padding_explicit() const { return m_padding_explicit; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_left	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex padding_left() const { return m_padding_left; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_left	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_left() const { return m_padding_left; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_right	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex padding_right() const { return m_padding_right; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_right	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_right() const { return m_padding_right; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_top	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex padding_top() const { return m_padding_top; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_top	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_top() const { return m_padding_top; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_top_z	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex padding_top_z() const { return m_padding_top_z; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_type	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    PaddingType padding_type() const { return m_padding_type; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_type	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    PaddingType padding_type() const { return m_padding_type; }$/;"	f	class:Eigen::TensorVolumePatchOp
padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    Scalar padding_value() const { return m_padding_value; }$/;"	f	class:Eigen::TensorImagePatchOp
padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^    Scalar padding_value() const { return m_padding_value; }$/;"	f	class:Eigen::TensorPaddingOp
padding_value	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    Scalar padding_value() const { return m_padding_value; }$/;"	f	class:Eigen::TensorVolumePatchOp
paintEvent	demos/mandelbrot/mandelbrot.cpp	/^void MandelbrotWidget::paintEvent(QPaintEvent *)$/;"	f	class:MandelbrotWidget
paintGL	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::paintGL()$/;"	f	class:RenderingWidget
palign	Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal
palign_impl	Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX/Complex.h	/^struct palign_impl<Offset,Packet2cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX/Complex.h	/^struct palign_impl<Offset,Packet4cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX/PacketMath.h	/^struct palign_impl<Offset,Packet4d>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX/PacketMath.h	/^struct palign_impl<Offset,Packet8f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct palign_impl<Offset, Packet16f> {$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct palign_impl<Offset, Packet8d> {$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/ZVector/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/ZVector/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/ZVector/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
pand	Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pand   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pand   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pand<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pand<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pand<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pand<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pand(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pandnot<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pandnot<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pandnot<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pandnot<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pandnot<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pandnot<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pandnot(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return pand<Packet4i>(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	bench/bench_norm.cpp	/^Packet2d pandnot(const Packet2d& a, Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	bench/bench_norm.cpp	/^Packet4f pandnot(const Packet4f& a, Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
panel_bmod	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^void SparseLUImpl<Scalar,StorageIndex>::panel_bmod(const Index m, const Index w, const Index jcol, $/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,StorageIndex>::panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs_traits	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  panel_dfs_traits(Index jcol, StorageIndex* marker)$/;"	f	struct:Eigen::internal::panel_dfs_traits
panel_dfs_traits	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^struct panel_dfs_traits$/;"	s	namespace:Eigen::internal
panel_size	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index panel_size; \/\/ a panel consists of at most <panel_size> consecutive columns$/;"	m	struct:Eigen::internal::perfvalues
par	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar par, sum;$/;"	m	class:Eigen::LevenbergMarquardt
parallelFor	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  void parallelFor(Index n, const TensorOpCost& cost,$/;"	f	struct:Eigen::ThreadPoolDevice
parallel_pack_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const bool parallel_pack_;$/;"	m	class:Eigen::TensorEvaluator::Context
parallelize_gemm	Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, Index depth, bool transpose)$/;"	f	namespace:Eigen::internal
parameters	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Parameters parameters;$/;"	m	class:Eigen::HybridNonLinearSolver
parameters	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Parameters parameters;$/;"	m	class:Eigen::LevenbergMarquardt
parametrizedline	test/geo_parametrizedline.cpp	/^template<typename LineType> void parametrizedline(const LineType& _line)$/;"	f
parametrizedline_alignment	test/geo_parametrizedline.cpp	/^template<typename Scalar> void parametrizedline_alignment()$/;"	f
pardisoInit	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl
pardisoParameterArray	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl
pardisoRelease	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl
pardiso_run_selector	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_run_selector	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
parent	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType parent ;  \/* parent in parent tree super-column structure, if *\/$/;"	m	union:internal::colamd_col::__anon868
parg	Eigen/src/Core/GenericPacketMath.h	/^parg(const Packet& a) { using numext::arg; return arg(a); }$/;"	f	namespace:Eigen::internal
partialPivLu	Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase
partial_lu_decomp	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void partial_lu_decomp(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:blas_interface
partial_lu_decomp	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void partial_lu_decomp(const gene_matrix & X, gene_matrix & C, int  N){$/;"	f	class:eigen3_interface
partial_lu_decomp	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void partial_lu_decomp(const gene_matrix & X, gene_matrix & R, int N){$/;"	f	class:gmm_interface
partial_lu_impl	Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::StorageIndex& nb_transpositions)$/;"	f	namespace:Eigen::internal
partition_action_t	bench/analyze-blocking-sizes.cpp	/^struct partition_action_t : action_t$/;"	s	file:
pasin	Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { using std::asin; return asin(a); }$/;"	f	namespace:Eigen::internal
pasin	unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^template<> EIGEN_DONT_INLINE Packet4f pasin(Packet4f x)$/;"	f	namespace:Eigen::internal
pasin	unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^template<typename Packet> inline static Packet pasin(Packet a) { return std::asin(a); }$/;"	f	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
patan	Eigen/src/Core/GenericPacketMath.h	/^Packet patan(const Packet& a) { using std::atan; return atan(a); }$/;"	f	namespace:Eigen::internal
patch_cols	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex patch_cols() const { return m_patch_cols; }$/;"	f	class:Eigen::TensorImagePatchOp
patch_cols	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex patch_cols() const { return m_patch_cols; }$/;"	f	class:Eigen::TensorVolumePatchOp
patch_dims	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^    const PatchDim& patch_dims() const { return m_patch_dims; }$/;"	f	class:Eigen::TensorPatchOp
patch_planes	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex patch_planes() const { return m_patch_planes; }$/;"	f	class:Eigen::TensorVolumePatchOp
patch_rows	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex patch_rows() const { return m_patch_rows; }$/;"	f	class:Eigen::TensorImagePatchOp
patch_rows	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex patch_rows() const { return m_patch_rows; }$/;"	f	class:Eigen::TensorVolumePatchOp
pbetainc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet pbetainc(const Packet& a, const Packet& b,const Packet& x) { using numext::betainc; return betainc(a, b, x); }$/;"	f	namespace:Eigen::internal
pbetainc	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 pbetainc<double2>(const double2& a, const double2& b, const double2& x)$/;"	f	namespace:Eigen::internal
pbetainc	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 pbetainc<float4>(const float4& a, const float4& b, const float4& x)$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/GenericPacketMath.h	/^pblend(const Selector<unpacket_traits<Packet>::size>& ifPacket, const Packet& thenPacket, const Packet& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pblend(const Selector<4>& ifPacket, const Packet4d& thenPacket, const Packet4d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pblend(const Selector<8>& ifPacket, const Packet8f& thenPacket, const Packet8f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pblend(const Selector<16>& \/*ifPacket*\/,$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pblend(const Selector<8>& \/*ifPacket*\/,$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/SSE/Complex.h	/^template<>  EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {$/;"	f	namespace:Eigen::internal
pblend	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {$/;"	f	namespace:Eigen::internal
pblueNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar pblueNorm(const T& v)$/;"	f
pbroadcast2	Eigen/src/Core/GenericPacketMath.h	/^inline void pbroadcast2(const typename unpacket_traits<Packet>::type *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/GenericPacketMath.h	/^inline void pbroadcast4(const typename unpacket_traits<Packet>::type *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^pbroadcast4<Packet4i>(const int *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/SSE/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/SSE/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet2d>(const double *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet4f>(const float *a,$/;"	f	namespace:Eigen::internal
pbroadcast4	Eigen/src/Core/arch/ZVector/PacketMath.h	/^pbroadcast4<Packet4i>(const int *a,$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a, const SrcPacket& \/*b*\/) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/GenericPacketMath.h	/^pcast(const SrcPacket& a, const SrcPacket& \/*b*\/, const SrcPacket& \/*c*\/, const SrcPacket& \/*d*\/) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/AVX/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8f pcast<Packet8i, Packet8f>(const Packet8i& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/AVX/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8i pcast<Packet8f, Packet8i>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pcast<half2, float4>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE half2 pcast<float4, half2>(const float4& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet16f pcast<Packet16h, Packet16f>(const Packet16h& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet16h pcast<Packet16f, Packet16h>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet4h, Packet4f>(const Packet4h& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4h pcast<Packet4f, Packet4h>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8f pcast<Packet8h, Packet8f>(const Packet8h& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet8h pcast<Packet8f, Packet8h>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet2d pcast<Packet4f, Packet2d>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet2d, Packet4f>(const Packet2d& a, const Packet2d& b) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet4i, Packet4f>(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
pcast	Eigen/src/Core/arch/SSE/TypeCasting.h	/^template<> EIGEN_STRONG_INLINE Packet4i pcast<Packet4f, Packet4i>(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/GenericPacketMath.h	/^Packet pceil(const Packet& a) { using numext::ceil; return ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pceil<Packet4d>(const Packet4d& a) { return _mm256_ceil_pd(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pceil<Packet8f>(const Packet8f& a) { return _mm256_ceil_ps(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a) { return _mm_ceil_pd(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a) { return _mm_ceil_ps(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }$/;"	f	namespace:Eigen::internal
pceil	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return numext::conj(a); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pconj(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pconj(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pconj(const Packet4d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pconj(const Packet8f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pconj(const Packet8i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pconj(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pconj(const Packet16i& a) {$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pconj(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(pxor(a.v, reinterpret_cast<Packet2d>(p2ul_CONJ_XOR2))); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf(pxor<Packet4f>(a.v, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR))); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pconj(const double2& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pconj(const float4& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pconj(const half2& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v), p2ul_CONJ_XOR))); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd((Packet2d)vec_xor((Packet2d)a.v, (Packet2d)p2ul_CONJ_XOR2)); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) const { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if
pconj	Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
pcos	Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { using std::cos; return cos(a); }$/;"	f	namespace:Eigen::internal
pcos	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pcosh	Eigen/src/Core/GenericPacketMath.h	/^Packet pcosh(const Packet& a) { using std::cosh; return cosh(a); }$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pcplxflip<Packet2cd>(const Packet2cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pcplxflip<Packet4cf>(const Packet4cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/NEON/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/* <Packet1cd> *\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/* <Packet2cf> *\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pdigamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet pdigamma(const Packet& a) { using numext::digamma; return digamma(a); }$/;"	f	namespace:Eigen::internal
pdigamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 pdigamma<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
pdigamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 pdigamma<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pdiv<Packet2cd>(const Packet2cd& a, const Packet2cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pdiv<Packet4cf>(const Packet4cf& a, const Packet4cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pdiv<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pdiv<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pdiv<Packet8i>(const Packet8i& \/*a*\/, const Packet8i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pdiv<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pdiv<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_div(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pdiv<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pdiv<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pdiv<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return vdivq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a \/ b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a \/ b); }$/;"	f	namespace:Eigen::internal
pending_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  std::deque<Task> pending_;        \/\/ Queue of pending work$/;"	m	class:Eigen::SimpleThreadPoolTempl
perf	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet perf(const Packet& a) { using numext::erf; return erf(a); }$/;"	f	namespace:Eigen::internal
perf	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 perf<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
perf	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 perf<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
perfc	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet perfc(const Packet& a) { using numext::erfc; return erfc(a); }$/;"	f	namespace:Eigen::internal
perfc	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 perfc<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
perfc	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 perfc<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
performFrancisQRStep	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur
perfvalues	Eigen/src/SparseLU/SparseLU_Structs.h	/^struct perfvalues {$/;"	s	namespace:Eigen::internal
perm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& perm() const { return m_perm; }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
permutation	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    PermutationType permutation() {return m_permutation; }$/;"	f	class:Eigen::LevenbergMarquardt
permutation	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    PermutationMatrix<Dynamic,Dynamic> permutation;$/;"	m	class:Eigen::LevenbergMarquardt
permutationP	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const PermutationType& permutationP() const { eigen_assert("m_analysisIsOk"); return m_perm; }$/;"	f	class:Eigen::IncompleteCholesky
permutationP	Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU
permutationP	Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU
permutationP	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationP	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU
permutationP	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU
permutationPinv	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationQ	Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU
permutationQ	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU
permutationQ	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU
permutation_matrix_product	Eigen/src/Core/ProductEvaluators.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, DenseShape>$/;"	s	namespace:Eigen::internal
permutation_matrix_product	Eigen/src/Geometry/Homogeneous.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, HomogeneousShape>$/;"	s	namespace:Eigen::internal
permutation_matrix_product	Eigen/src/SparseCore/SparsePermutation.h	/^struct permutation_matrix_product<ExpressionType, Side, Transposed, SparseShape>$/;"	s	namespace:Eigen::internal
permutationmatrices	test/permutationmatrices.cpp	/^template<typename MatrixType> void permutationmatrices(const MatrixType& m)$/;"	f
permute_symm_to_fullsymm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::StorageIndex>& _dest, const typename MatrixType::StorageIndex* perm)$/;"	f	namespace:Eigen::internal
permute_symm_to_symm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::StorageIndex>& _dest, const typename MatrixType::StorageIndex* perm)$/;"	f	namespace:Eigen::internal
perturbCol0	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::perturbCol0$/;"	f	class:Eigen::BDCSVD
pexp	Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { using std::exp; return exp(a); }$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/AVX/MathFunctions.h	/^pexp<Packet4d>(const Packet4d& _x) {$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/AVX/MathFunctions.h	/^pexp<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^pexp<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 pexp<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 pexp<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 pexp<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pexp<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/NEON/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> pfirst<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet4d>(const Packet4d& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet8f>(const Packet8f& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet8i>(const Packet8i& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double pfirst<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float pfirst<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE int pfirst<Packet16i>(const Packet16i& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double  pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore<double>(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double pfirst<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  pfirst<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half pfirst<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(a, 0); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float   pfirst<Packet4f>(const Packet4f& a) { float   EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t pfirst<Packet4i>(const Packet4i& a) { int32_t EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float  EIGEN_ALIGN16 x[2]; vec_st2f(a.v4f[0], &x[0]); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int    EIGEN_ALIGN16 x[4]; pstore(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/GenericPacketMath.h	/^Packet pfloor(const Packet& a) { using numext::floor; return floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pfloor<Packet4d>(const Packet4d& a) { return _mm256_floor_pd(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pfloor<Packet8f>(const Packet8f& a) { return _mm256_floor_ps(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return _mm_floor_pd(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return _mm_floor_ps(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }$/;"	f	namespace:Eigen::internal
pfloor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/GenericPacketMath.h	/^ template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline Packet pgather(const Scalar* from, Index \/*stride*\/)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cd pgather<std::complex<double>, Packet2cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4cf pgather<std::complex<float>, Packet4cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4d pgather<double, Packet4d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet8f pgather<float, Packet8f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline Packet16f pgather<float, Packet16f>(const float* from,$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline Packet8d pgather<double, Packet8d>(const double* from,$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double2 pgather<double, double2>(const double* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float4 pgather<float, float4>(const float* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pgather<Eigen::half, half2>(const Eigen::half* from, Index stride) {$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int32_t, Packet4i>(const int32_t* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride EIGEN_UNUSED)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)$/;"	f	namespace:Eigen::internal
pgather	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)$/;"	f	namespace:Eigen::internal
pigamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet pigamma(const Packet& a, const Packet& x) { using numext::igamma; return igamma(a, x); }$/;"	f	namespace:Eigen::internal
pigamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 pigamma<double2>(const double2& a, const double2& x)$/;"	f	namespace:Eigen::internal
pigamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 pigamma<float4>(const float4& a, const float4& x)$/;"	f	namespace:Eigen::internal
pigammac	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet pigammac(const Packet& a, const Packet& x) { using numext::igammac; return igammac(a, x); }$/;"	f	namespace:Eigen::internal
pigammac	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 pigammac<double2>(const double2& a, const double2& x)$/;"	f	namespace:Eigen::internal
pigammac	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 pigammac<float4>(const float4& a, const float4& x)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/GenericPacketMath.h	/^pinsertfirst(const Packet& a, typename unpacket_traits<Packet>::type b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pinsertfirst(const Packet2cd& a, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pinsertfirst(const Packet4cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pinsertfirst(const Packet4d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pinsertfirst(const Packet8f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pinsertfirst(const Packet1cd&, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pinsertfirst(const Packet2cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pinsertfirst(const Packet2d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pinsertfirst(const Packet4f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/GenericPacketMath.h	/^pinsertlast(const Packet& a, typename unpacket_traits<Packet>::type b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pinsertlast(const Packet2cd& a, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pinsertlast(const Packet4cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pinsertlast(const Packet4d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pinsertlast(const Packet8f& a, float b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pinsertlast(const Packet1cd&, std::complex<double> b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pinsertlast(const Packet2cf& a, std::complex<float> b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pinsertlast(const Packet2d& a, double b)$/;"	f	namespace:Eigen::internal
pinsertlast	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pinsertlast(const Packet4f& a, float b)$/;"	f	namespace:Eigen::internal
pivotL	Eigen/src/SparseLU/SparseLU_pivotL.h	/^Index SparseLUImpl<Scalar,StorageIndex>::pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
plain_array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_DEVICE_FUNC plain_array() {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array() $/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array()$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) $/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert)$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 32>$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 64>$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 8>$/;"	s	namespace:Eigen::internal
plain_matrix_type	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
plain_object_eval	Eigen/src/SparseCore/SparseUtil.h	/^struct plain_object_eval<T,Sparse>$/;"	s	namespace:Eigen::internal
planeInflateStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index planeInflateStride() const { return m_plane_inflate_strides; }$/;"	f	struct:Eigen::TensorEvaluator
planePaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index planePaddingTop() const { return m_planePaddingTop; }$/;"	f	struct:Eigen::TensorEvaluator
plane_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex plane_inflate_strides() const { return m_plane_inflate_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
plane_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex plane_strides() const { return m_plane_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
planes	test/geo_hyperplane.cpp	/^template<typename Scalar> void planes()$/;"	f
plgamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet plgamma(const Packet& a) { using numext::lgamma; return lgamma(a); }$/;"	f	namespace:Eigen::internal
plgamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 plgamma<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
plgamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 plgamma<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pload <Packet2cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pload <Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet4cf(pload<Packet8f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pload<Packet4d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pload<Packet8f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pload<Packet8i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm256_load_si256(reinterpret_cast<const __m256i*>(from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pload<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pload<Packet16i>(const int* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pload<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>*        from) { return Packet2cf(pload<Packet4f>((const float *) from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pload<double2>(const double* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pload<float4>(const float* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pload<half2>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f64(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*    from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int32_t*  from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const __m128i*>(from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/GenericPacketMath.h	/^pload1(const typename unpacket_traits<Packet>::type  *a) { return pset1<Packet>(*a); }$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pload1<Packet4d>(const double* from) { return _mm256_broadcast_sd(from); }$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pload1<Packet8f>(const float*  from) { return _mm256_broadcast_ss(from); }$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pload1<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pload1<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
pload1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload1<Packet4f>(const float *from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd ploaddup<Packet2cd>(const std::complex<double>* from) { return pset1<Packet2cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf ploaddup<Packet4cf>(const std::complex<float>* from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d ploaddup<Packet4d>(const double* from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploaddup<Packet8f>(const float* from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploaddup<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploaddup<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from)  { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double2 ploaddup<double2>(const double*  from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float4 ploaddup<float4>(const float*   from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> EIGEN_STRONG_INLINE half2 ploaddup<half2>(const Eigen::half*  from) {$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int32_t* from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from) {  return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*      from) {  return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*    from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploadquad	Eigen/src/Core/GenericPacketMath.h	/^ploadquad(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadquad	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploadquad<Packet8f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadquad	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploadquad<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadquad	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploadquad<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt	Eigen/src/Core/GenericPacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/GenericPacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt_ro(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE double2 ploadt_ro<double2, Aligned>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE double2 ploadt_ro<double2, Unaligned>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE float4 ploadt_ro<float4, Aligned>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE float4 ploadt_ro<float4, Unaligned>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^ __device__ EIGEN_ALWAYS_INLINE half2 ploadt_ro<half2, Aligned>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadt_ro	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^__device__ EIGEN_ALWAYS_INLINE half2 ploadt_ro<half2, Unaligned>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd ploadu<Packet2cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf ploadu<Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet4cf(ploadu<Packet8f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d ploadu<Packet4d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_pd(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f ploadu<Packet8f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_ps(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i ploadu<Packet8i>(const int* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm256_loadu_si256(reinterpret_cast<const __m256i*>(from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f ploadu<Packet16f>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i ploadu<Packet16i>(const int* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d ploadu<Packet8d>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>*       from) { return Packet2cf(ploadu<Packet4f>((const float*) from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 ploadu<double2>(const double* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 ploadu<float4>(const float* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 ploadu<half2>(const Eigen::half* from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f64(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*   from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int32_t* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double*    from) { return pload<Packet2d>(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*     from) { return pload<Packet4f>(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*       from) { return pload<Packet4i>(from); }$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { using std::log; return log(a); }$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/AVX/MathFunctions.h	/^plog<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^plog<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 plog<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 plog<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 plog<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plog<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plog10	Eigen/src/Core/GenericPacketMath.h	/^Packet plog10(const Packet& a) { using std::log10; return log10(a); }$/;"	f	namespace:Eigen::internal
plog1p	Eigen/src/Core/GenericPacketMath.h	/^Packet plog1p(const Packet& a) { return numext::log1p(a); }$/;"	f	namespace:Eigen::internal
plog1p	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 plog1p<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
plog1p	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 plog1p<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
plog1p	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plog1p<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/GenericPacketMath.h	/^plset(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d plset<Packet4d>(const double& a) { return _mm256_add_pd(_mm256_set1_pd(a), _mm256_set_pd(3.0,2.0,1.0,0.0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f plset<Packet8f>(const float& a) { return _mm256_add_ps(_mm256_set1_ps(a), _mm256_set_ps(7.0,6.0,5.0,4.0,3.0,2.0,1.0,0.0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f plset<Packet16f>(const float& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d plset<Packet8d>(const double& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return pset1<Packet2d>(a) + p2d_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return pset1<Packet4f>(a) + p4f_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)   { return pset1<Packet4i>(a) + p4i_COUNTDOWN; }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 plset<double2>(const double& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 plset<float4>(const float& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 plset<half2>(const Eigen::half& a) {$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int32_t& a)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return padd<Packet2d>(pset1<Packet2d>(a), p2d_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a)  { return padd<Packet4f>(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)    { return padd<Packet4i>(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plt	bench/bench_norm.cpp	/^Packet2d plt(const Packet2d& a, Packet2d& b) { return _mm_cmplt_pd(a,b); }$/;"	f	namespace:Eigen::internal
plt	bench/bench_norm.cpp	/^Packet4f plt(const Packet4f& a, Packet4f& b) { return _mm_cmplt_ps(a,b); }$/;"	f	namespace:Eigen::internal
pm	doc/snippets/HessenbergDecomposition_packedMatrix.cpp	/^Matrix4d pm = hessOfA.packedMatrix();$/;"	v
pm	doc/snippets/Tridiagonalization_packedMatrix.cpp	/^Matrix4d pm = triOfA.packedMatrix();$/;"	v
pmadd	Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet2cd& y, const Packet2cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet4cf& y, const Packet4cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmadd(const Packet4d& a, const Packet4d& b, const Packet4d& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmadd(const Packet8f& a, const Packet8f& b, const Packet8f& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmadd(const Packet16f& a, const Packet16f& b,$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmadd(const Packet8d& a, const Packet8d& b,$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return a*b + c; }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmadd<half2>(const half2& a, const half2& b, const half2& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vfmaq_f64(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vmlaq_f64(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vfmaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return _mm_fmadd_pd(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return _mm_fmadd_ps(a,b,c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pmadd(const double& a, const double& b, const double& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float pmadd(const float& a, const float& b, const float& c) {$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c)$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd<Packet4i>(pmul<Packet4i>(a, b), c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const LhsScalar& x, const RhsScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmax	Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmax<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmax<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmax<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmax<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmax<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmax<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmax<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vmaxq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmin<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmin<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmin<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmin<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmin<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmin<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmin<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vminq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& a, const Packet2cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/AVX/Complex.h	/^  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& a, const Packet4cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pmul<Packet2cd>(const Packet2cd& a, const Packet2cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pmul<Packet4cf>(const Packet4cf& a, const Packet4cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pmul<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pmul<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pmul<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pmul<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_madd(a,b,p2d_MZERO); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b, p4f_MZERO); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return a * b; }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pmul<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pmul<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pmul<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return vmulq_f64(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/ZVector/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a * b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a * b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const LhsScalar& x, const RhsScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pnegate	Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pnegate(const Packet2cd& a) { return Packet2cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pnegate(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pnegate(const Packet4d& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pnegate(const Packet8f& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pnegate(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pnegate(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return p2d_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return p4f_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return p4i_ZERO - a; }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pnegate(const double2& a) {$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pnegate(const float4& a) {$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pnegate(const half2& a) {$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate<Packet2d>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return vnegq_f64(a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(Packet4f(a.v))); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return (-a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return (-a); }$/;"	f	namespace:Eigen::internal
pnorm	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
pnorm	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
pointAt	Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt(const _Scalar& t) const$/;"	f	class:Eigen::ParametrizedLine
pointer	Eigen/src/Core/util/Memory.h	/^  typedef T*              pointer;$/;"	t	class:Eigen::aligned_allocator
pointer	Eigen/src/StlSupport/details.h	/^    typedef T*              pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
polevl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct polevl {$/;"	s	namespace:Eigen::internal::cephes
polevl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct polevl<Scalar, 0> {$/;"	s	namespace:Eigen::internal::cephes
poly_eval	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^T poly_eval( const Polynomials& poly, const T& x )$/;"	f	namespace:Eigen
poly_eval_horner	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^T poly_eval_horner( const Polynomials& poly, const T& x )$/;"	f	namespace:Eigen
polygamma	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    polygamma(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
polygamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^polygamma(const Eigen::ArrayBase<DerivedN>& n, const Eigen::ArrayBase<DerivedX>& x)$/;"	f	namespace:Eigen
polygamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half polygamma(const Eigen::half& n, const Eigen::half& x) {$/;"	f	namespace:Eigen::numext
polygamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^polygamma(const Scalar& n, const Scalar& x) {$/;"	f	namespace:Eigen::numext
polygamma_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct polygamma_impl {$/;"	s	namespace:Eigen::internal
polygamma_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct polygamma_retval {$/;"	s	namespace:Eigen::internal
polynomialsolver	unsupported/test/polynomialsolver.cpp	/^void polynomialsolver(int deg)$/;"	f
pool	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^    NonBlockingThreadPoolTempl* pool;  \/\/ Parent pool, or null for normal threads.$/;"	m	struct:Eigen::NonBlockingThreadPoolTempl::PerThread
pool	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    SimpleThreadPoolTempl* pool;  \/\/ Parent pool, or null for normal threads.$/;"	m	struct:Eigen::SimpleThreadPoolTempl::PerThread
pool_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  ThreadPoolInterface* pool_;$/;"	m	struct:Eigen::ThreadPoolDevice
popMatrix	demos/opengl/gpuhelper.h	/^inline void GpuHelper::popMatrix(GLenum matrixTarget)$/;"	f	class:GpuHelper
popProjectionMode2D	demos/opengl/gpuhelper.cpp	/^void GpuHelper::popProjectionMode2D(void)$/;"	f	class:GpuHelper
pop_back	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  void pop_back() {$/;"	f	class:Eigen::MaxSizeVector
por	Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd por    <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf por    <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d por<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f por<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f por<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d por<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(por(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
position	demos/opengl/camera.h	/^    Eigen::Vector3f position;$/;"	m	class:Frame
position	demos/opengl/camera.h	/^    inline const Eigen::Vector3f& position(void) const { return mFrame.position; }$/;"	f	class:Camera
positive_real_hypot	Eigen/src/Core/MathFunctionsImpl.h	/^RealScalar positive_real_hypot(const RealScalar& x, const RealScalar& y)$/;"	f	namespace:Eigen::internal
pot_block_size	bench/analyze-blocking-sizes.cpp	/^  uint16_t pot_block_size;$/;"	m	struct:inputfile_entry_t	file:
pow	Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<ExponentDerived>& exponents) $/;"	f	namespace:Eigen
pow	Eigen/src/Core/GlobalFunctions.h	/^  pow(const Scalar& x, const Eigen::ArrayBase<Derived>& exponents)$/;"	f	namespace:Eigen
pow	Eigen/src/Core/GlobalFunctions.h	/^  pow(const typename Derived::Scalar& x, const Eigen::ArrayBase<Derived>& exponents)$/;"	f	namespace:Eigen
pow	Eigen/src/Core/MathFunctions.h	/^inline typename internal::pow_impl<ScalarX,ScalarY>::result_type pow(const ScalarX& x, const ScalarY& y)$/;"	f	namespace:Eigen::numext
pow	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half pow(const half& a, const half& b) {$/;"	f	namespace:Eigen::half_impl
pow	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    pow(Scalar exponent) const {$/;"	f	class:Eigen::TensorBase
pow	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^pow(const Eigen::AutoDiffScalar<DerType> &x, const typename internal::traits<typename internal::remove_all<DerType>::type>::Scalar &y)$/;"	f	namespace:Eigen
pow	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^const MatrixComplexPowerReturnValue<Derived> MatrixBase<Derived>::pow(const std::complex<RealScalar>& p) const$/;"	f	class:Eigen::MatrixBase
pow	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^const MatrixPowerReturnValue<Derived> MatrixBase<Derived>::pow(const RealScalar& p) const$/;"	f	class:Eigen::MatrixBase
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow_impl	Eigen/src/Core/MathFunctions.h	/^struct pow_impl$/;"	s	namespace:Eigen::internal
pow_impl	Eigen/src/Core/MathFunctions.h	/^struct pow_impl<ScalarX,ScalarY, true>$/;"	s	namespace:Eigen::internal
powh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half powh(const Eigen::half& a, const Eigen::half& b) {$/;"	f
ppolygamma	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet ppolygamma(const Packet& n, const Packet& x) { using numext::polygamma; return polygamma(n, x); }$/;"	f	namespace:Eigen::internal
ppolygamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 ppolygamma<double2>(const double2& n, const double2& x)$/;"	f	namespace:Eigen::internal
ppolygamma	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 ppolygamma<float4>(const float4& n, const float4& x)$/;"	f	namespace:Eigen::internal
precision	Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat
precision	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    RealScalar precision() const {$/;"	f	class:Eigen::SkylineInplaceLU
preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
predux	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return (vget_low_f64(a) + vget_high_f64(a))[0]; }$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return vget_lane_f64(vget_low_f64(a) + vget_high_f64(a), 0); }$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op
predux	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op
predux	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op
predux	Eigen/src/Core/functors/BinaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op
predux_downto4	Eigen/src/Core/GenericPacketMath.h	/^predux_downto4(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_downto4	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f predux_downto4<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_downto4	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet4d predux_downto4<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_downto4	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8f predux_downto4<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_downto4	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^const DoublePacket<Packet>& predux_downto4(const DoublePacket<Packet> &a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_max<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_max<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_max<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_max<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_max<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(vpmaxq_f64(a, a), 0); }$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_min<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_min<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_min<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_min<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_min<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a) { return vgetq_lane_f64(vpminq_f64(a, a), 0); }$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet2cd>(const Packet2cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet4cf>(const Packet4cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet4d>(const Packet4d& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet8f>(const Packet8f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE double predux_mul<Packet8d>(const Packet8d& a) {$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE float predux_mul<Packet16f>(const Packet16f& a) {$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline double predux_mul<double2>(const double2& a) {$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline float  predux_mul<float4>(const float4& a) {$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE Eigen::half predux_mul<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a) { return (vget_low_f64(a) * vget_high_f64(a))[0]; }$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a) { return vget_lane_f64(vget_low_f64(a) * vget_high_f64(a), 0); }$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int32_t predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd preduxp<Packet2cd>(const Packet2cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf preduxp<Packet4cf>(const Packet4cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d preduxp<Packet4d>(const Packet4d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f preduxp<Packet8f>(const Packet8f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f preduxp<Packet16f>(const Packet16f*$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8d preduxp<Packet8d>(const Packet8d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)        { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> EIGEN_DEVICE_FUNC inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> * addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> * addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr)    { EIGEN_PPC_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ARM_PREFETCH((const double *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((const float *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>  (const float*    addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int32_t>(const int32_t*  addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *     addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { EIGEN_ZVECTOR_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
prefetch	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_STRONG_INLINE void prefetch(Index \/*i*\/) { }$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
prefetchIntoRegisters	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	100;"	d
prefetchIntoRegisters	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	292;"	d
prefetch_lhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	543;"	d
prefetch_lhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	688;"	d
preloadKernel	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void preloadKernel() {$/;"	f	struct:Eigen::TensorEvaluator
preloadKernel	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  EIGEN_STRONG_INLINE void preloadKernel() {$/;"	f	struct:Eigen::TensorEvaluator
preprocessed_inputfile_entry_t	bench/analyze-blocking-sizes.cpp	/^struct preprocessed_inputfile_entry_t$/;"	s	file:
preprocessed_inputfile_t	bench/analyze-blocking-sizes.cpp	/^  preprocessed_inputfile_t(const inputfile_t& inputfile)$/;"	f	struct:preprocessed_inputfile_t
preprocessed_inputfile_t	bench/analyze-blocking-sizes.cpp	/^struct preprocessed_inputfile_t$/;"	s	file:
prered	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar actred, prered;$/;"	m	class:Eigen::HybridNonLinearSolver
prered	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
prerotate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(const Scalar& s)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
preserve_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct preserve_inner_most_dims {$/;"	s	namespace:Eigen::internal
preserve_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct preserve_inner_most_dims<ReducedDims, NumTensorDims, ColMajor>{$/;"	s	namespace:Eigen::internal
preserve_inner_most_dims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^struct preserve_inner_most_dims<ReducedDims, NumTensorDims, RowMajor>{$/;"	s	namespace:Eigen::internal
preshear	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
pretranslate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
pretty_printers_dict	debug/gdb/printers.py	/^pretty_printers_dict = {}$/;"	v
prev	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType prev ;  \/* previous column in degree list, if col is in a *\/$/;"	m	union:internal::colamd_col::__anon870
preverse	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> EIGEN_DEVICE_FUNC inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd preverse(const Packet2cd& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf preverse(const Packet4cf& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d preverse(const Packet4d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f preverse(const Packet8f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet16f preverse(const Packet16f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AVX512/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8d preverse(const Packet8d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a) { return vcombine_f64(vget_high_f64(a), vget_low_f64(a)); }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(Packet2d(_mm_castps_pd(a.v))))); }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
printBenchStyle	bench/spbench/spbenchstyle.h	/^void printBenchStyle(std::ofstream& out)$/;"	f
printInfoLog	unsupported/test/openglsupport.cpp	/^void printInfoLog(GLuint objectID)$/;"	f
printStatheader	bench/spbench/spbenchsolver.h	/^void printStatheader(std::ofstream& out)$/;"	f
print_array	demos/mix_eigen_and_c/example.c	/^void print_array(double *array, int n)$/;"	f
print_matrix	Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal
print_mode	bench/product_threshold.cpp	/^void print_mode(int mode)$/;"	f
print_n	bench/product_threshold.cpp	/^template<> struct print_n<END> { static void run(){} };$/;"	s	file:
print_n	bench/product_threshold.cpp	/^template<int N> struct print_n$/;"	s	file:
print_partition	bench/analyze-blocking-sizes.cpp	/^void print_partition($/;"	f
print_size	doc/examples/function_taking_eigenbase.cpp	/^void print_size(const EigenBase<Derived>& b)$/;"	f
processDataLineBluestein	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void processDataLineBluestein(ComplexScalar* line_buf, Index line_len, Index good_composite, Index log_len, ComplexScalar* a, ComplexScalar* b, const ComplexScalar* pos_j_base_powered) {$/;"	f	struct:Eigen::TensorEvaluator
processDataLineCooleyTukey	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void processDataLineCooleyTukey(ComplexScalar* line_buf, Index line_len, Index log_len) {$/;"	f	struct:Eigen::TensorEvaluator
processRow	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void processRow(const LhsEval& lhsEval, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha, Index i, Index col)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
processTriangularMatrix	unsupported/test/matrix_functions.h	/^struct processTriangularMatrix$/;"	s
processTriangularMatrix	unsupported/test/matrix_functions.h	/^struct processTriangularMatrix<MatrixType,0>$/;"	s
prod	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase
prod	Eigen/src/Core/VectorwiseOp.h	/^    const ProdReturnType prod() const$/;"	f	class:Eigen::VectorwiseOp
prod	bench/product_threshold.cpp	/^EIGEN_DONT_INLINE void prod(const Lhs& a, const Rhs& b, Res& c)$/;"	f
prod	test/evaluators.cpp	/^  prod(const Lhs& lhs, const Rhs& rhs)$/;"	f	namespace:Eigen
prod	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    prod() const {$/;"	f	class:Eigen::TensorBase
prod	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    prod(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
product	test/product.h	/^template<typename MatrixType> void product(const MatrixType& m)$/;"	f
product1x1	test/product_small.cpp	/^void product1x1()$/;"	f
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, LazyCoeffBasedProductMode, DenseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, DenseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, Options>, ProductTag, LhsShape, RhsShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DenseShape, DiagonalShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Core/ProductEvaluators.h	/^struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DiagonalShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/Geometry/Homogeneous.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, DenseShape, HomogeneousShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/Geometry/Homogeneous.h	/^struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, HomogeneousShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, DenseShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, OuterProduct, SparseShape, DenseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  explicit product_evaluator(const XprType& xpr) : Base(xpr.lhs(), xpr.rhs().diagonal().transpose()) {}$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  explicit product_evaluator(const XprType& xpr) : Base(xpr.rhs(), xpr.lhs().diagonal()) {}$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, ProductTag, DiagonalShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, ProductTag, SparseShape, DiagonalShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparsePermutation.h	/^  explicit product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/SparseCore/SparsePermutation.h	/^struct product_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, PermutationShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparsePermutation.h	/^struct product_evaluator<Product<Lhs, Rhs, AliasFreeProduct>, ProductTag, SparseShape, PermutationShape >$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  product_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::product_evaluator
product_evaluator	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct product_evaluator<Product<Lhs, RhsView, DefaultProduct>, ProductTag, SparseShape, SparseSelfAdjointShape>$/;"	s	namespace:Eigen::internal
product_evaluator	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct product_evaluator<Product<LhsView, Rhs, DefaultProduct>, ProductTag, SparseSelfAdjointShape, SparseShape>$/;"	s	namespace:Eigen::internal
product_extra	test/product_extra.cpp	/^template<typename MatrixType> void product_extra(const MatrixType& m)$/;"	f
product_notemporary	test/product_notemporary.cpp	/^template<typename MatrixType> void product_notemporary(const MatrixType& m)$/;"	f
product_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct product_op       {$/;"	s	namespace:Eigen::internal
product_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct product_op {$/;"	s	namespace:Eigen::internal
product_promote_storage_type	Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Dense,Sparse, OuterProduct> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Sparse,Dense, OuterProduct> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<PermutationStorage, Sparse,             ProductTag> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_promote_storage_type	Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<Sparse,             PermutationStorage, ProductTag> { typedef Sparse ret; };$/;"	s	namespace:Eigen::internal
product_selfadjoint	test/product_selfadjoint.cpp	/^template<typename MatrixType> void product_selfadjoint(const MatrixType& m)$/;"	f
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size	bench/analyze-blocking-sizes.cpp	/^    uint16_t product_size;$/;"	m	struct:evaluate_defaults_action_t::results_entry_t	file:
product_size	bench/analyze-blocking-sizes.cpp	/^  uint16_t product_size;$/;"	m	struct:inputfile_entry_t	file:
product_size	bench/analyze-blocking-sizes.cpp	/^  uint16_t product_size;$/;"	m	struct:preprocessed_inputfile_entry_t	file:
product_size_category	Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal
product_type	Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int M>         struct product_type_selector<M, 1, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int N>         struct product_type_selector<1, N, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
project	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void project(MatrixSolver &OP, int n, int k, Scalar *vecs)$/;"	f	struct:Eigen::internal::OP
projection	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projectionMatrix	demos/opengl/camera.cpp	/^const Matrix4f& Camera::projectionMatrix(void) const$/;"	f	class:Camera
projective_transform_inverse	Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
promote	unsupported/test/FFTW.cpp	/^complex<long double>  promote(complex<T> x) { return complex<long double>((long double)x.real(),(long double)x.imag()); }$/;"	f
promote	unsupported/test/FFTW.cpp	/^complex<long double>  promote(double x) { return complex<long double>((long double)x); }$/;"	f
promote	unsupported/test/FFTW.cpp	/^complex<long double>  promote(float x) { return complex<long double>((long double)x); }$/;"	f
promote	unsupported/test/FFTW.cpp	/^complex<long double>  promote(long double x) { return complex<long double>((long double)x); }$/;"	f
promote_index_type	Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_scalar_arg	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg<S,T,false> : promote_scalar_arg_unsupported<S,T,typename NumTraits<S>::Literal> {};$/;"	s	namespace:Eigen::internal
promote_scalar_arg	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg<S,T,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<ExprScalar,T,PromotedType,false,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,PromotedType,ConvertibleToLiteral,false> {};$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,PromotedType,true,true>$/;"	s	namespace:Eigen::internal
promote_scalar_arg_unsupported	Eigen/src/Core/util/XprHelper.h	/^struct promote_scalar_arg_unsupported<S,T,S,false,true> {};$/;"	s	namespace:Eigen::internal
pround	Eigen/src/Core/GenericPacketMath.h	/^Packet pround(const Packet& a) { using numext::round; return round(a); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pround<Packet4d>(const Packet4d& a) { return _mm256_round_pd(a, _MM_FROUND_CUR_DIRECTION); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pround<Packet8f>(const Packet8f& a) { return _mm256_round_ps(a, _MM_FROUND_CUR_DIRECTION); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return _mm_round_pd(a, 0); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return _mm_round_ps(a, 0); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }$/;"	f	namespace:Eigen::internal
pround	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/GenericPacketMath.h	/^Packet prsqrt(const Packet& a) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet4d prsqrt<Packet4d>(const Packet4d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f prsqrt<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f prsqrt<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet16f prsqrt<Packet16f>(const Packet16f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^prsqrt<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^prsqrt<Packet8d>(const Packet8d& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 prsqrt<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 prsqrt<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 prsqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 prsqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& _x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d prsqrt<Packet2d>(const Packet2d& x) {$/;"	f	namespace:Eigen::internal
prsqrt	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f prsqrt<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
prune	Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage
prune	Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix
prune	Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix
prune	Eigen/src/SparseCore/SparseVector.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector
prune	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = dummy_precision<RealScalar > ()) {$/;"	f	class:Eigen::SkylineMatrix
prune	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void prune(Scalar reference, RealScalar epsilon = dummy_precision<RealScalar>()) {$/;"	f	class:Eigen::SkylineStorage
prune	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::DynamicSparseMatrix
pruneL	Eigen/src/SparseLU/SparseLU_pruneL.h	/^void SparseLUImpl<Scalar,StorageIndex>::pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg,$/;"	f	class:Eigen::internal::SparseLUImpl
prune_column	test/sparse_solver.h	/^  prune_column(Index col) : m_col(col) {}$/;"	f	struct:prune_column
prune_column	test/sparse_solver.h	/^struct prune_column {$/;"	s
pruned	Eigen/src/SparseCore/SparseView.h	/^SparseMatrixBase<Derived>::pruned(const Scalar& reference,$/;"	f	class:Eigen::SparseMatrixBase
pscatter	Eigen/src/Core/GenericPacketMath.h	/^ template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pscatter(Scalar* to, const Packet& from, Index \/*stride*\/)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet2cd>(std::complex<double>* to, const Packet2cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet4cf>(std::complex<float>* to, const Packet4cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet4d>(double* to, const Packet4d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet8f>(float* to, const Packet8f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void pscatter<double, Packet8d>(double* to,$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void pscatter<float, Packet16f>(float* to,$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, double2>(double* to, const double2& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, float4>(float* to, const float4& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pscatter<Eigen::half, half2>(Eigen::half* to, const half2& from, Index stride) {$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int32_t, Packet4i>(int32_t* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride EIGEN_UNUSED)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)$/;"	f	namespace:Eigen::internal
pscatter	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pset1<Packet2cd>(const std::complex<double>& from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pset1<Packet4cf>(const std::complex<float>& from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pset1<Packet4d>(const double& from) { return _mm256_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pset1<Packet8f>(const float&  from) { return _mm256_set1_ps(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8i pset1<Packet8i>(const int&    from) { return _mm256_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pset1<Packet16f>(const float& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16i pset1<Packet16i>(const int& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pset1<Packet8d>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double&  from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 pset1<double2>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 pset1<float4>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 pset1<half2>(const Eigen::half& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double&  from) { return vdupq_n_f64(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int32_t&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps1(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&    from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)$/;"	f	namespace:Eigen::internal
pseudoEigenvalueMatrix	Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver
pseudoEigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver
pseudoInverse	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const Inverse<CompleteOrthogonalDecomposition> pseudoInverse() const$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
pseudo_inverse	unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^void pseudo_inverse(const CMatrix &C, CINVMatrix &CINV)$/;"	f	namespace:Eigen::internal
pseudo_random	bench/btl/generic_bench/init/init_function.hh	/^double pseudo_random(int \/*index*\/)$/;"	f
pseudo_random	bench/btl/generic_bench/init/init_function.hh	/^double pseudo_random(int \/*index_i*\/, int \/*index_j*\/)$/;"	f
pshiftleft	Eigen/src/Core/arch/AVX/MathFunctions.h	/^inline Packet8i pshiftleft(Packet8i v, int n)$/;"	f	namespace:Eigen::internal
pshiftright	Eigen/src/Core/arch/AVX/MathFunctions.h	/^inline Packet8f pshiftright(Packet8f v, int n)$/;"	f	namespace:Eigen::internal
psin	Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { using std::sin; return sin(a); }$/;"	f	namespace:Eigen::internal
psin	Eigen/src/Core/arch/AVX/MathFunctions.h	/^psin<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
psin	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psinh	Eigen/src/Core/GenericPacketMath.h	/^Packet psinh(const Packet& a) { using std::sinh; return sinh(a); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { using std::sqrt; return sqrt(a); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet4d psqrt<Packet4d>(const Packet4d& x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^Packet8f psqrt<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX/MathFunctions.h	/^psqrt<Packet8f>(const Packet8f& _x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet16f psqrt<Packet16f>(const Packet16f& x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^EIGEN_STRONG_INLINE Packet8d psqrt<Packet8d>(const Packet8d& x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^psqrt<Packet16f>(const Packet16f& _x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AVX512/MathFunctions.h	/^psqrt<Packet8d>(const Packet8d& _x) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/AltiVec/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^double2 psqrt<double2>(const double2& a)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/CUDA/MathFunctions.h	/^float4 psqrt<float4>(const float4& a)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^half2 psqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 psqrt<half2>(const half2& a) {$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x) { return _mm_sqrt_pd(x); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x) { return _mm_sqrt_ps(x); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet2d psqrt<Packet2d>(const Packet2d& x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/ZVector/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& x)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet2cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float>* to, const Packet4cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet8f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet8i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm256_storeu_si256(reinterpret_cast<__m256i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet8d& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<float>(float* to, const Packet16f& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore<int>(int* to, const Packet16i& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstore<double>(double* to, const double2& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstore<float>(float*   to, const float4& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pstore<Eigen::half>(Eigen::half* to, const half2& from) {$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f64(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>  (float*    to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int32_t>(int32_t*  to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, Packet2d(from.v)); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), Packet4f(from.v)); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<__m128i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet8f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet8i>(int* to, const int& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet16f>(float* to, const float& a) {$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet16i>(int* to, const int& a) {$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstore1<Packet8d>(double* to, const double& a) {$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstoret	Eigen/src/Core/GenericPacketMath.h	/^EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet2cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float>* to, const Packet4cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet4d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet8f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet8i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm256_storeu_si256(reinterpret_cast<__m256i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet8d& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<float>(float* to, const Packet16f& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE void pstoreu<int>(int* to, const Packet16i& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const double2& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const float4& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE void pstoreu<Eigen::half>(Eigen::half* to, const half2& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f64(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>  (float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int32_t>(int32_t* to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, Packet2d(from.v)); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), Packet4f(from.v)); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_si128(reinterpret_cast<__m128i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from) { pstore<double>(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*    to, const Packet4f& from) { pstore<float>(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*        to, const Packet4i& from) { pstore<int>(to, from); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd psub<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf psub<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d psub<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f psub<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f psub<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d psub<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return a - b; }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double2 psub<double2>(const double2& a, const double2& b) {$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float4 psub<float4>(const float4& a, const float4& b) {$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> __device__ EIGEN_STRONG_INLINE half2 psub<half2>(const half2& a, const half2& b) {$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(psub<Packet2d>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return vsubq_f64(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a - b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a - b); }$/;"	f	namespace:Eigen::internal
ptan	Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { using std::tan; return tan(a); }$/;"	f	namespace:Eigen::internal
ptanh	Eigen/src/Core/GenericPacketMath.h	/^Packet ptanh(const Packet& a) { using std::tanh; return tanh(a); }$/;"	f	namespace:Eigen::internal
ptanh	Eigen/src/Core/arch/AVX/MathFunctions.h	/^ptanh<Packet8f>(const Packet8f& x) {$/;"	f	namespace:Eigen::internal
ptanh	Eigen/src/Core/arch/SSE/MathFunctions.h	/^ptanh<Packet4f>(const Packet4f& x) {$/;"	f	namespace:Eigen::internal
ptr	Eigen/src/Core/util/Memory.h	/^  T* &ptr() { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
ptr	Eigen/src/Core/util/Memory.h	/^  const T* ptr() const { return m_ptr; }$/;"	f	class:Eigen::internal::scoped_array
ptr	test/mapstaticmethods.cpp	/^float *ptr;$/;"	v
ptranspose	Eigen/src/Core/GenericPacketMath.h	/^ptranspose(PacketBlock<Packet,1>& \/*kernel*\/) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX/Complex.h	/^ptranspose(PacketBlock<Packet2cd,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX/Complex.h	/^ptranspose(PacketBlock<Packet4cf,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet4d,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet8f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX/PacketMath.h	/^ptranspose(PacketBlock<Packet8f,8>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet16f, 16>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet16f, 4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet8d, 4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet8d, 8>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AltiVec/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/CUDA/PacketMath.h	/^ptranspose(PacketBlock<double2,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/CUDA/PacketMath.h	/^ptranspose(PacketBlock<float4,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^ptranspose(PacketBlock<half2,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/NEON/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/NEON/Complex.h	/^ptranspose(PacketBlock<Packet2cf,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/NEON/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/SSE/Complex.h	/^ptranspose(PacketBlock<Packet2cf,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/SSE/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/ZVector/Complex.h	/^EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet2d,2>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet4f,4>& kernel) {$/;"	f	namespace:Eigen::internal
ptranspose	Eigen/src/Core/arch/ZVector/PacketMath.h	/^ptranspose(PacketBlock<Packet4i,4>& kernel) {$/;"	f	namespace:Eigen::internal
punpackp	Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal
pushDownZero	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::pushDownZero(Index z, Index f, Index l)$/;"	f	class:Eigen::RealQZ
pushMatrix	demos/opengl/gpuhelper.h	/^inline void GpuHelper::pushMatrix(GLenum matrixTarget)$/;"	f	class:GpuHelper
pushMatrix	demos/opengl/gpuhelper.h	/^inline void GpuHelper::pushMatrix(const Matrix<Scalar,4,4, _Flags, 4,4>& mat, GLenum matrixTarget)$/;"	f	class:GpuHelper
pushMatrix	demos/opengl/gpuhelper.h	/^void GpuHelper::pushMatrix($/;"	f	class:GpuHelper
pushProjectionMode2D	demos/opengl/gpuhelper.cpp	/^void GpuHelper::pushProjectionMode2D(ProjectionMode2D pm)$/;"	f	class:GpuHelper
push_assert	test/main.h	/^        static bool push_assert = false;$/;"	m	namespace:Eigen::internal
push_back	Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque
push_back	Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list
push_back	Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector
push_back	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  void push_back(const T& t) {$/;"	f	class:Eigen::MaxSizeVector
push_front	Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque
putMarketHeader	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putMarketHeader(std::string& header,int sym)$/;"	f	namespace:Eigen::internal
putVectorElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putVectorElt(Scalar value, std::ofstream& out)$/;"	f	namespace:Eigen::internal
putVectorElt	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putVectorElt(std::complex<Scalar> value, std::ofstream& out)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cd pxor   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet4cf pxor   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4d pxor<Packet4d>(const Packet4d& a, const Packet4d& b) { return _mm256_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet8f pxor<Packet8f>(const Packet8f& a, const Packet8f& b) { return _mm256_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet16f pxor<Packet16f>(const Packet16f& a,$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AVX512/PacketMath.h	/^EIGEN_STRONG_INLINE Packet8d pxor<Packet8d>(const Packet8d& a,$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pxor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v, b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pzeta	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsPacketMath.h	/^Packet pzeta(const Packet& x, const Packet& q) { using numext::zeta; return zeta(x, q); }$/;"	f	namespace:Eigen::internal
pzeta	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^double2 pzeta<double2>(const double2& x, const double2& q)$/;"	f	namespace:Eigen::internal
pzeta	unsupported/Eigen/src/SpecialFunctions/arch/CUDA/CudaSpecialFunctions.h	/^float4 pzeta<float4>(const float4& x, const float4& q)$/;"	f	namespace:Eigen::internal
qr	test/qr.cpp	/^template<typename MatrixType> void qr(const MatrixType& m)$/;"	f
qr	test/qr_colpivoting.cpp	/^template<typename MatrixType> void qr()$/;"	f
qr	test/qr_fullpivoting.cpp	/^template<typename MatrixType> void qr()$/;"	f
qr_fixedsize	test/qr.cpp	/^template<typename MatrixType, int Cols2> void qr_fixedsize()$/;"	f
qr_fixedsize	test/qr_colpivoting.cpp	/^template<typename MatrixType, int Cols2> void qr_fixedsize()$/;"	f
qr_invertible	test/qr.cpp	/^template<typename MatrixType> void qr_invertible()$/;"	f
qr_invertible	test/qr_colpivoting.cpp	/^template<typename MatrixType> void qr_invertible()$/;"	f
qr_invertible	test/qr_fullpivoting.cpp	/^template<typename MatrixType> void qr_invertible()$/;"	f
qr_kahan_matrix	test/qr_colpivoting.cpp	/^template<typename MatrixType> void qr_kahan_matrix()$/;"	f
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_should_do_anything	Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
qr_verify_assert	test/qr.cpp	/^template<typename MatrixType> void qr_verify_assert()$/;"	f
qr_verify_assert	test/qr_colpivoting.cpp	/^template<typename MatrixType> void qr_verify_assert()$/;"	f
qr_verify_assert	test/qr_fullpivoting.cpp	/^template<typename MatrixType> void qr_verify_assert()$/;"	f
qrsolv	unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^void qrsolv($/;"	f	namespace:Eigen::internal
qtf	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
qtf	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
quat_conj	Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived, typename Scalar> struct quat_conj$/;"	s	namespace:Eigen::internal
quat_conj	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_conj<Architecture::SSE, Derived, double>$/;"	s	namespace:Eigen::internal
quat_conj	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_conj<Architecture::SSE, Derived, float>$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar> struct quat_product$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double>$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float>$/;"	s	namespace:Eigen::internal
quaternion	test/geo_quaternion.cpp	/^template<typename Scalar, int Options> void quaternion(void)$/;"	f
quaternionAlignment	test/geo_quaternion.cpp	/^template<typename Scalar> void quaternionAlignment(void){$/;"	f
quaternionbase_assign_impl	Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
quatmul_default	bench/quatmul.cpp	/^EIGEN_DONT_INLINE void quatmul_default(const Quat& a, const Quat& b, Quat& c)$/;"	f
quatmul_novec	bench/quatmul.cpp	/^EIGEN_DONT_INLINE void quatmul_novec(const Quat& a, const Quat& b, Quat& c)$/;"	f
queryCacheSizes	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_amd	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_codes	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_direct	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryL1CacheSize	Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal
queryTopLevelCacheSize	Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal
queues_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  MaxSizeVector<Queue*> queues_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
quiet_NaN	Eigen/src/Core/arch/CUDA/Half.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half quiet_NaN() {$/;"	f	struct:Eigen::NumTraits
quiet_NaN	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half quiet_NaN() { return Eigen::half_impl::raw_uint16_to_half(0x7e00); }$/;"	f	struct:std::numeric_limits
quiet_NaN	Eigen/src/Core/util/Meta.h	/^  static T quiet_NaN() { assert(false && "quiet_NaN not supported for this type"); }$/;"	f	struct:Eigen::internal::device::numeric_limits
quiet_NaN	Eigen/src/Core/util/Meta.h	/^  static double quiet_NaN() { return CUDART_NAN; }$/;"	f	struct:Eigen::internal::device::numeric_limits
quiet_NaN	Eigen/src/Core/util/Meta.h	/^  static float quiet_NaN() { return CUDART_NAN_F; }$/;"	f	struct:Eigen::internal::device::numeric_limits
quiet_NaN	unsupported/test/mpreal/mpreal.h	/^        inline static const mpfr::mpreal quiet_NaN()        { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits
r	blas/f2c/datatypes.h	/^typedef struct { doublereal r, i; } doublecomplex;$/;"	m	struct:__anon204
r	blas/f2c/datatypes.h	/^typedef struct { real r, i; } complex;$/;"	m	struct:__anon203
r1mpyq	unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^void r1mpyq(DenseIndex m, DenseIndex n, Scalar *a, const std::vector<JacobiRotation<Scalar> > &v_givens, const std::vector<JacobiRotation<Scalar> > &w_givens)$/;"	f	namespace:Eigen::internal
r1updt	unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^void r1updt($/;"	f	namespace:Eigen::internal
r_cnjg	blas/f2c/r_cnjg.c	/^void r_cnjg(complex *r, complex *z) {$/;"	f
radius	unsupported/test/BVH.cpp	/^  double radius;$/;"	m	struct:Ball	file:
radix	Eigen/src/Core/arch/CUDA/Half.h	/^  static const int radix = 2;$/;"	m	struct:std::numeric_limits
radix	unsupported/Eigen/src/Polynomials/Companion.h	/^T radix(){ return 2; }$/;"	f	namespace:Eigen::internal
radix	unsupported/test/mpreal/mpreal.h	/^        static const int  radix             = 2;$/;"	m	class:std::numeric_limits
radix2	unsupported/Eigen/src/Polynomials/Companion.h	/^T radix2(){ return radix<T>()*radix<T>(); }$/;"	f	namespace:Eigen::internal
raise_assertion	test/mixingtypes.cpp	/^void raise_assertion(Index size = SizeAtCompileType)$/;"	f
ramp	doc/examples/class_CwiseUnaryOp_ptrfun.cpp	/^double ramp(double x)$/;"	f
rand	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^    uint64_t rand;  \/\/ Random generator state.$/;"	m	struct:Eigen::NonBlockingThreadPoolTempl::PerThread
randMatrixSpecialUnitary	test/umeyama.cpp	/^Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> randMatrixSpecialUnitary(int size)$/;"	f
randMatrixUnitary	test/umeyama.cpp	/^Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic> randMatrixUnitary(int size)$/;"	f
rand_reentrant	unsupported/test/cxx11_eventcount.cpp	/^int rand_reentrant(unsigned int* s) {$/;"	f
rand_reentrant	unsupported/test/cxx11_runqueue.cpp	/^int rand_reentrant(unsigned int* s) {$/;"	f
random	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal
random	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
random	bench/tensors/tensor_benchmarks.h	/^  void random(int num_iters) {$/;"	f	class:BenchmarkSuite
random	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    random() const {$/;"	f	class:Eigen::TensorBase
random	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    random(const RandomGenerator& gen = RandomGenerator()) const {$/;"	f	class:Eigen::TensorBase
random	unsupported/test/mpreal/mpreal.h	/^inline const mpreal random(unsigned int seed = 0)$/;"	f	namespace:mpfr
random2	unsupported/test/mpreal/mpreal.h	/^inline const mpreal random2 (mp_size_t size, mp_exp_t exp)$/;"	f	namespace:mpfr
randomMatrixWithImagEivals	unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals$/;"	s	file:
randomMatrixWithImagEivals	unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals<MatrixType, 0>$/;"	s	file:
randomMatrixWithImagEivals	unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals<MatrixType, 1>$/;"	s	file:
randomMatrixWithRealEivals	unsupported/test/matrix_function.cpp	/^MatrixType randomMatrixWithRealEivals(const typename MatrixType::Index size)$/;"	f
randomPermutationVector	test/main.h	/^void randomPermutationVector(PermutationVectorType& v, Index size)$/;"	f	namespace:Eigen
randomTest	unsupported/test/matrix_exponential.cpp	/^void randomTest(const MatrixType& m, double tol)$/;"	f
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/arch/CUDA/Half.h	/^struct random_default_impl<half, false, false>$/;"	s	namespace:Eigen::internal
random_impl	Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
random_impl	Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
random_retval	Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
rank	Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU
rank	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR
rank	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index rank() const { return m_cpqr.rank(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
rank	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR
rank	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index rank() const$/;"	f	class:Eigen::SPQR
rank	Eigen/src/SVD/SVDBase.h	/^  inline Index rank() const$/;"	f	class:Eigen::SVDBase
rank	Eigen/src/SparseQR/SparseQR.h	/^    Index rank() const$/;"	f	class:Eigen::SparseQR
rank	Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base
rank	Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base
rank	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                         rank()                   const { return NumIndices; }$/;"	f	class:Eigen::Tensor
rank	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t rank() const {$/;"	f	struct:Eigen::DSizes
rank	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::ptrdiff_t rank() const {$/;"	f	struct:Eigen::Sizes
rank	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                    rank()                   const { return NumIndices; }$/;"	f	class:Eigen::TensorFixedSize
rank	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Index rank() const { return m_dimensions.rank(); }$/;"	f	class:Eigen::TensorMap
rank	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Index rank() const { return m_evaluator->dimensions().size(); }$/;"	f	class:Eigen::TensorRef
rank2_update_selector	blas/Rank2Update.h	/^struct rank2_update_selector$/;"	s	namespace:internal
rankUpdate	Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)$/;"	f	class:Eigen::LDLT
rankUpdate	Eigen/src/Cholesky/LLT.h	/^  static Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace
rankUpdate	Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT
rankUpdate	Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,Mode>::rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SparseSelfAdjointView
rat42_functor	unsupported/test/NonLinearOptimization.cpp	/^    rat42_functor(void) : Functor<double>(3,9) {}$/;"	f	struct:rat42_functor
rat42_functor	unsupported/test/NonLinearOptimization.cpp	/^struct rat42_functor : Functor<double>$/;"	s	file:
rat42_functor	unsupported/test/levenberg_marquardt.cpp	/^    rat42_functor(void) : DenseFunctor<double>(3,9) {}$/;"	f	struct:rat42_functor
rat42_functor	unsupported/test/levenberg_marquardt.cpp	/^struct rat42_functor : DenseFunctor<double>$/;"	s	file:
rat43_functor	unsupported/test/NonLinearOptimization.cpp	/^    rat43_functor(void) : Functor<double>(4,15) {}$/;"	f	struct:rat43_functor
rat43_functor	unsupported/test/NonLinearOptimization.cpp	/^struct rat43_functor : Functor<double>$/;"	s	file:
rat43_functor	unsupported/test/levenberg_marquardt.cpp	/^    rat43_functor(void) : DenseFunctor<double>(4,15) {}$/;"	f	struct:rat43_functor
rat43_functor	unsupported/test/levenberg_marquardt.cpp	/^struct rat43_functor : DenseFunctor<double>$/;"	s	file:
ratio	bench/btl/data/gnuplot_common_settings.hh	/^set size ratio 0 1,1$/;"	v
ratio	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar ratio;$/;"	m	class:Eigen::HybridNonLinearSolver
ratio	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar ratio;$/;"	m	class:Eigen::LevenbergMarquardt
rawMatrix	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky
raw_uint16_to_half	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw raw_uint16_to_half(unsigned short x) {$/;"	f	namespace:Eigen::half_impl
rcond	Eigen/src/Cholesky/LDLT.h	/^    RealScalar rcond() const$/;"	f	class:Eigen::LDLT
rcond	Eigen/src/Cholesky/LLT.h	/^    RealScalar rcond() const$/;"	f	class:Eigen::LLT
rcond	Eigen/src/LU/FullPivLU.h	/^    inline RealScalar rcond() const$/;"	f	class:Eigen::FullPivLU
rcond	Eigen/src/LU/PartialPivLU.h	/^    inline RealScalar rcond() const$/;"	f	class:Eigen::PartialPivLU
rcond_compute_sign	Eigen/src/Core/ConditionEstimator.h	/^struct rcond_compute_sign {$/;"	s	namespace:Eigen::internal
rcond_compute_sign	Eigen/src/Core/ConditionEstimator.h	/^struct rcond_compute_sign<Vector, Vector, false> {$/;"	s	namespace:Eigen::internal
rcond_estimate_helper	Eigen/src/Core/ConditionEstimator.h	/^rcond_estimate_helper(typename Decomposition::RealScalar matrix_norm, const Decomposition& dec)$/;"	f	namespace:Eigen::internal
rcond_invmatrix_L1_norm_estimate	Eigen/src/Core/ConditionEstimator.h	/^typename Decomposition::RealScalar rcond_invmatrix_L1_norm_estimate(const Decomposition& dec)$/;"	f	namespace:Eigen::internal
read_xy_file	bench/btl/data/regularize.cxx	/^void read_xy_file(const string & filename, vector<int> & tab_sizes, vector<double> & tab_mflops){$/;"	f
read_xy_file	bench/btl/data/smooth.cxx	/^void read_xy_file(const string & filename, vector<int> & tab_sizes, vector<double> & tab_mflops){$/;"	f
read_xy_file	bench/btl/generic_bench/utils/xy_file.hh	/^bool read_xy_file(const std::string & filename, std::vector<int> & tab_sizes,$/;"	f
ready	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    bool ready;$/;"	m	struct:Eigen::SimpleThreadPoolTempl::Waiter
real	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::numext
real	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() const { return RealReturnType(derived()); }$/;"	f
real	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() { return NonConstRealReturnType(derived()); }$/;"	f
real	blas/f2c/datatypes.h	/^typedef float real;$/;"	t
real	test/exceptions.cpp	/^ScalarWithExceptions real(const ScalarWithExceptions &x) { return x; }$/;"	f
real	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    real() const {$/;"	f	class:Eigen::TensorBase
real	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline const AutoDiffScalar<DerType>& real(const AutoDiffScalar<DerType>& x)  { return x; }$/;"	f	namespace:Eigen
realRoots	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline void realRoots( Stl_back_insertion_sequence& bi_seq,$/;"	f	class:Eigen::PolynomialSolverBase
realRoots_to_monicPolynomial_scalar	unsupported/test/polynomialutils.cpp	/^template<typename _Scalar> void realRoots_to_monicPolynomial_scalar()$/;"	f
realRoots_to_monicPolynomial_test	unsupported/test/polynomialutils.cpp	/^void realRoots_to_monicPolynomial_test(int deg)$/;"	f
real_2x2_jacobi_svd	Eigen/src/misc/RealSvd2x2.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal
real_complex	test/linearstructure.cpp	/^template<typename MatrixType> void real_complex(DenseIndex rows = MatrixType::RowsAtCompileTime, DenseIndex cols = MatrixType::ColsAtCompileTime)$/;"	f
real_default_impl	Eigen/src/Core/MathFunctions.h	/^struct real_default_impl$/;"	s	namespace:Eigen::internal
real_default_impl	Eigen/src/Core/MathFunctions.h	/^struct real_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
real_impl	Eigen/src/Core/MathFunctions.h	/^struct real_impl<std::complex<T> >$/;"	s	namespace:Eigen::internal
real_impl	Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
real_qz	test/real_qz.cpp	/^template<typename MatrixType> void real_qz(const MatrixType& m)$/;"	f
real_ref	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref	Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref_impl	Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref_retval	Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
real_retval	Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
real_twiddles	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    Complex * real_twiddles(int ncfft2)$/;"	f	struct:Eigen::internal::kissfft_impl
real_type	bench/btl/libs/BLAS/c_interface_base.h	/^  typedef real                      real_type;$/;"	t	class:c_interface_base
real_type	bench/btl/libs/STL/STL_interface.hh	/^  typedef real real_type ;$/;"	t	class:STL_interface
real_type	bench/btl/libs/blaze/blaze_interface.hh	/^  typedef real real_type ;$/;"	t	class:blaze_interface
real_type	bench/btl/libs/blitz/blitz_interface.hh	/^  typedef real real_type ;$/;"	t	class:blitz_interface
real_type	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  typedef real real_type ;$/;"	t	class:tiny_blitz_interface
real_type	bench/btl/libs/eigen2/eigen2_interface.hh	/^  typedef real real_type;$/;"	t	class:eigen2_interface
real_type	bench/btl/libs/eigen3/eigen3_interface.hh	/^  typedef real real_type;$/;"	t	class:eigen3_interface
real_type	bench/btl/libs/gmm/gmm_interface.hh	/^  typedef real real_type ;$/;"	t	class:gmm_interface
real_type	bench/btl/libs/mtl4/mtl4_interface.hh	/^  typedef real real_type ;$/;"	t	class:mtl4_interface
real_type	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef real real_type;$/;"	t	class:tensor_interface
real_type	bench/btl/libs/tvmet/tvmet_interface.hh	/^  typedef real real_type ;$/;"	t	class:tvmet_interface
real_type	bench/btl/libs/ublas/ublas_interface.hh	/^  typedef real real_type ;$/;"	t	class:ublas_interface
realclock	bench/btl/generic_bench/btl.hh	/^  bool realclock;$/;"	m	class:BtlConfig
reallocate	Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector
reallocate	Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
reallocate	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void reallocate(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
reallocateSparse	Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector
rebind	Eigen/src/Core/util/Memory.h	/^  struct rebind$/;"	s	class:Eigen::aligned_allocator
rebind	Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection
rec_sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rec_sqrt(const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
reconstructedMatrix	Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT
reconstructedMatrix	Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT
reconstructedMatrix	Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU
reconstructedMatrix	Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    reduce(const Dims& dims, const Reducer& reducer) const {$/;"	f	class:Eigen::TensorBase
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(bool t, bool* accum) const {$/;"	f	struct:Eigen::internal::AndReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(bool t, bool* accum) const {$/;"	f	struct:Eigen::internal::OrReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) const {$/;"	f	struct:Eigen::internal::ArgMaxTupleReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) const {$/;"	f	struct:Eigen::internal::MaxReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) const {$/;"	f	struct:Eigen::internal::MinReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) const {$/;"	f	struct:Eigen::internal::ProdReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) const {$/;"	f	struct:Eigen::internal::SumReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) {$/;"	f	struct:Eigen::internal::MeanReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T& t, T* accum) const {$/;"	f	struct:Eigen::internal::ArgMinTupleReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename Self::CoeffReturnType reduce(const Self& self, typename Self::Index firstIndex, typename Self::Index numValuesToReduce, Op& reducer) {$/;"	f	struct:Eigen::internal::InnerMostDimReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const Self& self, typename Self::Index firstIndex, Op& reducer, typename Self::CoeffReturnType* accum) {$/;"	f	struct:Eigen::internal::GenericDimReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const Self& self, typename Self::Index firstIndex, Op& reducer, typename Self::PacketReturnType* accum) {$/;"	f	struct:Eigen::internal::InnerMostDimPreserver
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const Self& self, typename Self::Index index, Op& reducer, typename Self::CoeffReturnType* accum) {$/;"	f	struct:Eigen::internal::GenericDimReducer
reduce	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const Self&, typename Self::Index, Op&, typename Self::PacketReturnType*) {$/;"	f	struct:Eigen::internal::InnerMostDimPreserver
reduce	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^> struct reduce<Reducer, A, Ts...>$/;"	s	namespace:Eigen::internal
reduce	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^> struct reduce<Reducer, A>$/;"	s	namespace:Eigen::internal
reduce	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^> struct reduce<Reducer>$/;"	s	namespace:Eigen::internal
reduce	unsupported/test/cxx11_tensor_reduction.cpp	/^  void reduce(const float val, float* accum) { *accum += val * val; }$/;"	f	struct:UserReducer
reduceMatrix	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	403;"	d
reduceMatrix	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	422;"	d
reduceNoiseLevel	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void reduceNoiseLevel() { if (m_noise > 0) m_noise--; }$/;"	f	class:Eigen::IterationController
reducePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) const {$/;"	f	struct:Eigen::internal::MaxReducer
reducePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) const {$/;"	f	struct:Eigen::internal::MinReducer
reducePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) const {$/;"	f	struct:Eigen::internal::ProdReducer
reducePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) const {$/;"	f	struct:Eigen::internal::SumReducer
reducePacket	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) {$/;"	f	struct:Eigen::internal::MeanReducer
reduceRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	393;"	d
reduceRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	421;"	d
reduceToTriangularForm	Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur
reduce_dims	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  const Dims& reduce_dims() const { return m_reduce_dims; }$/;"	f	class:Eigen::TensorTupleReducerOp
reduce_op	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  const ReduceOp& reduce_op() const { return m_reduce_op; }$/;"	f	class:Eigen::TensorTupleReducerOp
reducer	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^    const Op& reducer() const { return m_reducer; }$/;"	f	class:Eigen::TensorReductionOp
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<AndReducer, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<ArgMaxTupleReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<ArgMinTupleReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<MaxReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<MeanReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<MinReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<OrReducer, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<ProdReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
reducer_traits	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct reducer_traits<SumReducer<T>, Device> {$/;"	s	namespace:Eigen::internal
redux	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase
redux	Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp
redux	Eigen/src/Geometry/Homogeneous.h	/^    redux(const Func& func) const$/;"	f	class:Eigen::Homogeneous
redux_evaluator	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC explicit redux_evaluator(const XprType &xpr) : m_evaluator(xpr), m_xpr(xpr) {}$/;"	f	class:Eigen::internal::redux_evaluator
redux_evaluator	Eigen/src/Core/Redux.h	/^class redux_evaluator$/;"	c	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_traits	Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
redux_vec_unroller	Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
refCount	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  int refCount() const { return m_refcount; }$/;"	f	class:Eigen::internal::TensorLazyBaseEvaluator
refX	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline VectorType& refX() $/;"	f	class:Eigen::MatrixMarketIterator
ref_matrix	test/ref.cpp	/^template<typename MatrixType> void ref_matrix(const MatrixType& m)$/;"	f
ref_prod	test/product_small.cpp	/^const TC& ref_prod(TC &C, const TA &A, const TB &B)$/;"	f
ref_vector	test/ref.cpp	/^template<typename VectorType> void ref_vector(const VectorType& m)$/;"	f
reference	Eigen/src/Core/util/Memory.h	/^  typedef T&              reference;$/;"	t	class:Eigen::aligned_allocator
reference	Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
reference	Eigen/src/SparseCore/SparseView.h	/^  Scalar reference() const { return m_reference; }$/;"	f	class:Eigen::SparseView
reference	Eigen/src/StlSupport/details.h	/^    typedef T&              reference;$/;"	t	class:Eigen::aligned_allocator_indirection
register_eigen_printers	debug/gdb/printers.py	/^def register_eigen_printers(obj):$/;"	f
regression_bug_654	test/array_for_matrix.cpp	/^void regression_bug_654()$/;"	f
regrrssion_bug_1410	test/array_for_matrix.cpp	/^void regrrssion_bug_1410()$/;"	f
regularize_curve	bench/btl/data/regularize.cxx	/^void regularize_curve(const string & filename,$/;"	f
relax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index relax; \/\/ To control degree of relaxing supernodes. If the number of nodes (columns) $/;"	m	struct:Eigen::internal::perfvalues
relax_snode	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^void SparseLUImpl<Scalar,StorageIndex>::relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
relerr	unsupported/test/matrix_functions.h	/^typename Derived::RealScalar relerr(const MatrixBase<Derived>& A, const MatrixBase<OtherDerived>& B)$/;"	f
rem	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rem (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
remainder	unsupported/test/mpreal/mpreal.h	/^inline const mpreal remainder (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
remquo	unsupported/test/mpreal/mpreal.h	/^inline const mpreal remquo (long* q, const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
render	demos/mandelbrot/mandelbrot.cpp	/^template<typename Real> void MandelbrotThread::render(int img_width, int img_height)$/;"	f	class:MandelbrotThread
rep_element	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename get<rep_pos, elements>::type rep_element;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
rep_pos	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  constexpr static int rep_pos = elements::count;$/;"	m	struct:Eigen::internal::group_theory::dimino_add_generator
repeat	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^array<t, n> repeat(t v) {$/;"	f	namespace:Eigen::internal
replicate	Eigen/src/Core/DenseBase.h	/^    const Replicate<Derived, Dynamic, Dynamic> replicate(Index rowFactor, Index colFactor) const$/;"	f	class:Eigen::DenseBase
replicate	Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase
replicate	Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp
replicate	Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp
replicate	test/array_replicate.cpp	/^template<typename MatrixType> void replicate(const MatrixType& m)$/;"	f
report_on_cerr_on_assert_failure	test/main.h	/^    static bool report_on_cerr_on_assert_failure = true;$/;"	m	namespace:Eigen
representation	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      std::vector<int> representation;$/;"	m	struct:Eigen::DynamicSGroup::GroupElement
reps	bench/btl/generic_bench/timers/STL_timer.hh	/^  unsigned int reps;  \/\/ Number of trials$/;"	m	class:STL_Timer
required_alignment	Eigen/src/Core/Matrix.h	/^      required_alignment = unpacket_traits<PacketScalar>::alignment,$/;"	e	enum:Eigen::internal::traits::__anon438
res	Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor
res	doc/snippets/PartialRedux_count.cpp	/^Matrix<ptrdiff_t, 3, 1> res = (m.array() >= 0.5).rowwise().count();$/;"	v
res	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	262;"	d
res	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	495;"	d
reserve	Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(Index size)$/;"	f	class:Eigen::internal::CompressedStorage
reserve	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix
reserve	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif =$/;"	f	class:Eigen::SparseMatrix
reserve	Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector
reserve	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void reserve(Index reserveSize, Index reserveUpperSize, Index reserveLowerSize) {$/;"	f	class:Eigen::SkylineMatrix
reserve	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void reserve(Index size, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
reserve	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline void reserve(const Index nonzerosblocks)$/;"	f	class:Eigen::BlockSparseMatrix
reserve	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void reserve(Index reserveSize = 1000)$/;"	f	class:Eigen::DynamicSparseMatrix
reserveInnerVectors	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix
reserve_	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  size_t reserve_;$/;"	m	class:Eigen::MaxSizeVector
reset	bench/BenchTimer.h	/^  inline void reset()$/;"	f	class:Eigen::BenchTimer
reset	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void reset() {$/;"	f	class:Eigen::SkylineStorage
resetCamera	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::resetCamera()$/;"	f	class:RenderingWidget
resetParameters	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void resetParameters() $/;"	f	class:Eigen::LevenbergMarquardt
resetParameters	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    void resetParameters(void) { parameters = Parameters(); }$/;"	f	class:Eigen::HybridNonLinearSolver
resetParameters	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    void resetParameters(void) { parameters = Parameters(); }$/;"	f	class:Eigen::LevenbergMarquardt
reshape	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    reshape(const NewDimensions& newDimensions) const {$/;"	f	class:Eigen::TensorBase
reshape	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    reshape(const NewDimensions& newDimensions) {$/;"	f	class:Eigen::TensorBase
residual	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double residual() const { return m_res; }$/;"	f	class:Eigen::IterationController
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index rows, Index cols) { m_expression.resize(rows,cols); }$/;"	f	class:Eigen::ArrayWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index rows, Index cols) { m_expression.resize(rows,cols); }$/;"	f	class:Eigen::MatrixWrapper
resize	Eigen/src/Core/DenseBase.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::DenseBase
resize	Eigen/src/Core/DenseBase.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index, Index cols)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(Index, Index, Index cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix
resize	Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::PermutationBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/Transpose.h	/^    void resize(Index nrows, Index ncols) {$/;"	f	class:Eigen::Transpose
resize	Eigen/src/Core/Transpositions.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::TranspositionsBase
resize	Eigen/src/Core/TriangularMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::TriangularBase
resize	Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector
resize	Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(Index size, double reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage
resize	Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
resize	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseSelfAdjointView
resize	Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector
resize	Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector
resize	Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque
resize	Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque
resize	Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list
resize	Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list
resize	Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector
resize	Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector
resize	test/array_for_matrix.cpp	/^template<typename MatrixTraits> void resize(const MatrixTraits& t)$/;"	f
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(CustomDimension& dimensions)$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC void resize(const DSizes<Index, NumIndices>& dimensions) {$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC void resize(const array<Index, NumIndices>& dimensions)$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    void resize()$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    void resize(Index firstDimension, IndexTypes... otherDimensions)$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    void resize(const Sizes<Indices...>& dimensions) {$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    void resize(const Sizes<V1, V2, V3, V4, V5>& dimensions) {$/;"	f	class:Eigen::Tensor
resize	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC void resize(Index size, const array<Index, NumIndices_>& nbDimensions)$/;"	f	class:Eigen::TensorStorage
resize	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  void resize(size_t n) {$/;"	f	class:Eigen::MaxSizeVector
resize	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void resize(size_t rows, size_t cols) {$/;"	f	class:Eigen::SkylineMatrix
resize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void resize(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize, float reserveSizeFactor = 0) {$/;"	f	class:Eigen::SkylineStorage
resize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline void resize(Index brow, Index bcol)$/;"	f	class:Eigen::BlockSparseMatrix
resize	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
resizeAndKeepData	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void resizeAndKeepData(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
resizeEvent	demos/mandelbrot/mandelbrot.cpp	/^void MandelbrotWidget::resizeEvent(QResizeEvent *)$/;"	f	class:MandelbrotWidget
resizeGL	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::resizeGL(int width, int height)$/;"	f	class:RenderingWidget
resizeHeight	doc/eigen_navtree_hacks.js	/^function resizeHeight() $/;"	f
resizeLike	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase
resizeLikeTest	test/resize.cpp	/^void resizeLikeTest()$/;"	f
resizeLikeTest1020	test/resize.cpp	/^void resizeLikeTest1020() { resizeLikeTest<10,20>(); }$/;"	f
resizeLikeTest12	test/resize.cpp	/^void resizeLikeTest12() { resizeLikeTest<1,2>(); }$/;"	f
resizeLikeTest31	test/resize.cpp	/^void resizeLikeTest31() { resizeLikeTest<3,1>(); }$/;"	f
resizeNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix
resizeNonZeros	Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector
resizeNonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void resizeNonZeros(Index size) {$/;"	f	class:Eigen::SkylineMatrix
resize_if_allowed	Eigen/src/Core/AssignEvaluator.h	/^void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &\/*func*\/)$/;"	f	namespace:Eigen::internal
resize_if_allowed	Eigen/src/Core/AssignEvaluator.h	/^void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const internal::assign_op<T1,T2> &\/*func*\/)$/;"	f	namespace:Eigen::internal
restart	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::restart()$/;"	f	class:Eigen::internal::AmbiVector
restart	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  Index restart() { return m_restart; }$/;"	f	class:Eigen::DGMRES
resu_stl	bench/btl/actions/action_aat_product.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_aat_product
resu_stl	bench/btl/actions/action_ata_product.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_ata_product
resu_stl	bench/btl/actions/action_atv_product.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_atv_product
resu_stl	bench/btl/actions/action_axpby.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_axpby
resu_stl	bench/btl/actions/action_axpy.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_axpy
resu_stl	bench/btl/actions/action_ger.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_ger
resu_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_hessenberg
resu_stl	bench/btl/actions/action_hessenberg.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_tridiagonalization
resu_stl	bench/btl/actions/action_lu_decomp.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_lu_decomp
resu_stl	bench/btl/actions/action_matrix_matrix_product.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_matrix_matrix_product
resu_stl	bench/btl/actions/action_matrix_vector_product.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_matrix_vector_product
resu_stl	bench/btl/actions/action_symv.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_symv
resu_stl	bench/btl/actions/action_syr2.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_syr2
resu_stl	bench/btl/actions/action_trisolve.hh	/^  typename Interface::stl_vector resu_stl;$/;"	m	class:Action_trisolve
resu_stl	bench/btl/actions/action_trisolve_matrix.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_trisolve_matrix
resu_stl	bench/btl/actions/action_trmm.hh	/^  typename Interface::stl_matrix resu_stl;$/;"	m	class:Action_trmm
result_of	Eigen/src/Core/functors/BinaryFunctors.h	/^struct result_of<scalar_cmp_op<LhsScalar, RhsScalar, Cmp>(LhsScalar,RhsScalar)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1,ArgType2)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of { };$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {$/;"	s	namespace:Eigen::internal
result_type	Eigen/src/Core/MathFunctions.h	/^  typedef ScalarX result_type;$/;"	t	struct:Eigen::internal::pow_impl
result_type	Eigen/src/Core/MathFunctions.h	/^  typedef typename ScalarBinaryOpTraits<ScalarX,ScalarY,internal::scalar_pow_op<ScalarX,ScalarY> >::ReturnType result_type;$/;"	t	struct:Eigen::internal::pow_impl
result_type	Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux
result_type	Eigen/src/Core/VectorwiseOp.h	/^  typedef ResultType result_type;$/;"	t	struct:Eigen::internal::member_lpnorm
result_type	Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_difference_op
result_type	Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op
result_type	Eigen/src/Core/arch/CUDA/Complex.h	/^  typedef typename std::complex<T> result_type;$/;"	t	struct:Eigen::internal::scalar_sum_op
result_type	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  typedef Eigen::half result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^  typedef float result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_cmp_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::result_type          result_type;$/;"	t	struct:Eigen::internal::bind1st_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::result_type          result_type;$/;"	t	struct:Eigen::internal::bind2nd_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_conj_product_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_difference_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_difference_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_max_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_max_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_min_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_min_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_product_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_quotient_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_sum_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_sum_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename ScalarBinaryOpTraits<Scalar,Exponent,scalar_pow_op>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_pow_op
result_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename scalar_quotient_op<LhsScalar,RhsScalar>::result_type result_type;$/;"	t	struct:Eigen::internal::functor_traits
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isfinite_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isinf_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef bool result_type;$/;"	t	struct:Eigen::internal::scalar_isnan_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::abs_knowing_score
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_arg_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op
result_type	Eigen/src/Core/functors/UnaryFunctors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op
result_type	blas/level1_cplx_impl.h	/^  typedef RealScalar result_type;$/;"	t	struct:scalar_norm1_op
result_type	doc/examples/class_CwiseBinaryOp.cpp	/^  typedef complex<Scalar> result_type;$/;"	t	struct:MakeComplexOp	file:
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};$/;"	s	namespace:mpfr::internal
result_type	unsupported/test/mpreal/mpreal.h	/^    template <typename ArgumentType> struct result_type {};$/;"	s	namespace:mpfr::internal
results_entry_t	bench/analyze-blocking-sizes.cpp	/^  struct results_entry_t {$/;"	s	struct:evaluate_defaults_action_t	file:
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon449
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon451
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon448
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon450
ret	Eigen/src/Core/GeneralProduct.h	/^    ret = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon291
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon296
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon304
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon303
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon305
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon298
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon302
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon307
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon306
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon312
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon315
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon310
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon313
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon301
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon300
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon308
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon297
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon311
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon314
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon309
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon299
ret	Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon295
ret	Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon292
ret	Eigen/src/Core/GeneralProduct.h	/^template<int M>         struct product_type_selector<M, 1, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon293
ret	Eigen/src/Core/GeneralProduct.h	/^template<int N>         struct product_type_selector<1, N, 1>            { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon294
ret	Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon445
ret	Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon444
ret	Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon365
ret	Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon606
ret	Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon601
ret	Eigen/src/Core/util/Meta.h	/^  enum { ret = A*K };$/;"	e	enum:Eigen::meta_least_common_multiple::__anon604
ret	Eigen/src/Core/util/Meta.h	/^  enum { ret = meta_least_common_multiple<A,B,K+1>::ret };$/;"	e	enum:Eigen::meta_least_common_multiple::__anon603
ret	Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon602
ret	Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon279
ret	Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon779
ret	Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Dense,Sparse, OuterProduct> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	Eigen/src/SparseCore/SparseDenseProduct.h	/^template <> struct product_promote_storage_type<Sparse,Dense, OuterProduct> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<PermutationStorage, Sparse,             ProductTag> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	Eigen/src/SparseCore/SparsePermutation.h	/^template <int ProductTag> struct product_promote_storage_type<Sparse,             PermutationStorage, ProductTag> { typedef Sparse ret; };$/;"	t	struct:Eigen::internal::product_promote_storage_type
ret	bench/product_threshold.cpp	/^    ret = M==1 && N==1 ? InnerProduct$/;"	e	enum:alt_prod::__anon19	file:
ret	bench/product_threshold.cpp	/^template<>  struct map_size<10> { enum { ret = 20 }; };$/;"	e	enum:map_size::__anon15	file:
ret	bench/product_threshold.cpp	/^template<>  struct map_size<11> { enum { ret = 50 }; };$/;"	e	enum:map_size::__anon16	file:
ret	bench/product_threshold.cpp	/^template<>  struct map_size<12> { enum { ret = 100 }; };$/;"	e	enum:map_size::__anon17	file:
ret	bench/product_threshold.cpp	/^template<>  struct map_size<13> { enum { ret = 300 }; };$/;"	e	enum:map_size::__anon18	file:
ret	bench/product_threshold.cpp	/^template<int S> struct map_size { enum { ret = S }; };$/;"	e	enum:map_size::__anon14	file:
ret	demos/mandelbrot/mandelbrot.cpp	/^template<> struct iters_before_test<double> { enum { ret = 16 }; };$/;"	e	enum:iters_before_test::__anon3	file:
ret	demos/mandelbrot/mandelbrot.cpp	/^template<typename T> struct iters_before_test { enum { ret = 8 }; };$/;"	e	enum:iters_before_test::__anon2	file:
ret	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^    enum { ret = packet_access_bit };$/;"	e	enum:Eigen::internal::compute_tensor_flags::__anon158
ret	unsupported/Eigen/src/Polynomials/Companion.h	/^    ret = (Size == Dynamic) ? Dynamic : Size-1 };$/;"	e	enum:Eigen::internal::decrement_if_fixed_size::__anon50
ret	unsupported/test/polynomialsolver.cpp	/^    ret = (Size == Dynamic) ? Dynamic : Size+1$/;"	e	enum:Eigen::internal::increment_if_fixed_size::__anon25	file:
ret	unsupported/test/polynomialutils.cpp	/^    ret = (Size == Dynamic) ? Dynamic : Size+1$/;"	e	enum:Eigen::internal::increment_if_fixed_size::__anon27	file:
return_dim	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  int return_dim() const { return m_return_dim; }$/;"	f	class:Eigen::TensorTupleReducerOp
reverse	Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const$/;"	f	class:Eigen::DenseBase
reverse	Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase
reverse	Eigen/src/Core/VectorwiseOp.h	/^    ReverseReturnType reverse()$/;"	f	class:Eigen::VectorwiseOp
reverse	Eigen/src/Core/VectorwiseOp.h	/^    const ConstReverseReturnType reverse() const$/;"	f	class:Eigen::VectorwiseOp
reverse	test/array_reverse.cpp	/^template<typename MatrixType> void reverse(const MatrixType& m)$/;"	f
reverse	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    reverse(const ReverseDimensions& rev) const {$/;"	f	class:Eigen::TensorBase
reverse	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    reverse(const ReverseDimensions& rev) {$/;"	f	class:Eigen::TensorBase
reverse	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^    const ReverseDimensions& reverse() const { return m_reverse_dims; }$/;"	f	class:Eigen::TensorReverseOp
reverseInPlace	Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase
reverseInPlace	Eigen/src/Core/Reverse.h	/^void VectorwiseOp<ExpressionType,Direction>::reverseInPlace()$/;"	f	class:Eigen::VectorwiseOp
reverseIndex	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index reverseIndex($/;"	f	struct:Eigen::TensorEvaluator
reverse_packet	Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse
reverse_packet_cond	Eigen/src/Core/Reverse.h	/^template<typename PacketType, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	Eigen/src/Core/Reverse.h	/^template<typename PacketType> struct reverse_packet_cond<PacketType,false>$/;"	s	namespace:Eigen::internal
revertSchur	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^inline void MatrixPower<MatrixType>::revertSchur($/;"	f	class:Eigen::MatrixPower
rhs	Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp
rhs	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	class:Eigen::Product
rhs	Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC const RhsType&       rhs() const { return m_rhs; }$/;"	f	class:Eigen::Solve
rhs	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC const RhsType&       rhs()   const { return m_rhs; }$/;"	f	class:Eigen::SolveWithGuess
rhs	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  const RhsMapper& rhs;$/;"	m	struct:Eigen::internal::packRhsAndKernelArg
rhs	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const {$/;"	f	class:Eigen::internal::SkylineProduct
rhs	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline VectorType& rhs() $/;"	f	class:Eigen::MatrixMarketIterator
rhsExpr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<RHSExpr, Dev> > rhsExpr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
rhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^    rhsExpression() const { return m_rhs_xpr; }$/;"	f	class:Eigen::TensorAssignOp
rhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^    rhsExpression() const { return m_rhs_xpr; }$/;"	f	class:Eigen::TensorConcatenationOp
rhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  rhsExpression() const { return m_rhs_xpr; }$/;"	f	class:Eigen::TensorContractionOp
rhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  rhsExpression() const { return m_rhs_xpr; }$/;"	f	class:Eigen::TensorCustomBinaryOp
rhsExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    rhsExpression() const { return m_rhs_xpr; }$/;"	f	class:Eigen::TensorCwiseBinaryOp
rhsNorm	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double rhsNorm() const { return m_rhsn; }$/;"	f	class:Eigen::IterationController
rhs_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    RhsMapper& rhs_;$/;"	m	class:Eigen::TensorEvaluator::Context
rhs_element	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	326;"	d
rhs_element	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	380;"	d
right	bench/bench_gemm.cpp	/^static char right = 'R';$/;"	v	file:
right	bench/btl/libs/BLAS/blas_interface.hh	/^static char right = 'R';$/;"	v
right	demos/opengl/camera.cpp	/^Vector3f Camera::right(void) const$/;"	f	class:Camera
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols(Index n = N) const$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols(Index n = N)$/;"	f
rightHouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
right_dim_mapper_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef array<Index, RDims> right_dim_mapper_t;$/;"	t	struct:Eigen::TensorEvaluator
right_dim_mapper_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef array<Index, RDims> right_dim_mapper_t;$/;"	t	struct:Eigen::TensorEvaluator
right_impl	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  const TensorEvaluator<RightArgType, Device>& right_impl() const { return m_rightImpl; }$/;"	f	struct:Eigen::TensorEvaluator
right_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<RightArgType, Device>& right_impl() const { return m_rightImpl; }$/;"	f	struct:Eigen::TensorEvaluator
right_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, RDims - ContractDims> right_nocontract_t;$/;"	t	struct:Eigen::TensorContractionEvaluatorBase
right_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef array<Index, RDims - ContractDims> right_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
right_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	/^  typedef array<Index, RDims - ContractDims> right_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
right_nocontract_t	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  typedef array<Index, RDims - ContractDims> right_nocontract_t;$/;"	t	struct:Eigen::TensorEvaluator
rint	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint       (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint      );     }$/;"	f	namespace:mpfr
rint_ceil	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_ceil  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_ceil );     }$/;"	f	namespace:mpfr
rint_floor	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_floor (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_floor);     }$/;"	f	namespace:mpfr
rint_round	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_round (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_round);     }$/;"	f	namespace:mpfr
rint_trunc	unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_trunc (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(rint_trunc);     }$/;"	f	namespace:mpfr
root	unsupported/test/mpreal/mpreal.h	/^inline const mpreal root(const mpreal& x, unsigned long int k, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
root_type	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  >::type root_type;$/;"	t	struct:Eigen::internal::tensor_symmetry_pre_analysis
root_type	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  typedef StaticSGroup<> root_type;$/;"	t	struct:Eigen::internal::tensor_symmetry_pre_analysis
rootdir	scripts/relicense.py	/^rootdir = sys.argv[1]$/;"	v
roots	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootsType& roots() const { return m_roots; }$/;"	f	class:Eigen::PolynomialSolverBase
roots_to_monicPolynomial	unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^void roots_to_monicPolynomial( const RootVector& rv, Polynomial& poly )$/;"	f	namespace:Eigen
rot	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void rot(gene_vector & A,  gene_vector & B, SCALAR c, SCALAR s, int N){$/;"	f	class:blas_interface
rot	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static EIGEN_DONT_INLINE void rot(gene_vector & A,  gene_vector & B, real c, real s, int  \/*N*\/){$/;"	f	class:eigen3_interface
rot	blas/level1_real_impl.h	/^int EIGEN_BLAS_FUNC(rot)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pc, RealScalar *ps)$/;"	f
rot_	blas/level1_cplx_impl.h	/^int EIGEN_CAT(EIGEN_CAT(SCALAR_SUFFIX,REAL_SCALAR_SUFFIX),rot_)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pc, RealScalar *ps)$/;"	f
rotate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotateAroundTarget	demos/opengl/camera.cpp	/^void Camera::rotateAroundTarget(const Quaternionf& q)$/;"	f	class:Camera
rotation	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
rotg	blas/level1_impl.h	/^int EIGEN_BLAS_FUNC(rotg)(RealScalar *pa, RealScalar *pb, RealScalar *pc, RealScalar *ps)$/;"	f
round	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(round, Scalar) round(const Scalar& x)$/;"	f	namespace:Eigen::numext
round	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^round() const$/;"	f
round	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    round() const {$/;"	f	class:Eigen::TensorBase
round	unsupported/test/mpreal/mpreal.h	/^inline const mpreal round(const mpreal& v)$/;"	f	namespace:mpfr
round_error	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half round_error() { return Eigen::half(0.5); }$/;"	f	struct:std::numeric_limits
round_error	unsupported/test/mpreal/mpreal.h	/^        inline static mpfr::mpreal round_error(mp_prec_t precision = mpfr::mpreal::get_default_prec())$/;"	f	class:std::numeric_limits
round_impl	Eigen/src/Core/MathFunctions.h	/^  struct round_impl {$/;"	s	namespace:Eigen::internal
round_impl	Eigen/src/Core/MathFunctions.h	/^  struct round_impl$/;"	s	namespace:Eigen::internal
round_retval	Eigen/src/Core/MathFunctions.h	/^struct round_retval$/;"	s	namespace:Eigen::internal
round_style	Eigen/src/Core/arch/CUDA/Half.h	/^  static const std::float_round_style round_style = std::round_to_nearest;$/;"	m	struct:std::numeric_limits
round_style	unsupported/test/mpreal/mpreal.h	/^        inline static float_round_style round_style()$/;"	f	class:std::numeric_limits
round_style	unsupported/test/mpreal/mpreal.h	/^        static const std::float_round_style round_style = round_to_nearest;$/;"	m	class:std::numeric_limits
row	Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Traits::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon457
row	Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Traits::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon458
row	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Index row() const             { return m_iter.row(); }$/;"	f	class:Eigen::InnerIterator
row	Eigen/src/Core/CoreIterators.h	/^  inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::internal::inner_iterator_selector
row	Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % DstXprType::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_loop::__anon456
row	Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon642
row	Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
row	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index row()    const { return EvalIterator::row()   - m_block.startRow(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerVectorInnerIterator
row	Eigen/src/SparseCore/SparseBlock.h	/^  inline Index row()    const { return IsRowMajor ? 0 : index(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
row	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
row	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return IsRowMajor ? m_lhsIter.outer() : m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return IsRowMajor ? m_rhsIter.outer() : m_id; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index row()   const { return NeedToTranspose ? m_outer : LhsIterator::index(); }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const    { return SparseXprType::IsRowMajor ? m_sparseIter.outer() : m_sparseIter.index(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseTranspose.h	/^      Index row() const { return EvalIterator::col(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
row	Eigen/src/SparseCore/SparseUtil.h	/^  const StorageIndex& row() const { return m_row; }$/;"	f	class:Eigen::Triplet
row	Eigen/src/SparseCore/SparseView.h	/^        inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
row	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index row() const { return index(); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
row	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f
row	Eigen/src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f
row	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index row() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
row	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index row() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
row	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index row() const  {return index(); }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
row	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index row() const { return index();}$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
row	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : Base::index(); }$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
row	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : Base::index(); }$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
rowChip	bench/tensors/tensor_benchmarks.h	/^  void rowChip(int num_iters) {$/;"	f	class:BenchmarkSuite
rowIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* rowIndex()  { return m_rowind; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* rowIndex() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexByOuterInner	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
rowIndexByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
rowIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* rowIndexPtr() { return m_rowind_colptr; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* rowIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowInflateStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index rowInflateStride() const { return m_row_inflate_strides; }$/;"	f	struct:Eigen::TensorEvaluator
rowInflateStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index rowInflateStride() const { return m_row_inflate_strides; }$/;"	f	struct:Eigen::TensorEvaluator
rowOffset	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }$/;"	f	struct:Eigen::internal::evaluator
rowOffset	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
rowPaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index rowPaddingTop() const { return m_rowPaddingTop; }$/;"	f	struct:Eigen::TensorEvaluator
rowPaddingTop	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index rowPaddingTop() const { return m_rowPaddingTop; }$/;"	f	struct:Eigen::TensorEvaluator
rowPrefix	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowReduction	bench/tensors/tensor_benchmarks.h	/^  void rowReduction(int num_iters) {$/;"	f	class:BenchmarkSuite
rowSeparator	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSpacer	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowStride	Eigen/src/Core/CoreEvaluators.h	/^  inline Index rowStride() const { return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value(); }$/;"	f	struct:Eigen::internal::mapbase_evaluator
rowStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase
rowSuffix	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex row_inflate_strides() const { return m_row_inflate_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
row_inflate_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex row_inflate_strides() const { return m_row_inflate_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
row_major_bit	Eigen/src/Core/Matrix.h	/^      row_major_bit = _Options&RowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon438
row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^    DenseIndex row_strides() const { return m_row_strides; }$/;"	f	class:Eigen::TensorImagePatchOp
row_strides	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^    DenseIndex row_strides() const { return m_row_strides; }$/;"	f	class:Eigen::TensorVolumePatchOp
rowblk	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index rowblk; \/\/ The minimum row dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
rows	Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT
rows	Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT
rows	Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline StorageIndex rows() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }$/;"	f	class:Eigen::CholmodBase
rows	Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper
rows	Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper
rows	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index rows() const        { return m_dstExpr.rows(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
rows	Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix
rows	Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
rows	Eigen/src/Core/Block.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
rows	Eigen/src/Core/CoreEvaluators.h	/^  Index rows() const $/;"	f	class:Eigen::internal::EvalToTemp
rows	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp
rows	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
rows	Eigen/src/Core/CwiseTernaryOp.h	/^  EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseTernaryOp
rows	Eigen/src/Core/CwiseUnaryOp.h	/^    Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp
rows	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView
rows	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows() const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal
rows	Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
rows	Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase
rows	Eigen/src/Core/ForceAlignedAccess.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess
rows	Eigen/src/Core/Inverse.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::Inverse
rows	Eigen/src/Core/MapBase.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase
rows	Eigen/src/Core/NestByValue.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue
rows	Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
rows	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase
rows	Eigen/src/Core/Product.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::Product
rows	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::internal::redux_evaluator
rows	Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate
rows	Eigen/src/Core/ReturnByValue.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue
rows	Eigen/src/Core/Reverse.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse
rows	Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select
rows	Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView
rows	Eigen/src/Core/Solve.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }$/;"	f	class:Eigen::Solve
rows	Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
rows	Eigen/src/Core/Transpose.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose
rows	Eigen/src/Core/Transpositions.h	/^    Index rows() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
rows	Eigen/src/Core/Transpositions.h	/^    Index rows() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
rows	Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase
rows	Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView
rows	Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr
rows	Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::internal::visitor_evaluator
rows	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
rows	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
rows	Eigen/src/Geometry/Homogeneous.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
rows	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
rows	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
rows	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return int(Mode)==int(Projective) ? m_matrix.cols() : (m_matrix.cols()-1); }$/;"	f	class:Eigen::Transform
rows	Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence
rows	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
rows	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    Index rows() const { return m_L.rows(); }$/;"	f	class:Eigen::IncompleteCholesky
rows	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT
rows	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return matrix().rows(); }$/;"	f	class:Eigen::IterativeSolverBase
rows	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }$/;"	f	class:Eigen::SolveWithGuess
rows	Eigen/src/LU/FullPivLU.h	/^    EIGEN_DEVICE_FUNC inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU
rows	Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU
rows	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase
rows	Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
rows	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR
rows	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline Index rows() const { return m_cpqr.rows(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
rows	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR
rows	Eigen/src/QR/FullPivHouseholderQR.h	/^  Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
rows	Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR
rows	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index rows() const {return m_rows; }$/;"	f	class:Eigen::SPQR
rows	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index rows() const { return m_transpose ? m_spqr.rows() : m_spqr.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
rows	Eigen/src/SVD/SVDBase.h	/^  inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::SVDBase
rows	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
rows	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl
rows	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
rows	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl
rows	Eigen/src/SparseCore/SparseMap.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMapBase
rows	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
rows	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase
rows	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView
rows	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
rows	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector
rows	Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView
rows	Eigen/src/SparseLU/SparseLU.h	/^    inline Index rows() const { return m_mat.rows(); }$/;"	f	class:Eigen::SparseLU
rows	Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
rows	Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
rows	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index rows() { return m_row; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rows	Eigen/src/SparseQR/SparseQR.h	/^    inline Index rows() const { return m_pmat.rows(); }$/;"	f	class:Eigen::SparseQR
rows	Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.matrixQ().rows(); }$/;"	f	struct:Eigen::SparseQR_QProduct
rows	Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
rows	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase
rows	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return mp_matrix.rows(); }$/;"	f	class:Eigen::UmfPackLU
rows	Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base
rows	Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base
rows	doc/examples/matrixfree_cg.cpp	/^  Index rows() const { return mp_mat->rows(); }$/;"	f	class:MatrixReplacement
rows	doc/snippets/Tutorial_commainit_02.cpp	/^int rows=5, cols=5;$/;"	v
rows	unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLU
rows	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^    inline Index rows() const { return m_A.rows() * m_B.rows(); }$/;"	f	class:Eigen::KroneckerProductBase
rows	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    Index rows() const { return m_src.rows(); }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixFunctionReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixComplexPowerReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixPower
rows	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixPowerReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^    Index rows() const { return m_pow.rows(); }$/;"	f	class:Eigen::MatrixPowerParenthesesReturnValue
rows	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    Index rows() const { return m_src.rows(); }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
rows	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index rows() const {$/;"	f	class:Eigen::SkylineMatrix
rows	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index rows() const {$/;"	f	class:Eigen::SkylineMatrixBase
rows	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::internal::SkylineProduct
rows	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    Index rows() const$/;"	f	class:Eigen::BlockSparseMatrixView
rows	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index rows() const { return (m_mat.m_blockSize==Dynamic) ? (m_mat.m_innerOffset[index()+1] - m_mat.m_innerOffset[index()]) : m_mat.m_blockSize; }$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
rows	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index rows() const$/;"	f	class:Eigen::BlockSparseMatrix
rows	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? outerSize() : m_innerSize; }$/;"	f	class:Eigen::DynamicSparseMatrix
rowsPermutation	Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& rowsPermutation() const$/;"	f	class:Eigen::SparseLU
rowsTranspositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntDiagSizeVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR
rows_select	Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon290
rowwise	Eigen/src/Core/DenseBase.h	/^    EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {$/;"	f	class:Eigen::DenseBase
rowwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase
rrow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	311;"	d
rrow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	378;"	d
rsqrt	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^rsqrt() const$/;"	f
rsqrt	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    rsqrt() const {$/;"	f	class:Eigen::TensorBase
rtime	bench/sparse_randomsetter.cpp	/^static double rtime;$/;"	v	file:
run	Eigen/src/CholmodSupport/CholmodSupport.h	/^  static void run(CholmodType& mat) {$/;"	f	struct:Eigen::internal::cholmod_configure_matrix
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &, Index) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::dense_assignment_loop
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_InnerUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_InnerUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel& kernel)$/;"	f	struct:Eigen::internal::copy_using_evaluator_LinearTraversal_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_LinearTraversal_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_innervec_CompleteUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index) { }$/;"	f	struct:Eigen::internal::copy_using_evaluator_DefaultTraversal_InnerUnrolling
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index, Index) {}$/;"	f	struct:Eigen::internal::unaligned_dense_assignment_loop
run	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)$/;"	f	struct:Eigen::internal::dense_assignment_loop
run	Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_DONT_INLINE void run(Kernel &kernel,$/;"	f	struct:Eigen::internal::unaligned_dense_assignment_loop
run	Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,SrcScalarType> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/AssignEvaluator.h	/^  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,SrcScalarType> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived & \/*mat*\/) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &\/*mat*\/) { return true; }$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/ConditionEstimator.h	/^  static inline Vector run(const Vector& v) {$/;"	f	struct:Eigen::internal::rcond_compute_sign
run	Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl
run	Eigen/src/Core/DenseCoeffsBase.h	/^  static inline Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	Eigen/src/Core/DenseCoeffsBase.h	/^  static inline Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/DiagonalMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/Dot.h	/^  static ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck
run	Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isApprox_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isApprox_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_dense_selector
run	Eigen/src/Core/GeneralProduct.h	/^  static void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_dense_selector
run	Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_impl
run	Eigen/src/Core/MathFunctions.h	/^    static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::arg_default_impl
run	Eigen/src/Core/MathFunctions.h	/^    static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::arg_impl
run	Eigen/src/Core/MathFunctions.h	/^    static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::round_impl
run	Eigen/src/Core/MathFunctions.h	/^  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)$/;"	f	struct:Eigen::internal::pow_impl
run	Eigen/src/Core/MathFunctions.h	/^  static EIGEN_DEVICE_FUNC inline result_type run(const ScalarX& x, const ScalarY& y)$/;"	f	struct:Eigen::internal::pow_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl_default
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::log1p_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline T run(const std::complex<T>& x)$/;"	f	struct:Eigen::internal::imag_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline T run(const std::complex<T>& x)$/;"	f	struct:Eigen::internal::real_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctionsImpl.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl
run	Eigen/src/Core/NumTraits.h	/^  static int run() { return 0; }$/;"	f	struct:Eigen::internal::default_digits10_impl
run	Eigen/src/Core/NumTraits.h	/^  static int run() { return std::numeric_limits<T>::digits10; }$/;"	f	struct:Eigen::internal::default_digits10_impl
run	Eigen/src/Core/NumTraits.h	/^  static int run() {$/;"	f	struct:Eigen::internal::default_digits10_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index, Index)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/ProductEvaluators.h	/^    static inline void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::permutation_matrix_product
run	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, Index \/*innerDim*\/, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index \/*innerDim*\/, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)$/;"	f	struct:Eigen::internal::etor_product_packet_impl
run	Eigen/src/Core/ProductEvaluators.h	/^  static inline void run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::transposition_matrix_product
run	Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const AssignFunc& func)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const InitialFunc& \/*func*\/)$/;"	f	struct:Eigen::internal::assignment_from_xpr_op_product
run	Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/ProductEvaluators.h	/^  void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC static Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Reverse.h	/^  static inline PacketType run(const PacketType& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	Eigen/src/Core/Reverse.h	/^  static inline PacketType run(const PacketType& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	Eigen/src/Core/Reverse.h	/^  static void run(ExpressionType &xpr)$/;"	f	struct:Eigen::internal::vectorwise_reverse_inplace_impl
run	Eigen/src/Core/Solve.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector
run	Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Kernel &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_loop
run	Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Kernel &kernel)$/;"	f	struct:Eigen::internal::triangular_assignment_loop
run	Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/TriangularMatrix.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	Eigen/src/Core/arch/AVX/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cd& first, const Packet2cd& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AVX/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet4cf& first, const Packet4cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AVX/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4d& first, const Packet4d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AVX/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet8f& first, const Packet8f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet16f& first,$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet8d& first, const Packet8d& second) {$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/CUDA/Half.h	/^  static inline half run()$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/arch/CUDA/Half.h	/^  static inline half run(const half& x, const half& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/NEON/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/ZVector/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/ZVector/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static void run(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha, bool beta)$/;"	f	struct:Eigen::general_product_to_triangular_selector
run	Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,LhsMapper,ColMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,ConjugateLhs,RhsScalar,RhsMapper,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static void run(Dest &dst, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_product_impl
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  static void run(Dest& dest, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_product_impl
run	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::selfadjoint_matrix_vector_product
run	Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update
run	Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector
run	Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector
run	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run($/;"	f	class:Eigen::internal::product_triangular_matrix_matrix
run	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix
run	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> static void run(Dest& dst, const Lhs &a_lhs, const Rhs &a_rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::triangular_product_impl
run	Eigen/src/Core/products/TriangularMatrixVector.h	/^  ::run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	class:Eigen::internal::triangular_matrix_vector_product
run	Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const Lhs &lhs, const Rhs &rhs, Dest& dest, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::trmv_selector
run	Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> static void run(Dest& dst, const Lhs &lhs, const Rhs &rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::triangular_product_impl
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector
run	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE To run(const From& x) { return To(x); }$/;"	f	struct:Eigen::internal::get_factor
run	Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }$/;"	f	struct:Eigen::internal::get_factor
run	Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector
run	Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector
run	Eigen/src/Core/util/Memory.h	/^  EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper
run	Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_memmove_helper
run	Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg
run	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase
run	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename ArgType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector
run	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived>& q){$/;"	f	struct:Eigen::internal::quat_conj
run	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC static inline void run(QuaternionBase<Derived>& q, const Other& a_mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_DEVICE_FUNC static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/RotationBase.h	/^  EIGEN_DEVICE_FUNC static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC static void run(MatrixType &mat)$/;"	f	struct:Eigen::internal::transform_make_affine
run	Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	Eigen/src/Geometry/Transform.h	/^  template<typename MatrixType> EIGEN_DEVICE_FUNC static void run(MatrixType &) { }$/;"	f	struct:Eigen::internal::transform_make_affine
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& q)$/;"	f	struct:Eigen::internal::quat_conj
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& q)$/;"	f	struct:Eigen::internal::quat_conj
run	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/Jacobi/Jacobi.h	/^  static inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)$/;"	f	struct:Eigen::internal::apply_rotation_in_the_plane_selector
run	Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	Eigen/src/LU/FullPivLU.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/LU/InverseImpl.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check
run	Eigen/src/LU/InverseImpl.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse
run	Eigen/src/LU/InverseImpl.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/LU/InverseImpl.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	Eigen/src/LU/PartialPivLU.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename LuType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& mat, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	Eigen/src/PardisoSupport/PardisoSupport.h	/^    static IndexType run( _MKL_DSS_HANDLE_t pt, IndexType maxfct, IndexType mnum, IndexType type, IndexType phase, IndexType n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector
run	Eigen/src/QR/ColPivHouseholderQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename QrType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename CodType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/QR/FullPivHouseholderQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename QrType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/QR/HouseholderQR.h	/^  static void run(MatrixQR& mat, HCoeffs& hCoeffs, Index maxBlockSize=32,$/;"	f	struct:Eigen::internal::householder_qr_inplace_blocked
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q, RealScalar& maxDiagEntry)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType&, SVD&, Index, Index, RealScalar&) { return true; }$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    static void run(const InputMatrixType& input, ConstCholMatrixPtr &pmat, CholMatrixType &tmp)$/;"	f	struct:Eigen::internal::simplicial_cholesky_grab_input
run	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    static void run(const MatrixType& input, ConstMatrixPtr &pmat, MatrixType &\/*tmp*\/)$/;"	f	struct:Eigen::internal::simplicial_cholesky_grab_input
run	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector
run	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::sparse_sparse_to_dense_product_selector
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(SparseMatrix<Scalar,Options,StorageIndex> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseAssign.h	/^  static void run(SparseMatrixBase<DstDerived> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	Eigen/src/SparseCore/SparsePermutation.h	/^    static inline void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)$/;"	f	struct:Eigen::internal::permutation_matrix_product
run	Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseProduct.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(DynamicSparseMatrix<DestScalar,ColMajor,StorageIndex>& dst, const SrcXprType &src, const AssignOpType&\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src, const AssignFunc& func)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src, const AssignOpType&\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<DestScalar,StorageOrder,StorageIndex> &dst, const SrcXprType &src,$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseMatrix<Scalar,Options,DstIndex> &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void run(SparseSelfAdjointView<DestType,DestMode>& dst, const SrcXprType &src, const internal::assign_op<Scalar,typename MatrixType::Scalar> &)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
run	Eigen/src/SparseCore/SparseVector.h	/^  static void run(Dest& dst, const Src& src) {$/;"	f	struct:Eigen::internal::sparse_vector_assign_selector
run	Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector
run	Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
run	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<1>::run(const Index \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<SegSizeAtCompileTime>::run(const Index segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	Eigen/src/SparseQR/SparseQR.h	/^  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &\/*func*\/)$/;"	f	struct:Eigen::internal::Assignment
run	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper
run	bench/analyze-blocking-sizes.cpp	/^  virtual void run(const vector<string>&) const { abort(); }$/;"	f	struct:action_t
run	bench/benchGeometry.cpp	/^    static EIGEN_DONT_INLINE res run( arg1& a1, arg2& a2 )$/;"	f	struct:func
run	bench/benchGeometry.cpp	/^    static void run()$/;"	f	struct:test_transform
run	bench/geometry.cpp	/^  static EIGEN_DONT_INLINE void run(const Transformation& t)$/;"	f	struct:bench_impl
run	bench/geometry.cpp	/^  static EIGEN_DONT_INLINE void run(const Transformation&) {}$/;"	f	struct:bench_impl
run	bench/product_threshold.cpp	/^  static void run()$/;"	f	struct:loop_on_k
run	bench/product_threshold.cpp	/^  static void run()$/;"	f	struct:loop_on_m
run	bench/product_threshold.cpp	/^  static void run()$/;"	f	struct:loop_on_n
run	bench/product_threshold.cpp	/^  static void run()$/;"	f	struct:print_n
run	bench/product_threshold.cpp	/^struct loop_on_k<M,N,END> { static void run(){} };$/;"	f	struct:loop_on_k
run	bench/product_threshold.cpp	/^struct loop_on_m<END,N,K> { static void run(){} };$/;"	f	struct:loop_on_m
run	bench/product_threshold.cpp	/^struct loop_on_n<M,END,K,Scalar,Mode> { static void run(){} };$/;"	f	struct:loop_on_n
run	bench/product_threshold.cpp	/^template<> struct print_n<END> { static void run(){} };$/;"	f	struct:print_n
run	blas/BandTriangularSolver.h	/^  static void run(Index size, Index k, const LhsScalar* _lhs, Index lhsStride, RhsScalar* _other)$/;"	f	struct:internal::band_solve_triangular_selector
run	blas/GeneralRank1Update.h	/^  static void run(Index rows, Index cols, Scalar* mat, Index stride, const Scalar* u, const Scalar* v, Scalar alpha)$/;"	f	struct:internal::general_rank1_update
run	blas/PackedSelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, const Scalar* vec, RealScalar alpha)$/;"	f	struct:internal::selfadjoint_packed_rank1_update
run	blas/PackedTriangularMatrixVector.h	/^  static void run(Index size, const LhsScalar* lhs, const RhsScalar* rhs, ResScalar* res, ResScalar alpha)$/;"	f	struct:internal::packed_triangular_matrix_vector_product
run	blas/PackedTriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* lhs, RhsScalar* rhs)$/;"	f	struct:internal::packed_triangular_solve_vector
run	blas/Rank2Update.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* u, const Scalar* v, Scalar alpha)$/;"	f	struct:internal::rank2_update_selector
run	blas/Rank2Update.h	/^  static void run(Index size, Scalar* mat, const Scalar* u, const Scalar* v, Scalar alpha)$/;"	f	struct:internal::packed_rank2_update_selector
run	blas/level2_impl.h	/^  static void run(Index rows, Index cols,const Scalar *lhs, Index lhsStride, const Scalar *rhs, Index rhsIncr, Scalar* res, Index resIncr, Scalar alpha)$/;"	f	struct:general_matrix_vector_product_wrapper
run	demos/mandelbrot/mandelbrot.cpp	/^void MandelbrotThread::run()$/;"	f	class:MandelbrotThread
run	test/adjoint.cpp	/^  static void run(const Vec& v1, const Vec& v2, Vec& v3, const Mat& square, Scalar s1, Scalar s2) {$/;"	f	struct:adjoint_specific
run	test/boostmultiprec.cpp	/^      static inline NewType run(const Real& x) {$/;"	f	struct:Eigen::internal::cast_impl
run	test/boostmultiprec.cpp	/^      static inline std::complex<Real>  run(const Real& x) {$/;"	f	struct:Eigen::internal::cast_impl
run	test/commainitializer.cpp	/^  static void run() { }$/;"	f	struct:test_block_recursion
run	test/commainitializer.cpp	/^  static void run()$/;"	f	struct:test_block_recursion
run	test/mapstaticmethods.cpp	/^  static void run(const PlainObjectType& m)$/;"	f	struct:mapstaticmethods_impl
run	test/mapstaticmethods.cpp	/^  static void run(const PlainObjectType& v)$/;"	f	struct:mapstaticmethods_impl
run	test/vectorization_logic.cpp	/^  static void run() {}$/;"	f	struct:vectorization_logic
run	test/vectorization_logic.cpp	/^  static void run() {}$/;"	f	struct:vectorization_logic_half
run	test/vectorization_logic.cpp	/^  static void run()$/;"	f	struct:vectorization_logic
run	test/vectorization_logic.cpp	/^  static void run()$/;"	f	struct:vectorization_logic_half
run	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void run() {$/;"	f	class:Eigen::TensorEvaluator::Context
run	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^    static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE PacketReturnType run(const TensorEvaluator<ArgType, Device>& impl, Index index) {$/;"	f	struct:Eigen::TensorEvaluator::PacketConv
run	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool run(Eval& impl, Scalar* data) {$/;"	f	struct:Eigen::ConversionSubExprEval
run	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool run(Eval& impl, Scalar*) {$/;"	f	struct:Eigen::ConversionSubExprEval
run	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  static void run(Barrier* b, Function f, Args... args) {$/;"	f	struct:Eigen::FunctionWrapperWithBarrier
run	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  static void run(Notification* n, Function f, Args... args) {$/;"	f	struct:Eigen::FunctionWrapperWithNotification
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static EIGEN_ALWAYS_INLINE bool run() {$/;"	f	struct:Eigen::internal::all_indices_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static EIGEN_ALWAYS_INLINE bool run(const DenseIndex) {$/;"	f	struct:Eigen::internal::index_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run() {$/;"	f	struct:Eigen::internal::all_indices_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run() {$/;"	f	struct:Eigen::internal::indices_statically_known_to_increase_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_gt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_lt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex) {$/;"	f	struct:Eigen::internal::index_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run() {$/;"	f	struct:Eigen::internal::indices_statically_known_to_increase_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run(const DenseIndex, const DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run(const DenseIndex, const DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_gt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run(const DenseIndex, const DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_lt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run(const DenseIndex, const DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool run(const DenseIndex, const DenseIndex){$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  Index run(array<Index, NumIndices> const& indices, array<Index, NumIndices> const& dimensions)$/;"	f	struct:Eigen::internal::tensor_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  Index run(array<Index, NumIndices> const& indices, array<Index, NumIndices> const&)$/;"	f	struct:Eigen::internal::tensor_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  Index run(array<Index, NumIndices> const& indices, std::vector<DenseIndex> const& dimensions)$/;"	f	struct:Eigen::internal::tensor_vsize_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  Index run(array<Index, NumIndices> const& indices, std::vector<DenseIndex> const&)$/;"	f	struct:Eigen::internal::tensor_vsize_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static EIGEN_DEVICE_FUNC  inline bool run(Dims1& dims1, Dims2& dims2) {$/;"	f	struct:Eigen::internal::sizes_match_below_dim
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static EIGEN_DEVICE_FUNC  inline bool run(Dims1&, Dims2&) {$/;"	f	struct:Eigen::internal::sizes_match_below_dim
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static inline Index run(array<Index, NumIndices> const& indices,$/;"	f	struct:Eigen::internal::fixed_size_tensor_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static inline Index run(array<Index, NumIndices> const&, const Dimensions&)$/;"	f	struct:Eigen::internal::fixed_size_tensor_index_linearization_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static inline Index run(const Index index,$/;"	f	struct:Eigen::internal::fixed_size_tensor_index_extraction_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static inline Index run(const Index,$/;"	f	struct:Eigen::internal::fixed_size_tensor_index_extraction_helper
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static inline void run(const Expression &expr, const SyclDevice &device) {$/;"	f	class:Eigen::internal::TensorExecutor
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static inline void run(const Expression& expr, const DefaultDevice& device = DefaultDevice())$/;"	f	class:Eigen::internal::TensorExecutor
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static inline void run(const Expression& expr, const Device& device = Device())$/;"	f	class:Eigen::internal::TensorExecutor
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static inline void run(const Expression& expr, const ThreadPoolDevice& device)$/;"	f	class:Eigen::internal::TensorExecutor
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  static void run(Evaluator* evaluator_in, const Index first, const Index last) {$/;"	f	struct:Eigen::internal::EvalRange
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^  void run(Evaluator& eval, Index first, Index last, Index step_size) {$/;"	f	struct:Eigen::internal::EigenMetaKernelEval
run	unsupported/Eigen/CXX11/src/Tensor/TensorExecutor.h	/^inline void TensorExecutor<Expression, GpuDevice, Vectorizable>::run($/;"	f	class:Eigen::internal::TensorExecutor
run	unsupported/Eigen/CXX11/src/Tensor/TensorIO.h	/^  static void run (std::ostream& os, const Tensor& tensor) {$/;"	f	struct:Eigen::internal::TensorPrinter
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run() {$/;"	f	struct:Eigen::internal::all_indices_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run() {$/;"	f	struct:Eigen::internal::indices_statically_known_to_increase_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_pair_first_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_pair_second_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_gt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_lt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(DenseIndex, DenseIndex) {$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i) {$/;"	f	struct:Eigen::internal::index_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_pair_first_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_pair_second_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_eq_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_gt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_lt_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::internal::index_statically_ne_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool run(const DenseIndex) {$/;"	f	struct:Eigen::internal::index_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static constexpr bool run() {$/;"	f	struct:Eigen::internal::all_indices_known_statically_impl
run	unsupported/Eigen/CXX11/src/Tensor/TensorInitializer.h	/^  static void run(TensorEvaluator<Derived, DefaultDevice>& tensor,$/;"	f	struct:Eigen::internal::Initializer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC static bool run(const Self&, Op&, const Device&, typename Self::CoeffReturnType*, typename Self::Index, typename Self::Index) {$/;"	f	struct:Eigen::internal::InnerReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  EIGEN_DEVICE_FUNC static bool run(const Self&, Op&, const Device&, typename Self::CoeffReturnType*, typename Self::Index, typename Self::Index) {$/;"	f	struct:Eigen::internal::OuterReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(const Self& self, typename Self::Index firstIndex,$/;"	f	struct:Eigen::internal::FullReducerShard
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static EIGEN_DEVICE_FUNC void run(const Self& self, Op& reducer, const Device&, typename Self::CoeffReturnType* output) {$/;"	f	struct:Eigen::internal::FullReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static void run(const InputDims& input_dims, const array<bool, Rank>&,$/;"	f	struct:Eigen::internal::DimInitializer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static void run(const InputDims& input_dims,$/;"	f	struct:Eigen::internal::DimInitializer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static void run(const Self& self, Op& reducer, const ThreadPoolDevice& device,$/;"	f	struct:Eigen::internal::FullReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static EIGEN_DEVICE_FUNC bool run(const Self&, Op&, const Device&, OutputType*, typename Self::Index, typename Self::Index) {$/;"	f	struct:Eigen::internal::OuterReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static EIGEN_DEVICE_FUNC bool run(const Self&, Op&, const GpuDevice&, OutputType*, typename Self::Index, typename Self::Index) {$/;"	f	struct:Eigen::internal::InnerReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static bool run(const Self& self, Op& reducer, const GpuDevice& device, OutputType* output, typename Self::Index num_coeffs_to_reduce, typename Self::Index num_preserved_vals) {$/;"	f	struct:Eigen::internal::InnerReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static bool run(const Self& self, Op& reducer, const GpuDevice& device, OutputType* output, typename Self::Index num_coeffs_to_reduce, typename Self::Index num_preserved_vals) {$/;"	f	struct:Eigen::internal::InnerReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static bool run(const Self& self, Op& reducer, const GpuDevice& device, float* output, typename Self::Index num_coeffs_to_reduce, typename Self::Index num_preserved_vals) {$/;"	f	struct:Eigen::internal::OuterReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static bool run(const Self& self, Op& reducer, const GpuDevice& device, half* output, typename Self::Index num_coeffs_to_reduce, typename Self::Index num_preserved_vals) {$/;"	f	struct:Eigen::internal::InnerReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static bool run(const Self&, Op&, const GpuDevice&, half*, typename Self::Index, typename Self::Index) {$/;"	f	struct:Eigen::internal::InnerReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static void run(const Self& self, Op& reducer, const GpuDevice& device, OutputType* output) {$/;"	f	struct:Eigen::internal::FullReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static void run(const Self& self, Op& reducer, const GpuDevice& device, OutputType* output, typename Self::Index num_coeffs) {$/;"	f	struct:Eigen::internal::FullReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static void run(const Self& self, Op& reducer, const GpuDevice& device, half* output, typename Self::Index num_coeffs) {$/;"	f	struct:Eigen::internal::FullReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static void run(const Self&, Op&, const GpuDevice&, OutputType*, typename Self::Index) {$/;"	f	struct:Eigen::internal::FullReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionCuda.h	/^  static void run(const Self&, Op&, const GpuDevice&, half*, typename Self::Index) {$/;"	f	struct:Eigen::internal::FullReductionLauncher
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  static bool run(const Self& self, Op& reducer, const Eigen::SyclDevice& dev, CoeffReturnType* output, typename Self::Index , typename Self::Index num_coeffs_to_preserve) {$/;"	f	struct:Eigen::internal::InnerReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^  static void run(const Self& self, Op& reducer, const Eigen::SyclDevice& dev, CoeffReturnType* output) {$/;"	f	struct:Eigen::internal::FullReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^static void run(BufferTOut* bufOut, BufferTIn& bufI, const Eigen::SyclDevice& dev, size_t length, size_t local){$/;"	f	struct:Eigen::internal::syclGenericBufferReducer
run	unsupported/Eigen/CXX11/src/Tensor/TensorSyclRun.h	/^void run(Expr &expr, Dev &dev) {$/;"	f	namespace:Eigen::TensorSycl
run	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  constexpr static inline std::array<T, N> run(const std::array<T, N>& indices)$/;"	f	struct:Eigen::internal::tensor_static_symgroup_permutate
run	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  static inline RV run(const std::array<Index, NumIndices>& idx, RV initial, Args&&... args)$/;"	f	struct:Eigen::internal::tensor_static_symgroup_do_apply
run	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  static inline RV run(const std::array<Index, NumIndices>&, RV initial, Args&&...)$/;"	f	struct:Eigen::internal::tensor_static_symgroup_do_apply
run	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  static inline RV run(const std::vector<Index>& idx, RV initial, Args&&... args)$/;"	f	struct:Eigen::internal::tensor_static_symgroup_do_apply
run	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  static inline RV run(const std::vector<Index>&, RV initial, Args&&...)$/;"	f	struct:Eigen::internal::tensor_static_symgroup_do_apply
run	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  static inline int run(const std::array<Index, NumIndices>& transformed_indices, int transform_flags, int current_flags, const std::array<Index, NumIndices>& orig_indices)$/;"	f	struct:Eigen::internal::tensor_symmetry_calculate_flags
run	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  static inline int run(const std::array<Index, NumIndices>& transformed_indices, int transformation_flags, int dummy, Tensor_& tensor, const Scalar& value_)$/;"	f	struct:Eigen::internal::tensor_symmetry_assign_value
run	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static inline A run(A a) { return a; }$/;"	f	struct:Eigen::internal::reduce
run	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static inline auto run(A a, Ts... ts) -> decltype(Reducer::run(a, reduce<Reducer, Ts...>::run(ts...))) {$/;"	f	struct:Eigen::internal::reduce
run	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static inline int run() { return Reducer::Identity; }$/;"	f	struct:Eigen::internal::reduce
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static inline bool run(const array<A, 1>& a) {$/;"	f	struct:Eigen::internal::ArrayApplyAndReduce
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static inline bool run(const array<A, 1>& a, const array<B, 1>& b) {$/;"	f	struct:Eigen::internal::ArrayZipAndReduce
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static inline bool run(const array<A, N>& a) {$/;"	f	struct:Eigen::internal::ArrayApplyAndReduce
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static inline bool run(const array<A, N>& a, const array<B, N>& b) {$/;"	f	struct:Eigen::internal::ArrayZipAndReduce
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a != b; }$/;"	f	struct:Eigen::internal::not_equal_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a && b; }$/;"	f	struct:Eigen::internal::logical_and_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a * b; }$/;"	f	struct:Eigen::internal::product_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a + b; }$/;"	f	struct:Eigen::internal::sum_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a < b; }$/;"	f	struct:Eigen::internal::lesser_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a <= b; }$/;"	f	struct:Eigen::internal::lesser_equal_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a == b; }$/;"	f	struct:Eigen::internal::equal_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a > b; }$/;"	f	struct:Eigen::internal::greater_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a >= b; }$/;"	f	struct:Eigen::internal::greater_equal_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A, typename B> static inline bool run(A a, B b) { return a || b; }$/;"	f	struct:Eigen::internal::logical_or_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A> static inline bool run(A a) { return !a; }$/;"	f	struct:Eigen::internal::not_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A> static inline bool run(A a) { return -a; }$/;"	f	struct:Eigen::internal::negation_op
run	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  template<typename A> static inline bool run(A a) { return a >= 0; }$/;"	f	struct:Eigen::internal::greater_equal_zero_op
run	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  static void run(A& a, B& b) {$/;"	f	struct:Eigen::internal::make_coherent_impl
run	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  static void run(A&, B&) {}$/;"	f	struct:Eigen::internal::make_coherent_impl
run	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  static void run(const ArgType& arg, MatrixType& U, MatrixType& V, int& squarings)$/;"	f	struct:Eigen::internal::matrix_exp_computeUV
run	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^  static void run(const MatA& A, AtomicType& atomic, ResultType &result)$/;"	f	struct:Eigen::internal::matrix_function_compute
run	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^  static void run(const MatrixType &arg, ResultType &result)$/;"	f	struct:Eigen::internal::matrix_sqrt_compute
run	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    static void run(const Lhs& lhs, const Rhs& rhs, ResultType & res) {$/;"	f	struct:Eigen::internal::skyline_product_selector
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    static EIGEN_STRONG_INLINE Scalar run(Scalar n, Scalar x) {$/;"	f	struct:Eigen::internal::polygamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    static Scalar run(Scalar n, Scalar x) {$/;"	f	struct:Eigen::internal::polygamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    static Scalar run(Scalar x, Scalar q) {$/;"	f	struct:Eigen::internal::zeta_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(Scalar a, Scalar b, Scalar x) {$/;"	f	struct:Eigen::internal::betainc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(Scalar a, Scalar b, Scalar x, bool small_branch) {$/;"	f	struct:Eigen::internal::incbeta_cfe
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(Scalar a, Scalar x) {$/;"	f	struct:Eigen::internal::igamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(Scalar, Scalar, Scalar) {$/;"	f	struct:Eigen::internal::betainc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar x, const Scalar coef[]) {$/;"	f	struct:Eigen::internal::cephes::polevl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar) {$/;"	f	struct:Eigen::internal::digamma_impl_maybe_poly
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar) {$/;"	f	struct:Eigen::internal::erf_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar) {$/;"	f	struct:Eigen::internal::erfc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar) {$/;"	f	struct:Eigen::internal::lgamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar) {$/;"	f	struct:Eigen::internal::zeta_impl_series
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Scalar, const Scalar coef[]) {$/;"	f	struct:Eigen::internal::cephes::polevl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE bool run(double& a, double& b, double& s, const double x, const double machep) {$/;"	f	struct:Eigen::internal::zeta_impl_series
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE bool run(float& a, float& b, float& s, const float x, const float machep) {$/;"	f	struct:Eigen::internal::zeta_impl_series
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double run(const double s) {$/;"	f	struct:Eigen::internal::digamma_impl_maybe_poly
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double run(const double x) { return ::erfc(x); }$/;"	f	struct:Eigen::internal::erfc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double run(double x) { return ::erf(x); }$/;"	f	struct:Eigen::internal::erf_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE double run(double x) {$/;"	f	struct:Eigen::internal::lgamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float run(const float s) {$/;"	f	struct:Eigen::internal::digamma_impl_maybe_poly
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float run(const float x) { return ::erfcf(x); }$/;"	f	struct:Eigen::internal::erfc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float run(float x) { return ::erff(x); }$/;"	f	struct:Eigen::internal::erf_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static EIGEN_STRONG_INLINE float run(float x) {$/;"	f	struct:Eigen::internal::lgamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static Scalar run(Scalar a, Scalar x) {$/;"	f	struct:Eigen::internal::igamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static Scalar run(Scalar a, Scalar x) {$/;"	f	struct:Eigen::internal::igammac_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static Scalar run(Scalar x) {$/;"	f	struct:Eigen::internal::digamma_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static double run(double aa, double bb, double xx) {$/;"	f	struct:Eigen::internal::betainc_impl
run	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  static float run(float a, float b, float x) {$/;"	f	struct:Eigen::internal::betainc_impl
run	unsupported/test/cxx11_meta.cpp	/^struct times2_op { template<typename A> static A run(A v) { return v * 2; } };$/;"	f	struct:times2_op
run	unsupported/test/cxx11_tensor_symmetry.cpp	/^  static inline int run(std::array<int, N> e, int flags, int dummy, std::set<uint64_t>& found, std::map<uint64_t, int> const& expected)$/;"	f	struct:checkIdx
run	unsupported/test/cxx11_tensor_symmetry.cpp	/^  static inline int run(std::vector<int> e, int flags, int dummy, std::set<uint64_t>& found, std::map<uint64_t, int> const& expected)$/;"	f	struct:checkIdx
run	unsupported/test/matrix_function.cpp	/^  static MatrixType run(const typename MatrixType::Index size)$/;"	f	struct:randomMatrixWithImagEivals
run	unsupported/test/matrix_functions.h	/^  static void run(MatrixType& m, MatrixType& T, const MatrixType& U)$/;"	f	struct:processTriangularMatrix
run	unsupported/test/matrix_functions.h	/^  static void run(MatrixType& result, typename MatrixType::Index size)$/;"	f	struct:generateTestMatrix
run	unsupported/test/matrix_functions.h	/^  static void run(MatrixType&, MatrixType&, const MatrixType&)$/;"	f	struct:processTriangularMatrix
run_and_compare_to_cuda	test/cuda_common.h	/^void run_and_compare_to_cuda(const Kernel& ker, int n, const Input& in, Output& out)$/;"	f
run_fixed_size_test	test/umeyama.cpp	/^void run_fixed_size_test(int num_elements)$/;"	f
run_matrix_tests	test/conservative_resize.cpp	/^void run_matrix_tests()$/;"	f
run_nesting_ops_1	test/nesting_ops.cpp	/^template <typename MatrixType> void run_nesting_ops_1(const MatrixType& _m)$/;"	f
run_nesting_ops_2	test/nesting_ops.cpp	/^template <typename MatrixType> void run_nesting_ops_2(const MatrixType& _m)$/;"	f
run_on_cpu	test/cuda_common.h	/^void run_on_cpu(const Kernel& ker, int n, const Input& in, Output& out)$/;"	f
run_on_cuda	test/cuda_common.h	/^void run_on_cuda(const Kernel& ker, int n, const Input& in, Output& out)$/;"	f
run_on_cuda_meta_kernel	test/cuda_common.h	/^void run_on_cuda_meta_kernel(const Kernel ker, int n, const Input* in, Output* out)$/;"	f
run_test	test/umeyama.cpp	/^void run_test(int dim, int num_elements)$/;"	f
run_trans	bench/benchGeometry.cpp	88;"	d	file:
run_vec	bench/benchGeometry.cpp	79;"	d	file:
run_vector_tests	test/conservative_resize.cpp	/^void run_vector_tests()$/;"	f
rvalue_copyassign	test/rvalue_types.cpp	/^void rvalue_copyassign(const MatrixType& m)$/;"	f
rwupdt	unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^void rwupdt($/;"	f	namespace:Eigen::internal
s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation
sample	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox
samples	bench/btl/data/gnuplot_common_settings.hh	/^set samples 100, 100$/;"	v
samples	doc/snippets/LLT_solve.cpp	/^DataMatrix samples = DataMatrix::Random(12,2);$/;"	v
saupd	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void saupd(int *ido, char *bmat, int *n, char *which,$/;"	f	struct:Eigen::internal::arpack_wrapper
saveAsBitmap	doc/special_examples/Tutorial_sparse_example_details.cpp	/^void saveAsBitmap(const Eigen::VectorXd& x, int n, const char* filename)$/;"	f
saveMarket	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool saveMarket(const SparseMatrixType& mat, const std::string& filename, int sym = 0)$/;"	f	namespace:Eigen
saveMarketVector	unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool saveMarketVector (const VectorType& vec, const std::string& filename)$/;"	f	namespace:Eigen
scal	blas/level1_impl.h	/^int EIGEN_BLAS_FUNC(scal)(int *n, RealScalar *palpha, RealScalar *px, int *incx)$/;"	f
scal_	blas/level1_cplx_impl.h	/^int EIGEN_CAT(EIGEN_CAT(SCALAR_SUFFIX,REAL_SCALAR_SUFFIX),scal_)(int *n, RealScalar *palpha, RealScalar *px, int *incx)$/;"	f
scalarCount_	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^    DenseIndex scalarCount_;$/;"	m	struct:Eigen::internal::MeanReducer
scalar_abs2_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_arg_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_arg_op {$/;"	s	namespace:Eigen::internal
scalar_asin_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_atan_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_atan_op {$/;"	s	namespace:Eigen::internal
scalar_betainc_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_betainc_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_not_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_boolean_not_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_xor_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_boolean_xor_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<Eigen::half, float> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<float, Eigen::half> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct scalar_cast_op<int, Eigen::half> {$/;"	s	namespace:Eigen::internal
scalar_cast_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
scalar_ceil_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_ceil_op {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_EQ> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_GE> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_GT> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_LE> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_LT> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_NEQ> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_UNORD> : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_conj_product_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_conj_product_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	Eigen/src/Core/functors/NullaryFunctors.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	Eigen/src/Core/functors/NullaryFunctors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cosh_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_cosh_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_difference_op<const std::complex<T>, const std::complex<T> >  : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_difference_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_difference_op<std::complex<T>, std::complex<T> > : scalar_difference_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_difference_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_difference_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_digamma_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_digamma_op {$/;"	s	namespace:Eigen::internal
scalar_div_cost	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 16 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 14 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };$/;"	s	namespace:Eigen::internal
scalar_div_cost	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };$/;"	s	namespace:Eigen::internal
scalar_erf_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_erf_op {$/;"	s	namespace:Eigen::internal
scalar_erfc_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_erfc_op {$/;"	s	namespace:Eigen::internal
scalar_exp_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_floor_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_floor_op {$/;"	s	namespace:Eigen::internal
scalar_fmod_op	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct scalar_fmod_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_hypot_op<Scalar,Scalar> : binary_op_base<Scalar,Scalar>$/;"	s	namespace:Eigen::internal
scalar_identity_op	Eigen/src/Core/functors/NullaryFunctors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_igamma_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_igamma_op : binary_op_base<Scalar,Scalar>$/;"	s	namespace:Eigen::internal
scalar_igammac_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_igammac_op : binary_op_base<Scalar,Scalar>$/;"	s	namespace:Eigen::internal
scalar_imag_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
scalar_isfinite_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isfinite_op {$/;"	s	namespace:Eigen::internal
scalar_isinf_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isinf_op {$/;"	s	namespace:Eigen::internal
scalar_isnan_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_isnan_op {$/;"	s	namespace:Eigen::internal
scalar_lgamma_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_lgamma_op {$/;"	s	namespace:Eigen::internal
scalar_log10_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log10_op {$/;"	s	namespace:Eigen::internal
scalar_log1p_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log1p_op {$/;"	s	namespace:Eigen::internal
scalar_log_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_max_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_min_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_min_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_mod2_op	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct scalar_mod2_op {$/;"	s	namespace:Eigen::internal
scalar_mod_op	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^  EIGEN_DEVICE_FUNC scalar_mod_op(const Scalar& divisor) : m_divisor(divisor) {}$/;"	f	struct:Eigen::internal::scalar_mod_op
scalar_mod_op	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct scalar_mod_op {$/;"	s	namespace:Eigen::internal
scalar_norm1_op	blas/level1_cplx_impl.h	/^struct scalar_norm1_op {$/;"	s
scalar_opposite_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
scalar_polygamma_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_polygamma_op {$/;"	s	namespace:Eigen::internal
scalar_pow_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_pow_op  : binary_op_base<Scalar,Exponent>$/;"	s	namespace:Eigen::internal
scalar_product_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_product_op<const std::complex<T>, const std::complex<T> >  : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_product_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_product_op<std::complex<T>, std::complex<T> > : scalar_product_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_product_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_product_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_product_traits	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct scalar_product_traits$/;"	s	namespace:Eigen
scalar_quotient_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_quotient_op<const std::complex<T>, const std::complex<T> > : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_quotient_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_quotient_op<std::complex<T>, std::complex<T> > : scalar_quotient_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_quotient_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_quotient_op  : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_random_op	Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_round_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_round_op {$/;"	s	namespace:Eigen::internal
scalar_rsqrt_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_rsqrt_op {$/;"	s	namespace:Eigen::internal
scalar_score_coeff_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_score_coeff_op : scalar_abs_op<Scalar>$/;"	s	namespace:Eigen::internal
scalar_sigmoid_op	unsupported/Eigen/CXX11/src/Tensor/TensorFunctors.h	/^struct scalar_sigmoid_op {$/;"	s	namespace:Eigen::internal
scalar_sign_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_sign_op<Scalar,false> {$/;"	s	namespace:Eigen::internal
scalar_sign_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_sign_op<Scalar,true> {$/;"	s	namespace:Eigen::internal
scalar_sin_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sinh_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sinh_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_sum_op<const std::complex<T>, const std::complex<T> > : binary_op_base<const std::complex<T>, const std::complex<T> > {$/;"	s	namespace:Eigen::internal
scalar_sum_op	Eigen/src/Core/arch/CUDA/Complex.h	/^template<typename T> struct scalar_sum_op<std::complex<T>, std::complex<T> > : scalar_sum_op<const std::complex<T>, const std::complex<T> > {};$/;"	s	namespace:Eigen::internal
scalar_sum_op	Eigen/src/Core/functors/BinaryFunctors.h	/^  scalar_sum_op() {}$/;"	f	struct:Eigen::internal::scalar_sum_op
scalar_sum_op	Eigen/src/Core/functors/BinaryFunctors.h	/^struct scalar_sum_op : binary_op_base<LhsScalar,RhsScalar>$/;"	s	namespace:Eigen::internal
scalar_sum_op	Eigen/src/Core/functors/BinaryFunctors.h	/^template<> struct scalar_sum_op<bool,bool> : scalar_sum_op<int,int> {$/;"	s	namespace:Eigen::internal
scalar_tan_op	Eigen/src/Core/functors/UnaryFunctors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
scalar_tanh_op	Eigen/src/Core/functors/UnaryFunctors.h	/^struct scalar_tanh_op {$/;"	s	namespace:Eigen::internal
scalar_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef double scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scalar_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef float scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scalar_type	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef long double scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scalar_zeta_op	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsFunctors.h	/^template<typename Scalar> struct scalar_zeta_op {$/;"	s	namespace:Eigen::internal
scalbn	unsupported/test/mpreal/mpreal.h	/^inline const mpreal scalbn(const mpreal& v, mp_exp_t exp)$/;"	f	namespace:mpfr
scale	Eigen/src/Geometry/Transform.h	/^EIGEN_DEVICE_FUNC inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(const Scalar& s)$/;"	f	class:Eigen::Transform
scale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scaleAndAddTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl_base
scaleAndAddTo	Eigen/src/Core/ProductEvaluators.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& a_lhs, const Rhs& a_rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const RhsView& rhsView, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  static void scaleAndAddTo(Dest& dst, const LhsView& lhsView, const Rhs& rhs, const typename Dest::Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	doc/examples/matrixfree_cg.cpp	/^    static void scaleAndAddTo(Dest& dst, const MatrixReplacement& lhs, const Rhs& rhs, const Scalar& alpha)$/;"	f	struct:Eigen::internal::generic_product_impl
scaleAndAddTo	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const typename Rhs::Scalar& alpha) const$/;"	f	class:Eigen::BlockSparseTimeDenseProduct
scalingS	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    const VectorRx& scalingS() const { eigen_assert("m_factorizationIsOk"); return m_scale; }$/;"	f	class:Eigen::IncompleteCholesky
scan	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    scan(const Index& axis, const Reducer& reducer, bool exclusive = false) const {$/;"	f	class:Eigen::TensorBase
scatterPacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {$/;"	f	class:Eigen::internal::blas_data_mapper
schur	test/schur_complex.cpp	/^template<typename MatrixType> void schur(int size = MatrixType::ColsAtCompileTime)$/;"	f
schur	test/schur_real.cpp	/^template<typename MatrixType> void schur(int size = MatrixType::ColsAtCompileTime)$/;"	f
schurValues	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^inline typename DGMRES<_MatrixType, _Preconditioner>::ComplexVector DGMRES<_MatrixType, _Preconditioner>::schurValues(const ComplexSchur<DenseMatrix>& schurofH) const$/;"	f	class:Eigen::DGMRES
schurValues	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^inline typename DGMRES<_MatrixType, _Preconditioner>::ComplexVector DGMRES<_MatrixType, _Preconditioner>::schurValues(const RealSchur<DenseMatrix>& schurofH) const$/;"	f	class:Eigen::DGMRES
scomplex	Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
scoped_array	Eigen/src/Core/util/Memory.h	/^  explicit scoped_array(std::ptrdiff_t size)$/;"	f	class:Eigen::internal::scoped_array
scoped_array	Eigen/src/Core/util/Memory.h	/^template<typename T> class scoped_array : noncopyable$/;"	c	namespace:Eigen::internal
score	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType score ; \/* the score used to maintain heap, if col is alive *\/$/;"	m	union:internal::colamd_col::__anon869
scramble_FFT	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE static void scramble_FFT(ComplexScalar* data, Index n) {$/;"	f	struct:Eigen::TensorEvaluator
scratch_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  mutable void* scratch_;$/;"	m	class:Eigen::CudaStreamDevice
scratchpad	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE void* scratchpad() const {$/;"	f	struct:Eigen::GpuDevice
scratchpad	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual void* scratchpad() const {$/;"	f	class:Eigen::CudaStreamDevice
sdsdot	blas/single.cpp	/^float BLASFUNC(sdsdot)(int* n, float* alpha, float* x, int* incx, float* y, int* incy)$/;"	f
searchLowerIndex	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
searchLowerIndex	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index start, Index end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
sec	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sec   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(sec  );    }$/;"	f	namespace:mpfr
sech	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sech  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(sech );    }$/;"	f	namespace:mpfr
second	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  Packet second;$/;"	m	struct:Eigen::internal::DoublePacket
second	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const DenseIndex second = s;$/;"	m	struct:Eigen::type2indexpair
second	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  Idx second;$/;"	m	struct:Eigen::IndexPair
second	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  V second;$/;"	m	struct:Eigen::Tuple
second	unsupported/Eigen/src/BVH/KdBVH.h	/^  int second;$/;"	m	struct:Eigen::internal::vector_int_pair
second_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef Arg2 second_argument_type;$/;"	t	struct:Eigen::internal::binary_op_base
second_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::second_argument_type second_argument_type;$/;"	t	struct:Eigen::internal::bind1st_op
second_argument_type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef typename BinaryOp::second_argument_type second_argument_type;$/;"	t	struct:Eigen::internal::bind2nd_op
second_type	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  typedef V second_type;$/;"	t	struct:Eigen::Tuple
secularEq	Eigen/src/SVD/BDCSVD.h	/^typename BDCSVD<MatrixType>::RealScalar BDCSVD<MatrixType>::secularEq(RealScalar mu, const ArrayRef& col0, const ArrayRef& diag, const IndicesRef &perm, const ArrayRef& diagShifted, RealScalar shift)$/;"	f	class:Eigen::BDCSVD
segment	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType segment(Index start, Index n) const$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType segment(Index start, Index n)$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type segment(Index start, Index n = N) const$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type segment(Index start, Index n = N)$/;"	f
segmentFromRange	doc/examples/class_VectorBlock.cpp	/^segmentFromRange(MatrixBase<Derived>& v, int start, int end)$/;"	f
segmentFromRange	doc/examples/class_VectorBlock.cpp	/^segmentFromRange(const MatrixBase<Derived>& v, int start, int end)$/;"	f
select	Eigen/src/Core/GenericPacketMath.h	/^  bool select[N];$/;"	m	struct:Eigen::internal::Selector
select	Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase
select	Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,$/;"	f	class:Eigen::DenseBase
select	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    select(const ThenDerived& thenTensor, const ElseDerived& elseTensor) const {$/;"	f	class:Eigen::TensorBase
selectAndHighlight	doc/eigen_navtree_hacks.js	/^function selectAndHighlight(hash,n)$/;"	f
selectComplexRoot_withRespectToNorm	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& selectComplexRoot_withRespectToNorm( squaredNormBinaryPredicate& pred ) const$/;"	f	class:Eigen::PolynomialSolverBase
selectRealRoot_withRespectToAbsRealPart	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& selectRealRoot_withRespectToAbsRealPart($/;"	f	class:Eigen::PolynomialSolverBase
selectRealRoot_withRespectToRealPart	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& selectRealRoot_withRespectToRealPart($/;"	f	class:Eigen::PolynomialSolverBase
selector	Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type
selfadjoint	test/selfadjoint.cpp	/^template<typename MatrixType> void selfadjoint(const MatrixType& m)$/;"	f
selfadjointView	Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase
selfadjointView	Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase
selfadjointView	Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView
selfadjointView	Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView
selfadjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^typename SparseMatrixBase<Derived>::template ConstSelfAdjointViewReturnType<UpLo>::Type SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase
selfadjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^typename SparseMatrixBase<Derived>::template SelfAdjointViewReturnType<UpLo>::Type SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase
selfadjoint_matrix_vector_product	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal
selfadjoint_packed_rank1_update	blas/PackedSelfadjointProduct.h	/^struct selfadjoint_packed_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:internal
selfadjoint_packed_rank1_update	blas/PackedSelfadjointProduct.h	/^struct selfadjoint_packed_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:internal
selfadjoint_product_impl	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct selfadjoint_product_impl<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen::internal
selfadjoint_product_impl	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_product_impl<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen::internal
selfadjoint_product_impl	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_product_impl<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen::internal
selfadjoint_product_selector	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
selfadjointeigensolver	test/eigensolver_selfadjoint.cpp	/^template<typename MatrixType> void selfadjointeigensolver(const MatrixType& m)$/;"	f
selfadjointeigensolver_essential_check	test/eigensolver_selfadjoint.cpp	/^template<typename MatrixType> void selfadjointeigensolver_essential_check(const MatrixType& m)$/;"	f
semaphore	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE unsigned int* semaphore() const {$/;"	f	struct:Eigen::GpuDevice
semaphore	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual unsigned int* semaphore() const {$/;"	f	class:Eigen::CudaStreamDevice
semaphore_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  mutable unsigned int* semaphore_;$/;"	m	class:Eigen::CudaStreamDevice
sep	doc/snippets/IOFormat.cpp	/^std::cout << m1 << sep;$/;"	v
sep	doc/snippets/IOFormat.cpp	/^std::string sep = "\\n----------------------------------------\\n";$/;"	v
set	Eigen/src/Core/ProductEvaluators.h	/^  struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
set	test/stdlist_overload.cpp	/^void set(Container & c, Position position, const Value & value)$/;"	f
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static void set(const DenseIndex i, IndexTuple<T...>& t, const ValueT value) {$/;"	f	struct:Eigen::internal::tuple_coeff
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static void set(const DenseIndex i, IndexTuple<T...>& t, const ValueT& value) {$/;"	f	struct:Eigen::internal::tuple_coeff
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC void set(DenseIndex val) {$/;"	f	struct:Eigen::type2index
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC void set(const IndexPair<DenseIndex>& val) {$/;"	f	struct:Eigen::type2indexpair
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC void set(const DenseIndex i, const DenseIndex value) {$/;"	f	struct:Eigen::IndexList
set	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC void set(const DenseIndex i, const IndexPair<DenseIndex> value) {$/;"	f	struct:Eigen::IndexPairList
set	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  EIGEN_DEVICE_FUNC void set(IndexPair<Idx> val) {$/;"	f	struct:Eigen::IndexPair
setBlockLayout	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline void setBlockLayout(const VectorXi& rowBlocks, const VectorXi& colBlocks)$/;"	f	class:Eigen::BlockSparseMatrix
setBlockSize	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline void setBlockSize(Index blockSize)$/;"	f	class:Eigen::BlockSparseMatrix
setBlockStructure	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    void setBlockStructure(const MatrixType& blockPattern)$/;"	f	class:Eigen::BlockSparseMatrix
setBounds	Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = convert_index(start); m_end = convert_index(end); }$/;"	f	class:Eigen::internal::AmbiVector
setCallback	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setCallback(void (*t)(const IterationController&))$/;"	f	class:Eigen::IterationController
setCamera	demos/opengl/trackball.h	/^    void setCamera(Camera* pCam) { mpCamera = pCam; }$/;"	f	class:Trackball
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& val)$/;"	f	class:Eigen::DenseBase
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularViewImpl
setConstant	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE Derived& setConstant(const Scalar& val) {$/;"	f	class:Eigen::TensorBase
setCpuCacheSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2, std::ptrdiff_t l3)$/;"	f	namespace:Eigen
setCudaSharedMemConfig	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^static EIGEN_DEVICE_FUNC inline void setCudaSharedMemConfig(cudaSharedMemConfig config) {$/;"	f	namespace:Eigen
setDirection	demos/opengl/camera.cpp	/^void Camera::setDirection(const Vector3f& newDirection)$/;"	f	class:Camera
setDroptol	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::setDroptol(const RealScalar& droptol)$/;"	f	class:Eigen::IncompleteLUT
setEigenv	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  void setEigenv(const Index neig) $/;"	f	class:Eigen::DGMRES
setEmpty	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline void setEmpty()$/;"	f	class:Eigen::AlignedBox
setEpsilon	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setEpsilon (RealScalar epsfcn) { m_epsfcn = epsfcn; }$/;"	f	class:Eigen::LevenbergMarquardt
setExternalScaling	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setExternalScaling(bool value) {m_useExternalScaling  = value; }$/;"	f	class:Eigen::LevenbergMarquardt
setFactor	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setFactor(RealScalar factor) { m_factor = factor; }    $/;"	f	class:Eigen::LevenbergMarquardt
setFillfactor	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar,StorageIndex>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT
setFlags	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setFlags(int f) {$/;"	f	class:Eigen::SkylineInplaceLU
setFovY	demos/opengl/camera.cpp	/^void Camera::setFovY(float value)$/;"	f	class:Camera
setFrame	demos/opengl/camera.cpp	/^void Camera::setFrame(const Frame& f)$/;"	f	class:Camera
setFromTriplets	Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix
setFromTriplets	Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_StorageIndex>::setFromTriplets(const InputIterators& begin, const InputIterators& end, DupFunctor dup_func)$/;"	f	class:Eigen::SparseMatrix
setFromTriplets	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    void setFromTriplets(const InputIterator& begin, const InputIterator& end)$/;"	f	class:Eigen::BlockSparseMatrix
setFromTwoVectors	Eigen/src/Geometry/Quaternion.h	/^EIGEN_DEVICE_FUNC inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase
setFtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setFtol(RealScalar ftol) { m_ftol = ftol; }$/;"	f	class:Eigen::LevenbergMarquardt
setGtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setGtol(RealScalar gtol) { m_gtol = gtol; }$/;"	f	class:Eigen::LevenbergMarquardt
setIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase
setIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
setIdentity	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase
setIdentity	Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index newSize)$/;"	f	class:Eigen::PermutationBase
setIdentity	Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase
setIdentity	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline QuaternionBase& setIdentity() { coeffs() << Scalar(0), Scalar(0), Scalar(0), Scalar(1); return *this; }$/;"	f	class:Eigen::QuaternionBase
setIdentity	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setIdentity()$/;"	f	class:Eigen::SparseMatrix
setIdentity_impl	Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setInf	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setInf(int sign)$/;"	f	class:mpfr::mpreal
setInfos	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void setInfos(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind,$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
setInitialShift	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^    void setInitialShift(RealScalar shift) { m_initialShift = shift; }$/;"	f	class:Eigen::IncompleteCholesky
setInvalidKey	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type& map, const KeyType& k)$/;"	f	struct:Eigen::GoogleDenseHashMapTraits
setInvalidKey	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::GoogleSparseHashMapTraits
setInvalidKey	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::StdMapTraits
setInvalidKey	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::StdUnorderedMapTraits
setIteration	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setIteration(size_t i) { m_nit = i; }$/;"	f	class:Eigen::IterationController
setLength	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence
setLerpMode	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::setLerpMode(int m)$/;"	f	class:RenderingWidget
setLinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setLinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setMatrixTarget	demos/opengl/gpuhelper.h	/^inline void GpuHelper::setMatrixTarget(GLenum matrixTarget)$/;"	f	class:GpuHelper
setMaxEigenv	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  void setMaxEigenv(const Index maxNeig) { m_maxNeig = maxNeig; }$/;"	f	class:Eigen::DGMRES
setMaxIterations	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexEigenSolver
setMaxIterations	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexSchur
setMaxIterations	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::EigenSolver
setMaxIterations	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::GeneralizedEigenSolver
setMaxIterations	Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealQZ
setMaxIterations	Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealSchur
setMaxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::IterativeSolverBase
setMaxIterations	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setMaxIterations(size_t i) { m_maxiter = i; }$/;"	f	class:Eigen::IterationController
setMaxResidual	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setMaxResidual(double r) { m_resmax = r; }$/;"	f	class:Eigen::IterationController
setMaxfev	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setMaxfev(Index maxfev) {m_maxfev = maxfev; }$/;"	f	class:Eigen::LevenbergMarquardt
setMode	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition
setMode	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky
setNan	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setNan()$/;"	f	class:mpfr::mpreal
setNavMode	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::setNavMode(int m)$/;"	f	class:RenderingWidget
setNbThreads	Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen
setNoiseLevel	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setNoiseLevel(int n) { m_noise = n; }$/;"	f	class:Eigen::IterationController
setNull	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setOnes	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularViewImpl
setOrderingMethod	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setOrderingMethod(int m) {$/;"	f	class:Eigen::SkylineInplaceLU
setOrientation	demos/opengl/camera.cpp	/^void Camera::setOrientation(const Quaternionf& q)$/;"	f	class:Camera
setPivotThreshold	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setPivotThreshold(const RealScalar& tol)$/;"	f	class:Eigen::SPQR
setPivotThreshold	Eigen/src/SparseLU/SparseLU.h	/^    void setPivotThreshold(const RealScalar& thresh)$/;"	f	class:Eigen::SparseLU
setPivotThreshold	Eigen/src/SparseQR/SparseQR.h	/^    void setPivotThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SparseQR
setPolynomial	unsupported/Eigen/src/Polynomials/Companion.h	/^    void setPolynomial( const VectorType& poly )$/;"	f	class:Eigen::internal::companion
setPolynomial	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline void setPolynomial( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolverBase
setPosition	demos/opengl/camera.cpp	/^void Camera::setPosition(const Vector3f& p)$/;"	f	class:Camera
setPrecision	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setPrecision(RealScalar v) {$/;"	f	class:Eigen::SkylineInplaceLU
setPrecision	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setPrecision(int Precision, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
setRandom	Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setRandom	Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setRandom	Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase
setRandom	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE Derived& setRandom() {$/;"	f	class:Eigen::TensorBase
setRhsNorm	unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setRhsNorm(double r) { m_rhsn = r; }$/;"	f	class:Eigen::IterationController
setRotationMode	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::setRotationMode(int m)$/;"	f	class:RenderingWidget
setSPQROrdering	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setSPQROrdering(int ord) { m_ordering = ord;}$/;"	f	class:Eigen::SPQR
setScalarType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix
setShift	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& setShift(const RealScalar& offset)$/;"	f	class:Eigen::CholmodBase
setShift	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence
setShift	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase
setSign	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setSign(int sign, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
setStorageType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix
setSwitchSize	Eigen/src/SVD/BDCSVD.h	/^  void setSwitchSize(int s) $/;"	f	class:Eigen::BDCSVD
setTarget	demos/opengl/camera.cpp	/^void Camera::setTarget(const Vector3f& target)$/;"	f	class:Camera
setThreshold	Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU
setThreshold	Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU
setThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& setThreshold(Default_t) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
setThreshold	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  CompleteOrthogonalDecomposition& setThreshold(const RealScalar& threshold) {$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
setThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	Eigen/src/SVD/SVDBase.h	/^  Derived& setThreshold(Default_t)$/;"	f	class:Eigen::SVDBase
setThreshold	Eigen/src/SVD/SVDBase.h	/^  Derived& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SVDBase
setTolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(const RealScalar& tolerance)$/;"	f	class:Eigen::IterativeSolverBase
setTolerance	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void setTolerance(double tol)$/;"	f	class:Eigen::IterScaling
setTrans	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence
setValues	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE Derived& setValues($/;"	f	class:Eigen::TensorBase
setViewport	demos/opengl/camera.cpp	/^void Camera::setViewport(uint offsetx, uint offsety, uint width, uint height)$/;"	f	class:Camera
setViewport	demos/opengl/camera.cpp	/^void Camera::setViewport(uint width, uint height)$/;"	f	class:Camera
setXtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    void setXtol(RealScalar xtol) { m_xtol = xtol; }$/;"	f	class:Eigen::LevenbergMarquardt
setZero	Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setZero	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	Eigen/src/Core/TriangularMatrix.h	/^    TriangularViewType& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularViewImpl
setZero	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_StorageIndex>::setZero()$/;"	f	class:Eigen::internal::AmbiVector
setZero	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix
setZero	Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector
setZero	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    EIGEN_STRONG_INLINE Derived& setZero() {$/;"	f	class:Eigen::TensorBase
setZero	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void setZero() {$/;"	f	class:Eigen::SkylineMatrix
setZero	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void setZero()$/;"	f	class:Eigen::DynamicSparseMatrix
setZero	unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setZero(int sign)$/;"	f	class:mpfr::mpreal
set_default_prec	unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_default_prec(mp_prec_t prec)$/;"	f	class:mpfr::mpreal
set_default_rnd	unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_default_rnd(mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
set_emax	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_emax (mp_exp_t exp)$/;"	f	class:mpfr::mpreal
set_emin	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_emin (mp_exp_t exp)$/;"	f	class:mpfr::mpreal
set_exp	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_exp (mp_exp_t e)$/;"	f	class:mpfr::mpreal
set_from_triplets	Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, DupFunctor dup_func)$/;"	f	namespace:Eigen::internal
set_is_malloc_allowed	Eigen/src/Core/util/Memory.h	/^EIGEN_DEVICE_FUNC inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal
set_prec	unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_prec(mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
set_repeat_from_string	test/main.h	/^inline void set_repeat_from_string(const char *str)$/;"	f
set_restart	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  void set_restart(const Index restart) { m_restart=restart; }$/;"	f	class:Eigen::DGMRES
set_restart	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void set_restart(const Index restart) { m_restart=restart; }$/;"	f	class:Eigen::GMRES
set_seed_from_string	test/main.h	/^inline void set_seed_from_string(const char *str)$/;"	f
set_val	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static void set_val(IndexTuple<T, O...>& val, V& new_val) {$/;"	f	struct:Eigen::internal::IndexTupleExtractor
setinnerrand_eigen	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setinnerrand_eigen(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_compact	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_compact(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_dynamic	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_dynamic(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_gnu_hash	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_gnu_hash(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_google_dense	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_google_dense(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_google_sparse	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_google_sparse(const Coordinates& coords, const Values& vals)$/;"	f
setrand_eigen_sumeq	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_eigen_sumeq(const Coordinates& coords, const Values& vals)$/;"	f
setrand_scipy	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_scipy(const Coordinates& coords, const Values& vals)$/;"	f
setrand_ublas_genvec	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_ublas_genvec(const Coordinates& coords, const Values& vals)$/;"	f
setrand_ublas_mapped	bench/sparse_setter.cpp	/^EIGEN_DONT_INLINE Scalar* setrand_ublas_mapped(const Coordinates& coords, const Values& vals)$/;"	f
seupd	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void seupd(int *rvec, char *All, int *select, Scalar *d,$/;"	f	struct:Eigen::internal::arpack_wrapper
seupd	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void seupd(int *rvec, char *All, int *select, double *d,$/;"	f	struct:Eigen::internal::arpack_wrapper
seupd	unsupported/Eigen/src/Eigenvalues/ArpackSelfAdjointEigenSolver.h	/^  static inline void seupd(int *rvec, char *All, int *select, float *d,$/;"	f	struct:Eigen::internal::arpack_wrapper
sgn	unsupported/test/mpreal/mpreal.h	/^inline int sgn(const mpreal& op)$/;"	f	namespace:mpfr
shardByCol	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^  static bool shardByCol(Index m, Index n, Index num_threads) {$/;"	f	struct:Eigen::TensorEvaluator
shard_by_col_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    const bool shard_by_col_;$/;"	m	class:Eigen::TensorEvaluator::Context
shared1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon872
shared1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon868
shared2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon873
shared2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon869
shared3	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared3 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon870
shared4	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared4 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon871
sharedMemPerBlock	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE int sharedMemPerBlock() const {$/;"	f	struct:Eigen::GpuDevice
shear	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
shift	Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
shift	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  int32_t shift;$/;"	m	class:Eigen::internal::TensorIntDivisor
shift1	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  int32_t shift1;$/;"	m	struct:Eigen::internal::TensorIntDivisor
shift2	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^  int32_t shift2;$/;"	m	struct:Eigen::internal::TensorIntDivisor
should_raise_an_assert	test/main.h	/^    static const bool should_raise_an_assert = false;$/;"	m	namespace:Eigen
show_usage_and_exit	bench/analyze-blocking-sizes.cpp	/^  void show_usage_and_exit() const$/;"	f	struct:evaluate_defaults_action_t
show_usage_and_exit	bench/analyze-blocking-sizes.cpp	/^void show_usage_and_exit(int argc, char* argv[],$/;"	f
shuffle	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    shuffle(const Shuffle& shuffle) const {$/;"	f	class:Eigen::TensorBase
shuffle	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    shuffle(const Shuffle& shuffle) {$/;"	f	class:Eigen::TensorBase
shuffleInc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	391;"	d
shuffleInc	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	420;"	d
shufflePermutation	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^    const Shuffle& shufflePermutation() const { return m_shuffle; }$/;"	f	class:Eigen::TensorShufflingOp
shuffling	bench/tensors/tensor_benchmarks.h	/^  void shuffling(int num_iters) {$/;"	f	class:BenchmarkSuite
sigmoid	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    sigmoid() const {$/;"	f	class:Eigen::TensorBase
sign	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sign() const$/;"	f
sign	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    sign() const {$/;"	f	class:Eigen::TensorBase
signDeterminant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar signDeterminant()$/;"	f	class:Eigen::SparseLU
signal_kernel	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void signal_kernel(Index m, Index n, Index k, bool sync) {$/;"	f	class:Eigen::TensorEvaluator::Context
signal_packing	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void signal_packing(Index k) {$/;"	f	class:Eigen::TensorEvaluator::Context
signal_switch	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    void signal_switch(Index k, Index v = 1) {$/;"	f	class:Eigen::TensorEvaluator::Context
signaling_NaN	Eigen/src/Core/arch/CUDA/Half.h	/^  static Eigen::half signaling_NaN() { return Eigen::half_impl::raw_uint16_to_half(0x7e00); }$/;"	f	struct:std::numeric_limits
signaling_NaN	unsupported/test/mpreal/mpreal.h	/^        inline static const mpfr::mpreal signaling_NaN()    { return mpfr::mpreal().setNan();    }$/;"	f	class:std::numeric_limits
signbit	unsupported/test/mpreal/mpreal.h	/^inline bool signbit(const mpreal& x)$/;"	f	namespace:mpfr
signedDistance	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane
signed_integer_type_tests	test/integer_types.cpp	/^template<typename MatrixType> void signed_integer_type_tests(const MatrixType& m)$/;"	f
significant_decimals_impl	Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal
simple_function	bench/btl/generic_bench/init/init_function.hh	/^double simple_function(int index)$/;"	f
simple_function	bench/btl/generic_bench/init/init_function.hh	/^double simple_function(int index_i, int index_j)$/;"	f
simplicial_cholesky_grab_input	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  struct simplicial_cholesky_grab_input {$/;"	s	namespace:Eigen::internal
simplicial_cholesky_grab_input	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  struct simplicial_cholesky_grab_input<MatrixType,MatrixType> {$/;"	s	namespace:Eigen::internal
sin	Eigen/src/Core/MathFunctions.h	/^T sin(const T &x) {$/;"	f	namespace:Eigen::numext
sin	Eigen/src/Core/MathFunctions.h	/^double sin(const double &x) { return ::sin(x); }$/;"	f	namespace:Eigen::numext
sin	Eigen/src/Core/MathFunctions.h	/^float sin(const float &x) { return ::sinf(x); }$/;"	f	namespace:Eigen::numext
sin	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sin(const half& a) {$/;"	f	namespace:Eigen::half_impl
sin	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f
sin	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::sin() const$/;"	f	class:Eigen::MatrixBase
sin	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sin   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(sin  );    }$/;"	f	namespace:mpfr
sin_cos	unsupported/test/mpreal/mpreal.h	/^inline int sin_cos(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
sin_over_x	bench/quat_slerp.cpp	/^inline T sin_over_x(T x)$/;"	f
sing	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool sing;$/;"	m	class:Eigen::HybridNonLinearSolver
single_precision	demos/mandelbrot/mandelbrot.h	/^    bool single_precision;$/;"	m	class:MandelbrotThread
singularValues	Eigen/src/SVD/SVDBase.h	/^  const SingularValuesType& singularValues() const$/;"	f	class:Eigen::SVDBase
sinh	Eigen/src/Core/MathFunctions.h	/^T sinh(const T &x) {$/;"	f	namespace:Eigen::numext
sinh	Eigen/src/Core/MathFunctions.h	/^double sinh(const double &x) { return ::sinh(x); }$/;"	f	namespace:Eigen::numext
sinh	Eigen/src/Core/MathFunctions.h	/^float sinh(const float &x) { return ::sinhf(x); }$/;"	f	namespace:Eigen::numext
sinh	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sinh() const$/;"	f
sinh	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::sinh() const$/;"	f	class:Eigen::MatrixBase
sinh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sinh  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(sinh );    }$/;"	f	namespace:mpfr
sinh_cosh	unsupported/test/mpreal/mpreal.h	/^inline int sinh_cosh(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
size	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC Index size() const        { return m_dstExpr.size(); }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
size	Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase
size	Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon497
size	Eigen/src/Core/Matrix.h	/^  enum { size = internal::size_at_compile_time<_Rows,_Cols>::ret };$/;"	e	enum:Eigen::internal::traits::__anon437
size	Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
size	Eigen/src/Core/Redux.h	/^  EIGEN_DEVICE_FUNC Index size() const { return m_xpr.size(); }$/;"	f	class:Eigen::internal::redux_evaluator
size	Eigen/src/Core/Transpositions.h	/^    Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
size	Eigen/src/Core/Transpositions.h	/^    Index size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
size	Eigen/src/Core/Visitor.h	/^  EIGEN_DEVICE_FUNC Index size() const { return m_xpr.size(); }$/;"	f	class:Eigen::internal::visitor_evaluator
size	Eigen/src/Core/arch/AVX/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon650
size	Eigen/src/Core/arch/AVX/Complex.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon648
size	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon651
size	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon649
size	Eigen/src/Core/arch/AVX/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon656
size	Eigen/src/Core/arch/AVX/PacketMath.h	/^    size=8,$/;"	e	enum:Eigen::internal::packet_traits::__anon655
size	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon660
size	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon659
size	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon661
size	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    size = 16,$/;"	e	enum:Eigen::internal::packet_traits::__anon665
size	Eigen/src/Core/arch/AVX512/PacketMath.h	/^    size = 8,$/;"	e	enum:Eigen::internal::packet_traits::__anon666
size	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon667
size	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 16, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon669
size	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { size = 8, alignment=Aligned64 };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon668
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon696
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon694
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon697
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon695
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon699
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon702
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon698
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon703
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon700
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon701
size	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon691
size	Eigen/src/Core/arch/CUDA/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon690
size	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon693
size	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon692
size	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon684
size	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon685
size	Eigen/src/Core/arch/NEON/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon706
size	Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon704
size	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon707
size	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon705
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon712
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon708
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon709
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon713
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon710
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon711
size	Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon733
size	Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon731
size	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon734
size	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon732
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon739
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon738
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon740
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon742
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon741
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon743
size	Eigen/src/Core/arch/ZVector/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon716
size	Eigen/src/Core/arch/ZVector/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon715
size	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon718
size	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon717
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon721
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon723
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon722
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon726
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon725
size	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon724
size	Eigen/src/SparseCore/AmbiVector.h	/^    StorageIndex size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector
size	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage
size	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase
size	demos/mandelbrot/mandelbrot.h	/^    int size;$/;"	m	class:MandelbrotWidget
size	doc/snippets/Tutorial_AdvancedInitialization_ThreeWays.cpp	/^const int size = 6;$/;"	v
size	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                         size()                   const { return m_storage.size(); }$/;"	f	class:Eigen::Tensor
size	unsupported/Eigen/CXX11/src/Tensor/TensorFixedSize.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index                    size()                   const { return m_storage.size(); }$/;"	f	class:Eigen::TensorFixedSize
size	unsupported/Eigen/CXX11/src/Tensor/TensorMap.h	/^    EIGEN_STRONG_INLINE Index size() const { return m_dimensions.TotalSize(); }$/;"	f	class:Eigen::TensorMap
size	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  static const int size = 1;$/;"	m	struct:Eigen::PacketType
size	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  static const int size = 2;$/;"	m	struct:Eigen::PacketType
size	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  static const size_t size = 1;$/;"	m	struct:Eigen::max_n_1
size	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  static const size_t size = n;$/;"	m	struct:Eigen::max_n_1
size	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE Index size() const { return m_evaluator->dimensions().TotalSize(); }$/;"	f	class:Eigen::TensorRef
size	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Index& size() const {$/;"	f	struct:Eigen::TensorEvaluator
size	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index size() const { return m_dimensions.TotalSize(); }$/;"	f	class:Eigen::TensorStorage
size	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^  EIGEN_STRONG_INLINE DenseIndex size() const { return m_dimensions.TotalSize(); }$/;"	f	class:Eigen::TensorStorage
size	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^static constexpr size_t size(Tuple<Args...> &) {$/;"	f	namespace:utility::tuple
size	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^    inline std::size_t size() const { return m_elements.size(); }$/;"	f	class:Eigen::DynamicSGroup
size	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static inline std::size_t size() {$/;"	f	class:Eigen::StaticSGroup
size	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  constexpr static std::size_t size = type::static_size;$/;"	m	struct:Eigen::internal::tensor_static_symgroup
size	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t size = 0;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_if
size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  static EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE std::size_t size() { return 0; }$/;"	f	class:Eigen::array
size	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  static std::size_t size() { return n; }$/;"	f	class:Eigen::array
size	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  size_t size() const { return size_; }$/;"	f	class:Eigen::MaxSizeVector
size	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    Index size() const { return m_values.size(); }$/;"	f	class:Eigen::AutoDiffVector
size	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline size_t size() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
size	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline size_t size() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
size	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index size() const {$/;"	f	class:Eigen::SkylineMatrixBase
size	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index size() const$/;"	f	class:Eigen::BlockVectorReturn
size	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Index size() const$/;"	f	class:Eigen::BlockVectorView
size_	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  size_t size_;$/;"	m	class:Eigen::MaxSizeVector
size_lin_log	bench/btl/generic_bench/utils/size_lin_log.hh	/^void size_lin_log(const int nb_point, const int \/*size_min*\/, const int size_max, Vector & X)$/;"	f
size_log	bench/btl/generic_bench/utils/size_log.hh	/^void size_log(const int nb_point, const int size_min, const int size_max, Vector & X)$/;"	f
size_triple_t	bench/analyze-blocking-sizes.cpp	/^  size_triple_t() : k(0), m(0), n(0) {}$/;"	f	struct:size_triple_t
size_triple_t	bench/analyze-blocking-sizes.cpp	/^  size_triple_t(const size_triple_t& o) : k(o.k), m(o.m), n(o.n) {}$/;"	f	struct:size_triple_t
size_triple_t	bench/analyze-blocking-sizes.cpp	/^  size_triple_t(size_t _k, size_t _m, size_t _n) : k(_k), m(_m), n(_n) {}$/;"	f	struct:size_triple_t
size_triple_t	bench/analyze-blocking-sizes.cpp	/^  size_triple_t(uint16_t compact)$/;"	f	struct:size_triple_t
size_triple_t	bench/analyze-blocking-sizes.cpp	/^struct size_triple_t$/;"	s	file:
size_type	Eigen/src/Core/util/Memory.h	/^  typedef std::size_t     size_type;$/;"	t	class:Eigen::aligned_allocator
size_type	Eigen/src/StlSupport/details.h	/^    typedef std::size_t     size_type;$/;"	t	class:Eigen::aligned_allocator_indirection
sizes	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar,Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox
sizes	bench/dense_solvers.cpp	/^std::vector<Array2i> sizes;$/;"	v
sizes	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const Sizes& sizes() const { return m_sizes; }$/;"	f	class:Eigen::TensorSlicingOp
sizes_match_below_dim	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct sizes_match_below_dim {$/;"	s	namespace:Eigen::internal
sizes_match_below_dim	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct sizes_match_below_dim<Dims1, Dims2, 0, 0> {$/;"	s	namespace:Eigen::internal
sizes_match_below_dim	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct sizes_match_below_dim<Dims1, Dims2, n, n> {$/;"	s	namespace:Eigen::internal
skip	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n, typename a> struct skip { typedef decltype(h_skip<n>::helper(a())) type; };$/;"	s	namespace:Eigen::internal
skipAction	bench/btl/generic_bench/btl.hh	/^  BTL_DONT_INLINE static bool skipAction(const std::string& _name)$/;"	f	class:BtlConfig
skyline_col_major_time_dense_product	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^EIGEN_DONT_INLINE void skyline_col_major_time_dense_product(const Lhs& lhs, const Rhs& rhs, Dest& dst) {$/;"	f	namespace:Eigen::internal
skyline_product_selector	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct skyline_product_selector<Lhs, Rhs, ResultType, ColMajor> {$/;"	s	namespace:Eigen::internal
skyline_product_selector	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct skyline_product_selector<Lhs, Rhs, ResultType, RowMajor> {$/;"	s	namespace:Eigen::internal
skyline_row_major_time_dense_product	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^EIGEN_DONT_INLINE void skyline_row_major_time_dense_product(const Lhs& lhs, const Rhs& rhs, Dest& dst) {$/;"	f	namespace:Eigen::internal
sleep	unsupported/test/cxx11_tensor_notification.cpp	/^void sleep(int seconds) {$/;"	f
slerp	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
slerp	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Rotation2D slerp(const Scalar& t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
slerp_eigen	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q slerp_eigen(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
slerp_gael	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q slerp_gael(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
slerp_legacy	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q slerp_legacy(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
slerp_legacy_nlerp	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q slerp_legacy_nlerp(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
slerp_rw	bench/quat_slerp.cpp	/^EIGEN_DONT_INLINE Q slerp_rw(const Q& a, const Q& b, typename Q::Scalar t)$/;"	f
slice	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    slice(const StartIndices& startIndices, const Sizes& sizes) const {$/;"	f	class:Eigen::TensorBase
slice	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    slice(const StartIndices& startIndices, const Sizes& sizes) {$/;"	f	class:Eigen::TensorBase
slice	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int start, int count, typename a> struct slice : take<count, typename skip<start, a>::type> {};$/;"	s	namespace:Eigen::internal
slicing	bench/tensors/tensor_benchmarks.h	/^  void slicing(int num_iters) {$/;"	f	class:BenchmarkSuite
smallVectors	test/smallvectors.cpp	/^template<typename Scalar> void smallVectors()$/;"	f
smallestAngle	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar smallestAngle() const {$/;"	f	class:Eigen::Rotation2D
smallestPositiveAngle	Eigen/src/Geometry/Rotation2D.h	/^  EIGEN_DEVICE_FUNC inline Scalar smallestPositiveAngle() const {$/;"	f	class:Eigen::Rotation2D
smallestRealRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& smallestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
smallestRoot	unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& smallestRoot() const$/;"	f	class:Eigen::PolynomialSolverBase
smart_copy	Eigen/src/Core/util/Memory.h	/^template<typename T> EIGEN_DEVICE_FUNC void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_copy_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
smart_memmove	Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_memmove(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_memmove_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_memmove_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_memmove_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_memmove_helper<T,true> {$/;"	s	namespace:Eigen::internal
smooth_curve	bench/btl/data/smooth.cxx	/^void smooth_curve(const vector<double> & tab_mflops, vector<double> & smooth_tab_mflops,int window_half_width){$/;"	f
solve	Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT
solve	Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT
solve	Eigen/src/Core/SolveTriangular.h	/^TriangularViewImpl<Derived,Mode,Dense>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solve	Eigen/src/Core/SolverBase.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SolverBase
solve	Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner
solve	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner
solve	Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU
solve	Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU
solve	Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR
solve	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  inline const Solve<CompleteOrthogonalDecomposition, Rhs> solve($/;"	f	class:Eigen::CompleteOrthogonalDecomposition
solve	Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR
solve	Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR
solve	Eigen/src/SVD/SVDBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SVDBase
solve	Eigen/src/SparseCore/SparseSolverBase.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SparseSolverBase
solve	Eigen/src/SparseCore/SparseSolverBase.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SparseSolverBase
solve	Eigen/src/SparseQR/SparseQR.h	/^    inline const Solve<SparseQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseQR
solve	Eigen/src/SparseQR/SparseQR.h	/^    inline const Solve<SparseQR, Rhs> solve(const SparseMatrixBase<Rhs>& B) const$/;"	f	class:Eigen::SparseQR
solve	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solve(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solve	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^bool SkylineInplaceLU<MatrixType>::solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>* x, const int transposed) const {$/;"	f	class:Eigen::SkylineInplaceLU
solveInPlace	Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT
solveInPlace	Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(const MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT
solveInPlace	Eigen/src/Core/SolveTriangular.h	/^void TriangularViewImpl<MatrixType,Mode,Dense>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	Eigen/src/SparseCore/TriangularSolver.h	/^void TriangularViewImpl<ExpressionType,Mode,Sparse>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	Eigen/src/SparseCore/TriangularSolver.h	/^void TriangularViewImpl<ExpressionType,Mode,Sparse>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularViewImpl
solveInPlace	Eigen/src/SparseLU/SparseLU.h	/^  template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
solveInPlace	Eigen/src/SparseLU/SparseLU.h	/^  void solveInPlace( MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
solveInPlace	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^void MappedSuperNodalMatrix<Scalar,Index_>::solveInPlace( MatrixBase<Dest>&X) const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
solveInit	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveInit(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiff	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiff(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiffInit	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffInit(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiffOneStep	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffOneStep(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveOneStep	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveOneStep(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveWithGuess	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::IterativeSolverBase
solve_sparse_through_dense_panels	Eigen/src/SparseCore/SparseSolverBase.h	/^solve_sparse_through_dense_panels(const Decomposition &dec, const Rhs& rhs, Dest &dest)$/;"	f	namespace:Eigen::internal
solve_traits	Eigen/src/Core/Solve.h	/^struct solve_traits<Decomposition,RhsType,Dense>$/;"	s	namespace:Eigen::internal
solve_traits	Eigen/src/SparseCore/SparseUtil.h	/^struct solve_traits<Decomposition,RhsType,Sparse>$/;"	s	namespace:Eigen::internal
solve_with_guess	test/sparse_solver.h	/^void solve_with_guess(IterativeSolverBase<Solver>& solver, const MatrixBase<Rhs>& b, const Guess& g, Result &x) {$/;"	f
solve_with_guess	test/sparse_solver.h	/^void solve_with_guess(SparseSolverBase<Solver>& solver, const MatrixBase<Rhs>& b, const Guess& , Result& x) {$/;"	f
solve_with_guess	test/sparse_solver.h	/^void solve_with_guess(SparseSolverBase<Solver>& solver, const SparseMatrixBase<Rhs>& b, const Guess& , Result& x) {$/;"	f
solver	doc/snippets/BiCGSTAB_simple.cpp	/^  BiCGSTAB<SparseMatrix<double> > solver;$/;"	v
solver_stats	test/sparse_solver.h	/^std::string solver_stats(const IterativeSolverBase<Derived> &solver)$/;"	f
solver_stats	test/sparse_solver.h	/^std::string solver_stats(const SparseSolverBase<Derived> &\/*solver*\/)$/;"	f
some_non_vectorizable_type	test/first_aligned.cpp	/^struct some_non_vectorizable_type { float x; };$/;"	s	file:
sortEigenvalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
sortWithPermutation	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^void sortWithPermutation (VectorType& vec, IndexType& perm, typename IndexType::Scalar& ncut)$/;"	f	namespace:Eigen::internal
span	unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::span(Scalar u) const$/;"	f	class:Eigen::Spline
sparseGaussianTest	test/sparseLM.cpp	/^  sparseGaussianTest(int inputs, int values) : SparseFunctor<Scalar,int>(inputs,values)$/;"	f	struct:sparseGaussianTest
sparseGaussianTest	test/sparseLM.cpp	/^struct sparseGaussianTest : SparseFunctor<Scalar, int>$/;"	s	file:
sparseView	Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& reference,$/;"	f	class:Eigen::MatrixBase
sparse_basic	test/sparse_basic.cpp	/^template<typename SparseMatrixType> void sparse_basic(const SparseMatrixType& ref)$/;"	f
sparse_block	test/sparse_block.cpp	/^template<typename SparseMatrixType> void sparse_block(const SparseMatrixType& ref)$/;"	f
sparse_conjunction_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^  explicit sparse_conjunction_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::sparse_conjunction_evaluator
sparse_conjunction_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IndexBased, IteratorBased>$/;"	s	namespace:Eigen::internal
sparse_conjunction_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IteratorBased, IndexBased>$/;"	s	namespace:Eigen::internal
sparse_conjunction_evaluator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^struct sparse_conjunction_evaluator<XprType, IteratorBased, IteratorBased>$/;"	s	namespace:Eigen::internal
sparse_dense_outer_product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  sparse_dense_outer_product_evaluator(const ActualRhs &rhs, const Lhs1 &lhs)$/;"	f	struct:Eigen::internal::sparse_dense_outer_product_evaluator
sparse_dense_outer_product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  sparse_dense_outer_product_evaluator(const Lhs1 &lhs, const ActualRhs &rhs)$/;"	f	struct:Eigen::internal::sparse_dense_outer_product_evaluator
sparse_dense_outer_product_evaluator	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_dense_outer_product_evaluator$/;"	s	namespace:Eigen::internal
sparse_diagonal_product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  sparse_diagonal_product_evaluator(const SparseXprType &sparseXpr, const DiagCoeffType &diagCoeff)$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
sparse_diagonal_product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  sparse_diagonal_product_evaluator(const SparseXprType &sparseXpr, const DiagonalCoeffType &diagCoeff)$/;"	f	struct:Eigen::internal::sparse_diagonal_product_evaluator
sparse_diagonal_product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct sparse_diagonal_product_evaluator<SparseXprType, DiagCoeffType, SDP_AsCwiseProduct>$/;"	s	namespace:Eigen::internal
sparse_diagonal_product_evaluator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct sparse_diagonal_product_evaluator<SparseXprType, DiagonalCoeffType, SDP_AsScalarProduct>$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols,int Flags> struct sparse_eval<T,1,Cols,Flags> {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Flags> struct sparse_eval<T,1,1,Flags> {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols,int Flags> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Flags> struct sparse_eval<T,Rows,1,Flags> {$/;"	s	namespace:Eigen::internal
sparse_extra	unsupported/test/sparse_extra.cpp	/^template<typename SparseMatrixType> void sparse_extra(const SparseMatrixType& ref)$/;"	f
sparse_matrix_block_impl	Eigen/src/SparseCore/SparseBlock.h	/^    inline sparse_matrix_block_impl(SparseMatrixType& xpr, Index i)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
sparse_matrix_block_impl	Eigen/src/SparseCore/SparseBlock.h	/^    inline sparse_matrix_block_impl(SparseMatrixType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
sparse_matrix_block_impl	Eigen/src/SparseCore/SparseBlock.h	/^class sparse_matrix_block_impl$/;"	c	namespace:Eigen::internal
sparse_permutations	test/sparse_permutations.cpp	/^template<int OtherStorage, typename SparseMatrixType> void sparse_permutations(const SparseMatrixType& ref)$/;"	f
sparse_permutations_all	test/sparse_permutations.cpp	/^template<typename Scalar> void sparse_permutations_all(int size)$/;"	f
sparse_product	test/sparse_product.cpp	/^template<typename SparseMatrixType> void sparse_product()$/;"	f
sparse_product_regression_test	test/sparse_product.cpp	/^template<typename SparseMatrixType, typename DenseMatrixType> void sparse_product_regression_test()$/;"	f
sparse_selfadjoint_time_dense_product	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^inline void sparse_selfadjoint_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solvers	test/sparse_solvers.cpp	/^template<typename Scalar> void sparse_solvers(int rows, int cols)$/;"	f
sparse_sparse_product_with_pruning_impl	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)$/;"	f	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_impl	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void sparse_sparse_to_dense_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_to_dense_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct sparse_sparse_to_dense_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product	Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, RowMajor, true>$/;"	s	namespace:Eigen::internal
sparse_vector	test/sparse_vector.cpp	/^template<typename Scalar,typename StorageIndex> void sparse_vector(int rows, int cols)$/;"	f
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Inner> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Outer> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_RuntimeSwitch> {$/;"	s	namespace:Eigen::internal
sparselu_gemm	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^void sparselu_gemm(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)$/;"	f	namespace:Eigen::internal
special_numbers	test/special_numbers.cpp	/^template<typename Scalar> void special_numbers()$/;"	f
specificTest1	test/geo_alignedbox.cpp	/^void specificTest1()$/;"	f
specificTest2	test/geo_alignedbox.cpp	/^void specificTest2()$/;"	f
spinning_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  std::atomic<bool> spinning_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
spline3d	unsupported/test/splines.cpp	/^Spline<double, 3, Dynamic> spline3d()$/;"	f
split	bench/btl/generic_bench/btl.hh	/^    std::vector<BtlString> split( const BtlString& delims = "\\t\\n ") const$/;"	f	class:BtlString
split	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^void MatrixPower<MatrixType>::split(RealScalar& p, RealScalar& intpart)$/;"	f	class:Eigen::MatrixPower
splitOffTwoRows	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::splitOffTwoRows(Index i)$/;"	f	class:Eigen::RealQZ
splitOffTwoRows	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)$/;"	f	class:Eigen::RealSchur
spr	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(spr)(char *uplo, int *n, Scalar *palpha, Scalar *px, int *incx, Scalar *pap)$/;"	f
spr2	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(spr2)(char *uplo, int *n, RealScalar *palpha, RealScalar *px, int *incx, RealScalar *py, int *incy, RealScalar *pap)$/;"	f
sqr	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqr  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
sqrt	Eigen/src/Core/MathFunctions.h	/^T sqrt(const T &x)$/;"	f	namespace:Eigen::numext
sqrt	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sqrt(const half& a) {$/;"	f	namespace:Eigen::half_impl
sqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^double sqrt(const double &x)$/;"	f	namespace:Eigen::numext
sqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^float sqrt(const float &x)$/;"	f	namespace:Eigen::numext
sqrt	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f
sqrt	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    sqrt() const {$/;"	f	class:Eigen::TensorBase
sqrt	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^const MatrixSquareRootReturnValue<Derived> MatrixBase<Derived>::sqrt() const$/;"	f	class:Eigen::MatrixBase
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt  (const double v, mp_rnd_t rnd_mode)         {   return sqrt(mpreal(v),rnd_mode);    }$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt  (const long double v, mp_rnd_t rnd_mode)    {   return sqrt(mpreal(v),rnd_mode);    }$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const long int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const unsigned int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const unsigned long int x, mp_rnd_t r)$/;"	f	namespace:mpfr
sqrtA	doc/snippets/SelfAdjointEigenSolver_operatorSqrt.cpp	/^MatrixXd sqrtA = es.operatorSqrt();$/;"	v
sqrt_epsilon	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    static Scalar sqrt_epsilon()$/;"	f	class:Eigen::LevenbergMarquardt
sqrth	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half sqrth(const Eigen::half& a) {$/;"	f
sqsumNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar sqsumNorm(T& v)$/;"	f
square	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f
square	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    square() const {$/;"	f	class:Eigen::TensorBase
squaredDistance	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredExteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^EIGEN_DEVICE_FUNC inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^EIGEN_DEVICE_FUNC inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox
squaredNorm	Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase
squaredNorm	Eigen/src/Core/VectorwiseOp.h	/^    const SquaredNormReturnType squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp
squaredNorm	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase
squaredNorm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase
squeeze	Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage
squeeze	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void squeeze() {$/;"	f	class:Eigen::SkylineMatrix
squeeze	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void squeeze() {$/;"	f	class:Eigen::SkylineStorage
srcCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index srcCoeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
srcCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index srcCoeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
srcCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index srcCoeff(Index index) const {$/;"	f	struct:Eigen::TensorEvaluator
srcCoeff	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index srcCoeff(Index index) const$/;"	f	struct:Eigen::TensorEvaluator
srcEvaluator	Eigen/src/Core/AssignEvaluator.h	/^  EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const { return m_src; }$/;"	f	class:Eigen::internal::generic_dense_assignment_kernel
srotm_	blas/f2c/srotm.c	/^\/* Subroutine *\/ int srotm_(integer *n, real *sx, integer *incx, real *sy, $/;"	f
srotmg_	blas/f2c/srotmg.c	/^\/* Subroutine *\/ int srotmg_(real *sd1, real *sd2, real *sx1, real *sy1, real $/;"	f
ssbmv_	blas/f2c/ssbmv.c	/^\/* Subroutine *\/ int ssbmv_(char *uplo, integer *n, integer *k, real *alpha, $/;"	f
sspmv_	blas/f2c/sspmv.c	/^\/* Subroutine *\/ int sspmv_(char *uplo, integer *n, real *alpha, real *ap, $/;"	f
stableNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase
stableNorm	Eigen/src/Core/VectorwiseOp.h	/^    const StableNormReturnType stableNorm() const$/;"	f	class:Eigen::VectorwiseOp
stableNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar stableNorm(T& v)$/;"	f
stableNormalize	Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE void MatrixBase<Derived>::stableNormalize()$/;"	f	class:Eigen::MatrixBase
stableNormalized	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::stableNormalized() const$/;"	f	class:Eigen::MatrixBase
stable_norm	test/stable_norm.cpp	/^template<typename MatrixType> void stable_norm(const MatrixType& m)$/;"	f
stable_norm_kernel	Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal
start	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType start ;   \/* index for A of first col in this row *\/$/;"	m	struct:internal::Colamd_Row
start	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  IndexType start ;   \/* index for A of first row in this column, or DEAD *\/$/;"	m	struct:internal::colamd_col
start	bench/BenchTimer.h	/^  inline void start()$/;"	f	class:Eigen::BenchTimer
start	bench/btl/generic_bench/timers/STL_timer.hh	/^  void start(unsigned int r){$/;"	f	class:STL_Timer
start	bench/btl/generic_bench/timers/portable_timer.hh	/^    LARGE_INTEGER start;$/;"	m	struct:Portable_Timer::__anon5
start	bench/btl/generic_bench/timers/portable_timer.hh	/^   void start() { QueryPerformanceCounter(&startVal); }$/;"	f	class:Portable_Timer
start	bench/btl/generic_bench/timers/portable_timer.hh	/^  void start()$/;"	f	class:Portable_Timer
start	bench/btl/generic_bench/timers/x86_timer.hh	/^  inline void start( void ){$/;"	f	class:X86_Timer
start	demos/opengl/trackball.h	/^    void start(Mode m = Around) { mMode = m; mLastPointOk = false; }$/;"	f	class:Trackball
startCol	Eigen/src/Core/Block.h	/^    StorageIndex startCol() const$/;"	f	class:Eigen::internal::BlockImpl_dense
startCol	Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return IsRowMajor ? 0 : m_outerStart; }$/;"	f	class:Eigen::BlockImpl
startCol	Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return IsRowMajor ? 0 : m_outerStart; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
startCol	Eigen/src/SparseCore/SparseBlock.h	/^    Index startCol() const { return m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl
startFill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector
startFill	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED void startFill(Index reserveSize = 1000)$/;"	f	class:Eigen::DynamicSparseMatrix
startIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices& startIndices() const { return m_indices; }$/;"	f	class:Eigen::TensorSlicingOp
startIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices& startIndices() const { return m_startIndices; }$/;"	f	class:Eigen::TensorStridingSlicingOp
startRow	Eigen/src/Core/Block.h	/^    StorageIndex startRow() const$/;"	f	class:Eigen::internal::BlockImpl_dense
startRow	Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return IsRowMajor ? m_outerStart : 0; }$/;"	f	class:Eigen::BlockImpl
startRow	Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return IsRowMajor ? m_outerStart : 0; }$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
startRow	Eigen/src/SparseCore/SparseBlock.h	/^    Index startRow() const { return m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl
startVal	bench/btl/generic_bench/timers/portable_timer.hh	/^   LARGE_INTEGER startVal;$/;"	m	class:Portable_Timer
startVec	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix
startVec	Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector
startVec	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void startVec(Index \/*outer*\/) {}$/;"	f	class:Eigen::DynamicSparseMatrix
start_baseline	bench/btl/generic_bench/timers/STL_timer.hh	/^  void start_baseline(unsigned int r)$/;"	f	class:STL_Timer
state	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^    unsigned state;$/;"	m	class:Eigen::EventCount::Waiter
state	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^    std::atomic<uint8_t> state;$/;"	m	struct:Eigen::RunQueue::Elem
state_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  std::atomic<unsigned int> state_;  \/\/ low bit is waiter flag$/;"	m	class:Eigen::Barrier
state_	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  std::atomic<uint64_t> state_;$/;"	m	class:Eigen::EventCount
state_kernel_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    std::atomic<uint8_t>** state_kernel_[P];$/;"	m	class:Eigen::TensorEvaluator::Context
state_packing_ready_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    std::atomic<Index> state_packing_ready_[P];$/;"	m	class:Eigen::TensorEvaluator::Context
state_switch_	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    std::atomic<Index> state_switch_[P];$/;"	m	class:Eigen::TensorEvaluator::Context
static_assertion	Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
static_size	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static std::size_t static_size = ge::count;$/;"	m	class:Eigen::StaticSGroup
static_size_generator	bench/btl/generic_bench/static/static_size_generator.hh	/^struct static_size_generator<1,Perf_Analyzer,Action,Interface>{  $/;"	s
static_size_generator	bench/btl/generic_bench/static/static_size_generator.hh	/^struct static_size_generator{$/;"	s
static_val	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static_val() { }$/;"	f	struct:Eigen::internal::static_val
static_val	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static_val(const T& v) {$/;"	f	struct:Eigen::internal::static_val
static_val	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^struct static_val {$/;"	s	namespace:Eigen::internal
stbmv_	blas/f2c/stbmv.c	/^\/* Subroutine *\/ int stbmv_(char *uplo, char *trans, char *diag, integer *n, $/;"	f
std	Eigen/src/Core/arch/CUDA/Half.h	/^namespace std {$/;"	n
std	Eigen/src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	Eigen/src/StlSupport/StdList.h	/^namespace std$/;"	n
std	Eigen/src/StlSupport/StdVector.h	/^namespace std {$/;"	n
std	test/fastmath.cpp	/^namespace std {$/;"	n	file:
std	test/sparse.h	/^namespace std {$/;"	n
std	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^namespace std {$/;"	n
std	unsupported/test/mpreal/mpreal.h	/^namespace std$/;"	n
std_fallback	Eigen/src/Core/MathFunctions.h	/^namespace std_fallback {$/;"	n	namespace:Eigen::internal
std_vector_gcc_warning	test/stdvector.cpp	/^void std_vector_gcc_warning()$/;"	f
stem_function	Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
stem_function_cos	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^Scalar stem_function_cos(Scalar x, int n)$/;"	f	namespace:Eigen::internal
stem_function_cosh	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^Scalar stem_function_cosh(Scalar x, int n)$/;"	f	namespace:Eigen::internal
stem_function_exp	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^Scalar stem_function_exp(Scalar x, int)$/;"	f	namespace:Eigen::internal
stem_function_sin	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^Scalar stem_function_sin(Scalar x, int n)$/;"	f	namespace:Eigen::internal
stem_function_sinh	unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^Scalar stem_function_sinh(Scalar x, int n)$/;"	f	namespace:Eigen::internal
step	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::step(Index f, Index l, Index iter)$/;"	f	class:Eigen::RealQZ
stl_matrix	bench/btl/libs/BLAS/c_interface_base.h	/^  typedef std::vector<stl_vector >  stl_matrix;$/;"	t	class:c_interface_base
stl_matrix	bench/btl/libs/STL/STL_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:STL_interface
stl_matrix	bench/btl/libs/blaze/blaze_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:blaze_interface
stl_matrix	bench/btl/libs/blitz/blitz_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:blitz_interface
stl_matrix	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:tiny_blitz_interface
stl_matrix	bench/btl/libs/eigen2/eigen2_interface.hh	/^  typedef std::vector<stl_vector> stl_matrix;$/;"	t	class:eigen2_interface
stl_matrix	bench/btl/libs/eigen3/eigen3_interface.hh	/^  typedef std::vector<stl_vector> stl_matrix;$/;"	t	class:eigen3_interface
stl_matrix	bench/btl/libs/gmm/gmm_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:gmm_interface
stl_matrix	bench/btl/libs/mtl4/mtl4_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:mtl4_interface
stl_matrix	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef std::vector<stl_vector> stl_matrix;$/;"	t	class:tensor_interface
stl_matrix	bench/btl/libs/tvmet/tvmet_interface.hh	/^  typedef std::vector<stl_vector > stl_matrix;$/;"	t	class:tvmet_interface
stl_matrix	bench/btl/libs/ublas/ublas_interface.hh	/^  typedef std::vector<stl_vector> stl_matrix;$/;"	t	class:ublas_interface
stl_vector	bench/btl/libs/BLAS/c_interface_base.h	/^  typedef std::vector<real>         stl_vector;$/;"	t	class:c_interface_base
stl_vector	bench/btl/libs/STL/STL_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:STL_interface
stl_vector	bench/btl/libs/blaze/blaze_interface.hh	/^  typedef std::vector<real>        stl_vector;$/;"	t	class:blaze_interface
stl_vector	bench/btl/libs/blitz/blitz_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:blitz_interface
stl_vector	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:tiny_blitz_interface
stl_vector	bench/btl/libs/eigen2/eigen2_interface.hh	/^  typedef std::vector<real> stl_vector;$/;"	t	class:eigen2_interface
stl_vector	bench/btl/libs/eigen3/eigen3_interface.hh	/^  typedef std::vector<real> stl_vector;$/;"	t	class:eigen3_interface
stl_vector	bench/btl/libs/gmm/gmm_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:gmm_interface
stl_vector	bench/btl/libs/mtl4/mtl4_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:mtl4_interface
stl_vector	bench/btl/libs/tensors/tensor_interface.hh	/^  typedef std::vector<real> stl_vector;$/;"	t	class:tensor_interface
stl_vector	bench/btl/libs/tvmet/tvmet_interface.hh	/^  typedef std::vector<real>  stl_vector;$/;"	t	class:tvmet_interface
stl_vector	bench/btl/libs/ublas/ublas_interface.hh	/^  typedef std::vector<real> stl_vector;$/;"	t	class:ublas_interface
stop	bench/BenchTimer.h	/^  inline void stop()$/;"	f	class:Eigen::BenchTimer
stop	bench/btl/generic_bench/timers/portable_timer.hh	/^    LARGE_INTEGER stop;$/;"	m	struct:Portable_Timer::__anon5
stop	bench/btl/generic_bench/timers/portable_timer.hh	/^   void stop() { QueryPerformanceCounter(&stopVal); }$/;"	f	class:Portable_Timer
stop	bench/btl/generic_bench/timers/portable_timer.hh	/^  void stop()$/;"	f	class:Portable_Timer
stop	bench/btl/generic_bench/timers/x86_timer.hh	/^  inline void stop( void ){$/;"	f	class:X86_Timer
stopAnimation	demos/opengl/quaternion_demo.cpp	/^void RenderingWidget::stopAnimation()$/;"	f	class:RenderingWidget
stopIndices	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices& stopIndices() const { return m_stopIndices; }$/;"	f	class:Eigen::TensorStridingSlicingOp
stopVal	bench/btl/generic_bench/timers/portable_timer.hh	/^   LARGE_INTEGER stopVal;$/;"	m	class:Portable_Timer
stopWatch	bench/btl/generic_bench/timers/portable_timer.hh	/^   } stopWatch;$/;"	t	class:Portable_Timer	typeref:struct:Portable_Timer::__anon5
storage	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon865
storage_kind_to_evaluator_kind	Eigen/src/Core/CoreEvaluators.h	/^struct storage_kind_to_evaluator_kind {$/;"	s	namespace:Eigen::internal
storage_kind_to_evaluator_kind	Eigen/src/SparseCore/SparseAssign.h	/^struct storage_kind_to_evaluator_kind<Sparse> {$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<Dense>                  { typedef DenseShape Shape;           };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<PermutationStorage>     { typedef PermutationShape Shape;     };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<SolverStorage>          { typedef SolverShape Shape;           };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/Core/CoreEvaluators.h	/^template<> struct storage_kind_to_shape<TranspositionsStorage>  { typedef TranspositionsShape Shape;  };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/Core/DiagonalMatrix.h	/^template<> struct storage_kind_to_shape<DiagonalShape> { typedef DiagonalShape Shape; };$/;"	s	namespace:Eigen::internal
storage_kind_to_shape	Eigen/src/SparseCore/SparseAssign.h	/^struct storage_kind_to_shape<Sparse> {$/;"	s	namespace:Eigen::internal
store	test/packetmath.cpp	/^  inline void store(T* to, const Packet& x) const { internal::pstore(to,x); }$/;"	f	struct:packet_helper
store	test/packetmath.cpp	/^  inline void store(T* to, const T& x) const { *to = x; }$/;"	f	struct:packet_helper
storePacket	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const Packet &p) const {$/;"	f	class:Eigen::internal::BlasLinearMapper
storePacket	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, Packet p) const {$/;"	f	class:Eigen::internal::TensorContractionSubMapper
stored	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object1 stored;$/;"	m	struct:Eigen::internal::intersector_helper2
stored	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object1 stored;$/;"	m	struct:Eigen::internal::minimizer_helper2
stored	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object2 stored;$/;"	m	struct:Eigen::internal::intersector_helper1
stored	unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object2 stored;$/;"	m	struct:Eigen::internal::minimizer_helper1
stream	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_STRONG_INLINE const cudaStream_t& stream() const {$/;"	f	struct:Eigen::GpuDevice
stream	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  const cudaStream_t& stream() const { return *stream_; }$/;"	f	class:Eigen::CudaStreamDevice
stream_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  const StreamInterface* stream_;$/;"	m	struct:Eigen::GpuDevice
stream_	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  const cudaStream_t* stream_;$/;"	m	class:Eigen::CudaStreamDevice
stride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase
stride	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_DEVICE_FUNC const Index stride() const { return m_stride; }$/;"	f	class:Eigen::internal::blas_data_mapper
stride	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    stride(const Strides& strides) const {$/;"	f	class:Eigen::TensorBase
stride	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    stride(const Strides& strides) {$/;"	f	class:Eigen::TensorBase
stride	unsupported/Eigen/CXX11/src/Tensor/TensorContractionMapper.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Index stride() const {$/;"	f	class:Eigen::internal::SimpleTensorContractionMapper
stride	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Index& stride() const {$/;"	f	struct:Eigen::TensorEvaluator
stridedSlice	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    stridedSlice(const StartIndices& startIndices, const StopIndices& stopIndices, const Strides& strides) const {$/;"	f	class:Eigen::TensorBase
stridedSlice	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    stridedSlice(const StartIndices& startIndices, const StopIndices& stopIndices, const Strides& strides) {$/;"	f	class:Eigen::TensorBase
strides	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^    const Strides& strides() const { return m_strides; }$/;"	f	class:Eigen::TensorInflationOp
strides	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^    const StartIndices& strides() const { return m_strides; }$/;"	f	class:Eigen::TensorStridingSlicingOp
strides	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^    const Strides& strides() const { return m_dims; }$/;"	f	class:Eigen::TensorStridingOp
striding	bench/tensors/tensor_benchmarks.h	/^ void striding(int num_iters) {$/;"	f	class:BenchmarkSuite
strip_identities	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct strip_identities<Equality, id, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(ts)>>$/;"	s	namespace:Eigen::internal::group_theory
strip_identities	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^struct strip_identities<Equality, id, type_list<t, ts...>>$/;"	s	namespace:Eigen::internal::group_theory
structured_update	Eigen/src/SVD/BDCSVD.h	/^void BDCSVD<MatrixType>::structured_update(Block<MatrixXr,Dynamic,Dynamic> A, const MatrixXr &B, Index n1)$/;"	f	class:Eigen::BDCSVD
sub	Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	Eigen/src/Core/ProductEvaluators.h	/^  struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	s	struct:Eigen::internal::generic_product_impl
sub	test/svd_common.h	/^template<typename T> EIGEN_DONT_INLINE  T sub(T a, T b) { return a - b; }$/;"	f
subDiagonal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization
subTo	Eigen/src/Core/EigenBase.h	/^  inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
subTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	Eigen/src/Core/ProductEvaluators.h	/^  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl_base
subTo	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::generic_product_impl
subTo	Eigen/src/SparseCore/SparseProduct.h	/^  static void subTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, typename enable_if<is_same<typename evaluator_traits<Dest>::Shape,DenseShape>::value,int*>::type* = 0)$/;"	f	struct:Eigen::internal::generic_product_impl
subVector	Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp
subVectors	Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp
sub_assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename DstScalar,typename SrcScalar> struct sub_assign_op {$/;"	s	namespace:Eigen::internal
subdiag	doc/snippets/Tridiagonalization_diagonal.cpp	/^VectorXd subdiag = triOfA.subDiagonal();$/;"	v
subdiagonalEntryIsNeglegible	Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur
subnormalize	unsupported/test/mpreal/mpreal.h	/^inline int mpreal::subnormalize (int t,mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
subtract_assign_using_evaluator	test/evaluators.cpp	/^  void subtract_assign_using_evaluator(const DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen
succeeded	unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    inline bool succeeded(void) const {$/;"	f	class:Eigen::SkylineInplaceLU
sum	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase
sum	Eigen/src/Core/VectorwiseOp.h	/^    const SumReturnType sum() const$/;"	f	class:Eigen::VectorwiseOp
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector
sum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    sum() const {$/;"	f	class:Eigen::TensorBase
sum	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    sum(const Dims& dims) const {$/;"	f	class:Eigen::TensorBase
sum	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    Scalar sum() const { \/*std::cerr << "sum \\n\\n";*\/ \/*std::cerr << m_jacobian.rowwise().sum() << "\\n\\n";*\/ return Scalar(m_values.sum(), m_jacobian.rowwise().sum()); }$/;"	f	class:Eigen::AutoDiffVector
sum	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar sum;$/;"	m	class:Eigen::HybridNonLinearSolver
sum	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar par, sum;$/;"	m	class:Eigen::LevenbergMarquardt
sum	unsupported/test/mpreal/mpreal.h	/^inline const mpreal sum (const mpreal tab[], const unsigned long int n, int& status, mp_rnd_t mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
sum_op	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct sum_op           {$/;"	s	namespace:Eigen::internal
sum_op	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct sum_op {$/;"	s	namespace:Eigen::internal
sumupDuplicates	Eigen/src/SparseCore/SparseMatrix.h	/^    void sumupDuplicates() { collapseDuplicates(internal::scalar_sum_op<Scalar,Scalar>()); }$/;"	f	class:Eigen::SparseMatrix
supIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index supIndex() const { return m_supno; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
supToCol	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    StorageIndex* supToCol() { return m_sup_to_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
supToCol	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const StorageIndex* supToCol() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
super	Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
super	Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
supno	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector supno; \/\/ Supernode number corresponding to this column (column to supernode mapping)$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
svd_all_trivial_2x2	test/svd_common.h	/^void svd_all_trivial_2x2( void (*cb)(const MatrixType&,bool) )$/;"	f
svd_check_full	test/svd_common.h	/^void svd_check_full(const MatrixType& m, const SvdType& svd)$/;"	f
svd_compare_to_full	test/svd_common.h	/^void svd_compare_to_full(const MatrixType& m,$/;"	f
svd_fill_random	test/svd_fill.h	/^void svd_fill_random(MatrixType &m, int Option = 0)$/;"	f
svd_inf_nan	test/svd_common.h	/^void svd_inf_nan()$/;"	f
svd_least_square	test/svd_common.h	/^void svd_least_square(const MatrixType& m, unsigned int computationOptions)$/;"	f
svd_min_norm	test/svd_common.h	/^void svd_min_norm(const MatrixType& m, unsigned int computationOptions)$/;"	f
svd_preallocate	test/svd_common.h	/^void svd_preallocate()$/;"	f
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
svd_test_all_computation_options	test/svd_common.h	/^void svd_test_all_computation_options(const MatrixType& m, bool full_only)$/;"	f
svd_underoverflow	test/svd_common.h	/^void svd_underoverflow()$/;"	f
svd_verify_assert	test/svd_common.h	/^void svd_verify_assert(const MatrixType& m)$/;"	f
swap	Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/PlainObjectBase.h	/^    void swap(DenseBase<OtherDerived> & other)$/;"	f	class:Eigen::PlainObjectBase
swap	Eigen/src/Core/PlainObjectBase.h	/^    void swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase
swap	Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularViewImpl
swap	Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> &other)$/;"	f	class:Eigen::TriangularViewImpl
swap	Eigen/src/Core/util/Memory.h	/^template<typename T> void swap(scoped_array<T> &a,scoped_array<T> &b)$/;"	f	namespace:Eigen::internal
swap	Eigen/src/Core/util/Meta.h	/^template<typename T> EIGEN_DEVICE_FUNC   void swap(T &a, T &b) { T tmp = b; b = a; a = tmp; }$/;"	f	namespace:numext
swap	Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
swap	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
swap	Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseMatrix<Scalar,OtherOptions,StorageIndex>& other)$/;"	f	class:Eigen::SparseVector
swap	Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector
swap	blas/level1_impl.h	/^int EIGEN_BLAS_FUNC(swap)(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy)$/;"	f
swap	test/swap.cpp	/^template<typename MatrixType> void swap(const MatrixType& m)$/;"	f
swap	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  void swap(Tuple& rhs) {$/;"	f	struct:Eigen::Tuple
swap	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC  void swap(Self& other)$/;"	f	class:Eigen::TensorStorage
swap	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void swap(SkylineMatrix & other) {$/;"	f	class:Eigen::SkylineMatrix
swap	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void swap(SkylineStorage& other) {$/;"	f	class:Eigen::SkylineStorage
swap	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    friend void swap(BlockSparseMatrix& first, BlockSparseMatrix& second)$/;"	f	class:Eigen::BlockSparseMatrix
swap	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void swap(DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
swap	unsupported/test/mpreal/mpreal.h	/^    inline void swap(mpfr::mpreal& x, mpfr::mpreal& y)$/;"	f	namespace:std
swap	unsupported/test/mpreal/mpreal.h	/^inline void         swap (mpreal& a, mpreal& b)            {    mpfr_swap(a.mp,b.mp);   }$/;"	f	namespace:mpfr
swap_assign_op	Eigen/src/Core/functors/AssignmentFunctors.h	/^template<typename Scalar> struct swap_assign_op {$/;"	s	namespace:Eigen::internal
swap_layout	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    swap_layout() const {$/;"	f	class:Eigen::TensorBase
swap_layout	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    swap_layout() {$/;"	f	class:Eigen::TensorBase
swap_using_evaluator	test/evaluators.cpp	/^  void swap_using_evaluator(const DstXprType& dst, const SrcXprType& src)$/;"	f	namespace:Eigen
syclGenericBufferReducer	unsupported/Eigen/CXX11/src/Tensor/TensorReductionSycl.h	/^template<typename CoeffReturnType, typename KernelName> struct syclGenericBufferReducer{$/;"	s	namespace:Eigen::internal
sycl_queue	bench/tensors/tensor_benchmarks_sycl.cc	/^cl::sycl::queue sycl_queue() {$/;"	f
sym	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline int sym() { return m_sym; }$/;"	f	class:Eigen::MatrixMarketIterator
sym_to_string	test/sparse_solver.h	/^std::string sym_to_string(int sym)$/;"	f
symm	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(symm)(const char *side, const char *uplo, const int *m, const int *n, const RealScalar *palpha,$/;"	f
symm	test/product_symm.cpp	/^template<typename Scalar, int Size, int OtherSize> void symm(int size = Size, int othersize = OtherSize)$/;"	f
symm_pack_lhs	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
symv	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void symv(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blas_interface
symv	bench/btl/libs/STL/STL_interface.hh	/^  static inline void symv(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:STL_interface
symv	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void symv(const gene_matrix & A, const gene_vector & B, gene_vector & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
symv	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(symv) (const char *uplo, const int *n, const RealScalar *palpha, const RealScalar *pa, const int *lda,$/;"	f
sync	Eigen/src/Core/products/Parallelizer.h	/^  Index volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo
synchronize	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void synchronize() const {$/;"	f	struct:Eigen::GpuDevice
syr	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(syr)(const char *uplo, const int *n, const RealScalar *palpha, const RealScalar *px, const int *incx, RealScalar *pc, const int *ldc)$/;"	f
syr2	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void syr2(gene_matrix & A, gene_vector & B, gene_vector & X, int N){$/;"	f	class:blas_interface
syr2	bench/btl/libs/STL/STL_interface.hh	/^  static inline void syr2(gene_matrix & A, gene_vector & B, gene_vector & X, int N)$/;"	f	class:STL_interface
syr2	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static EIGEN_DONT_INLINE void syr2(gene_matrix & A,  gene_vector & X, gene_vector & Y, int  N){$/;"	f	class:eigen3_interface
syr2	blas/level2_real_impl.h	/^int EIGEN_BLAS_FUNC(syr2)(const char *uplo, const int *n, const RealScalar *palpha, const RealScalar *px, const int *incx, const RealScalar *py, const int *incy, RealScalar *pc, const int *ldc)$/;"	f
syr2k	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(syr2k)(const char *uplo, const char *op, const int *n, const int *k, const RealScalar *palpha,$/;"	f
syrk	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(syrk)(const char *uplo, const char *op, const int *n, const int *k,$/;"	f
syrk	test/product_syrk.cpp	/^template<typename MatrixType> void syrk(const MatrixType& m)$/;"	f
szero	bench/bench_gemm.cpp	/^static double szero = 0;$/;"	v	file:
tail	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType tail(Index n) const$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType tail(Index n)$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type tail(Index n = N) const$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type tail(Index n = N)$/;"	f
tail	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  Tuple<Ts...> tail;$/;"	m	struct:utility::tuple::Tuple
tail	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const Tail tail;$/;"	m	struct:Eigen::internal::type_list
tailresult	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<T2, T3, T4, T5, T6, T7, T8>::type tailresult;$/;"	t	struct:Eigen::internal::make_type_list
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<>                                  struct take<0, type_list<>>         { typedef type_list<> type; };$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n, typename a, typename... as> struct take<n, type_list<a, as...>> : concat<type_list<a>, typename take<n-1, type_list<as...>>::type> {};$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n>                             struct take<n, type_list<>>         { typedef type_list<> type; };$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T... as>        struct take<0, numeric_list<T, a, as...>> { typedef numeric_list<T> type; };$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n, T a, T... as> struct take<n, numeric_list<T, a, as...>> : concat<numeric_list<T, a>, typename take<n-1, numeric_list<T, as...>>::type> {};$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n>               struct take<n, numeric_list<T>>           { typedef numeric_list<T> type; };$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T>                      struct take<0, numeric_list<T>>           { typedef numeric_list<T> type; };$/;"	s	namespace:Eigen::internal
take	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename... as>        struct take<0, type_list<a, as...>> { typedef type_list<> type; };$/;"	s	namespace:Eigen::internal
take_affine_part	Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	Eigen/src/Core/MathFunctions.h	/^T tan(const T &x) {$/;"	f	namespace:Eigen::numext
tan	Eigen/src/Core/MathFunctions.h	/^double tan(const double &x) { return ::tan(x); }$/;"	f	namespace:Eigen::numext
tan	Eigen/src/Core/MathFunctions.h	/^float tan(const float &x) { return ::tanf(x); }$/;"	f	namespace:Eigen::numext
tan	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tan(const half& a) {$/;"	f	namespace:Eigen::half_impl
tan	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f
tan	unsupported/test/mpreal/mpreal.h	/^inline const mpreal tan   (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(tan  );    }$/;"	f	namespace:mpfr
tanh	Eigen/src/Core/MathFunctions.h	/^T tanh(const T &x) {$/;"	f	namespace:Eigen::numext
tanh	Eigen/src/Core/MathFunctions.h	/^double tanh(const double &x) { return ::tanh(x); }$/;"	f	namespace:Eigen::numext
tanh	Eigen/src/Core/MathFunctions.h	/^float tanh(const float &x) { return ::tanhf(x); }$/;"	f	namespace:Eigen::numext
tanh	Eigen/src/Core/MathFunctions.h	/^float tanh(float x) { return internal::generic_fast_tanh_float(x); }$/;"	f	namespace:Eigen::numext
tanh	Eigen/src/Core/arch/CUDA/Half.h	/^EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tanh(const half& a) {$/;"	f	namespace:Eigen::half_impl
tanh	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tanh() const$/;"	f
tanh	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    tanh() const {$/;"	f	class:Eigen::TensorBase
tanh	unsupported/test/mpreal/mpreal.h	/^inline const mpreal tanh  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(tanh );    }$/;"	f	namespace:mpfr
target	demos/opengl/camera.h	/^    inline const Eigen::Vector3f& target(void) { return mTarget; }$/;"	f	class:Camera
task	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    Task task;$/;"	m	struct:Eigen::SimpleThreadPoolTempl::Waiter
taskSize	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double taskSize($/;"	f	class:Eigen::TensorCostModel
tbsv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(tbsv)(char *uplo, char *op, char *diag, int *n, int *k, RealScalar *pa, int *lda, RealScalar *px, int *incx)$/;"	f
temp	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar temp;$/;"	m	class:Eigen::HybridNonLinearSolver
temp	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
temp1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
temp2	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
tensor_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct tensor_index_linearization_helper$/;"	s	namespace:Eigen::internal
tensor_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct tensor_index_linearization_helper<Index, NumIndices, 0, RowMajor>$/;"	s	namespace:Eigen::internal
tensor_interface	bench/btl/libs/tensors/tensor_interface.hh	/^class tensor_interface$/;"	c
tensor_static_symgroup	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_do_apply	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_do_apply<internal::type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>>$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_do_apply	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_do_apply<internal::type_list<first, next...>>$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_element	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_element$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_element_ctor	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_element_ctor$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_equality	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_equality$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_identity_ctor	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_identity_ctor$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_if	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_static_symgroup_if$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_if	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_static_symgroup_if<true, NumIndices, Gens...> : tensor_static_symgroup<NumIndices, Gens...> {};$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_index_permute	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^constexpr static inline std::array<Index, N> tensor_static_symgroup_index_permute(std::array<Index, N> idx, internal::numeric_list<int, ii...>, internal::numeric_list<int, jj...>)$/;"	f	namespace:Eigen::internal
tensor_static_symgroup_index_permute	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^static inline std::vector<Index> tensor_static_symgroup_index_permute(std::vector<Index> idx, internal::numeric_list<int, ii...>)$/;"	f	namespace:Eigen::internal
tensor_static_symgroup_multiply	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_multiply$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_multiply_helper	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_multiply_helper$/;"	s	namespace:Eigen::internal
tensor_static_symgroup_permutate	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^struct tensor_static_symgroup_permutate<numeric_list<int, nn...>>$/;"	s	namespace:Eigen::internal
tensor_symmetry_assign_value	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_symmetry_assign_value$/;"	s	namespace:Eigen::internal
tensor_symmetry_calculate_flags	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_symmetry_calculate_flags$/;"	s	namespace:Eigen::internal
tensor_symmetry_num_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^template<int One_, int Two_, typename... Sym> struct tensor_symmetry_num_indices<AntiHermiticity<One_, Two_>, Sym...>$/;"	s	namespace:Eigen::internal
tensor_symmetry_num_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^template<int One_, int Two_, typename... Sym> struct tensor_symmetry_num_indices<AntiSymmetry<One_, Two_>, Sym...>$/;"	s	namespace:Eigen::internal
tensor_symmetry_num_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^template<int One_, int Two_, typename... Sym> struct tensor_symmetry_num_indices<Hermiticity<One_, Two_>, Sym...>$/;"	s	namespace:Eigen::internal
tensor_symmetry_num_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^template<int One_, int Two_, typename... Sym> struct tensor_symmetry_num_indices<Symmetry<One_, Two_>, Sym...>$/;"	s	namespace:Eigen::internal
tensor_symmetry_num_indices	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^template<typename... Sym> struct tensor_symmetry_num_indices$/;"	s	namespace:Eigen::internal
tensor_symmetry_pre_analysis	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_symmetry_pre_analysis<NumIndices, Gen_, Gens_...>$/;"	s	namespace:Eigen::internal
tensor_symmetry_pre_analysis	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^struct tensor_symmetry_pre_analysis<NumIndices>$/;"	s	namespace:Eigen::internal
tensor_symmetry_value_setter	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^    inline tensor_symmetry_value_setter(Tensor_& tensor, Symmetry_ const& symmetry, std::array<Index, NumIndices> const& indices)$/;"	f	class:Eigen::internal::tensor_symmetry_value_setter
tensor_symmetry_value_setter	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^class tensor_symmetry_value_setter$/;"	c	namespace:Eigen::internal
tensor_vsize_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct tensor_vsize_index_linearization_helper$/;"	s	namespace:Eigen::internal
tensor_vsize_index_linearization_helper	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^struct tensor_vsize_index_linearization_helper<Index, NumIndices, 0, RowMajor>$/;"	s	namespace:Eigen::internal
ternary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit ternary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::ternary_evaluator
ternary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3>, IndexBased, IndexBased>$/;"	s	namespace:Eigen::internal
ternary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	s	namespace:Eigen::internal
ternary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
ternary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
test2dHyperbolicRotation	unsupported/test/matrix_exponential.cpp	/^void test2dHyperbolicRotation(double tol)$/;"	f
test2dHyperbolicRotation	unsupported/test/matrix_power.cpp	/^void test2dHyperbolicRotation(const T& tol)$/;"	f
test2dRotation	unsupported/test/matrix_exponential.cpp	/^void test2dRotation(double tol)$/;"	f
test2dRotation	unsupported/test/matrix_power.cpp	/^void test2dRotation(const T& tol)$/;"	f
test3dRotation	unsupported/test/matrix_power.cpp	/^void test3dRotation(const T& tol)$/;"	f
testChkder	unsupported/test/NonLinearOptimization.cpp	/^void testChkder()$/;"	f
testGeneral	unsupported/test/matrix_power.cpp	/^void testGeneral(const MatrixType& m, const typename MatrixType::RealScalar& tol)$/;"	f
testGonioFunctions	unsupported/test/matrix_function.cpp	/^void testGonioFunctions(const MatrixType& A)$/;"	f
testHybrd	unsupported/test/NonLinearOptimization.cpp	/^void testHybrd()$/;"	f
testHybrd1	unsupported/test/NonLinearOptimization.cpp	/^void testHybrd1()$/;"	f
testHybrj	unsupported/test/NonLinearOptimization.cpp	/^void testHybrj()$/;"	f
testHybrj1	unsupported/test/NonLinearOptimization.cpp	/^void testHybrj1()$/;"	f
testHyperbolicFunctions	unsupported/test/matrix_function.cpp	/^void testHyperbolicFunctions(const MatrixType& A)$/;"	f
testIntersect1	unsupported/test/BVH.cpp	/^  void testIntersect1()$/;"	f	struct:TreeTest
testIntersect2	unsupported/test/BVH.cpp	/^  void testIntersect2()$/;"	f	struct:TreeTest
testLmder	unsupported/test/NonLinearOptimization.cpp	/^void testLmder()$/;"	f
testLmder	unsupported/test/levenberg_marquardt.cpp	/^void testLmder()$/;"	f
testLmder1	unsupported/test/NonLinearOptimization.cpp	/^void testLmder1()$/;"	f
testLmder1	unsupported/test/levenberg_marquardt.cpp	/^void testLmder1()$/;"	f
testLmdif	unsupported/test/NonLinearOptimization.cpp	/^void testLmdif()$/;"	f
testLmdif	unsupported/test/levenberg_marquardt.cpp	/^void testLmdif()$/;"	f
testLmdif1	unsupported/test/NonLinearOptimization.cpp	/^void testLmdif1()$/;"	f
testLmdif1	unsupported/test/levenberg_marquardt.cpp	/^void testLmdif1()$/;"	f
testLmstr	unsupported/test/NonLinearOptimization.cpp	/^void testLmstr()$/;"	f
testLmstr1	unsupported/test/NonLinearOptimization.cpp	/^void testLmstr1()$/;"	f
testLogThenExp	unsupported/test/matrix_power.cpp	/^void testLogThenExp(const MatrixType& m_const, const typename MatrixType::RealScalar& tol)$/;"	f
testMatrix	unsupported/test/matrix_function.cpp	/^void testMatrix(const MatrixType& A)$/;"	f
testMatrixExponential	unsupported/test/matrix_function.cpp	/^void testMatrixExponential(const MatrixType& A)$/;"	f
testMatrixLogarithm	unsupported/test/matrix_function.cpp	/^void testMatrixLogarithm(const MatrixType& A)$/;"	f
testMatrixSqrt	unsupported/test/matrix_square_root.cpp	/^void testMatrixSqrt(const MatrixType& m)$/;"	f
testMatrixType	test/nullary.cpp	/^void testMatrixType(const MatrixType& m)$/;"	f
testMatrixType	unsupported/test/matrix_function.cpp	/^void testMatrixType(const MatrixType& m)$/;"	f
testMinimize1	unsupported/test/BVH.cpp	/^  void testMinimize1()$/;"	f	struct:TreeTest
testMinimize2	unsupported/test/BVH.cpp	/^  void testMinimize2()$/;"	f	struct:TreeTest
testNistBennett5	unsupported/test/NonLinearOptimization.cpp	/^void testNistBennett5(void)$/;"	f
testNistBennett5	unsupported/test/levenberg_marquardt.cpp	/^void testNistBennett5(void)$/;"	f
testNistBoxBOD	unsupported/test/NonLinearOptimization.cpp	/^void testNistBoxBOD(void)$/;"	f
testNistBoxBOD	unsupported/test/levenberg_marquardt.cpp	/^void testNistBoxBOD(void)$/;"	f
testNistChwirut2	unsupported/test/NonLinearOptimization.cpp	/^void testNistChwirut2(void)$/;"	f
testNistChwirut2	unsupported/test/levenberg_marquardt.cpp	/^void testNistChwirut2(void)$/;"	f
testNistEckerle4	unsupported/test/NonLinearOptimization.cpp	/^void testNistEckerle4(void)$/;"	f
testNistEckerle4	unsupported/test/levenberg_marquardt.cpp	/^void testNistEckerle4(void)$/;"	f
testNistHahn1	unsupported/test/NonLinearOptimization.cpp	/^void testNistHahn1(void)$/;"	f
testNistHahn1	unsupported/test/levenberg_marquardt.cpp	/^void testNistHahn1(void)$/;"	f
testNistLanczos1	unsupported/test/NonLinearOptimization.cpp	/^void testNistLanczos1(void)$/;"	f
testNistLanczos1	unsupported/test/levenberg_marquardt.cpp	/^void testNistLanczos1(void)$/;"	f
testNistMGH09	unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH09(void)$/;"	f
testNistMGH09	unsupported/test/levenberg_marquardt.cpp	/^void testNistMGH09(void)$/;"	f
testNistMGH10	unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH10(void)$/;"	f
testNistMGH10	unsupported/test/levenberg_marquardt.cpp	/^void testNistMGH10(void)$/;"	f
testNistMGH17	unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH17(void)$/;"	f
testNistMGH17	unsupported/test/levenberg_marquardt.cpp	/^void testNistMGH17(void)$/;"	f
testNistMisra1a	unsupported/test/NonLinearOptimization.cpp	/^void testNistMisra1a(void)$/;"	f
testNistMisra1a	unsupported/test/levenberg_marquardt.cpp	/^void testNistMisra1a(void)$/;"	f
testNistMisra1d	unsupported/test/NonLinearOptimization.cpp	/^void testNistMisra1d(void)$/;"	f
testNistMisra1d	unsupported/test/levenberg_marquardt.cpp	/^void testNistMisra1d(void)$/;"	f
testNistRat42	unsupported/test/NonLinearOptimization.cpp	/^void testNistRat42(void)$/;"	f
testNistRat42	unsupported/test/levenberg_marquardt.cpp	/^void testNistRat42(void)$/;"	f
testNistRat43	unsupported/test/NonLinearOptimization.cpp	/^void testNistRat43(void)$/;"	f
testNistRat43	unsupported/test/levenberg_marquardt.cpp	/^void testNistRat43(void)$/;"	f
testNistThurber	unsupported/test/NonLinearOptimization.cpp	/^void testNistThurber(void)$/;"	f
testNistThurber	unsupported/test/levenberg_marquardt.cpp	/^void testNistThurber(void)$/;"	f
testPascal	unsupported/test/matrix_exponential.cpp	/^void testPascal(double tol)$/;"	f
testSingular	unsupported/test/matrix_power.cpp	/^void testSingular(const MatrixType& m_const, const typename MatrixType::RealScalar& tol)$/;"	f
testVectorType	test/nullary.cpp	/^void testVectorType(const VectorType& base)$/;"	f
test_0d	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_0d()$/;"	f	file:
test_0d	unsupported/test/cxx11_tensor_map.cpp	/^static void test_0d()$/;"	f	file:
test_0d	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_0d()$/;"	f	file:
test_1D	unsupported/test/cxx11_tensor_generator.cpp	/^static void test_1D()$/;"	f	file:
test_1D_fft_ifft_invariant	unsupported/test/cxx11_tensor_ifft.cpp	/^static void test_1D_fft_ifft_invariant(int sequence_length) {$/;"	f	file:
test_1d	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_1d()$/;"	f	file:
test_1d	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_1d()$/;"	f	file:
test_1d	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_1d()$/;"	f	file:
test_1d	unsupported/test/cxx11_tensor_map.cpp	/^static void test_1d()$/;"	f	file:
test_1d	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_1d()$/;"	f	file:
test_1d_scan	unsupported/test/cxx11_tensor_scan.cpp	/^static void test_1d_scan()$/;"	f	file:
test_2D	unsupported/test/cxx11_tensor_generator.cpp	/^static void test_2D()$/;"	f	file:
test_2D_fft_ifft_invariant	unsupported/test/cxx11_tensor_ifft.cpp	/^static void test_2D_fft_ifft_invariant(int dim0, int dim1) {$/;"	f	file:
test_2d	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_2d()$/;"	f	file:
test_2d	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_2d()$/;"	f	file:
test_2d	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_2d()$/;"	f	file:
test_2d	unsupported/test/cxx11_tensor_map.cpp	/^static void test_2d()$/;"	f	file:
test_2d	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_2d()$/;"	f	file:
test_3D_fft_ifft_invariant	unsupported/test/cxx11_tensor_ifft.cpp	/^static void test_3D_fft_ifft_invariant(int dim0, int dim1, int dim2) {$/;"	f	file:
test_3d	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_3d()$/;"	f	file:
test_3d	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_3d()$/;"	f	file:
test_3d	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_3d()$/;"	f	file:
test_3d	unsupported/test/cxx11_tensor_map.cpp	/^static void test_3d()$/;"	f	file:
test_3d	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_3d()$/;"	f	file:
test_4d_scan	unsupported/test/cxx11_tensor_scan.cpp	/^static void test_4d_scan()$/;"	f	file:
test_BVH	unsupported/test/BVH.cpp	/^void test_BVH()$/;"	f
test_EulerAngles	unsupported/test/EulerAngles.cpp	/^void test_EulerAngles()$/;"	f
test_FFTW	unsupported/test/FFT.cpp	1;"	d	file:
test_FFTW	unsupported/test/FFTW.cpp	/^void test_FFTW()$/;"	f
test_NonLinearOptimization	unsupported/test/NonLinearOptimization.cpp	/^void test_NonLinearOptimization()$/;"	f
test_NumericalDiff	unsupported/test/NumericalDiff.cpp	/^void test_NumericalDiff()$/;"	f
test_abs	unsupported/test/cxx11_tensor_of_complex.cpp	/^static void test_abs()$/;"	f	file:
test_add	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_add() {$/;"	f
test_additions	unsupported/test/cxx11_tensor_of_complex.cpp	/^static void test_additions()$/;"	f	file:
test_additions	unsupported/test/cxx11_tensor_of_strings.cpp	/^static void test_additions()$/;"	f	file:
test_adjoint	test/adjoint.cpp	/^void test_adjoint()$/;"	f
test_aliasing	test/product_large.cpp	/^void test_aliasing()$/;"	f
test_alignedvector3	unsupported/test/alignedvector3.cpp	/^void test_alignedvector3()$/;"	f
test_apply_op	unsupported/test/cxx11_meta.cpp	/^static void test_apply_op()$/;"	f	file:
test_arg_reductions	unsupported/test/cxx11_meta.cpp	/^static void test_arg_reductions()$/;"	f	file:
test_argmax_dim	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_argmax_dim()$/;"	f	file:
test_argmax_tuple_reducer	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_argmax_tuple_reducer()$/;"	f	file:
test_argmin_dim	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_argmin_dim()$/;"	f	file:
test_argmin_tuple_reducer	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_argmin_tuple_reducer()$/;"	f	file:
test_arithmetic	test/half_float.cpp	/^void test_arithmetic()$/;"	f
test_array	test/array.cpp	/^void test_array()$/;"	f
test_array	test/half_float.cpp	/^void test_array()$/;"	f
test_array	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_array()$/;"	f	file:
test_array_for_matrix	test/array_for_matrix.cpp	/^void test_array_for_matrix()$/;"	f
test_array_misc	unsupported/test/cxx11_meta.cpp	/^static void test_array_misc()$/;"	f	file:
test_array_of_string	test/array_of_string.cpp	/^void test_array_of_string()$/;"	f
test_array_replicate	test/array_replicate.cpp	/^void test_array_replicate()$/;"	f
test_array_reverse	test/array_reverse.cpp	/^void test_array_reverse()$/;"	f
test_array_reverse_and_reduce	unsupported/test/cxx11_meta.cpp	/^static void test_array_reverse_and_reduce()$/;"	f	file:
test_array_zip_and_apply	unsupported/test/cxx11_meta.cpp	/^static void test_array_zip_and_apply()$/;"	f	file:
test_assign	test/vectorization_logic.cpp	/^bool test_assign(const Dst&, const Src&, int traversal, int unrolling)$/;"	f
test_assign	test/vectorization_logic.cpp	/^bool test_assign(int traversal, int unrolling)$/;"	f
test_assign	unsupported/test/cxx11_tensor_of_const_values.cpp	/^static void test_assign()$/;"	f	file:
test_assign	unsupported/test/cxx11_tensor_of_strings.cpp	/^static void test_assign()$/;"	f	file:
test_assign_of_const_tensor	unsupported/test/cxx11_tensor_const.cpp	/^static void test_assign_of_const_tensor()$/;"	f	file:
test_auto_resize	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_auto_resize()$/;"	f	file:
test_autodiff	unsupported/test/autodiff.cpp	/^void test_autodiff()$/;"	f
test_autodiff_hessian	unsupported/test/autodiff.cpp	/^void test_autodiff_hessian()$/;"	f
test_autodiff_jacobian	unsupported/test/autodiff.cpp	/^void test_autodiff_jacobian()$/;"	f
test_autodiff_scalar	unsupported/test/autodiff.cpp	/^void test_autodiff_scalar()$/;"	f
test_autodiff_scalar	unsupported/test/autodiff_scalar.cpp	/^void test_autodiff_scalar()$/;"	f
test_autodiff_vector	unsupported/test/autodiff.cpp	/^void test_autodiff_vector()$/;"	f
test_bandmatrix	test/bandmatrix.cpp	/^void test_bandmatrix()$/;"	f
test_basic_eventcount	unsupported/test/cxx11_eventcount.cpp	/^static void test_basic_eventcount()$/;"	f	file:
test_basic_functions	test/half_float.cpp	/^void test_basic_functions()$/;"	f
test_basic_runqueue	unsupported/test/cxx11_runqueue.cpp	/^void test_basic_runqueue()$/;"	f
test_basicstuff	test/basicstuff.cpp	/^void test_basicstuff()$/;"	f
test_bdcsvd	test/bdcsvd.cpp	/^void test_bdcsvd()$/;"	f
test_bicgstab	test/bicgstab.cpp	/^void test_bicgstab()$/;"	f
test_bicgstab_T	test/bicgstab.cpp	/^template<typename T, typename I> void test_bicgstab_T()$/;"	f
test_big_to_small_type_cast	unsupported/test/cxx11_tensor_casts.cpp	/^static void test_big_to_small_type_cast()$/;"	f	file:
test_block	test/block.cpp	/^void test_block()$/;"	f
test_block_recursion	test/commainitializer.cpp	/^struct test_block_recursion$/;"	s	file:
test_block_recursion	test/commainitializer.cpp	/^struct test_block_recursion<-1>$/;"	s	file:
test_blocks	test/commainitializer.cpp	/^void test_blocks()$/;"	f
test_boolean	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_boolean()$/;"	f	file:
test_boostmultiprec	test/boostmultiprec.cpp	/^void test_boostmultiprec()$/;"	f
test_broadcast_sycl	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	/^static void test_broadcast_sycl(const Eigen::SyclDevice &sycl_device){$/;"	f	file:
test_casting	unsupported/test/cxx11_tensor_map.cpp	/^static void test_casting()$/;"	f	file:
test_central	unsupported/test/NumericalDiff.cpp	/^void test_central()$/;"	f
test_chip_as_lvalue	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_chip_as_lvalue()$/;"	f	file:
test_chip_in_expr	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_chip_in_expr() {$/;"	f	file:
test_chip_raw_data_col_major	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_chip_raw_data_col_major()$/;"	f	file:
test_chip_raw_data_row_major	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_chip_raw_data_row_major()$/;"	f	file:
test_chol_update	test/cholesky.cpp	/^template<typename MatrixType,template <typename,int> class CholType> void test_chol_update(const MatrixType& symm)$/;"	f
test_cholesky	test/cholesky.cpp	/^void test_cholesky()$/;"	f
test_cholmod_T	test/cholmod_support.cpp	/^template<typename T> void test_cholmod_T()$/;"	f
test_cholmod_support	test/cholmod_support.cpp	/^void test_cholmod_support()$/;"	f
test_coeff_ref	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_coeff_ref()$/;"	f	file:
test_commainitializer	test/commainitializer.cpp	/^void test_commainitializer()$/;"	f
test_comparison	test/half_float.cpp	/^void test_comparison()$/;"	f
test_comparison_sugar	unsupported/test/cxx11_tensor_sugar.cpp	/^static void test_comparison_sugar() {$/;"	f	file:
test_complex	unsupported/test/FFTW.cpp	/^void test_complex(int nfft)$/;"	f
test_complex_generic	unsupported/test/FFTW.cpp	/^void test_complex_generic(int nfft)$/;"	f
test_composition	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_composition()$/;"	f	file:
test_compound_assign	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_compound_assign()$/;"	f	file:
test_compound_assignment	unsupported/test/cxx11_tensor_lvalue.cpp	/^static void test_compound_assignment()$/;"	f	file:
test_compute_block_size	test/product_extra.cpp	/^Index test_compute_block_size(Index m, Index n, Index k)$/;"	f
test_concat	unsupported/test/cxx11_meta.cpp	/^static void test_concat()$/;"	f	file:
test_concat	unsupported/test/cxx11_tensor_of_strings.cpp	/^static void test_concat()$/;"	f	file:
test_concatenation_as_lvalue	unsupported/test/cxx11_tensor_concatenation.cpp	/^static void test_concatenation_as_lvalue()$/;"	f	file:
test_conj_helper	test/packetmath.cpp	/^template<typename Scalar,bool ConjLhs,bool ConjRhs> void test_conj_helper(Scalar* data1, Scalar* data2, Scalar* ref, Scalar* pval)$/;"	f
test_conjugate	unsupported/test/cxx11_tensor_of_complex.cpp	/^static void test_conjugate()$/;"	f	file:
test_conjugate_gradient	test/conjugate_gradient.cpp	/^void test_conjugate_gradient()$/;"	f
test_conjugate_gradient_T	test/conjugate_gradient.cpp	/^template<typename T, typename I> void test_conjugate_gradient_T()$/;"	f
test_conservative_resize	test/conservative_resize.cpp	/^void test_conservative_resize()$/;"	f
test_consistency	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_consistency()$/;"	f	file:
test_const	unsupported/test/cxx11_tensor_forced_eval.cpp	/^static void test_const()$/;"	f	file:
test_const_inputs	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_const_inputs()$/;"	f	file:
test_const_slice	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_const_slice()$/;"	f	file:
test_constants	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_constants()$/;"	f	file:
test_constructor	test/constructor.cpp	/^void test_constructor()$/;"	f
test_contained_in_list	unsupported/test/cxx11_meta.cpp	/^static void test_contained_in_list()$/;"	f	file:
test_contraction_corner_cases	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_contraction_corner_cases()$/;"	f
test_contraction_of_contraction	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_contraction_of_contraction()$/;"	f	file:
test_contractions	unsupported/test/cxx11_tensor_of_complex.cpp	/^static void test_contractions()$/;"	f	file:
test_conversion	test/half_float.cpp	/^void test_conversion()$/;"	f
test_corners	test/corners.cpp	/^void test_corners()$/;"	f
test_create_destroy_empty_pool	unsupported/test/cxx11_non_blocking_thread_pool.cpp	/^static void test_create_destroy_empty_pool()$/;"	f	file:
test_ctorleak	test/ctorleak.cpp	/^void test_ctorleak()$/;"	f
test_current	bench/perf_monitoring/gemm/run.sh	/^function test_current $/;"	f
test_custom	unsupported/test/cxx11_tensor_random.cpp	/^static void test_custom()$/;"	f	file:
test_custom_binary_op	unsupported/test/cxx11_tensor_custom_op.cpp	/^static void test_custom_binary_op()$/;"	f	file:
test_custom_unary_op	unsupported/test/cxx11_tensor_custom_op.cpp	/^static void test_custom_unary_op()$/;"	f	file:
test_cxx11_eventcount	unsupported/test/cxx11_eventcount.cpp	/^void test_cxx11_eventcount()$/;"	f
test_cxx11_meta	unsupported/test/cxx11_meta.cpp	/^void test_cxx11_meta()$/;"	f
test_cxx11_non_blocking_thread_pool	unsupported/test/cxx11_non_blocking_thread_pool.cpp	/^void test_cxx11_non_blocking_thread_pool()$/;"	f
test_cxx11_runqueue	unsupported/test/cxx11_runqueue.cpp	/^void test_cxx11_runqueue()$/;"	f
test_cxx11_tensor_argmax	unsupported/test/cxx11_tensor_argmax.cpp	/^void test_cxx11_tensor_argmax()$/;"	f
test_cxx11_tensor_assign	unsupported/test/cxx11_tensor_assign.cpp	/^void test_cxx11_tensor_assign()$/;"	f
test_cxx11_tensor_broadcast_sycl	unsupported/test/cxx11_tensor_broadcast_sycl.cpp	/^void test_cxx11_tensor_broadcast_sycl() {$/;"	f
test_cxx11_tensor_broadcasting	unsupported/test/cxx11_tensor_broadcasting.cpp	/^void test_cxx11_tensor_broadcasting()$/;"	f
test_cxx11_tensor_casts	unsupported/test/cxx11_tensor_casts.cpp	/^void test_cxx11_tensor_casts()$/;"	f
test_cxx11_tensor_chipping	unsupported/test/cxx11_tensor_chipping.cpp	/^void test_cxx11_tensor_chipping()$/;"	f
test_cxx11_tensor_comparisons	unsupported/test/cxx11_tensor_comparisons.cpp	/^void test_cxx11_tensor_comparisons()$/;"	f
test_cxx11_tensor_concatenation	unsupported/test/cxx11_tensor_concatenation.cpp	/^void test_cxx11_tensor_concatenation()$/;"	f
test_cxx11_tensor_const	unsupported/test/cxx11_tensor_const.cpp	/^void test_cxx11_tensor_const()$/;"	f
test_cxx11_tensor_contraction	unsupported/test/cxx11_tensor_contraction.cpp	/^void test_cxx11_tensor_contraction()$/;"	f
test_cxx11_tensor_convolution	unsupported/test/cxx11_tensor_convolution.cpp	/^void test_cxx11_tensor_convolution()$/;"	f
test_cxx11_tensor_custom_index	unsupported/test/cxx11_tensor_custom_index.cpp	/^void test_cxx11_tensor_custom_index() {$/;"	f
test_cxx11_tensor_custom_op	unsupported/test/cxx11_tensor_custom_op.cpp	/^void test_cxx11_tensor_custom_op()$/;"	f
test_cxx11_tensor_device_sycl	unsupported/test/cxx11_tensor_device_sycl.cpp	/^void test_cxx11_tensor_device_sycl() {$/;"	f
test_cxx11_tensor_dimension	unsupported/test/cxx11_tensor_dimension.cpp	/^void test_cxx11_tensor_dimension()$/;"	f
test_cxx11_tensor_empty	unsupported/test/cxx11_tensor_empty.cpp	/^void test_cxx11_tensor_empty()$/;"	f
test_cxx11_tensor_expr	unsupported/test/cxx11_tensor_expr.cpp	/^void test_cxx11_tensor_expr()$/;"	f
test_cxx11_tensor_fft	unsupported/test/cxx11_tensor_fft.cpp	/^void test_cxx11_tensor_fft() {$/;"	f
test_cxx11_tensor_fixed_size	unsupported/test/cxx11_tensor_fixed_size.cpp	/^void test_cxx11_tensor_fixed_size()$/;"	f
test_cxx11_tensor_forced_eval	unsupported/test/cxx11_tensor_forced_eval.cpp	/^void test_cxx11_tensor_forced_eval()$/;"	f
test_cxx11_tensor_forced_eval_sycl	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	/^void test_cxx11_tensor_forced_eval_sycl() {$/;"	f
test_cxx11_tensor_generator	unsupported/test/cxx11_tensor_generator.cpp	/^void test_cxx11_tensor_generator()$/;"	f
test_cxx11_tensor_ifft	unsupported/test/cxx11_tensor_ifft.cpp	/^void test_cxx11_tensor_ifft() {$/;"	f
test_cxx11_tensor_image_patch	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_cxx11_tensor_image_patch()$/;"	f
test_cxx11_tensor_index_list	unsupported/test/cxx11_tensor_index_list.cpp	/^void test_cxx11_tensor_index_list()$/;"	f
test_cxx11_tensor_inflation	unsupported/test/cxx11_tensor_inflation.cpp	/^void test_cxx11_tensor_inflation()$/;"	f
test_cxx11_tensor_intdiv	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_cxx11_tensor_intdiv()$/;"	f
test_cxx11_tensor_io	unsupported/test/cxx11_tensor_io.cpp	/^void test_cxx11_tensor_io()$/;"	f
test_cxx11_tensor_layout_swap	unsupported/test/cxx11_tensor_layout_swap.cpp	/^void test_cxx11_tensor_layout_swap()$/;"	f
test_cxx11_tensor_lvalue	unsupported/test/cxx11_tensor_lvalue.cpp	/^void test_cxx11_tensor_lvalue()$/;"	f
test_cxx11_tensor_map	unsupported/test/cxx11_tensor_map.cpp	/^void test_cxx11_tensor_map()$/;"	f
test_cxx11_tensor_math	unsupported/test/cxx11_tensor_math.cpp	/^void test_cxx11_tensor_math()$/;"	f
test_cxx11_tensor_mixed_indices	unsupported/test/cxx11_tensor_mixed_indices.cpp	/^void test_cxx11_tensor_mixed_indices()$/;"	f
test_cxx11_tensor_morphing	unsupported/test/cxx11_tensor_morphing.cpp	/^void test_cxx11_tensor_morphing()$/;"	f
test_cxx11_tensor_notification	unsupported/test/cxx11_tensor_notification.cpp	/^void test_cxx11_tensor_notification()$/;"	f
test_cxx11_tensor_of_complex	unsupported/test/cxx11_tensor_of_complex.cpp	/^void test_cxx11_tensor_of_complex()$/;"	f
test_cxx11_tensor_of_const_values	unsupported/test/cxx11_tensor_of_const_values.cpp	/^void test_cxx11_tensor_of_const_values()$/;"	f
test_cxx11_tensor_of_strings	unsupported/test/cxx11_tensor_of_strings.cpp	/^void test_cxx11_tensor_of_strings()$/;"	f
test_cxx11_tensor_padding	unsupported/test/cxx11_tensor_padding.cpp	/^void test_cxx11_tensor_padding()$/;"	f
test_cxx11_tensor_patch	unsupported/test/cxx11_tensor_patch.cpp	/^void test_cxx11_tensor_patch()$/;"	f
test_cxx11_tensor_random	unsupported/test/cxx11_tensor_random.cpp	/^void test_cxx11_tensor_random()$/;"	f
test_cxx11_tensor_reduction	unsupported/test/cxx11_tensor_reduction.cpp	/^void test_cxx11_tensor_reduction() {$/;"	f
test_cxx11_tensor_reduction_sycl	unsupported/test/cxx11_tensor_reduction_sycl.cpp	/^void test_cxx11_tensor_reduction_sycl() {$/;"	f
test_cxx11_tensor_ref	unsupported/test/cxx11_tensor_ref.cpp	/^void test_cxx11_tensor_ref()$/;"	f
test_cxx11_tensor_reverse	unsupported/test/cxx11_tensor_reverse.cpp	/^void test_cxx11_tensor_reverse()$/;"	f
test_cxx11_tensor_roundings	unsupported/test/cxx11_tensor_roundings.cpp	/^void test_cxx11_tensor_roundings()$/;"	f
test_cxx11_tensor_scan	unsupported/test/cxx11_tensor_scan.cpp	/^void test_cxx11_tensor_scan() {$/;"	f
test_cxx11_tensor_shuffling	unsupported/test/cxx11_tensor_shuffling.cpp	/^void test_cxx11_tensor_shuffling()$/;"	f
test_cxx11_tensor_simple	unsupported/test/cxx11_tensor_simple.cpp	/^void test_cxx11_tensor_simple()$/;"	f
test_cxx11_tensor_striding	unsupported/test/cxx11_tensor_striding.cpp	/^void test_cxx11_tensor_striding()$/;"	f
test_cxx11_tensor_sugar	unsupported/test/cxx11_tensor_sugar.cpp	/^void test_cxx11_tensor_sugar()$/;"	f
test_cxx11_tensor_sycl	unsupported/test/cxx11_tensor_sycl.cpp	/^void test_cxx11_tensor_sycl() {$/;"	f
test_cxx11_tensor_symmetry	unsupported/test/cxx11_tensor_symmetry.cpp	/^void test_cxx11_tensor_symmetry()$/;"	f
test_cxx11_tensor_thread_pool	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_cxx11_tensor_thread_pool()$/;"	f
test_cxx11_tensor_uint128	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_cxx11_tensor_uint128()$/;"	f
test_cxx11_tensor_volume_patch	unsupported/test/cxx11_tensor_volume_patch.cpp	/^void test_cxx11_tensor_volume_patch()$/;"	f
test_default	unsupported/test/cxx11_tensor_random.cpp	/^static void test_default()$/;"	f	file:
test_denseLM	test/denseLM.cpp	/^void test_denseLM()$/;"	f
test_denseLM_T	test/denseLM.cpp	/^void test_denseLM_T()$/;"	f
test_dense_storage	test/dense_storage.cpp	/^void test_dense_storage()$/;"	f
test_determinant	test/determinant.cpp	/^void test_determinant()$/;"	f
test_device_sycl	unsupported/test/cxx11_tensor_device_sycl.cpp	/^void test_device_sycl(const Eigen::SyclDevice &sycl_device) {$/;"	f
test_dgmres	unsupported/test/dgmres.cpp	/^void test_dgmres()$/;"	f
test_dgmres_T	unsupported/test/dgmres.cpp	/^template<typename T> void test_dgmres_T()$/;"	f
test_diagonal	test/diagonal.cpp	/^void test_diagonal()$/;"	f
test_diagonalmatrices	test/diagonalmatrices.cpp	/^void test_diagonalmatrices()$/;"	f
test_dim_check	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_dim_check()$/;"	f	file:
test_dimension_failures	unsupported/test/cxx11_tensor_concatenation.cpp	/^static void test_dimension_failures()$/;"	f	file:
test_div	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_div() {$/;"	f
test_dontalign	test/dontalign.cpp	/^void test_dontalign()$/;"	f
test_dynalloc	test/dynalloc.cpp	/^void test_dynalloc()$/;"	f
test_dynamic_chip	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_dynamic_chip()$/;"	f	file:
test_dynamic_index_list	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_dynamic_index_list()$/;"	f	file:
test_dynamic_size	unsupported/test/cxx11_tensor_dimension.cpp	/^static void test_dynamic_size()$/;"	f	file:
test_eigen2support	test/eigen2support.cpp	/^void test_eigen2support()$/;"	f
test_eigensolver_complex	test/eigensolver_complex.cpp	/^void test_eigensolver_complex()$/;"	f
test_eigensolver_generalized_real	test/eigensolver_generalized_real.cpp	/^void test_eigensolver_generalized_real()$/;"	f
test_eigensolver_generic	test/eigensolver_generic.cpp	/^void test_eigensolver_generic()$/;"	f
test_eigensolver_selfadjoint	test/eigensolver_selfadjoint.cpp	/^void test_eigensolver_selfadjoint()$/;"	f
test_empty_fixed_size_tensor	unsupported/test/cxx11_tensor_empty.cpp	/^static void test_empty_fixed_size_tensor()$/;"	f	file:
test_empty_runqueue	unsupported/test/cxx11_runqueue.cpp	/^void test_empty_runqueue()$/;"	f
test_empty_tensor	unsupported/test/cxx11_tensor_empty.cpp	/^static void test_empty_tensor()$/;"	f	file:
test_entire_volume_patch	unsupported/test/cxx11_tensor_volume_patch.cpp	/^static void test_entire_volume_patch()$/;"	f	file:
test_equality	unsupported/test/cxx11_tensor_comparisons.cpp	/^static void test_equality()$/;"	f	file:
test_evals	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_evals()$/;"	f	file:
test_evals	unsupported/test/cxx11_tensor_convolution.cpp	/^static void test_evals()$/;"	f	file:
test_evaluators	test/evaluators.cpp	/^void test_evaluators()$/;"	f
test_exceptions	test/exceptions.cpp	/^void test_exceptions()$/;"	f
test_expr	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_expr()$/;"	f	file:
test_expr	unsupported/test/cxx11_tensor_convolution.cpp	/^static void test_expr()$/;"	f	file:
test_expr_reverse	unsupported/test/cxx11_tensor_reverse.cpp	/^static void test_expr_reverse(bool LValue)$/;"	f	file:
test_expr_shuffling	unsupported/test/cxx11_tensor_shuffling.cpp	/^static void test_expr_shuffling()$/;"	f	file:
test_fastmath	test/fastmath.cpp	/^void test_fastmath() {$/;"	f
test_fft_2D_golden	unsupported/test/cxx11_tensor_fft.cpp	/^static void test_fft_2D_golden() {$/;"	f	file:
test_fft_complex_input_golden	unsupported/test/cxx11_tensor_fft.cpp	/^static void test_fft_complex_input_golden() {$/;"	f	file:
test_fft_real_input_energy	unsupported/test/cxx11_tensor_fft.cpp	/^static void test_fft_real_input_energy() {$/;"	f	file:
test_fft_real_input_golden	unsupported/test/cxx11_tensor_fft.cpp	/^static void test_fft_real_input_golden() {$/;"	f	file:
test_first_aligned	test/first_aligned.cpp	/^void test_first_aligned()$/;"	f
test_first_aligned_helper	test/first_aligned.cpp	/^void test_first_aligned_helper(Scalar *array, int size)$/;"	f
test_first_dim_reductions_sycl	unsupported/test/cxx11_tensor_reduction_sycl.cpp	/^static void test_first_dim_reductions_sycl(const Eigen::SyclDevice& sycl_device) {$/;"	f	file:
test_fixed_size	unsupported/test/cxx11_tensor_dimension.cpp	/^static void test_fixed_size()$/;"	f	file:
test_fixed_size_broadcasting	unsupported/test/cxx11_tensor_broadcasting.cpp	/^static void test_fixed_size_broadcasting()$/;"	f	file:
test_float_ceiling	unsupported/test/cxx11_tensor_roundings.cpp	/^static void test_float_ceiling()$/;"	f	file:
test_float_flooring	unsupported/test/cxx11_tensor_roundings.cpp	/^static void test_float_flooring()$/;"	f	file:
test_float_rounding	unsupported/test/cxx11_tensor_roundings.cpp	/^static void test_float_rounding()$/;"	f	file:
test_float_to_int_cast	unsupported/test/cxx11_tensor_casts.cpp	/^static void test_float_to_int_cast()$/;"	f	file:
test_forced_eval_sycl	unsupported/test/cxx11_tensor_forced_eval_sycl.cpp	/^void test_forced_eval_sycl(const Eigen::SyclDevice &sycl_device) {$/;"	f
test_forward	unsupported/test/NumericalDiff.cpp	/^void test_forward()$/;"	f
test_forward_adolc	unsupported/test/forward_adolc.cpp	/^void test_forward_adolc()$/;"	f
test_from_tensor	unsupported/test/cxx11_tensor_map.cpp	/^static void test_from_tensor()$/;"	f	file:
test_full_contraction	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_full_contraction() {$/;"	f
test_full_reductions	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_full_reductions() {$/;"	f	file:
test_full_reductions_sycl	unsupported/test/cxx11_tensor_reduction_sycl.cpp	/^static void test_full_reductions_sycl(const Eigen::SyclDevice&  sycl_device) {$/;"	f	file:
test_full_redux	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_full_redux()$/;"	f	file:
test_functors	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_functors()$/;"	f	file:
test_gaussian	unsupported/test/cxx11_tensor_generator.cpp	/^static void test_gaussian()$/;"	f	file:
test_gen_numeric_list	unsupported/test/cxx11_meta.cpp	/^static void test_gen_numeric_list()$/;"	f	file:
test_geo_alignedbox	test/geo_alignedbox.cpp	/^void test_geo_alignedbox()$/;"	f
test_geo_eulerangles	test/geo_eulerangles.cpp	/^void test_geo_eulerangles()$/;"	f
test_geo_homogeneous	test/geo_homogeneous.cpp	/^void test_geo_homogeneous()$/;"	f
test_geo_hyperplane	test/geo_hyperplane.cpp	/^void test_geo_hyperplane()$/;"	f
test_geo_orthomethods	test/geo_orthomethods.cpp	/^void test_geo_orthomethods()$/;"	f
test_geo_parametrizedline	test/geo_parametrizedline.cpp	/^void test_geo_parametrizedline()$/;"	f
test_geo_quaternion	test/geo_quaternion.cpp	/^void test_geo_quaternion()$/;"	f
test_geo_transformations	test/geo_transformations.cpp	/^void test_geo_transformations()$/;"	f
test_get	unsupported/test/cxx11_meta.cpp	/^static void test_get()$/;"	f	file:
test_gmres	unsupported/test/gmres.cpp	/^void test_gmres()$/;"	f
test_gmres_T	unsupported/test/gmres.cpp	/^template<typename T> void test_gmres_T()$/;"	f
test_half_float	test/half_float.cpp	/^void test_half_float()$/;"	f
test_hessenberg	test/hessenberg.cpp	/^void test_hessenberg()$/;"	f
test_holes	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_holes() {$/;"	f	file:
test_householder	test/householder.cpp	/^void test_householder()$/;"	f
test_id	unsupported/test/cxx11_meta.cpp	/^static void test_id()$/;"	f	file:
test_id_helper	unsupported/test/cxx11_meta.cpp	/^static void test_id_helper(dummy_a a, dummy_a b, dummy_a c)$/;"	f	file:
test_id_numeric	unsupported/test/cxx11_meta.cpp	/^static void test_id_numeric()$/;"	f	file:
test_id_type	unsupported/test/cxx11_meta.cpp	/^static void test_id_type()$/;"	f	file:
test_imagenet_patches	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_imagenet_patches()$/;"	f
test_incomplete_cholesky	test/incomplete_cholesky.cpp	/^void test_incomplete_cholesky()$/;"	f
test_incomplete_cholesky_T	test/incomplete_cholesky.cpp	/^template<typename T, typename I> void test_incomplete_cholesky_T()$/;"	f
test_index_tuples_dim	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_index_tuples_dim()$/;"	f	file:
test_initialization	unsupported/test/cxx11_tensor_of_strings.cpp	/^static void test_initialization()$/;"	f	file:
test_innermost_first_dims	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_innermost_first_dims() {$/;"	f	file:
test_innermost_last_dims	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_innermost_last_dims() {$/;"	f	file:
test_inplace_decomposition	test/inplace_decomposition.cpp	/^void test_inplace_decomposition()$/;"	f
test_integer_types	test/integer_types.cpp	/^void test_integer_types()$/;"	f
test_inverse	test/inverse.cpp	/^void test_inverse()$/;"	f
test_isApprox	test/boostmultiprec.cpp	/^  inline bool test_isApprox(const Real& a, const Real& b) {$/;"	f	namespace:boost::multiprecision
test_isApprox	test/main.h	/^inline bool test_isApprox(const Type1& a, const Type2& b, typename Type1::Scalar* = 0) \/\/ Enabled for Eigen's type only$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const double& a, const double& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const float& a, const float& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const half& a, const half& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const int& a, const int& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const long double& a, const long double& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const long& a, const long& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const short& a, const short& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const std::complex<long double>& a, const std::complex<long double>& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const unsigned int& a, const unsigned int& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const unsigned long& a, const unsigned long& b)$/;"	f	namespace:Eigen
test_isApprox	test/main.h	/^inline bool test_isApprox(const unsigned short& a, const unsigned short& b)$/;"	f	namespace:Eigen
test_isApproxOrLessThan	test/boostmultiprec.cpp	/^  inline bool test_isApproxOrLessThan(const Real& a, const Real& b) {$/;"	f	namespace:boost::multiprecision
test_isApproxOrLessThan	test/main.h	/^inline bool test_isApproxOrLessThan(const double& a, const double& b)$/;"	f	namespace:Eigen
test_isApproxOrLessThan	test/main.h	/^inline bool test_isApproxOrLessThan(const float& a, const float& b)$/;"	f	namespace:Eigen
test_isApproxOrLessThan	test/main.h	/^inline bool test_isApproxOrLessThan(const half& a, const half& b)$/;"	f	namespace:Eigen
test_isApproxOrLessThan	test/main.h	/^inline bool test_isApproxOrLessThan(const int& a, const int& b)$/;"	f	namespace:Eigen
test_isApproxOrLessThan	test/main.h	/^inline bool test_isApproxOrLessThan(const long double& a, const long double& b)$/;"	f	namespace:Eigen
test_isApproxWithRef	test/main.h	/^inline bool test_isApproxWithRef(const Scalar& a, const Scalar& b, const ScalarRef& ref)$/;"	f	namespace:Eigen
test_isApprox_abs	unsupported/test/matrix_function.cpp	/^inline bool test_isApprox_abs(const Type1& a, const Type2& b)$/;"	f
test_isMuchSmallerThan	test/boostmultiprec.cpp	/^  inline bool test_isMuchSmallerThan(const Real& a, const Real& b) {$/;"	f	namespace:boost::multiprecision
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const MatrixBase<Derived1>& m1,$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const MatrixBase<Derived>& m,$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const double& a, const double& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const float& a, const float& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const half& a, const half& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const int& a, const int& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const long double& a, const long double& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen
test_isMuchSmallerThan	test/main.h	/^inline bool test_isMuchSmallerThan(const std::complex<long double>& a, const std::complex<long double>& b)$/;"	f	namespace:Eigen
test_isUnitary	test/main.h	/^inline bool test_isUnitary(const MatrixBase<Derived>& m)$/;"	f	namespace:Eigen
test_is_equal	test/main.h	/^bool test_is_equal(const T& actual, const U& expected, bool expect_equal)$/;"	f	namespace:Eigen
test_is_same_dense	test/is_same_dense.cpp	/^void test_is_same_dense()$/;"	f
test_is_same_gf	unsupported/test/cxx11_meta.cpp	/^static void test_is_same_gf()$/;"	f	file:
test_jacobi	test/jacobi.cpp	/^void test_jacobi()$/;"	f
test_jacobisvd	test/jacobisvd.cpp	/^void test_jacobisvd()$/;"	f
test_kronecker_product	unsupported/test/kronecker_product.cpp	/^void test_kronecker_product()$/;"	f
test_large_contraction	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_large_contraction()$/;"	f	file:
test_last_dim_reductions_sycl	unsupported/test/cxx11_tensor_reduction_sycl.cpp	/^static void test_last_dim_reductions_sycl(const Eigen::SyclDevice &sycl_device) {$/;"	f	file:
test_lazy_all_layout	test/product_small.cpp	/^void test_lazy_all_layout(int rows=Rows, int cols=Cols, int depth=Depth)$/;"	f
test_lazy_l1	test/product_small.cpp	/^void test_lazy_l1()$/;"	f
test_lazy_l2	test/product_small.cpp	/^void test_lazy_l2()$/;"	f
test_lazy_l3	test/product_small.cpp	/^void test_lazy_l3()$/;"	f
test_lazy_single	test/product_small.cpp	/^test_lazy_single(int rows, int cols, int depth)$/;"	f
test_lazy_single	test/product_small.cpp	/^test_lazy_single(int, int, int)$/;"	f
test_levenberg_marquardt	unsupported/test/levenberg_marquardt.cpp	/^void test_levenberg_marquardt()$/;"	f
test_linear_but_not_vectorizable	test/product_small.cpp	/^void test_linear_but_not_vectorizable()$/;"	f
test_linearstructure	test/linearstructure.cpp	/^void test_linearstructure()$/;"	f
test_lmder	test/denseLM.cpp	/^int test_lmder(FunctorType& functor, VectorType& uv)$/;"	f
test_lscg	test/lscg.cpp	/^void test_lscg()$/;"	f
test_lscg_T	test/lscg.cpp	/^template<typename T> void test_lscg_T()$/;"	f
test_lu	test/lu.cpp	/^void test_lu()$/;"	f
test_map_as_index	unsupported/test/cxx11_tensor_custom_index.cpp	/^static void test_map_as_index()$/;"	f	file:
test_mapped_matrix	test/mapped_matrix.cpp	/^void test_mapped_matrix()$/;"	f
test_mapstaticmethods	test/mapstaticmethods.cpp	/^void test_mapstaticmethods()$/;"	f
test_mapstride	test/mapstride.cpp	/^void test_mapstride()$/;"	f
test_match	unsupported/test/cxx11_tensor_dimension.cpp	/^static void test_match()$/;"	f	file:
test_matrix_as_index	unsupported/test/cxx11_tensor_custom_index.cpp	/^static void test_matrix_as_index()$/;"	f	file:
test_matrix_exponential	unsupported/test/matrix_exponential.cpp	/^void test_matrix_exponential()$/;"	f
test_matrix_function	unsupported/test/matrix_function.cpp	/^void test_matrix_function()$/;"	f
test_matrix_power	unsupported/test/matrix_power.cpp	/^void test_matrix_power()$/;"	f
test_matrix_square_root	unsupported/test/matrix_square_root.cpp	/^void test_matrix_square_root()$/;"	f
test_matrix_vector	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_matrix_vector()$/;"	f	file:
test_memcpy	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_memcpy() {$/;"	f
test_meta	test/meta.cpp	/^void test_meta()$/;"	f
test_metis_T	test/metis_support.cpp	/^template<typename T> void test_metis_T()$/;"	f
test_metis_support	test/metis_support.cpp	/^void test_metis_support()$/;"	f
test_minimizeLM	test/denseLM.cpp	/^int test_minimizeLM(FunctorType& functor, VectorType& uv)$/;"	f
test_minimizeSteps	test/denseLM.cpp	/^int test_minimizeSteps(FunctorType& functor, VectorType& uv)$/;"	f
test_minres	unsupported/test/minres.cpp	/^void test_minres()$/;"	f
test_minres_T	unsupported/test/minres.cpp	/^template<typename T> void test_minres_T()$/;"	f
test_misc1	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_misc1() {$/;"	f
test_misc2	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_misc2() {$/;"	f
test_miscmatrices	test/miscmatrices.cpp	/^void test_miscmatrices()$/;"	f
test_mixed_index_list	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_mixed_index_list()$/;"	f	file:
test_mixing_types	test/sparse_product.cpp	/^void test_mixing_types()$/;"	f
test_mixingtypes	test/mixingtypes.cpp	/^void test_mixingtypes()$/;"	f
test_modes	unsupported/test/cxx11_tensor_convolution.cpp	/^static void test_modes() {$/;"	f	file:
test_mpreal_support	unsupported/test/mpreal_support.cpp	/^void test_mpreal_support()$/;"	f
test_mul	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_mul() {$/;"	f
test_multidims	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_multidims()$/;"	f	file:
test_multiple_dims	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_multiple_dims()$/;"	f	file:
test_multithread_compound_assignment	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_compound_assignment()$/;"	f
test_multithread_contraction	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_contraction()$/;"	f
test_multithread_contraction_agrees_with_singlethread	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_contraction_agrees_with_singlethread() {$/;"	f
test_multithread_elementwise	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_elementwise()$/;"	f
test_multithread_random	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_random()$/;"	f
test_multithread_shuffle	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithread_shuffle()$/;"	f
test_multithreaded_reductions	unsupported/test/cxx11_tensor_thread_pool.cpp	/^void test_multithreaded_reductions() {$/;"	f
test_nested_ops_with_ref	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_nested_ops_with_ref()$/;"	f	file:
test_nesting_ops	test/nesting_ops.cpp	/^void test_nesting_ops()$/;"	f
test_nomalloc	test/nomalloc.cpp	/^void test_nomalloc()$/;"	f
test_none_aligned_helper	test/first_aligned.cpp	/^void test_none_aligned_helper(Scalar *array, int size)$/;"	f
test_normal	unsupported/test/cxx11_tensor_random.cpp	/^static void test_normal()$/;"	f	file:
test_notification_multiple	unsupported/test/cxx11_tensor_notification.cpp	/^static void test_notification_multiple()$/;"	f	file:
test_notification_single	unsupported/test/cxx11_tensor_notification.cpp	/^static void test_notification_single()$/;"	f	file:
test_nullary	test/nullary.cpp	/^void test_nullary()$/;"	f
test_numext	test/numext.cpp	/^void test_numext() {$/;"	f
test_numtraits	test/half_float.cpp	/^void test_numtraits()$/;"	f
test_openglsupport	unsupported/test/openglsupport.cpp	/^void test_openglsupport()$/;"	f
test_orderings	unsupported/test/cxx11_tensor_comparisons.cpp	/^static void test_orderings()$/;"	f	file:
test_out_of_order_contraction	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_out_of_order_contraction()$/;"	f	file:
test_output_0d	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_0d()$/;"	f	file:
test_output_1d	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_1d()$/;"	f	file:
test_output_2d	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_2d()$/;"	f	file:
test_output_const	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_const()$/;"	f	file:
test_output_expr	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_expr()$/;"	f	file:
test_output_string	unsupported/test/cxx11_tensor_io.cpp	/^static void test_output_string()$/;"	f	file:
test_packetmath	test/packetmath.cpp	/^void test_packetmath()$/;"	f
test_padded_expr	unsupported/test/cxx11_tensor_padding.cpp	/^static void test_padded_expr()$/;"	f	file:
test_parallelism	unsupported/test/cxx11_non_blocking_thread_pool.cpp	/^static void test_parallelism()$/;"	f	file:
test_pardiso_T	test/pardiso_support.cpp	/^template<typename T> void test_pardiso_T()$/;"	f
test_pardiso_support	test/pardiso_support.cpp	/^void test_pardiso_support()$/;"	f
test_pastix_T	test/pastix_support.cpp	/^template<typename T> void test_pastix_T()$/;"	f
test_pastix_T_LU	test/pastix_support.cpp	/^template<typename T> void test_pastix_T_LU()$/;"	f
test_pastix_support	test/pastix_support.cpp	/^void test_pastix_support()$/;"	f
test_patch_no_extra_dim	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_patch_no_extra_dim()$/;"	f
test_patch_padding_same	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_patch_padding_same()$/;"	f
test_patch_padding_valid	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_patch_padding_valid()$/;"	f
test_patch_padding_valid_same_value	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_patch_padding_valid_same_value()$/;"	f
test_permutationmatrices	test/permutationmatrices.cpp	/^void test_permutationmatrices()$/;"	f
test_plus	unsupported/test/cxx11_tensor_of_const_values.cpp	/^static void test_plus()$/;"	f	file:
test_plus_equal	unsupported/test/cxx11_tensor_of_const_values.cpp	/^static void test_plus_equal()$/;"	f	file:
test_polynomialsolver	unsupported/test/polynomialsolver.cpp	/^void test_polynomialsolver()$/;"	f
test_polynomialutils	unsupported/test/polynomialutils.cpp	/^void test_polynomialutils()$/;"	f
test_powers_32bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_powers_32bit() {$/;"	f
test_powers_64bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_powers_64bit() {$/;"	f
test_prec_inverse_4x4	test/prec_inverse_4x4.cpp	/^void test_prec_inverse_4x4()$/;"	f
test_precision	bench/spbench/spbenchsolver.h	/^template<> inline double test_precision<double>() { return 1e-6; }                                                            $/;"	f
test_precision	bench/spbench/spbenchsolver.h	/^template<> inline double test_precision<std::complex<double> >() { return test_precision<double>(); }$/;"	f
test_precision	bench/spbench/spbenchsolver.h	/^template<> inline float test_precision<float>() { return 1e-3f; }                                                             $/;"	f
test_precision	bench/spbench/spbenchsolver.h	/^template<> inline float test_precision<std::complex<float> >() { return test_precision<float>(); }$/;"	f
test_precision	bench/spbench/spbenchsolver.h	/^template<typename T> inline typename NumTraits<T>::Real test_precision() { return NumTraits<T>::dummy_precision(); }$/;"	f
test_precision	test/boostmultiprec.cpp	/^  Real test_precision<Real>() { return 1e-50; }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline double test_precision<double>() { return 1e-6; }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline double test_precision<std::complex<double> >() { return test_precision<double>(); }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline float test_precision<float>() { return 1e-3f; }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline float test_precision<std::complex<float> >() { return test_precision<float>(); }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline long double test_precision<long double>() { return 1e-6l; }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<> inline long double test_precision<std::complex<long double> >() { return test_precision<long double>(); }$/;"	f	namespace:Eigen
test_precision	test/main.h	/^template<typename T> inline typename NumTraits<T>::Real test_precision() { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen
test_product_extra	test/product_extra.cpp	/^void test_product_extra()$/;"	f
test_product_large	test/product_large.cpp	/^void test_product_large()$/;"	f
test_product_mmtr	test/product_mmtr.cpp	/^void test_product_mmtr()$/;"	f
test_product_notemporary	test/product_notemporary.cpp	/^void test_product_notemporary()$/;"	f
test_product_selfadjoint	test/product_selfadjoint.cpp	/^void test_product_selfadjoint()$/;"	f
test_product_small	test/product_small.cpp	/^void test_product_small()$/;"	f
test_product_symm	test/product_symm.cpp	/^void test_product_symm()$/;"	f
test_product_syrk	test/product_syrk.cpp	/^void test_product_syrk()$/;"	f
test_product_trmm	test/product_trmm.cpp	/^void test_product_trmm()$/;"	f
test_product_trmv	test/product_trmv.cpp	/^void test_product_trmv()$/;"	f
test_product_trsolve	test/product_trsolve.cpp	/^void test_product_trsolve()$/;"	f
test_qr	test/qr.cpp	/^void test_qr()$/;"	f
test_qr_colpivoting	test/qr_colpivoting.cpp	/^void test_qr_colpivoting()$/;"	f
test_qr_fullpivoting	test/qr_fullpivoting.cpp	/^void test_qr_fullpivoting()$/;"	f
test_qtvector	test/qtvector.cpp	/^void test_qtvector()$/;"	f
test_rand	test/rand.cpp	/^void test_rand()$/;"	f
test_random_setter	unsupported/test/sparse_extra.cpp	/^bool test_random_setter(DynamicSparseMatrix<T>& sm, const DenseType& ref, const std::vector<Vector2i>& nonzeroCoords)$/;"	f
test_random_setter	unsupported/test/sparse_extra.cpp	/^bool test_random_setter(SparseMatrix<Scalar,Options>& sm, const DenseType& ref, const std::vector<Vector2i>& nonzeroCoords)$/;"	f
test_rank_zero	unsupported/test/cxx11_tensor_dimension.cpp	/^static void test_rank_zero()$/;"	f	file:
test_real_qz	test/real_qz.cpp	/^void test_real_qz()$/;"	f
test_reduce_middle_dims	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_reduce_middle_dims() {$/;"	f	file:
test_reductions_in_expr	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_reductions_in_expr() {$/;"	f	file:
test_redux	test/redux.cpp	/^void test_redux()$/;"	f
test_redux	test/vectorization_logic.cpp	/^bool test_redux(const Xpr&, int traversal, int unrolling)$/;"	f
test_ref	test/ref.cpp	/^void test_ref()$/;"	f
test_ref_ambiguous	test/ref.cpp	/^void test_ref_ambiguous(const Ref<const ArrayXd> &A, Ref<ArrayXd> B)$/;"	f
test_ref_fixed_size_assert	test/ref.cpp	/^void test_ref_fixed_size_assert()$/;"	f
test_ref_in_expr	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_ref_in_expr()$/;"	f	file:
test_ref_of_ref	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_ref_of_ref()$/;"	f	file:
test_ref_overload_fun1	test/ref.cpp	/^int test_ref_overload_fun1(Ref<MatrixXd> )       { return 1; }$/;"	f
test_ref_overload_fun1	test/ref.cpp	/^int test_ref_overload_fun1(Ref<MatrixXf> )       { return 3; }$/;"	f
test_ref_overload_fun1	test/ref.cpp	/^int test_ref_overload_fun1(Ref<RowMatrixXd> )    { return 2; }$/;"	f
test_ref_overload_fun2	test/ref.cpp	/^int test_ref_overload_fun2(Ref<const MatrixXd> ) { return 4; }$/;"	f
test_ref_overload_fun2	test/ref.cpp	/^int test_ref_overload_fun2(Ref<const MatrixXf> ) { return 5; }$/;"	f
test_ref_overloads	test/ref.cpp	/^void test_ref_overloads()$/;"	f
test_reference	test/nomalloc.cpp	/^template<typename MatrixType> void test_reference(const MatrixType& m) {$/;"	f
test_relative_error	test/boostmultiprec.cpp	/^  Real test_relative_error(const Real &a, const Real &b) {$/;"	f	namespace:boost::multiprecision
test_relative_error	test/main.h	/^S test_relative_error(const AlignedBox<S,D> &a, const AlignedBox<S,D> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^S test_relative_error(const ParametrizedLine<S,D,O> &a, const ParametrizedLine<S,D,O> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^S test_relative_error(const Translation<S,D> &a, const Translation<S,D> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^T test_relative_error(const AngleAxis<T> &a, const AngleAxis<T> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^T test_relative_error(const Rotation2D<T> &a, const Rotation2D<T> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename NumTraits<typename NumTraits<T1>::Real>::NonInteger test_relative_error(const T1 &a, const T2 &b, typename internal::enable_if<internal::is_arithmetic<typename NumTraits<T1>::Real>::value, T1>::type* = 0)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename NumTraits<typename T1::RealScalar>::NonInteger test_relative_error(const EigenBase<T1> &a, const EigenBase<T2> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename T1::RealScalar test_relative_error(const MatrixBase<T1> &a, const SparseMatrixBase<T2> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename T1::RealScalar test_relative_error(const SparseMatrixBase<T1> &a, const MatrixBase<T2> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename T1::RealScalar test_relative_error(const SparseMatrixBase<T1> &a, const SparseMatrixBase<T2> &b)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename T1::RealScalar test_relative_error(const T1 &a, const T2 &b, const typename T1::Coefficients* = 0)$/;"	f	namespace:Eigen
test_relative_error	test/main.h	/^typename T1::Scalar test_relative_error(const T1 &a, const T2 &b, const typename T1::MatrixType* = 0)$/;"	f	namespace:Eigen
test_relative_error	unsupported/test/alignedvector3.cpp	/^T test_relative_error(const AlignedVector3<T> &a, const MatrixBase<Derived> &b)$/;"	f	namespace:Eigen
test_reshape_as_lvalue	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_reshape_as_lvalue()$/;"	f	file:
test_reshape_in_expr	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_reshape_in_expr() {$/;"	f	file:
test_resize	test/resize.cpp	/^void test_resize()$/;"	f
test_resize	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_resize()$/;"	f	file:
test_return_by_value	unsupported/test/FFTW.cpp	/^void test_return_by_value(int len)$/;"	f
test_rvalue_types	test/rvalue_types.cpp	/^void test_rvalue_types()$/;"	f
test_same_type	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_same_type()$/;"	f	file:
test_scalar	unsupported/test/FFTW.cpp	/^void test_scalar(int nfft)$/;"	f
test_scalar	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_scalar()$/;"	f	file:
test_scalar_generic	unsupported/test/FFTW.cpp	/^void test_scalar_generic(int nfft)$/;"	f
test_scalar_sugar_add_mul	unsupported/test/cxx11_tensor_sugar.cpp	/^static void test_scalar_sugar_add_mul() {$/;"	f	file:
test_scalar_sugar_sub_div	unsupported/test/cxx11_tensor_sugar.cpp	/^static void test_scalar_sugar_sub_div() {$/;"	f	file:
test_schur_complex	test/schur_complex.cpp	/^void test_schur_complex()$/;"	f
test_schur_real	test/schur_real.cpp	/^void test_schur_real()$/;"	f
test_select	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_select()$/;"	f	file:
test_selfadjoint	test/selfadjoint.cpp	/^void test_selfadjoint()$/;"	f
test_shuffle_unshuffle	unsupported/test/cxx11_tensor_shuffling.cpp	/^static void test_shuffle_unshuffle()$/;"	f	file:
test_shuffling_as_value	unsupported/test/cxx11_tensor_shuffling.cpp	/^static void test_shuffling_as_value()$/;"	f	file:
test_sigmoid	unsupported/test/cxx11_tensor_math.cpp	/^static void test_sigmoid()$/;"	f	file:
test_signed_32bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_signed_32bit()$/;"	f
test_signed_64bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_signed_64bit()$/;"	f
test_simple	unsupported/test/cxx11_tensor_forced_eval.cpp	/^static void test_simple()$/;"	f	file:
test_simple	unsupported/test/cxx11_tensor_mixed_indices.cpp	/^static void test_simple()$/;"	f	file:
test_simple_argmax	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_simple_argmax()$/;"	f	file:
test_simple_argmin	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_simple_argmin()$/;"	f	file:
test_simple_assign	unsupported/test/cxx11_tensor_const.cpp	/^static void test_simple_assign()$/;"	f	file:
test_simple_assign	unsupported/test/cxx11_tensor_simple.cpp	/^static void test_simple_assign()$/;"	f	file:
test_simple_broadcasting	unsupported/test/cxx11_tensor_broadcasting.cpp	/^static void test_simple_broadcasting()$/;"	f	file:
test_simple_cast	unsupported/test/cxx11_tensor_casts.cpp	/^static void test_simple_cast()$/;"	f	file:
test_simple_chip	unsupported/test/cxx11_tensor_chipping.cpp	/^static void test_simple_chip()$/;"	f	file:
test_simple_concatenation	unsupported/test/cxx11_tensor_concatenation.cpp	/^static void test_simple_concatenation()$/;"	f	file:
test_simple_index_tuples	unsupported/test/cxx11_tensor_argmax.cpp	/^static void test_simple_index_tuples()$/;"	f	file:
test_simple_inflation	unsupported/test/cxx11_tensor_inflation.cpp	/^static void test_simple_inflation()$/;"	f	file:
test_simple_lvalue_ref	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_simple_lvalue_ref()$/;"	f	file:
test_simple_padding	unsupported/test/cxx11_tensor_padding.cpp	/^static void test_simple_padding()$/;"	f	file:
test_simple_patch	unsupported/test/cxx11_tensor_image_patch.cpp	/^void test_simple_patch()$/;"	f
test_simple_patch	unsupported/test/cxx11_tensor_patch.cpp	/^static void test_simple_patch()$/;"	f	file:
test_simple_reductions	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_simple_reductions() {$/;"	f	file:
test_simple_reshape	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_simple_reshape()$/;"	f	file:
test_simple_reverse	unsupported/test/cxx11_tensor_reverse.cpp	/^static void test_simple_reverse()$/;"	f	file:
test_simple_rvalue_ref	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_simple_rvalue_ref()$/;"	f	file:
test_simple_shuffling	unsupported/test/cxx11_tensor_shuffling.cpp	/^static void test_simple_shuffling()$/;"	f	file:
test_simple_slice	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_simple_slice()$/;"	f	file:
test_simple_striding	unsupported/test/cxx11_tensor_striding.cpp	/^static void test_simple_striding()$/;"	f	file:
test_simple_swap	unsupported/test/cxx11_tensor_layout_swap.cpp	/^static void test_simple_swap()$/;"	f	file:
test_simplicial_cholesky	test/simplicial_cholesky.cpp	/^void test_simplicial_cholesky()$/;"	f
test_simplicial_cholesky_T	test/simplicial_cholesky.cpp	/^template<typename T, typename I> void test_simplicial_cholesky_T()$/;"	f
test_single_voxel_patch	unsupported/test/cxx11_tensor_volume_patch.cpp	/^static void test_single_voxel_patch()$/;"	f	file:
test_sizeof	test/sizeof.cpp	/^void test_sizeof()$/;"	f
test_sizeoverflow	test/sizeoverflow.cpp	/^void test_sizeoverflow()$/;"	f
test_sizes_as_index	unsupported/test/cxx11_tensor_custom_index.cpp	/^static void test_sizes_as_index()$/;"	f	file:
test_slice	unsupported/test/cxx11_meta.cpp	/^static void test_slice()$/;"	f	file:
test_slice	unsupported/test/cxx11_tensor_ref.cpp	/^static void test_slice()$/;"	f	file:
test_slice_as_lvalue	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_slice_as_lvalue()$/;"	f	file:
test_slice_in_expr	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_slice_in_expr() {$/;"	f	file:
test_slice_raw_data	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_slice_raw_data()$/;"	f	file:
test_slices	unsupported/test/cxx11_tensor_of_strings.cpp	/^static void test_slices()$/;"	f	file:
test_small_blocking_factors	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_small_blocking_factors()$/;"	f	file:
test_small_to_big_type_cast	unsupported/test/cxx11_tensor_casts.cpp	/^static void test_small_to_big_type_cast()$/;"	f	file:
test_smallvectors	test/smallvectors.cpp	/^void test_smallvectors()$/;"	f
test_sparseLM	test/sparseLM.cpp	/^void test_sparseLM()$/;"	f
test_sparseLM_T	test/sparseLM.cpp	/^void test_sparseLM_T()$/;"	f
test_sparse_basic	test/sparse_basic.cpp	/^void test_sparse_basic()$/;"	f
test_sparse_block	test/sparse_block.cpp	/^void test_sparse_block()$/;"	f
test_sparse_extra	unsupported/test/sparse_extra.cpp	/^void test_sparse_extra()$/;"	f
test_sparse_permutations	test/sparse_permutations.cpp	/^void test_sparse_permutations()$/;"	f
test_sparse_product	test/sparse_product.cpp	/^void test_sparse_product()$/;"	f
test_sparse_ref	test/sparse_ref.cpp	/^void test_sparse_ref()$/;"	f
test_sparse_solvers	test/sparse_solvers.cpp	/^void test_sparse_solvers()$/;"	f
test_sparse_vector	test/sparse_vector.cpp	/^void test_sparse_vector()$/;"	f
test_sparselu	test/sparselu.cpp	/^void test_sparselu()$/;"	f
test_sparselu_T	test/sparselu.cpp	/^template<typename T> void test_sparselu_T()$/;"	f
test_sparseqr	test/sparseqr.cpp	/^void test_sparseqr()$/;"	f
test_sparseqr_scalar	test/sparseqr.cpp	/^template<typename Scalar> void test_sparseqr_scalar()$/;"	f
test_special_functions	unsupported/test/special_functions.cpp	/^void test_special_functions()$/;"	f
test_special_numbers	test/special_numbers.cpp	/^void test_special_numbers()$/;"	f
test_specific	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_specific() {$/;"	f
test_splines	unsupported/test/splines.cpp	/^void test_splines()$/;"	f
test_spqr_scalar	test/spqr_support.cpp	/^template<typename Scalar> void test_spqr_scalar()$/;"	f
test_spqr_support	test/spqr_support.cpp	/^void test_spqr_support()$/;"	f
test_stable_norm	test/stable_norm.cpp	/^void test_stable_norm()$/;"	f
test_static_broadcasting	unsupported/test/cxx11_tensor_broadcasting.cpp	/^static void test_static_broadcasting()$/;"	f	file:
test_static_dimension_failure	unsupported/test/cxx11_tensor_concatenation.cpp	/^static void test_static_dimension_failure()$/;"	f	file:
test_static_dims	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_static_dims() {$/;"	f	file:
test_static_index_list	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_static_index_list()$/;"	f	file:
test_std_initializers_tensor	unsupported/test/cxx11_tensor_assign.cpp	/^static void test_std_initializers_tensor() {$/;"	f	file:
test_stddeque	test/stddeque.cpp	/^void test_stddeque()$/;"	f
test_stddeque_overload	test/stddeque_overload.cpp	/^void test_stddeque_overload()$/;"	f
test_stdlist	test/stdlist.cpp	/^void test_stdlist()$/;"	f
test_stdlist_overload	test/stdlist_overload.cpp	/^void test_stdlist_overload()$/;"	f
test_stdvector	test/stdvector.cpp	/^void test_stdvector()$/;"	f
test_stdvector_overload	test/stdvector_overload.cpp	/^void test_stdvector_overload()$/;"	f
test_stress_eventcount	unsupported/test/cxx11_eventcount.cpp	/^static void test_stress_eventcount()$/;"	f	file:
test_stress_runqueue	unsupported/test/cxx11_runqueue.cpp	/^void test_stress_runqueue()$/;"	f
test_strided_slice	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_strided_slice()$/;"	f	file:
test_strided_slice_write	unsupported/test/cxx11_tensor_morphing.cpp	/^static void test_strided_slice_write()$/;"	f	file:
test_strides	unsupported/test/cxx11_tensor_convolution.cpp	/^static void test_strides() {$/;"	f	file:
test_striding_as_lvalue	unsupported/test/cxx11_tensor_striding.cpp	/^static void test_striding_as_lvalue()$/;"	f	file:
test_sub	unsupported/test/cxx11_tensor_uint128.cpp	/^void test_sub() {$/;"	f
test_sub_fft_ifft_invariant	unsupported/test/cxx11_tensor_ifft.cpp	/^static void test_sub_fft_ifft_invariant(int dim0, int dim1, int dim2, int dim3) {$/;"	f	file:
test_superlu_support	test/superlu_support.cpp	/^void test_superlu_support()$/;"	f
test_swap	test/swap.cpp	/^void test_swap()$/;"	f
test_swap_as_lvalue	unsupported/test/cxx11_tensor_layout_swap.cpp	/^static void test_swap_as_lvalue()$/;"	f	file:
test_sycl_cpu	unsupported/test/cxx11_tensor_sycl.cpp	/^void test_sycl_cpu(const Eigen::SyclDevice &sycl_device) {$/;"	f
test_symgroups_dynamic	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_symgroups_dynamic()$/;"	f	file:
test_symgroups_selection	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_symgroups_selection()$/;"	f	file:
test_symgroups_static	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_symgroups_static()$/;"	f	file:
test_tanh	unsupported/test/cxx11_tensor_math.cpp	/^static void test_tanh()$/;"	f	file:
test_tensor_asym	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_tensor_asym()$/;"	f	file:
test_tensor_dynsym	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_tensor_dynsym()$/;"	f	file:
test_tensor_epsilon	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_tensor_epsilon()$/;"	f	file:
test_tensor_map	unsupported/test/cxx11_tensor_fixed_size.cpp	/^static void test_tensor_map()$/;"	f	file:
test_tensor_maps	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_tensor_maps() {$/;"	f	file:
test_tensor_maps	unsupported/test/cxx11_tensor_scan.cpp	/^static void test_tensor_maps() {$/;"	f	file:
test_tensor_product	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_tensor_product()$/;"	f	file:
test_tensor_randacc	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_tensor_randacc()$/;"	f	file:
test_tensor_sym	unsupported/test/cxx11_tensor_symmetry.cpp	/^static void test_tensor_sym()$/;"	f	file:
test_tensor_vector	unsupported/test/cxx11_tensor_contraction.cpp	/^static void test_tensor_vector()$/;"	f	file:
test_transform	bench/benchGeometry.cpp	/^struct test_transform$/;"	s	file:
test_triangular	test/triangular.cpp	/^void test_triangular()$/;"	f
test_trigonometric_functions	test/half_float.cpp	/^void test_trigonometric_functions()$/;"	f
test_trivial_reductions	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_trivial_reductions() {$/;"	f	file:
test_type2index_list	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_type2index_list()$/;"	f	file:
test_type2indexpair_list	unsupported/test/cxx11_tensor_index_list.cpp	/^static void test_type2indexpair_list()$/;"	f	file:
test_type_casting	unsupported/test/cxx11_tensor_expr.cpp	/^static void test_type_casting()$/;"	f	file:
test_umeyama	test/umeyama.cpp	/^void test_umeyama()$/;"	f
test_umfpack_support	test/umfpack_support.cpp	/^void test_umfpack_support()$/;"	f
test_umfpack_support_T	test/umfpack_support.cpp	/^template<typename T> void test_umfpack_support_T()$/;"	f
test_unalignedassert	test/unalignedassert.cpp	/^void test_unalignedassert()$/;"	f
test_unalignedcount	test/unalignedcount.cpp	/^void test_unalignedcount()$/;"	f
test_unsigned_32bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_unsigned_32bit()$/;"	f
test_unsigned_64bit	unsupported/test/cxx11_tensor_intdiv.cpp	/^void test_unsigned_64bit()$/;"	f
test_upperbidiagonalization	test/upperbidiagonalization.cpp	/^void test_upperbidiagonalization()$/;"	f
test_user_defined_reductions	unsupported/test/cxx11_tensor_reduction.cpp	/^static void test_user_defined_reductions() {$/;"	f	file:
test_varlist_as_index	unsupported/test/cxx11_tensor_custom_index.cpp	/^static void test_varlist_as_index()$/;"	f	file:
test_vectorization_logic	test/vectorization_logic.cpp	/^void test_vectorization_logic()$/;"	f
test_vectorized_broadcasting	unsupported/test/cxx11_tensor_broadcasting.cpp	/^static void test_vectorized_broadcasting()$/;"	f	file:
test_vectorized_cast	unsupported/test/cxx11_tensor_casts.cpp	/^static void test_vectorized_cast()$/;"	f	file:
test_vectorwiseop	test/vectorwiseop.cpp	/^void test_vectorwiseop()$/;"	f
test_visitor	test/visitor.cpp	/^void test_visitor()$/;"	f
test_zerosized	test/nomalloc.cpp	/^void test_zerosized() {$/;"	f
test_zerosized	test/zerosized.cpp	/^void test_zerosized()$/;"	f
testing	bench/tensors/benchmark.h	/^namespace testing {$/;"	n
testing	bench/tensors/benchmark_main.cc	/^namespace testing {$/;"	n	file:
tgamma	unsupported/test/mpreal/mpreal.h	/^inline const mpreal tgamma  (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(gamma  );    }$/;"	f	namespace:mpfr
thenExpr	unsupported/Eigen/CXX11/src/Tensor/TensorSyclExtractFunctors.h	/^  FunctorExtractor<TensorEvaluator<ThenExpr, Dev> > thenExpr;$/;"	m	struct:Eigen::TensorSycl::internal::FunctorExtractor
thenExpression	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^    const ThenXprType& thenExpression() const { return m_then; }$/;"	f	class:Eigen::TensorSelectOp
thenMatrix	Eigen/src/Core/Select.h	/^    inline EIGEN_DEVICE_FUNC const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select
then_impl	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  const TensorEvaluator<ThenArgType, Device>& then_impl() const { return m_thenImpl; }$/;"	f	struct:Eigen::TensorEvaluator
thickness	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    IndexType thickness ; \/* number of original columns represented by this *\/$/;"	m	union:internal::colamd_col::__anon868
thinQ	doc/snippets/HouseholderQR_householderQ.cpp	/^std::cout << "The thin matrix Q is:\\n" << thinQ << "\\n\\n";$/;"	v
thr_	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^    std::thread thr_;$/;"	m	class:Eigen::StlThreadEnvironment::EnvThread
threadIdx	test/cuda_common.h	/^dim3 threadIdx, blockDim, blockIdx;$/;"	v
thread_id	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^    int thread_id;  \/\/ Worker thread index in pool.$/;"	m	struct:Eigen::NonBlockingThreadPoolTempl::PerThread
thread_id	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^    int thread_id;                \/\/ Worker thread index in pool.$/;"	m	struct:Eigen::SimpleThreadPoolTempl::PerThread
threadcount	demos/mandelbrot/mandelbrot.h	/^    int threadcount;$/;"	m	class:MandelbrotWidget
threads	demos/mandelbrot/mandelbrot.h	/^    MandelbrotThread **threads;$/;"	m	class:MandelbrotWidget
threads_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  MaxSizeVector<Thread*> threads_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
threads_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  MaxSizeVector<Thread*> threads_;  \/\/ All threads$/;"	m	class:Eigen::SimpleThreadPoolTempl
threshold	Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU
threshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR
threshold	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  RealScalar threshold() const { return m_cpqr.threshold(); }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
threshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR
threshold	Eigen/src/SVD/SVDBase.h	/^  RealScalar threshold() const$/;"	f	class:Eigen::SVDBase
threshold_	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  Index threshold_;$/;"	m	struct:Eigen::__anon91::MemcpyTriggerForSlicing
throw_std_bad_alloc	Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal
thurber_functor	unsupported/test/NonLinearOptimization.cpp	/^    thurber_functor(void) : Functor<double>(7,37) {}$/;"	f	struct:thurber_functor
thurber_functor	unsupported/test/NonLinearOptimization.cpp	/^struct thurber_functor : Functor<double>$/;"	s	file:
thurber_functor	unsupported/test/levenberg_marquardt.cpp	/^    thurber_functor(void) : DenseFunctor<double>(7,37) {}$/;"	f	struct:thurber_functor
thurber_functor	unsupported/test/levenberg_marquardt.cpp	/^struct thurber_functor : DenseFunctor<double>$/;"	s	file:
time_calculate	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  BTL_DONT_INLINE double time_calculate(Action & action)$/;"	f	class:Portable_Perf_Analyzer
time_calculate	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  inline double time_calculate(Action & action)$/;"	f	class:Portable_Perf_Analyzer
time_init	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  inline double time_init(Action & action)$/;"	f	class:Portable_Perf_Analyzer
timer	bench/benchmark-blocking-sizes.cpp	/^static BenchTimer timer;$/;"	v	file:
times2_op	unsupported/test/cxx11_meta.cpp	/^struct times2_op { template<typename A> static A run(A v) { return v * 2; } };$/;"	s	file:
tindices	demos/opengl/icosphere.cpp	/^static GLint tindices[20][3] = {$/;"	v	file:
tiny_blitz_interface	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^class tiny_blitz_interface$/;"	c
tinyness_before	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool tinyness_before = false;$/;"	m	struct:std::numeric_limits
tinyness_before	unsupported/test/mpreal/mpreal.h	/^        static const bool tinyness_before   = true;$/;"	m	class:std::numeric_limits
tmp1	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp1 = indices_statically_known_to_increase<ReducedDims>();$/;"	m	struct:Eigen::internal::are_inner_most_dims
tmp1	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp1 = indices_statically_known_to_increase<ReducedDims>();$/;"	m	struct:Eigen::internal::preserve_inner_most_dims
tmp2	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp2 = index_statically_eq<ReducedDims>(0, 0);$/;"	m	struct:Eigen::internal::are_inner_most_dims
tmp2	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp2 = index_statically_eq<ReducedDims>(0, NumTensorDims - array_size<ReducedDims>::value);$/;"	m	struct:Eigen::internal::are_inner_most_dims
tmp2	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp2 = index_statically_gt<ReducedDims>(0, 0);$/;"	m	struct:Eigen::internal::preserve_inner_most_dims
tmp2	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp2 = index_statically_lt<ReducedDims>(array_size<ReducedDims>::value - 1, NumTensorDims - 1);$/;"	m	struct:Eigen::internal::preserve_inner_most_dims
tmp3	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp3 = index_statically_eq<ReducedDims>(array_size<ReducedDims>::value - 1, NumTensorDims - 1);$/;"	m	struct:Eigen::internal::are_inner_most_dims
tmp3	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool tmp3 = index_statically_eq<ReducedDims>(array_size<ReducedDims>::value-1, array_size<ReducedDims>::value-1);$/;"	m	struct:Eigen::internal::are_inner_most_dims
toBool	unsupported/test/mpreal/mpreal.h	/^inline bool               mpreal::toBool   (             )  const    {    return  mpfr_zero_p (mpfr_srcptr()) == 0;     }$/;"	f	class:mpfr::mpreal
toDense	Eigen/src/SparseCore/SparseMatrixBase.h	/^    DenseMatrixType toDense() const$/;"	f	class:Eigen::SparseMatrixBase
toDense	unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime> toDense() const {$/;"	f	class:Eigen::SkylineMatrixBase
toDenseMatrix	Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase
toDenseMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase
toDenseMatrix	Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::InverseImpl
toDenseMatrix	Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase
toDenseMatrix	Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase
toDouble	unsupported/test/mpreal/mpreal.h	/^inline double             mpreal::toDouble (mp_rnd_t mode)  const    {    return  mpfr_get_d  (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toFloat	unsupported/test/mpreal/mpreal.h	/^inline float              mpreal::toFloat  (mp_rnd_t mode)  const    {    return  mpfr_get_flt(mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLDouble	unsupported/test/mpreal/mpreal.h	/^inline long double        mpreal::toLDouble(mp_rnd_t mode)  const    {    return  mpfr_get_ld (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLLong	unsupported/test/mpreal/mpreal.h	/^inline long long          mpreal::toLLong  (mp_rnd_t mode)  const    {    return  mpfr_get_sj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLong	unsupported/test/mpreal/mpreal.h	/^inline long               mpreal::toLong   (mp_rnd_t mode)  const    {    return  mpfr_get_si (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toLowerCase	bench/btl/generic_bench/btl.hh	/^    BtlString toLowerCase( void )$/;"	f	class:BtlString
toQMatrix	Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQTransform	Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toRotationMatrix	Eigen/src/Geometry/AngleAxis.h	/^EIGEN_DEVICE_FUNC AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase
toRotationMatrix	Eigen/src/Geometry/Rotation2D.h	/^EIGEN_DEVICE_FUNC Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^    EIGEN_DEVICE_FUNC inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^EIGEN_DEVICE_FUNC static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal
toRotationMatrix	demos/opengl/quaternion_demo.cpp	/^  Matrix3 toRotationMatrix(void) const$/;"	f	class:EulerAngles
toRotationMatrix	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^      Matrix3 toRotationMatrix() const$/;"	f	class:Eigen::EulerAngles
toString	unsupported/test/mpreal/mpreal.h	/^inline std::string mpreal::toString(const std::string& format) const$/;"	f	class:mpfr::mpreal
toString	unsupported/test/mpreal/mpreal.h	/^inline std::string mpreal::toString(int n, int b, mp_rnd_t mode) const$/;"	f	class:mpfr::mpreal
toString	unsupported/test/mpreal/mpreal.h	/^inline std::string toString(T t, std::ios_base & (*f)(std::ios_base&))$/;"	f	namespace:mpfr
toULLong	unsupported/test/mpreal/mpreal.h	/^inline unsigned long long mpreal::toULLong (mp_rnd_t mode)  const    {    return  mpfr_get_uj (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toULong	unsupported/test/mpreal/mpreal.h	/^inline unsigned long      mpreal::toULong  (mp_rnd_t mode)  const    {    return  mpfr_get_ui (mpfr_srcptr(), mode);    }$/;"	f	class:mpfr::mpreal
toUpperCase	bench/btl/generic_bench/btl.hh	/^    BtlString toUpperCase( void )$/;"	f	class:BtlString
to_string	debug/gdb/printers.py	/^	def to_string(self):$/;"	m	class:EigenMatrixPrinter
to_string	debug/gdb/printers.py	/^	def to_string(self):$/;"	m	class:EigenQuaternionPrinter
tolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase
topLeft2x2Corner	doc/examples/class_FixedBlock.cpp	/^topLeft2x2Corner(MatrixBase<Derived>& m)$/;"	f
topLeft2x2Corner	doc/examples/class_FixedBlock.cpp	/^topLeft2x2Corner(const MatrixBase<Derived>& m)$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr topLeftCorner(Index cRows, Index cCols) const$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topLeftCorner() const$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topLeftCorner(Index cRows, Index cCols) const$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topLeftCorner()$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	doc/examples/class_Block.cpp	/^topLeftCorner(MatrixBase<Derived>& m, int rows, int cols)$/;"	f
topLeftCorner	doc/examples/class_Block.cpp	/^topLeftCorner(const MatrixBase<Derived>& m, int rows, int cols)$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline BlockXpr topRightCorner(Index cRows, Index cCols)$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const ConstBlockXpr topRightCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topRightCorner() const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const typename ConstFixedBlockXpr<CRows,CCols>::Type topRightCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topRightCorner()$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedBlockXpr<CRows,CCols>::Type topRightCorner(Index cRows, Index cCols)$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows(Index n = N) const$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows(Index n = N)$/;"	f
total	bench/BenchTimer.h	/^  inline double total(int TIMER = CPU_TIMER) const$/;"	f	class:Eigen::BenchTimer
totalCost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double totalCost($/;"	f	class:Eigen::TensorCostModel
total_cost	unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE double total_cost($/;"	f	class:Eigen::TensorOpCost
total_iter	demos/mandelbrot/mandelbrot.h	/^    long long total_iter;$/;"	m	class:MandelbrotThread
total_size	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static const std::ptrdiff_t total_size = internal::arg_prod(Indices...);$/;"	m	struct:Eigen::Sizes
tpmv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(tpmv)(char *uplo, char *opa, char *diag, int *n, RealScalar *pap, RealScalar *px, int *incx)$/;"	f
tpsv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(tpsv)(char *uplo, char *opa, char *diag, int *n, RealScalar *pap, RealScalar *px, int *incx)$/;"	f
trace	Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase
track	demos/opengl/trackball.cpp	/^void Trackball::track(const Vector2i& point2D)$/;"	f	class:Trackball
traits	Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CoreEvaluators.h	/^struct traits<EvalToTemp<ArgType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseTernaryOp.h	/^struct traits<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > {$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Inverse.h	/^struct traits<Inverse<XprType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Product.h	/^struct traits<Product<Lhs, Rhs, Option> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Ref.h	/^struct traits<Ref<_PlainObjectType, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Ref.h	/^struct traits<RefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Solve.h	/^struct traits<Solve<Decomposition, RhsType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : public traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<Transpose<TranspositionsBase<Derived> > >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,_StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Transform.h	/^struct traits<Transform<_Scalar,_Dim,_Mode,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^struct traits<LeastSquaresConjugateGradient<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/SolveWithGuess.h	/^struct traits<SolveWithGuess<Decomposition, RhsType, GuessType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> struct traits<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> struct traits<PartialPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> struct traits<ColPivHouseholderQR<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^struct traits<CompleteOrthogonalDecomposition<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> struct traits<FullPivHouseholderQR<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType, typename Derived> struct traits<SPQR_QProduct<SPQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQTransposeReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SVD/BDCSVD.h	/^struct traits<BDCSVD<_MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SVD/JacobiSVD.h	/^struct traits<JacobiSVD<_MatrixType,QRPreconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _StorageIndex> > : traits<SparseMatrix<_Scalar, _Flags, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseCompressedBase.h	/^struct traits<SparseCompressedBase<Derived> > : traits<Derived>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMap.h	/^struct traits<Map<SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMap.h	/^struct traits<Map<const SparseMatrix<MatScalar,MatOptions,MatIndex>, Options, StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<SparseMatrix<_Scalar, _Options, _StorageIndex>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _StorageIndex>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<SparseMatrix<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<SparseVector<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<const SparseMatrix<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseRef.h	/^struct traits<Ref<const SparseVector<MatScalar,MatOptions,MatIndex>, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseRef.h	/^struct traits<SparseRefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,Mode> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,Mode> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _StorageIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType, typename Derived> struct traits<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQTransposeReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	doc/examples/matrixfree_cg.cpp	/^  struct traits<MatrixReplacement> :  public Eigen::internal::traits<Eigen::SparseMatrix<double> >$/;"	s	namespace:Eigen::internal	file:
traits	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct traits<TensorIndexTupleOp<XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^struct traits<TensorTupleReducerOp<ReduceOp, Dims, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^struct traits<TensorAssignOp<LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^struct traits<TensorBroadcastingOp<Broadcast, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^struct traits<TensorChippingOp<DimId, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^struct traits<TensorConcatenationOp<Axis, LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct traits<TensorContractionOp<Dimensions, LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^struct traits<TensorEvaluator<const TensorContractionOp<Indices_, LeftArgType_, RightArgType_>, Device_> > {$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^struct traits<TensorConversionOp<TargetType, XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^struct traits<TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct traits<TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^struct traits<TensorCustomUnaryOp<CustomUnaryFunc, XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^struct traits<TensorEvalToOp<XprType, MakePointer_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct traits<TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct traits<TensorCwiseNullaryOp<NullaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct traits<TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct traits<TensorCwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^struct traits<TensorSelectOp<IfXprType, ThenXprType, ElseXprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^struct traits<TensorFFTOp<FFT, XprType, FFTResultType, FFTDir> > : public traits<XprType> {$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^struct traits<TensorForcedEvalOp<XprType, MakePointer_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^struct traits<TensorGeneratorOp<Generator, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^struct traits<TensorImagePatchOp<Rows, Cols, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^struct traits<TensorInflationOp<Strides, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^struct traits<TensorLayoutSwapOp<XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct traits<TensorReshapingOp<NewDimensions, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct traits<TensorSlicingOp<StartIndices, Sizes, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^struct traits<TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^struct traits<TensorPaddingOp<PaddingDimensions, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^struct traits<TensorPatchOp<PatchDim, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  struct traits<TensorReductionOp<Op, Dims, XprType, MakePointer_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^struct traits<TensorReverseOp<ReverseDimensions,$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^struct traits<TensorScanOp<Op, XprType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^struct traits<TensorShufflingOp<Shuffle, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^struct traits<TensorStridingOp<Strides, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct traits<Tensor<Scalar_, NumIndices_, Options_, IndexType_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct traits<TensorFixedSize<Scalar_, Dimensions, Options_, IndexType_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct traits<TensorMap<PlainObjectType, Options_, MakePointer_> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^struct traits<TensorRef<PlainObjectType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^struct traits<TensorVolumePatchOp<Planes, Rows, Cols, XprType> > : public traits<XprType>$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/EulerAngles/EulerAngles.h	/^    struct traits<EulerAngles<_Scalar, _System> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^struct traits<DGMRES<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^struct traits<GMRES<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        struct traits<MINRES<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^struct traits<KroneckerProduct<_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^struct traits<KroneckerProductSparse<_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct traits<MatrixExponentialReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^struct traits<MatrixFunctionReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  struct traits<MatrixLogarithmReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^struct traits< MatrixComplexPowerReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^struct traits< MatrixPowerParenthesesReturnValue<MatrixPowerType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixPower.h	/^struct traits< MatrixPowerReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^struct traits<MatrixSquareRootReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^struct traits<SkylineMatrix<_Scalar, _Options> > {$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct internal::traits<SkylineProduct<LhsNested, RhsNested, ProductMode> > {$/;"	s	class:Eigen::internal
traits	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^struct traits<BlockSparseMatrix<_Scalar,_BlockAtCompileTime,_Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^struct traits<BlockSparseMatrixView<BlockSparseMatrixT> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^struct traits<BlockSparseTimeDenseProduct<BlockSparseMatrixT, VecType> >$/;"	s	namespace:Eigen::internal
traits	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^struct traits<DynamicSparseMatrix<_Scalar, _Options, _StorageIndex> >$/;"	s	namespace:Eigen::internal
trans	Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence
trans	bench/bench_gemm.cpp	/^static char trans = 'T';  $/;"	v	file:
trans	bench/btl/libs/BLAS/blas_interface.hh	/^static char trans = 'T';$/;"	v
transcendentalFunc	bench/tensors/tensor_benchmarks.h	/^  void transcendentalFunc(int num_iters) {$/;"	f	class:BenchmarkSuite
transform	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane
transform	bench/geometry.cpp	/^EIGEN_DONT_INLINE void transform(const Quaternion<Scalar>& t, Data& data)$/;"	f
transform	bench/geometry.cpp	/^EIGEN_DONT_INLINE void transform(const ToRotationMatrixWrapper<QType>& t, Data& data)$/;"	f
transform	bench/geometry.cpp	/^EIGEN_DONT_INLINE void transform(const Transform<Scalar,Dim,Projective>& t, Data& data)$/;"	f
transform	bench/geometry.cpp	/^EIGEN_DONT_INLINE void transform(const Transformation& t, Data& data)$/;"	f
transform_alignment	test/geo_transformations.cpp	/^template<typename Scalar> void transform_alignment()$/;"	f
transform_associativity	test/geo_transformations.cpp	/^void transform_associativity(const RotationType& R)$/;"	f
transform_associativity2	test/geo_transformations.cpp	/^void transform_associativity2(const A1& a1, const A2& a2, const P& p, const Q& q, const V& v, const H& h)$/;"	f
transform_associativity_left	test/geo_transformations.cpp	/^void transform_associativity_left(const A1& a1, const A2& a2, const P& p, const Q& q, const V& v, const H& h)$/;"	f
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_make_affine	Eigen/src/Geometry/Transform.h	/^struct transform_make_affine$/;"	s	namespace:Eigen::internal
transform_make_affine	Eigen/src/Geometry/Transform.h	/^struct transform_make_affine<AffineCompact>$/;"	s	namespace:Eigen::internal
transform_product_result	Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_products	test/geo_transformations.cpp	/^template<typename Scalar, int Dim, int Options> void transform_products()$/;"	f
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0, RhsCols>$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1, RhsCols>$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2, 1> \/\/ rhs is a vector of size Dim$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2, RhsCols>$/;"	s	namespace:Eigen::internal
transform_take_affine_part	Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
transform_traits	Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transformations	test/geo_transformations.cpp	/^template<typename Scalar, int Mode, int Options> void transformations()$/;"	f
translate	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox
translate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation
translation	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
translationExt	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform
translationExt	Eigen/src/Geometry/Transform.h	/^  EIGEN_DEVICE_FUNC inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform
transpose	Eigen/src/Core/PermutationMatrix.h	/^    inline InverseReturnType transpose() const$/;"	f	class:Eigen::PermutationBase
transpose	Eigen/src/Core/SelfAdjointView.h	/^    inline TransposeReturnType transpose()$/;"	f	class:Eigen::SelfAdjointView
transpose	Eigen/src/Core/SelfAdjointView.h	/^    inline const ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::SelfAdjointView
transpose	Eigen/src/Core/SolverBase.h	/^    inline ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::SolverBase
transpose	Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase
transpose	Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase
transpose	Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase
transpose	Eigen/src/Core/TriangularMatrix.h	/^    inline TransposeReturnType transpose()$/;"	f	class:Eigen::TriangularView
transpose	Eigen/src/Core/TriangularMatrix.h	/^    inline const ConstTransposeReturnType transpose() const$/;"	f	class:Eigen::TriangularView
transpose	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence
transpose	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation
transpose	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> transpose() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
transpose	Eigen/src/SparseCore/SparseMatrixBase.h	/^    TransposeReturnType transpose() { return TransposeReturnType(derived()); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	Eigen/src/SparseCore/SparseMatrixBase.h	/^    const ConstTransposeReturnType transpose() const { return ConstTransposeReturnType(derived()); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> transpose() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
transposeInPlace	Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase
transposed_matrix_matrix_product	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void transposed_matrix_matrix_product(gene_matrix & A, gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:blas_interface
transposed_matrix_matrix_product	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void transposed_matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:blaze_interface
transposed_matrix_matrix_product	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void transposed_matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:eigen2_interface
transposed_matrix_matrix_product	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void transposed_matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int  \/*N*\/){$/;"	f	class:eigen3_interface
transposed_matrix_matrix_product	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void transposed_matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:gmm_interface
transposed_matrix_matrix_product	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void transposed_matrix_matrix_product(const gene_matrix & A, const gene_matrix & B, gene_matrix & X, int N){$/;"	f	class:mtl4_interface
transposition_matrix_product	Eigen/src/Core/ProductEvaluators.h	/^struct transposition_matrix_product$/;"	s	namespace:Eigen::internal
transpositionsP	Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT
traps	Eigen/src/Core/arch/CUDA/Half.h	/^  static const bool traps = true;$/;"	m	struct:std::numeric_limits
traps	unsupported/test/mpreal/mpreal.h	/^        static const bool traps             = true;$/;"	m	class:std::numeric_limits
treePostorder	Eigen/src/SparseCore/SparseColEtree.h	/^void treePostorder(typename IndexVector::Scalar n, IndexVector& parent, IndexVector& post)$/;"	f	namespace:Eigen::internal
tri	doc/snippets/Tridiagonalization_compute.cpp	/^Tridiagonalization<MatrixXf> tri;$/;"	v
triangularView	Eigen/src/Core/SelfAdjointView.h	/^    triangularView() const$/;"	f	class:Eigen::SelfAdjointView
triangularView	Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase
triangularView	Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase
triangularView	Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase
triangular_assignment_loop	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop$/;"	s	namespace:Eigen::internal
triangular_assignment_loop	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop<Kernel, Mode, 0, SetOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_loop	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_loop<Kernel, Mode, Dynamic, SetOpposite>$/;"	s	namespace:Eigen::internal
triangular_dense_assignment_kernel	Eigen/src/Core/SelfAdjointView.h	/^  EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
triangular_dense_assignment_kernel	Eigen/src/Core/SelfAdjointView.h	/^class triangular_dense_assignment_kernel<UpLo,SelfAdjoint,SetOpposite,DstEvaluatorTypeT,SrcEvaluatorTypeT,Functor,Version>$/;"	c	namespace:Eigen::internal
triangular_dense_assignment_kernel	Eigen/src/Core/TriangularMatrix.h	/^  EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)$/;"	f	class:Eigen::internal::triangular_dense_assignment_kernel
triangular_dense_assignment_kernel	Eigen/src/Core/TriangularMatrix.h	/^class triangular_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version>$/;"	c	namespace:Eigen::internal
triangular_matrix_vector_product	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	Eigen/src/Core/products/TriangularMatrixVector_BLAS.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal
triangular_product_impl	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct triangular_product_impl<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen::internal
triangular_product_impl	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_product_impl<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen::internal
triangular_product_impl	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_product_impl<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen::internal
triangular_rect	test/triangular.cpp	/^template<typename MatrixType> void triangular_rect(const MatrixType& m)$/;"	f
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval
triangular_solve_retval	Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,true> {$/;"	s	namespace:Eigen::internal
triangular_square	test/triangular.cpp	/^template<typename MatrixType> void triangular_square(const MatrixType& m)$/;"	f
triassign	bench/btl/libs/eigen3/eigen3_interface.hh	/^  template<typename Dest, typename Src> static void triassign(Dest& dst, const Src& src)$/;"	f	class:eigen3_interface
tribb_kernel	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
tridiagonal_qr_step	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal
tridiagonalization	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void tridiagonalization(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:blas_interface
tridiagonalization	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void tridiagonalization(const gene_matrix & X, gene_matrix & C, int N){$/;"	f	class:eigen2_interface
tridiagonalization	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void tridiagonalization(const gene_matrix & X, gene_matrix & C, int  N){$/;"	f	class:eigen3_interface
tridiagonalization	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void tridiagonalization(const gene_matrix & X, gene_matrix & R, int N){$/;"	f	class:gmm_interface
tridiagonalization_inplace	Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
tries	bench/btl/generic_bench/btl.hh	/^  int tries;$/;"	m	class:BtlConfig
triggerMatrixBadAlloc	test/sizeoverflow.cpp	/^void triggerMatrixBadAlloc(Index rows, Index cols)$/;"	f
triggerVectorBadAlloc	test/sizeoverflow.cpp	/^void triggerVectorBadAlloc(Index size)$/;"	f
trim	bench/btl/generic_bench/btl.hh	/^    void trim( bool left = true, bool right = true )$/;"	f	class:BtlString
trisolve_lower	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector & X, int N){$/;"	f	class:blas_interface
trisolve_lower	bench/btl/libs/STL/STL_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector & B, gene_vector & X, int N){$/;"	f	class:STL_interface
trisolve_lower	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector& X, int N){$/;"	f	class:eigen2_interface
trisolve_lower	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector& X, int  \/*N*\/){$/;"	f	class:eigen3_interface
trisolve_lower	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector & X, int N){$/;"	f	class:gmm_interface
trisolve_lower	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector & X, int N){$/;"	f	class:mtl4_interface
trisolve_lower	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void trisolve_lower(const gene_matrix & L, const gene_vector& B, gene_vector & X, int N){$/;"	f	class:ublas_interface
trisolve_lower_matrix	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void trisolve_lower_matrix(const gene_matrix & L, const gene_matrix& B, gene_matrix & X, int N){$/;"	f	class:blas_interface
trisolve_lower_matrix	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static inline void trisolve_lower_matrix(const gene_matrix & L, const gene_matrix& B, gene_matrix& X, int N){$/;"	f	class:eigen2_interface
trisolve_lower_matrix	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void trisolve_lower_matrix(const gene_matrix & L, const gene_matrix& B, gene_matrix& X, int  \/*N*\/){$/;"	f	class:eigen3_interface
trmm	bench/btl/libs/BLAS/blas_interface_impl.hh	/^  static inline void trmm(gene_matrix & A, gene_matrix & B, gene_matrix & \/*X*\/, int N){$/;"	f	class:blas_interface
trmm	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static inline void trmm(const gene_matrix & L, const gene_matrix& B, gene_matrix& X, int  \/*N*\/){$/;"	f	class:eigen3_interface
trmm	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(trmm)(const char *side, const char *uplo, const char *opa, const char *diag, const int *m, const int *n,$/;"	f
trmm	test/product_trmm.cpp	/^void trmm(int rows=get_random_size<Scalar>(), int cols=get_random_size<Scalar>(), int otherCols = get_random_size<Scalar>())$/;"	f
trmm	test/product_trmm.cpp	/^void trmm(int rows=get_random_size<Scalar>(),$/;"	f
trmv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(trmv)(const char *uplo, const char *opa, const char *diag, const int *n, const RealScalar *pa, const int *lda, RealScalar *pb, const int *incb)$/;"	f
trmv	test/product_trmm.cpp	/^void trmv(int rows=get_random_size<Scalar>(), int cols=get_random_size<Scalar>())$/;"	f
trmv	test/product_trmv.cpp	/^template<typename MatrixType> void trmv(const MatrixType& m)$/;"	f
trmv_selector	Eigen/src/Core/products/TriangularMatrixVector.h	/^template<int Mode> struct trmv_selector<Mode,ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	Eigen/src/Core/products/TriangularMatrixVector.h	/^template<int Mode> struct trmv_selector<Mode,RowMajor>$/;"	s	namespace:Eigen::internal
trsm	blas/level3_impl.h	/^int EIGEN_BLAS_FUNC(trsm)(const char *side, const char *uplo, const char *opa, const char *diag, const int *m, const int *n,$/;"	f
trsolve	test/product_trsolve.cpp	/^template<typename Scalar,int Size, int Cols> void trsolve(int size=Size,int cols=Cols)$/;"	f
trsolve_traits	Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
trsv	blas/level2_impl.h	/^int EIGEN_BLAS_FUNC(trsv)(const char *uplo, const char *opa, const char *diag, const int *n, const RealScalar *pa, const int *lda, RealScalar *pb, const int *incb)$/;"	f
true_type	Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
trunc	unsupported/test/mpreal/mpreal.h	/^inline const mpreal trunc(const mpreal& v)$/;"	f	namespace:mpfr
tuple	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^namespace tuple {$/;"	n	namespace:utility
tuple_coeff	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct tuple_coeff {$/;"	s	namespace:Eigen::internal
tuple_coeff	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct tuple_coeff<0, ValueT> {$/;"	s	namespace:Eigen::internal
tvmet_interface	bench/btl/libs/tvmet/tvmet_interface.hh	/^class tvmet_interface{$/;"	c
twistedBy	Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm) const$/;"	f	class:Eigen::SparseMatrixBase
twistedBy	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,Mode> twistedBy(const PermutationMatrix<Dynamic,Dynamic,StorageIndex>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView
two	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^      int two;$/;"	m	struct:Eigen::DynamicSGroup::Generator
two_demos	unsupported/doc/examples/FFT.cpp	/^void two_demos(int nfft)$/;"	f
twopassNorm	bench/bench_norm.cpp	/^EIGEN_DONT_INLINE typename T::Scalar twopassNorm(T& v)$/;"	f
type	Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic
type	Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::log1p_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::round_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::arg_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void
type	Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType
type	Eigen/src/Core/Ref.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match
type	Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested_eval
type	Eigen/src/Core/SolverBase.h	/^  typedef SolverBase<Derived> type;$/;"	t	struct:Eigen::internal::generic_xpr_base
type	Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base
type	Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet2cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX/Complex.h	/^  typedef Packet4cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet4d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX/PacketMath.h	/^  typedef Packet8f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet16f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef Packet8d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef double type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef float type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  typedef int type;$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef double2 type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/CUDA/PacketMath.h	/^  typedef float4 type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^  typedef half2 type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/ZVector/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/functors/BinaryFunctors.h	/^  typedef bool type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function
type	Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^    typedef typename ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^  typedef typename remove_all<type1>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional
type	Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional
type	Eigen/src/Core/util/Meta.h	/^struct ternary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const
type	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<char>             { typedef unsigned char type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed __int64>   { typedef unsigned __int64 type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed char>      { typedef unsigned char type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed int>       { typedef unsigned int type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed long>      { typedef unsigned long type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<signed short>     { typedef unsigned short type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned __int64> { typedef unsigned __int64 type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned char>    { typedef unsigned char type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned int>     { typedef unsigned int type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned long>    { typedef unsigned long type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<> struct make_unsigned<unsigned short>   { typedef unsigned short type; };$/;"	t	struct:Eigen::internal::make_unsigned
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1,ArgType2)>::type type;};$/;"	t	struct:Eigen::internal::ternary_result_of_select
type	Eigen/src/Core/util/XprHelper.h	/^  typedef PromotedType type;$/;"	t	struct:Eigen::internal::promote_scalar_arg_unsupported
type	Eigen/src/Core/util/XprHelper.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::promote_scalar_arg
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type
type	Eigen/src/LU/PartialPivLU.h	/^  typedef Derived type;$/;"	t	struct:Eigen::internal::enable_if_ref
type	Eigen/src/SparseCore/SparseRef.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _StorageIndex> type;$/;"	t	struct:Eigen::internal::plain_matrix_type
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, ColMajor, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, RowMajor, _StorageIndex> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^  typedef SparseMatrixBase<Derived> type;$/;"	t	struct:Eigen::internal::generic_xpr_base
type	Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,SelfAdjointShape> { typedef SparseSelfAdjointShape type;  };$/;"	t	struct:Eigen::internal::glue_shapes
type	Eigen/src/SparseCore/SparseUtil.h	/^template<> struct glue_shapes<SparseShape,TriangularShape > { typedef SparseTriangularShape  type;  };$/;"	t	struct:Eigen::internal::glue_shapes
type	bench/analyze-blocking-sizes.cpp	/^  type_t type;$/;"	m	struct:inputfile_t	file:
type	test/main.h	/^template<> struct GetDifferentType<double> { typedef float type; };$/;"	t	struct:GetDifferentType
type	test/main.h	/^template<> struct GetDifferentType<float> { typedef double type; };$/;"	t	struct:GetDifferentType
type	test/main.h	/^{ typedef std::complex<typename GetDifferentType<T>::type> type; };$/;"	t	struct:GetDifferentType
type	test/swap.cpp	/^  typedef Matrix<_Scalar, _Rows, _Cols, _Options^RowMajor, _MaxRows, _MaxCols> type;$/;"	t	struct:other_matrix_type	file:
type	test/swap.cpp	/^  typedef int type;$/;"	t	struct:other_matrix_type	file:
type	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef TensorIndexTupleOp<XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef TensorTupleReducerOp<ReduceOp, Dims, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef const TensorIndexTupleOp<XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorArgMax.h	/^  typedef const TensorTupleReducerOp<ReduceOp, Dims, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef TensorAssignOp<LhsXprType, RhsXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorAssign.h	/^  typedef const TensorAssignOp<LhsXprType, RhsXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef TensorBroadcastingOp<Broadcast, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  typedef const TensorBroadcastingOp<Broadcast, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef TensorChippingOp<DimId, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  typedef const TensorChippingOp<DimId, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef TensorConcatenationOp<Axis, LhsXprType, RhsXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  typedef const TensorConcatenationOp<Axis, LhsXprType, RhsXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef TensorContractionOp<Dimensions, LhsXprType, RhsXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorContraction.h	/^  typedef const TensorContractionOp<Dimensions, LhsXprType, RhsXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef TensorConversionOp<TargetType, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorConversion.h	/^  typedef const TensorConversionOp<TargetType, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef TensorConvolutionOp<Dimensions, InputXprType, KernelXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorConvolution.h	/^  typedef const TensorConvolutionOp<Dimensions, InputXprType, KernelXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef TensorCustomUnaryOp<CustomUnaryFunc, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef const TensorCustomBinaryOp<CustomBinaryFunc, LhsXprType, RhsXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorCustomOp.h	/^  typedef const TensorCustomUnaryOp<CustomUnaryFunc, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef TensorEvalToOp<XprType, MakePointer_> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  typedef const TensorEvalToOp<XprType, MakePointer_>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef TensorCwiseUnaryOp<UnaryOp, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef TensorSelectOp<IfXprType, ThenXprType, ElseXprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef const TensorCwiseBinaryOp<BinaryOp, LhsXprType, RhsXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef const TensorCwiseTernaryOp<TernaryOp, Arg1XprType, Arg2XprType, Arg3XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef const TensorCwiseUnaryOp<UnaryOp, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorExpr.h	/^  typedef const TensorSelectOp<IfXprType, ThenXprType, ElseXprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h	/^  typedef const TensorFFTOp<FFT, XprType, FFTResultType, FFTDirection>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef TensorForcedEvalOp<XprType, MakePointer_> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorForcedEval.h	/^  typedef const TensorForcedEvalOp<XprType, MakePointer_>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef TensorGeneratorOp<Generator, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorGenerator.h	/^  typedef const TensorGeneratorOp<Generator, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef TensorImagePatchOp<Rows, Cols, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  typedef const TensorImagePatchOp<Rows, Cols, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef TensorInflationOp<Strides, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorInflation.h	/^  typedef const TensorInflationOp<Strides, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^    typedef typename UnsignedTraits<T>::type type;$/;"	t	struct:Eigen::internal::__anon139::DividerTraits
type	unsupported/Eigen/CXX11/src/Tensor/TensorIntDiv.h	/^    typedef typename conditional<sizeof(T) == 8, uint64_t, uint32_t>::type type;$/;"	t	struct:Eigen::internal::__anon139::UnsignedTraits
type	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef TensorLayoutSwapOp<XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  typedef const TensorLayoutSwapOp<XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  typedef T type;$/;"	t	struct:Eigen::PacketType
type	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  typedef half2 type;$/;"	t	struct:Eigen::PacketType
type	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^  typedef typename internal::packet_traits<Scalar>::type type;$/;"	t	struct:Eigen::PacketType
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorReshapingOp<NewDimensions, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorSlicingOp<StartIndices, Sizes, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef const TensorReshapingOp<NewDimensions, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef const TensorSlicingOp<StartIndices, Sizes, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  typedef const TensorStridingSlicingOp<StartIndices, StopIndices, Strides, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef TensorPaddingOp<PaddingDimensions, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  typedef const TensorPaddingOp<PaddingDimensions, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef TensorPatchOp<PatchDim, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorPatch.h	/^  typedef const TensorPatchOp<PatchDim, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef TensorReductionOp<Op, Dims, XprType, MakePointer_> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  typedef const TensorReductionOp<Op, Dims, XprType, MakePointer_>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef TensorReverseOp<ReverseDimensions, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  typedef const TensorReverseOp<ReverseDimensions, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef TensorScanOp<Op, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorScan.h	/^  typedef const TensorScanOp<Op, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef TensorShufflingOp<Shuffle, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  typedef const TensorShufflingOp<Shuffle, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef TensorStridingOp<Strides, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  typedef const TensorStridingOp<Strides, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  typedef IndexList<Is...> type;$/;"	t	struct:utility::tuple::RangeBuilder
type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  typedef T type;$/;"	t	struct:utility::tuple::ElemTypeHolder
type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  typedef T type;$/;"	t	struct:utility::tuple::StaticIf
type	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^  typedef typename ElemTypeHolder<k - 1, Tuple<Ts...> >::type type;$/;"	t	struct:utility::tuple::ElemTypeHolder
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const Tensor<Scalar_, NumIndices_, Options_, IndexType_>& type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const Tensor<_Scalar, NumIndices_, Options, IndexType_>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorFixedSize<Scalar_, Dimensions, Options, IndexType_>& type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorMap<PlainObjectType, Options, MakePointer>& type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorRef<PlainObjectType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef const TensorRef<PlainObjectType>& type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorTraits.h	/^  typedef typename ref_selector<T>::type type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef TensorVolumePatchOp<Planes, Rows, Cols, XprType> type;$/;"	t	struct:Eigen::internal::nested
type	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  typedef const TensorVolumePatchOp<Planes, Rows, Cols, XprType>& type;$/;"	t	struct:Eigen::internal::eval
type	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    > type;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_multiply
type	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  > type;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_element_ctor
type	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  > type;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_identity_ctor
type	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^  typedef StaticSGroup<Gen...> type;$/;"	t	struct:Eigen::internal::tensor_static_symgroup
type	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  typedef void type;$/;"	t	struct:Eigen::internal::tensor_static_symgroup_if
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  >::type type;$/;"	t	struct:Eigen::internal::group_theory::strip_identities
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef elements type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef elements type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef elements type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_generator
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef elements type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef elements type;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements_helper
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef type_list<> type;$/;"	t	struct:Eigen::internal::group_theory::dimino_get_coset_elements
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef type_list<> type;$/;"	t	struct:Eigen::internal::group_theory::strip_identities
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef type_list<id> type;$/;"	t	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _helper::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_all_coset_spaces
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _helper::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_cosets_for_rep
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _helper::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_generator
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _helper::type type;$/;"	t	struct:Eigen::internal::group_theory::enumerate_group_elements_noid
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename _next_iter::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_add_remaining_generators
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename apply_op_from_right<Multiply, new_coset_rep, sub_group_elements>::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_get_coset_elements
type	unsupported/Eigen/CXX11/src/TensorSymmetry/util/TemplateGroupTheory.h	/^  typedef typename helper::type type;$/;"	t	struct:Eigen::internal::group_theory::dimino_first_step_elements
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct apply_op_from_left { typedef decltype(h_apply_op<true, op, additional_param>::helper(a())) type; };$/;"	t	struct:Eigen::internal::apply_op_from_left
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct apply_op_from_right { typedef decltype(h_apply_op<false, op, additional_param>::helper(a())) type; };$/;"	t	struct:Eigen::internal::apply_op_from_right
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_apply_op_helper                                        { typedef type_list<typename op<values, additional_param>::type...> type; };$/;"	t	struct:Eigen::internal::h_apply_op_helper
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct h_apply_op_helper<true, op, additional_param, values...> { typedef type_list<typename op<additional_param, values>::type...> type; };$/;"	t	struct:Eigen::internal::h_apply_op_helper
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<>                                  struct h_skip_helper_type<0>           { typedef type_list<> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_type
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<>                                  struct take<0, type_list<>>         { typedef type_list<> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n, typename a> struct skip { typedef decltype(h_skip<n>::helper(a())) type; };$/;"	t	struct:Eigen::internal::skip
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n>                             struct h_skip_helper_type<n>           { typedef type_list<> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_type
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<int n>                             struct take<n, type_list<>>         { typedef type_list<> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T V, T... nn>                struct gen_numeric_list_repeated<T, 0, V, nn...> { typedef numeric_list<T, nn...> type; };$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T b, T start, T... ii>                    struct gen_numeric_list_swapped_pair<T, 0, a, b, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	t	struct:Eigen::internal::gen_numeric_list_swapped_pair
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T... as>        struct take<0, numeric_list<T, a, as...>> { typedef numeric_list<T> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T dummy, typename t> struct id_numeric  { typedef t type; };$/;"	t	struct:Eigen::internal::id_numeric
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T i, T... ii>        struct h_skip_helper_numeric<T, 0, i, ii...> { typedef numeric_list<T, i, ii...> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_numeric
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T start, T... ii>                    struct gen_numeric_list<T, 0, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	t	struct:Eigen::internal::gen_numeric_list
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T start, T... ii>                    struct gen_numeric_list_reversed<T, 0, start, ii...> { typedef numeric_list<T, ii...> type; };$/;"	t	struct:Eigen::internal::gen_numeric_list_reversed
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T... as, T... bs>   struct concat<numeric_list<T, as...>, numeric_list<T, bs...> > { typedef numeric_list<T, as..., bs...> type; };$/;"	t	struct:Eigen::internal::concat
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n>               struct h_skip_helper_numeric<T, n>           { typedef numeric_list<T> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_numeric
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, int n>               struct take<n, numeric_list<T>>           { typedef numeric_list<T> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T>                      struct h_skip_helper_numeric<T, 0>           { typedef numeric_list<T> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_numeric
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T>                      struct take<0, numeric_list<T>>           { typedef numeric_list<T> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename... as>                      struct get<0, type_list<a, as...>>   { typedef a type; };$/;"	t	struct:Eigen::internal::get
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a, typename... as>        struct take<0, type_list<a, as...>> { typedef type_list<> type; };$/;"	t	struct:Eigen::internal::take
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename a>                             struct mconcat<a>           { typedef a type; };$/;"	t	struct:Eigen::internal::mconcat
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename dummy, typename t>      struct id_type     { typedef t type; };$/;"	t	struct:Eigen::internal::id_type
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename t, typename... tt>        struct h_skip_helper_type<0, t, tt...> { typedef type_list<t, tt...> type; };$/;"	t	struct:Eigen::internal::h_skip_helper_type
type	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename... as, typename... bs> struct concat<type_list<as...>,       type_list<bs...>>        { typedef type_list<as..., bs...> type; };$/;"	t	struct:Eigen::internal::concat
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^                                  type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^                                  type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^                                  type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef Head type;$/;"	t	struct:Eigen::internal::get_type
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::type2val
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef empty_list type;$/;"	t	struct:Eigen::internal::make_type_list
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef type_list<T1, tailresult> type;$/;"	t	struct:Eigen::internal::make_type_list
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename Head::type type;$/;"	t	struct:Eigen::internal::get
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename Tail::HeadType::type type;$/;"	t	struct:Eigen::internal::get
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename get_type<i-1, Tail>::type type;$/;"	t	struct:Eigen::internal::get_type
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<type2val<T, V>, type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef typename make_type_list<type2val<T, V>, type2val<T, V>, type2val<T, V>, type2val<T, V>, type2val<T, V> >::type type;$/;"	t	struct:Eigen::internal::gen_numeric_list_repeated
type	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  typedef void type;$/;"	t	struct:Eigen::internal::get
type	unsupported/Eigen/src/Skyline/SkylineUtil.h	/^    typedef SkylineMatrix<_Scalar, _Flags> type;$/;"	t	class:Eigen::internal::eval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    typedef Scalar type;$/;"	t	struct:Eigen::internal::polygamma_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^    typedef Scalar type;$/;"	t	struct:Eigen::internal::zeta_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::betainc_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::digamma_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::erf_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::erfc_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::igamma_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::igammac_retval
type	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::lgamma_retval
type	unsupported/test/FFTW.cpp	/^  typedef Matrix<Scalar,Dynamic,1> type;$/;"	t	struct:VectorType	file:
type	unsupported/test/FFTW.cpp	/^  typedef vector<Scalar> type;$/;"	t	struct:VectorType	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_a> { typedef dummy_e type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_b> { typedef dummy_c type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_a, dummy_c> { typedef dummy_d type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_a> { typedef dummy_d type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_b> { typedef dummy_e type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_b, dummy_c> { typedef dummy_a type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_a> { typedef dummy_b type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_b> { typedef dummy_d type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_op<dummy_c, dummy_c> { typedef dummy_e type; };$/;"	t	struct:dummy_op	file:
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<double>              {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<int>                 {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long double>         {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long int>            {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<long long>           {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpq_t>               {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpreal>              {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<mpz_t>               {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned int>        {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned long int>   {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type	unsupported/test/mpreal/mpreal.h	/^    template <> struct result_type<unsigned long long>  {typedef mpreal type;};$/;"	t	struct:mpfr::internal::result_type
type1	Eigen/src/Core/util/Meta.h	/^  typedef typename std::result_of<T>::type type1;$/;"	t	struct:Eigen::internal::result_of
type2index	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct type2index {$/;"	s	namespace:Eigen
type2indexpair	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^struct type2indexpair {$/;"	s	namespace:Eigen
type2val	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^struct type2val {$/;"	s	namespace:Eigen::internal
typeCasting	bench/tensors/tensor_benchmarks.h	/^  void typeCasting(int num_iters) {$/;"	f	class:BenchmarkSuite
type_casting_traits	Eigen/src/Core/GenericPacketMath.h	/^template <typename Src, typename Tgt> struct type_casting_traits {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/AVX/TypeCasting.h	/^struct type_casting_traits<float, int> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/AVX/TypeCasting.h	/^struct type_casting_traits<int, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<Eigen::half, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<float, Eigen::half> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<float, half> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/CUDA/TypeCasting.h	/^struct type_casting_traits<half, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<double, float> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<float, double> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<float, int> {$/;"	s	namespace:Eigen::internal
type_casting_traits	Eigen/src/Core/arch/SSE/TypeCasting.h	/^struct type_casting_traits<int, float> {$/;"	s	namespace:Eigen::internal
type_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct type_list { constexpr static int count = sizeof...(tt); };$/;"	s	namespace:Eigen::internal
type_list	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct type_list<t, tt...> { constexpr static int count = sizeof...(tt) + 1; typedef t first_type; };$/;"	s	namespace:Eigen::internal
type_list	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^template<typename T, typename Tail=empty_list> struct type_list {$/;"	s	namespace:Eigen::internal
type_name	test/main.h	/^template<> std::string type_name<double>()                      { return "double"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<float>()                       { return "float"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<int>()                         { return "int"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<long double>()                 { return "long double"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<std::complex<double> >()       { return "complex<double>"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<std::complex<float> >()        { return "complex<float>"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<std::complex<int> >()          { return "complex<int>"; }$/;"	f
type_name	test/main.h	/^template<> std::string type_name<std::complex<long double> >()  { return "complex<long double>"; }$/;"	f
type_name	test/main.h	/^template<typename T> std::string type_name()                    { return "other"; }$/;"	f
type_t	bench/analyze-blocking-sizes.cpp	/^  enum class type_t {$/;"	c	struct:inputfile_t	file:
u	Eigen/src/Core/arch/CUDA/Half.h	/^  unsigned int u;$/;"	m	union:Eigen::half_impl::float32_bits
u	doc/snippets/class_FullPivLU.cpp	/^Matrix5x3 u = lu.matrixLU().triangularView<Upper>();$/;"	v
u32	bench/btl/generic_bench/timers/x86_timer.hh	28;"	d
ublas_interface	bench/btl/libs/ublas/ublas_interface.hh	/^class ublas_interface{$/;"	c
ucol	Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  ucol; \/\/ nonzero values of U ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
ui	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  uint32_t ui[4];$/;"	m	union:Eigen::internal::__anon720
uint128_t	unsupported/test/cxx11_tensor_uint128.cpp	/^typedef __uint128_t uint128_t;$/;"	t	file:
uinteger	blas/f2c/datatypes.h	/^typedef unsigned int uinteger;$/;"	t
ul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  uint64_t ul[2];$/;"	m	union:Eigen::internal::__anon720
umeyama	Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen
umeyama_transform_matrix_type	Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpackControl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline UmfpackControl& umfpackControl()$/;"	f	class:Eigen::UmfPackLU
umfpackControl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const UmfpackControl& umfpackControl() const$/;"	f	class:Eigen::UmfPackLU
umfpackFactorizeReturncode	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline int umfpackFactorizeReturncode() const$/;"	f	class:Eigen::UmfPackLU
umfpackReportControl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void umfpackReportControl()$/;"	f	class:Eigen::UmfPackLU
umfpackReportInfo	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void umfpackReportInfo()$/;"	f	class:Eigen::UmfPackLU
umfpackReportStatus	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void umfpackReportStatus() {$/;"	f	class:Eigen::UmfPackLU
umfpack_defaults	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_defaults(double control[UMFPACK_CONTROL], double)$/;"	f	namespace:Eigen
umfpack_defaults	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_defaults(double control[UMFPACK_CONTROL], std::complex<double>)$/;"	f	namespace:Eigen
umfpack_free_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen
umfpack_free_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_free_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen
umfpack_free_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_lunz	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen
umfpack_get_lunz	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen
umfpack_get_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen
umfpack_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_report_control	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_control(double control[UMFPACK_CONTROL], double)$/;"	f	namespace:Eigen
umfpack_report_control	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_control(double control[UMFPACK_CONTROL], std::complex<double>)$/;"	f	namespace:Eigen
umfpack_report_info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], double)$/;"	f	namespace:Eigen
umfpack_report_info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_info(double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], std::complex<double>)$/;"	f	namespace:Eigen
umfpack_report_status	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_status(double control[UMFPACK_CONTROL], int status, double)$/;"	f	namespace:Eigen
umfpack_report_status	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_report_status(double control[UMFPACK_CONTROL], int status, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen
unProject	demos/opengl/camera.cpp	/^Vector3f Camera::unProject(const Vector2f& uv, float depth) const$/;"	f	class:Camera
unProject	demos/opengl/camera.cpp	/^Vector3f Camera::unProject(const Vector2f& uv, float depth, const Matrix4f& invModelview) const$/;"	f	class:Camera
unaligned_dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct unaligned_dense_assignment_loop$/;"	s	namespace:Eigen::internal
unaligned_dense_assignment_loop	Eigen/src/Core/AssignEvaluator.h	/^struct unaligned_dense_assignment_loop<false>$/;"	s	namespace:Eigen::internal
unaligned_objects	test/product_extra.cpp	/^void unaligned_objects()$/;"	f
unalignedassert	test/unalignedassert.cpp	/^void unalignedassert()$/;"	f
unaryExpr	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f
unaryExpr	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    unaryExpr(const CustomUnaryOp& func) const {$/;"	f	class:Eigen::TensorBase
unaryViewExpr	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& block)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& replicate)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& reverse)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& wrapper)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^  explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<ArrayWrapper<TArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<CwiseUnaryView<UnaryOp, ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<MatrixWrapper<TArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Replicate<ArgType, RowFactor, ColFactor> >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Reverse<ArgType, Direction> >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/CoreEvaluators.h	/^struct unary_evaluator<Transpose<ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/Inverse.h	/^  unary_evaluator(const InverseType& inv_xpr)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/Inverse.h	/^struct unary_evaluator<Inverse<ArgType> >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Core/TriangularMatrix.h	/^  unary_evaluator(const XprType &xpr) : Base(xpr.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Core/TriangularMatrix.h	/^struct unary_evaluator<TriangularView<MatrixType,Mode>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/Geometry/Homogeneous.h	/^  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/Geometry/Homogeneous.h	/^struct unary_evaluator<Homogeneous<ArgType,Direction>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseBlock.h	/^    explicit unary_evaluator(const XprType& op)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseBlock.h	/^  explicit unary_evaluator(const XprType &xpr) : Base(xpr) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased >$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseBlock.h	/^struct unary_evaluator<Block<const SparseMatrix<_Scalar, _Options, _StorageIndex>,BlockRows,BlockCols,true>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    explicit unary_evaluator(const XprType& op) : m_functor(op.functor()), m_argImpl(op.nestedExpression())$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^struct unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^struct unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseProduct.h	/^  explicit unary_evaluator(const XprType& xpr)$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseProduct.h	/^struct unary_evaluator<SparseView<Product<Lhs, Rhs, Options> >, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseTranspose.h	/^    explicit unary_evaluator(const XprType& op) :m_argImpl(op.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseTranspose.h	/^struct unary_evaluator<Transpose<ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseTriangularView.h	/^  explicit unary_evaluator(const XprType &xpr) : m_argImpl(xpr.nestedExpression()), m_arg(xpr.nestedExpression()) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseTriangularView.h	/^struct unary_evaluator<TriangularView<ArgType,Mode>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseView.h	/^    explicit unary_evaluator(const XprType& xpr) : m_argImpl(xpr.nestedExpression()), m_view(xpr) {}$/;"	f	struct:Eigen::internal::unary_evaluator
unary_evaluator	Eigen/src/SparseCore/SparseView.h	/^struct unary_evaluator<SparseView<ArgType>, IndexBased>$/;"	s	namespace:Eigen::internal
unary_evaluator	Eigen/src/SparseCore/SparseView.h	/^struct unary_evaluator<SparseView<ArgType>, IteratorBased>$/;"	s	namespace:Eigen::internal
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unblocked	Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked	Eigen/src/Cholesky/LLT.h	/^  static Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked_lu	Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl
uncompress	Eigen/src/SparseCore/SparseMatrix.h	/^    void uncompress()$/;"	f	class:Eigen::SparseMatrix
unitOrthogonal	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
unknown	bench/analyze-blocking-sizes.cpp	/^    unknown,$/;"	m	class:inputfile_t::type_t	file:
unpacket_traits	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX/Complex.h	/^template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet4d> { typedef double type; typedef Packet2d half; enum {size=4, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8f> { typedef float  type; typedef Packet4f half; enum {size=8, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct unpacket_traits<Packet8i> { typedef int    type; typedef Packet4i half; enum {size=8, alignment=Aligned32}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet16f> {$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet16i> {$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AVX512/PacketMath.h	/^struct unpacket_traits<Packet8d> {$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<double2> { typedef double type; enum {size=2, alignment=Aligned16}; typedef double2 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct unpacket_traits<float4>  { typedef float  type; enum {size=4, alignment=Aligned16}; typedef float4 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct unpacket_traits<half2> { typedef Eigen::half type; enum {size=2, alignment=Aligned16}; typedef half2 half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double  type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float   type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int32_t type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/ZVector/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^template<typename Packet> struct unpacket_traits<DoublePacket<Packet> > { typedef DoublePacket<Packet> half; };$/;"	s	namespace:Eigen::internal
unrefEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    EIGEN_STRONG_INLINE void unrefEvaluator() {$/;"	f	class:Eigen::TensorRef
up	demos/opengl/camera.cpp	/^Vector3f Camera::up(void) const$/;"	f	class:Camera
update	Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	scripts/relicense.py	/^def update(text):$/;"	f
updateCostPerDimension	unsupported/Eigen/CXX11/src/Tensor/TensorPadding.h	/^  void updateCostPerDimension(TensorOpCost& cost, int i, bool first) const {$/;"	f	struct:Eigen::TensorEvaluator
updateGlobalFlags	unsupported/Eigen/CXX11/src/TensorSymmetry/DynamicSymmetry.h	/^inline void DynamicSGroup::updateGlobalFlags(int flagDiffOfSameGenerator)$/;"	f	class:Eigen::DynamicSGroup
updateInPlace	Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
updateList	Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h	/^inline void IncompleteCholesky<Scalar,_UpLo, OrderingType>::updateList(Ref<const VectorIx> colPtr, Ref<VectorIx> rowIdx, Ref<VectorSx> vals, const Index& col, const Index& jk, VectorIx& firstElt, VectorList& listCol)$/;"	f	class:Eigen::IncompleteCholesky
updateProjectionMatrix	demos/opengl/camera.cpp	/^void Camera::updateProjectionMatrix(void) const$/;"	f	class:Camera
updateViewMatrix	demos/opengl/camera.cpp	/^void Camera::updateViewMatrix(void) const$/;"	f	class:Camera
update_segrep	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  bool update_segrep(Index \/*krep*\/, Index \/*jj*\/)$/;"	f	struct:Eigen::internal::column_dfs_traits
update_segrep	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  bool update_segrep(Index krep, StorageIndex jj)$/;"	f	struct:Eigen::internal::panel_dfs_traits
update_value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC void update_value(T& val, DenseIndex new_val) {$/;"	f	namespace:Eigen::internal
update_value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC void update_value(T& val, IndexPair<DenseIndex> new_val) {$/;"	f	namespace:Eigen::internal
update_value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC void update_value(type2index<n>& val, DenseIndex new_val) {$/;"	f	namespace:Eigen::internal
update_value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^EIGEN_DEVICE_FUNC void update_value(type2indexpair<f, s>& val, IndexPair<DenseIndex> new_val) {$/;"	f	namespace:Eigen::internal
upper	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HIGH upper() const {$/;"	f	struct:Eigen::internal::TensorUInt128
upper	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& upper(Index i) {$/;"	f	class:Eigen::SkylineStorage
upper	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& upper(Index i) const {$/;"	f	class:Eigen::SkylineStorage
upperNonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index upperNonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
upperNonZeros	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index upperNonZeros(Index j) const {$/;"	f	class:Eigen::SkylineMatrix
upperProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index& upperProfile(Index i) {$/;"	f	class:Eigen::SkylineStorage
upperProfile	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Index& upperProfile(Index i) const {$/;"	f	class:Eigen::SkylineStorage
upperProfileSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index upperProfileSize() const {$/;"	f	class:Eigen::SkylineStorage
upperSize	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index upperSize() const {$/;"	f	class:Eigen::SkylineStorage
upperbidiag	test/upperbidiagonalization.cpp	/^template<typename MatrixType> void upperbidiag(const MatrixType& m)$/;"	f
upperbidiagonalization_blocked_helper	Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_blocked_helper(MatrixType& A,$/;"	f	namespace:Eigen::internal
upperbidiagonalization_inplace_blocked	Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_inplace_blocked(MatrixType& A, BidiagType& bidiagonal,$/;"	f	namespace:Eigen::internal
upperbidiagonalization_inplace_unblocked	Eigen/src/SVD/UpperBidiagonalization.h	/^void upperbidiagonalization_inplace_unblocked(MatrixType& mat,$/;"	f	namespace:Eigen::internal
urandom	unsupported/test/mpreal/mpreal.h	/^inline const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode = mpreal::get_default_rnd())$/;"	f	namespace:mpfr
urandomb	unsupported/test/mpreal/mpreal.h	/^inline const mpreal urandomb (gmp_randstate_t& state)$/;"	f	namespace:mpfr
url	scripts/eigen_gen_credits.cpp	/^  string url;$/;"	m	struct:contributor	file:
useExternalScaling	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool useExternalScaling; $/;"	m	class:Eigen::HybridNonLinearSolver
useExternalScaling	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    bool useExternalScaling; $/;"	m	class:Eigen::LevenbergMarquardt
useSpecificBlockingSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline bool useSpecificBlockingSizes(Index& k, Index& m, Index& n)$/;"	f	namespace:Eigen::internal
use_n_times	test/nesting_ops.cpp	/^void use_n_times(const XprType &xpr)$/;"	f
userColStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index userColStride() const { return m_col_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userColStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userColStride() const { return m_col_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userInColStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index userInColStride() const { return m_in_col_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userInColStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userInColStride() const { return m_in_col_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userInPlaneStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userInPlaneStride() const { return m_in_plane_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userInRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index userInRowStride() const { return m_in_row_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userInRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userInRowStride() const { return m_in_row_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userPlaneStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userPlaneStride() const { return m_plane_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorImagePatch.h	/^  Index userRowStride() const { return m_row_strides; }$/;"	f	struct:Eigen::TensorEvaluator
userRowStride	unsupported/Eigen/CXX11/src/Tensor/TensorVolumePatch.h	/^  Index userRowStride() const { return m_row_strides; }$/;"	f	struct:Eigen::TensorEvaluator
user_time	bench/btl/generic_bench/timers/portable_timer.hh	/^   double user_time() { return elapsed(); }$/;"	f	class:Portable_Timer
user_time	bench/btl/generic_bench/timers/portable_timer.hh	/^  double user_time()$/;"	f	class:Portable_Timer
users	Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo
usub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector usub; \/\/ row indices of U columns in ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
utility	unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h	/^namespace utility {$/;"	n
v	Eigen/src/Core/arch/AVX/Complex.h	/^  __m256  v;$/;"	m	struct:Eigen::internal::Packet4cf
v	Eigen/src/Core/arch/AVX/Complex.h	/^  __m256d  v;$/;"	m	struct:Eigen::internal::Packet2cd
v	Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/NEON/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd
v	Eigen/src/Core/arch/ZVector/Complex.h	/^    Packet4f v;$/;"	m	union:Eigen::internal::Packet2cf::__anon714
v	Eigen/src/Core/arch/ZVector/Complex.h	/^  Packet2d v;$/;"	m	struct:Eigen::internal::Packet1cd
v	doc/snippets/ComplexEigenSolver_compute.cpp	/^VectorXcf v = ces.eigenvectors().col(0);$/;"	v
v	doc/snippets/Cwise_arg.cpp	/^ArrayXcf v = ArrayXcf::Random(3);$/;"	v
v	doc/snippets/Cwise_atan.cpp	/^ArrayXd v = ArrayXd::LinSpaced(5,0,1);$/;"	v
v	doc/snippets/Cwise_ceil.cpp	/^ArrayXd v = ArrayXd::LinSpaced(7,-2,2);$/;"	v
v	doc/snippets/Cwise_cosh.cpp	/^ArrayXd v = ArrayXd::LinSpaced(5,0,1);$/;"	v
v	doc/snippets/Cwise_floor.cpp	/^ArrayXd v = ArrayXd::LinSpaced(7,-2,2);$/;"	v
v	doc/snippets/Cwise_round.cpp	/^ArrayXd v = ArrayXd::LinSpaced(7,-2,2);$/;"	v
v	doc/snippets/Cwise_sinh.cpp	/^ArrayXd v = ArrayXd::LinSpaced(5,0,1);$/;"	v
v	doc/snippets/Cwise_tanh.cpp	/^ArrayXd v = ArrayXd::LinSpaced(5,0,1);$/;"	v
v	doc/snippets/DenseBase_setLinSpaced.cpp	/^VectorXf v;$/;"	v
v	doc/snippets/DirectionWise_replicate_int.cpp	/^Vector3i v = Vector3i::Random();$/;"	v
v	doc/snippets/EigenSolver_EigenSolver_MatrixType.cpp	/^VectorXcd v = es.eigenvectors().col(0);$/;"	v
v	doc/snippets/HouseholderSequence_HouseholderSequence.cpp	/^Matrix3d v = Matrix3d::Random();$/;"	v
v	doc/snippets/Jacobi_makeGivens.cpp	/^Vector2f v = Vector2f::Random();$/;"	v
v	doc/snippets/Map_placement_new.cpp	/^cout << "Now v is: " << v << "\\n";/;"	v
v	doc/snippets/Map_placement_new.cpp	/^cout << "The mapped vector v is: " << v << "\\n";$/;"	v
v	doc/snippets/MatrixBase_end_int.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/MatrixBase_hnormalized.cpp	/^Vector4d v = Vector4d::Random();$/;"	v
v	doc/snippets/MatrixBase_homogeneous.cpp	/^Vector3d v = Vector3d::Random(), w;$/;"	v
v	doc/snippets/MatrixBase_replicate_int_int.cpp	/^Vector3i v = Vector3i::Random();$/;"	v
v	doc/snippets/MatrixBase_segment_int_int.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/MatrixBase_start_int.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/MatrixBase_template_int_end.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/MatrixBase_template_int_segment.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/MatrixBase_template_int_start.cpp	/^RowVector4i v = RowVector4i::Random();$/;"	v
v	doc/snippets/Matrix_setConstant_int.cpp	/^VectorXf v;$/;"	v
v	doc/snippets/Matrix_setOnes_int.cpp	/^VectorXf v;$/;"	v
v	doc/snippets/Matrix_setRandom_int.cpp	/^VectorXf v;$/;"	v
v	doc/snippets/Matrix_setZero_int.cpp	/^VectorXf v;$/;"	v
v	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType.cpp	/^VectorXd v = es.eigenvectors().col(0);$/;"	v
v	doc/snippets/SelfAdjointEigenSolver_SelfAdjointEigenSolver_MatrixType2.cpp	/^VectorXd v = es.eigenvectors().col(0);$/;"	v
v	doc/snippets/Tutorial_SlicingVec.cpp	/^RowVectorXf v = RowVectorXf::LinSpaced(20,0,19);$/;"	v
v	doc/snippets/tut_arithmetic_redux_minmax.cpp	/^  RowVector4i v = RowVector4i::Random();$/;"	v
v	test/exceptions.cpp	/^    float* v;$/;"	m	class:ScalarWithExceptions	file:
v1	doc/snippets/MatrixBase_set.cpp	/^      v1, m1.block(1,1,2,2);$/;"	v
v1	doc/snippets/MatrixBase_set.cpp	/^Vector2i v1;$/;"	v
v2d	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2d  v2d;$/;"	m	union:Eigen::internal::__anon720
v2l	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2l  v2l;$/;"	m	union:Eigen::internal::__anon720
v2ul	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet2ul v2ul;$/;"	m	union:Eigen::internal::__anon720
v4f	Eigen/src/Core/arch/ZVector/PacketMath.h	/^	Packet2d  v4f[2];$/;"	m	struct:Eigen::internal::__anon719
v4i	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet4i  v4i;$/;"	m	union:Eigen::internal::__anon720
v4ui	Eigen/src/Core/arch/ZVector/PacketMath.h	/^  Packet4ui v4ui;$/;"	m	union:Eigen::internal::__anon720
val_	unsupported/test/cxx11_eventcount.cpp	/^  std::atomic<int> val_;$/;"	m	struct:TestQueue	file:
value	Eigen/src/Core/CoreEvaluators.h	/^  static const bool value = false;$/;"	m	struct:Eigen::internal::evaluator_assume_aliasing
value	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Scalar value() const          { return m_iter.value(); }$/;"	f	class:Eigen::InnerIterator
value	Eigen/src/Core/CoreIterators.h	/^  EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::inner_iterator_selector
value	Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase
value	Eigen/src/Core/GeneralProduct.h	/^    value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon288
value	Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret,$/;"	e	enum:Eigen::internal::product_type::__anon291
value	Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(meta_floor_log2_terminate)$/;"	e	enum:Eigen::internal::meta_floor_log2_selector::__anon318
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon321
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = meta_floor_log2<n, lower, meta_floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon319
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = meta_floor_log2<n, meta_floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::meta_floor_log2::__anon320
value	Eigen/src/Core/ProductEvaluators.h	/^  static const bool value = true;$/;"	m	struct:Eigen::internal::evaluator_assume_aliasing
value	Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; };$/;"	e	enum:Eigen::internal::member_lpnorm::Cost::__anon638
value	Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon639
value	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon652
value	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon654
value	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct is_arithmetic<__m256i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon653
value	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 16 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon658
value	Eigen/src/Core/arch/AVX/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 14 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon657
value	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon662
value	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon663
value	Eigen/src/Core/arch/AVX512/PacketMath.h	/^  enum { value = true };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon664
value	Eigen/src/Core/arch/CUDA/Half.h	/^template<> struct is_arithmetic<half> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon670
value	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<double2> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon689
value	Eigen/src/Core/arch/CUDA/PacketMath.h	/^template<> struct is_arithmetic<float4>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon688
value	Eigen/src/Core/arch/CUDA/PacketMathHalf.h	/^template<> struct is_arithmetic<half2> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon683
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon735
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon737
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon736
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon745
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };$/;"	e	enum:Eigen::internal::scalar_div_cost::__anon744
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon374
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon368
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon371
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon377
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon372
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon366
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon369
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon375
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 1}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon373
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon367
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon370
value	Eigen/src/Core/functors/NullaryFunctors.h	/^struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon376
value	Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon607
value	Eigen/src/Core/util/Meta.h	/^  enum { value = is_convertible_impl<typename remove_all<From>::type,$/;"	e	enum:Eigen::internal::is_convertible::__anon593
value	Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(test(ms_from, 0))==sizeof(yes) };$/;"	e	enum:Eigen::internal::is_convertible_impl::__anon592
value	Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_binary_operator::__anon600
value	Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_nullary_operator::__anon598
value	Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_unary_operator::__anon599
value	Eigen/src/Core/util/Meta.h	/^  enum { value = sizeof(testFunctor<T>(0)) == sizeof(meta_yes) };$/;"	e	enum:Eigen::internal::has_ReturnType::__anon597
value	Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon562
value	Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon561
value	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon590
value	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon591
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon569
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon570
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon567
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon566
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon568
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon571
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon575
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon577
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon573
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon572
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon576
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon578
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon574
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<bool>            { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon580
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<char>            { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon581
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed char>     { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon582
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed int>      { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon586
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed long>     { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon588
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<signed short>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon584
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon583
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon587
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon589
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_integral<unsigned short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_integral::__anon585
value	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon563
value	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon565
value	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_integral        { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_integral::__anon579
value	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon564
value	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  enum { value = is_ref_compatible_impl<typename remove_all<MatrixType>::type>::value };$/;"	e	enum:Eigen::internal::is_ref_compatible::__anon234
value	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  enum { value = sizeof(test<MatrixType>(ms_from, 0))==sizeof(yes) };$/;"	e	enum:Eigen::internal::is_ref_compatible_impl::__anon233
value	Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
value	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
value	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(Index i) { eigen_internal_assert(m_values!=0); return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(Index i) const { eigen_internal_assert(m_values!=0); return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	Eigen/src/SparseCore/SparseBlock.h	/^  inline Scalar value() const { return m_it.value(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
value	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
value	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { eigen_internal_assert(m_id<m_innerSize); return m_value; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::binary_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_conjunction_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return LhsIterator::value() * m_factor; }$/;"	f	class:Eigen::internal::sparse_dense_outer_product_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_coeff * SparseXprInnerIterator::value(); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Scalar value() const { return m_sparseIter.value() * m_diagCoeffNested.coeff(index()); }$/;"	f	class:Eigen::internal::sparse_diagonal_product_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseTriangularView.h	/^      inline Scalar value() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet
value	Eigen/src/SparseCore/SparseView.h	/^        EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
value	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_idval]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
value	bench/BenchTimer.h	/^  inline double value(int TIMER = CPU_TIMER) const$/;"	f	class:Eigen::BenchTimer
value	unsupported/Eigen/CXX11/src/Tensor/Tensor.h	/^      static const bool value = is_array | is_int;$/;"	m	struct:Eigen::Tensor::isOfNormalIndex
value	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const bool value = (Sizes<Indices...>::total_size == 1);$/;"	m	struct:Eigen::internal::is_input_scalar
value	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const bool value = false;$/;"	m	struct:Eigen::internal::is_input_scalar
value	unsupported/Eigen/CXX11/src/Tensor/TensorBroadcasting.h	/^  static const bool value = true;$/;"	m	struct:Eigen::internal::is_input_scalar
value	unsupported/Eigen/CXX11/src/Tensor/TensorDimensionList.h	/^  static const size_t value = Rank;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static const size_t value = NumDims;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static const size_t value = Sizes<V1,V2,V3,V4,V5>::count;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^  static const std::size_t value = get<n, Dimension>::value;$/;"	m	struct:Eigen::internal::dget
value	unsupported/Eigen/CXX11/src/Tensor/TensorDimensions.h	/^static const std::ptrdiff_t value = Sizes<Indices...>::count;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  static const bool value = TensorEvaluator<Expression, Device>::PacketAccess;$/;"	m	struct:Eigen::internal::IsVectorizable
value	unsupported/Eigen/CXX11/src/Tensor/TensorForwardDeclarations.h	/^  static const bool value = TensorEvaluator<Expression, GpuDevice>::PacketAccess &&$/;"	m	struct:Eigen::internal::IsVectorizable
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const DenseIndex value = n;$/;"	m	struct:Eigen::type2index
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const size_t value = IndexTuple<T, O...>::count;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const size_t value = array_size<IndexTuple<FirstType, OtherTypes...> >::value;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static const size_t value = std::tuple_size<std::tuple<FirstType, OtherTypes...> >::value;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static constexpr bool value = false;$/;"	m	struct:Eigen::internal::is_compile_time_constant
value	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  static constexpr bool value = true;$/;"	m	struct:Eigen::internal::is_compile_time_constant
value	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    static const bool value = sizeof(check(Host<B,D>(), int())) == sizeof(yes);$/;"	m	struct:Eigen::internal::is_base_of
value	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool value = false;$/;"	m	struct:Eigen::internal::are_inner_most_dims
value	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool value = false;$/;"	m	struct:Eigen::internal::preserve_inner_most_dims
value	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool value = tmp1 & tmp2 & tmp3;$/;"	m	struct:Eigen::internal::are_inner_most_dims
value	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  static const bool value = tmp1 & tmp2;$/;"	m	struct:Eigen::internal::preserve_inner_most_dims
value	unsupported/Eigen/CXX11/src/Tensor/TensorUInt128.h	/^  static const uint64_t value = n;$/;"	m	struct:Eigen::internal::static_val
value	unsupported/Eigen/CXX11/src/TensorSymmetry/StaticSymmetry.h	/^    constexpr static bool value = is_same<iia, iib>::value;$/;"	m	struct:Eigen::internal::tensor_static_symgroup_equality
value	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t value = (maxOneTwoPlusOne > Three) ? maxOneTwoPlusOne : Three;$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
value	unsupported/Eigen/CXX11/src/TensorSymmetry/Symmetry.h	/^  constexpr static std::size_t value = 1;$/;"	m	struct:Eigen::internal::tensor_symmetry_num_indices
value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static bool value = true;$/;"	m	struct:Eigen::internal::contained_in_list
value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^  constexpr static bool value = true;$/;"	m	struct:Eigen::internal::contained_in_list_gf
value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, false> { constexpr static bool value = false; };$/;"	m	struct:Eigen::internal::contained_in_list
value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^struct contained_in_list_gf<test, check_against, type_list<EIGEN_TPL_PP_SPEC_HACK_USE(empty)>, default_flags, false, last_check_flags> { constexpr static bool value = false; constexpr static int global_flags = default_flags; };$/;"	m	struct:Eigen::internal::contained_in_list_gf
value	unsupported/Eigen/CXX11/src/util/CXX11Meta.h	/^template<typename T, T a, T... as>                               struct get<0, numeric_list<T, a, as...>>   { constexpr static T value = a; };$/;"	m	struct:Eigen::internal::get
value	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  static const size_t value = N;$/;"	m	struct:Eigen::internal::array_size
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const T value = n;$/;"	m	struct:Eigen::internal::type2val
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const char value = '\\0';$/;"	m	struct:Eigen::internal::get
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const int value = 1;$/;"	m	struct:Eigen::internal::arg_prod
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const type value = Head::value;$/;"	m	struct:Eigen::internal::get
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const type value = get<i-1, Tail>::value;$/;"	m	struct:Eigen::internal::get
value	unsupported/Eigen/CXX11/src/util/EmulateCXX11Meta.h	/^  static const typename NList::HeadType::type value = get<0, NList>::value * arg_prod<typename NList::TailType>::value;$/;"	m	struct:Eigen::internal::arg_prod
value	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline Scalar& value() { return m_value; }$/;"	f	class:Eigen::AutoDiffScalar
value	unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::AutoDiffScalar
value	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      enum { value = -Num };$/;"	e	enum:Eigen::internal::Abs::__anon46
value	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      enum { value = Axis != 0 && Abs<Axis>::value <= 3 };$/;"	e	enum:Eigen::internal::IsValidAxis::__anon47
value	unsupported/Eigen/src/EulerAngles/EulerSystem.h	/^      enum { value = Num };$/;"	e	enum:Eigen::internal::Abs::__anon45
value	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  static const int value = 3;$/;"	m	struct:Eigen::internal::matrix_log_min_pade_degree
value	unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  static const int value = std::numeric_limits<RealScalar>::digits<= 24?  5:  \/\/ single precision$/;"	m	struct:Eigen::internal::matrix_log_max_pade_degree
value	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar value() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
value	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar value() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
value	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline const Map<const BlockScalar> value() const$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
value	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline const Scalar& value() const$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
value	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      Scalar value;$/;"	m	struct:Eigen::RandomSetter::ScalarWrapper
value	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_a, dummy_a>     { constexpr static bool value = true;  constexpr static int global_flags = 1; };$/;"	m	struct:dummy_test	file:
value	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_b, dummy_b>     { constexpr static bool value = true;  constexpr static int global_flags = 2; };$/;"	m	struct:dummy_test	file:
value	unsupported/test/cxx11_meta.cpp	/^template<> struct dummy_test<dummy_c, dummy_c>     { constexpr static bool value = true;  constexpr static int global_flags = 4; };$/;"	m	struct:dummy_test	file:
value	unsupported/test/cxx11_meta.cpp	/^template<typename A, typename B> struct dummy_test { constexpr static bool value = false; constexpr static int global_flags = 0; };$/;"	m	struct:dummy_test	file:
valuePtr	Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	Eigen/src/SparseCore/CompressedStorage.h	/^    const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
valuePtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::internal::sparse_matrix_block_impl
valuePtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar* valuePtr() { return derived().valuePtr(); }$/;"	f	class:Eigen::SparseCompressedBase
valuePtr	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline const Scalar* valuePtr() const { return derived().valuePtr(); }$/;"	f	class:Eigen::SparseCompressedBase
valuePtr	Eigen/src/SparseCore/SparseMap.h	/^    inline Scalar* valuePtr()              { return Base::m_values; }$/;"	f	class:Eigen::SparseMapBase
valuePtr	Eigen/src/SparseCore/SparseMap.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::SparseMapBase
valuePtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline Scalar* valuePtr() { return derived().nestedExpression().valuePtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
valuePtr	Eigen/src/SparseCore/SparseTranspose.h	/^    inline const Scalar* valuePtr() const { return derived().nestedExpression().valuePtr(); }$/;"	f	class:Eigen::internal::SparseTransposeImpl
valuePtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* valuePtr() {  return m_nzval; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valuePtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Scalar* valuePtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valuePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* valuePtr() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
valuePtr	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* valuePtr() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
valuePtr	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline BlockScalarReturnType *valuePtr() {return static_cast<BlockScalarReturnType *>(m_values);}$/;"	f	class:Eigen::BlockSparseMatrix
valueRef	Eigen/src/SparseCore/SparseBlock.h	/^  inline Scalar& valueRef() { return m_it.valueRef(); }$/;"	f	class:Eigen::internal::unary_evaluator::OuterVectorInnerIterator
valueRef	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseCompressedBase::ReverseInnerIterator
valueRef	Eigen/src/SparseCore/SparseCompressedBase.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseCompressedBase::InnerIterator
valueRef	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::internal::unary_evaluator::InnerIterator
valueRef	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_idval]); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
valueRef	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& valueRef() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
valueRef	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& valueRef() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
valueRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Map<BlockScalar> valueRef()$/;"	f	class:Eigen::BlockSparseMatrix::BlockInnerIterator
valueRef	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    inline Scalar& valueRef()$/;"	f	class:Eigen::BlockSparseMatrix::InnerIterator
value_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr bool value_known_statically(const DenseIndex i) const {$/;"	f	struct:Eigen::IndexList
value_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr bool value_known_statically(const DenseIndex i) const {$/;"	f	struct:Eigen::IndexPairList
value_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool value_known_statically(const DenseIndex i, const IndexTuple<T...>& t) {$/;"	f	struct:Eigen::internal::tuple_coeff
value_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool value_known_statically(const DenseIndex i, const IndexTuple<T...>&) {$/;"	f	struct:Eigen::internal::tuple_coeff
value_type	Eigen/src/Core/DenseBase.h	/^    typedef Scalar value_type;$/;"	t	class:Eigen::DenseBase
value_type	Eigen/src/Core/util/Memory.h	/^  typedef T               value_type;$/;"	t	class:Eigen::aligned_allocator
value_type	Eigen/src/SparseCore/SparseMatrix.h	/^        typedef StorageIndex value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector
value_type	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Scalar value_type;$/;"	t	class:Eigen::SparseMatrixBase
value_type	Eigen/src/StlSupport/details.h	/^    typedef T               value_type;$/;"	t	class:Eigen::aligned_allocator_indirection
values	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon865
values	unsupported/Eigen/CXX11/src/util/EmulateArray.h	/^  T values[n];$/;"	m	class:Eigen::array
values	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline ValueType& values() { return m_values; }$/;"	f	class:Eigen::AutoDiffVector
values	unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline const ValueType& values() const { return m_values; }$/;"	f	class:Eigen::AutoDiffVector
values	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  int values() const { return m_values; }$/;"	f	struct:Eigen::DenseFunctor
values	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^  int values() const { return m_values; }$/;"	f	struct:Eigen::SparseFunctor
values	unsupported/test/NonLinearOptimization.cpp	/^  int values() const { return m_values; }$/;"	f	struct:Functor
values	unsupported/test/NumericalDiff.cpp	/^  int values() const { return m_values; }$/;"	f	struct:Functor
values	unsupported/test/autodiff.cpp	/^  int values() const { return m_values; }$/;"	f	struct:TestFunc1
values	unsupported/test/forward_adolc.cpp	/^  int values() const { return m_values; }$/;"	f	struct:TestFunc1
values_statically_known_to_increase	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC constexpr bool values_statically_known_to_increase() const {$/;"	f	struct:Eigen::IndexList
values_up_to_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool values_up_to_known_statically(const IndexTuple<T...>& t) {$/;"	f	struct:Eigen::internal::tuple_coeff
values_up_to_known_statically	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool values_up_to_known_statically(const IndexTuple<T...>&) {$/;"	f	struct:Eigen::internal::tuple_coeff
values_up_to_statically_known_to_increase	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool values_up_to_statically_known_to_increase(const IndexTuple<T...>& t) {$/;"	f	struct:Eigen::internal::tuple_coeff
values_up_to_statically_known_to_increase	unsupported/Eigen/CXX11/src/Tensor/TensorIndexList.h	/^  EIGEN_DEVICE_FUNC static constexpr bool values_up_to_statically_known_to_increase(const IndexTuple<T...>&) {$/;"	f	struct:Eigen::internal::tuple_coeff
vdata	demos/opengl/icosphere.cpp	/^static GLfloat vdata[12][3] = {$/;"	v	file:
vec	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec1	doc/snippets/Tutorial_AdvancedInitialization_Join.cpp	/^joined << vec1, vec2;$/;"	v
vec2	doc/snippets/Tutorial_AdvancedInitialization_Join.cpp	/^joined << vec1, vec2;$/;"	v
vec2d_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	70;"	d
vec4f_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	64;"	d
vec4f_swizzle2	Eigen/src/Core/arch/SSE/PacketMath.h	73;"	d
vec4i_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	67;"	d
vec4i_swizzle2	Eigen/src/Core/arch/SSE/PacketMath.h	76;"	d
vec_splat_dbl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<0>(Packet2d& a)$/;"	f	namespace:Eigen::internal
vec_splat_dbl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<1>(Packet2d& a)$/;"	f	namespace:Eigen::internal
vec_splat_packet4f	Eigen/src/Core/arch/ZVector/PacketMath.h	/^template<int element> EIGEN_STRONG_INLINE Packet4f vec_splat_packet4f(const Packet4f&   from)$/;"	f	namespace:Eigen::internal
vector	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
vectorD	Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT
vectorD	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky
vectorD	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT
vectorRedux	test/redux.cpp	/^template<typename VectorType> void vectorRedux(const VectorType& w)$/;"	f
vectorVisitor	test/visitor.cpp	/^template<typename VectorType> void vectorVisitor(const VectorType& w)$/;"	f
vector_base	Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector
vector_from_stl	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:c_interface_base
vector_from_stl	bench/btl/libs/STL/STL_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:STL_interface
vector_from_stl	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:blaze_interface
vector_from_stl	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:blitz_interface
vector_from_stl	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tiny_blitz_interface
vector_from_stl	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static BTL_DONT_INLINE  void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:eigen2_interface
vector_from_stl	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static BTL_DONT_INLINE  void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:eigen3_interface
vector_from_stl	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:gmm_interface
vector_from_stl	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:mtl4_interface
vector_from_stl	bench/btl/libs/tensors/tensor_interface.hh	/^  static BTL_DONT_INLINE  void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tensor_interface
vector_from_stl	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tvmet_interface
vector_from_stl	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void vector_from_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:ublas_interface
vector_int_pair	unsupported/Eigen/src/BVH/KdBVH.h	/^  vector_int_pair(const VectorType &v, int i) : first(v), second(i) {}$/;"	f	struct:Eigen::internal::vector_int_pair
vector_int_pair	unsupported/Eigen/src/BVH/KdBVH.h	/^struct vector_int_pair$/;"	s	namespace:Eigen::internal
vector_to_stl	bench/btl/libs/BLAS/c_interface_base.h	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:c_interface_base
vector_to_stl	bench/btl/libs/STL/STL_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:STL_interface
vector_to_stl	bench/btl/libs/blaze/blaze_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:blaze_interface
vector_to_stl	bench/btl/libs/blitz/blitz_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:blitz_interface
vector_to_stl	bench/btl/libs/blitz/tiny_blitz_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tiny_blitz_interface
vector_to_stl	bench/btl/libs/eigen2/eigen2_interface.hh	/^  static BTL_DONT_INLINE  void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:eigen2_interface
vector_to_stl	bench/btl/libs/eigen3/eigen3_interface.hh	/^  static BTL_DONT_INLINE  void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:eigen3_interface
vector_to_stl	bench/btl/libs/gmm/gmm_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:gmm_interface
vector_to_stl	bench/btl/libs/mtl4/mtl4_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:mtl4_interface
vector_to_stl	bench/btl/libs/tensors/tensor_interface.hh	/^  static BTL_DONT_INLINE  void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tensor_interface
vector_to_stl	bench/btl/libs/tvmet/tvmet_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:tvmet_interface
vector_to_stl	bench/btl/libs/ublas/ublas_interface.hh	/^  static inline void vector_to_stl(gene_vector & B, stl_vector & B_stl){$/;"	f	class:ublas_interface
vectorization_logic	test/vectorization_logic.cpp	/^struct vectorization_logic$/;"	s	file:
vectorization_logic	test/vectorization_logic.cpp	/^template<typename Scalar> struct vectorization_logic<Scalar,false>$/;"	s	file:
vectorization_logic_half	test/vectorization_logic.cpp	/^struct vectorization_logic_half$/;"	s	file:
vectorization_logic_half	test/vectorization_logic.cpp	/^template<typename Scalar> struct vectorization_logic_half<Scalar,false>$/;"	s	file:
vectorwise_reverse_inplace_impl	Eigen/src/Core/Reverse.h	/^struct vectorwise_reverse_inplace_impl<Horizontal>$/;"	s	namespace:Eigen::internal
vectorwise_reverse_inplace_impl	Eigen/src/Core/Reverse.h	/^struct vectorwise_reverse_inplace_impl<Vertical>$/;"	s	namespace:Eigen::internal
vectorwiseop_array	test/vectorwiseop.cpp	/^template<typename ArrayType> void vectorwiseop_array(const ArrayType& m)$/;"	f
vectorwiseop_matrix	test/vectorwiseop.cpp	/^template<typename MatrixType> void vectorwiseop_matrix(const MatrixType& m)$/;"	f
verifyIsApprox	test/main.h	/^inline bool verifyIsApprox(const Type1& a, const Type2& b)$/;"	f	namespace:Eigen
verifyIsQuasiTriangular	test/schur_real.cpp	/^template<typename MatrixType> void verifyIsQuasiTriangular(const MatrixType& T)$/;"	f
verifySizeOf	test/sizeof.cpp	/^template<typename MatrixType> void verifySizeOf(const MatrixType&)$/;"	f
verify_component_wise	unsupported/test/special_functions.cpp	/^void verify_component_wise(const X& x, const Y& y)$/;"	f
verify_euler	test/geo_eulerangles.cpp	/^void verify_euler(const Matrix<Scalar,3,1>& ea, int i, int j, int k)$/;"	f
verify_euler	unsupported/test/EulerAngles.cpp	/^void verify_euler(const Matrix<Scalar,3,1>& ea)$/;"	f
verify_euler_ranged	unsupported/test/EulerAngles.cpp	/^void verify_euler_ranged(const Matrix<Scalar,3,1>& ea,$/;"	f
verify_eval_type	test/nesting_ops.cpp	/^bool verify_eval_type(const XprType &, const ReferenceType&)$/;"	f
verify_impl	test/main.h	/^inline void verify_impl(bool condition, const char *testname, const char *file, int line, const char *condition_as_string)$/;"	f
verify_is_approx_upto_permutation	test/eigensolver_complex.cpp	/^void verify_is_approx_upto_permutation(const VectorType& vec1, const VectorType& vec2)$/;"	f
vertices	demos/opengl/icosphere.h	/^    const std::vector<Eigen::Vector3f>& vertices() const { return mVertices; }$/;"	f	class:IcoSphere
view	bench/btl/data/gnuplot_common_settings.hh	/^set view 60, 30, 1, 1$/;"	v
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(Ref<SparseMatrix<_Scalar,_Options,_StorageIndex> > mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<const SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseVector<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsEigen	Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,StorageIndex> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen
viewMatrix	demos/opengl/camera.cpp	/^const Affine3f& Camera::viewMatrix(void) const$/;"	f	class:Camera
visit	Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase
visitor_evaluator	Eigen/src/Core/Visitor.h	/^  explicit visitor_evaluator(const XprType &xpr) : m_evaluator(xpr), m_xpr(xpr) {}$/;"	f	class:Eigen::internal::visitor_evaluator
visitor_evaluator	Eigen/src/Core/Visitor.h	/^class visitor_evaluator$/;"	c	namespace:Eigen::internal
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_dup_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_dup_f32 (const float* x) { return ::vld1_dup_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1q_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vml_assign_traits	Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
volume	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox
vpHeight	demos/opengl/camera.h	/^    inline uint vpHeight(void) const { return mVpHeight; }$/;"	f	class:Camera
vpWidth	demos/opengl/camera.h	/^    inline uint vpWidth(void) const { return mVpWidth; }$/;"	f	class:Camera
vpX	demos/opengl/camera.h	/^    inline uint vpX(void) const { return mVpX; }$/;"	f	class:Camera
vpY	demos/opengl/camera.h	/^    inline uint vpY(void) const { return mVpY; }$/;"	f	class:Camera
vreinterpretq_f64_u64	Eigen/src/Core/arch/NEON/PacketMath.h	/^float64x2_t vreinterpretq_f64_u64(T a)$/;"	f	namespace:Eigen::internal
vreinterpretq_u64_f64	Eigen/src/Core/arch/NEON/PacketMath.h	/^uint64x2_t vreinterpretq_u64_f64(T a)$/;"	f	namespace:Eigen::internal
vst1_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
vst1q_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
w	Eigen/src/Core/DenseCoeffsBase.h	/^    w() const$/;"	f	class:Eigen::DenseCoeffsBase
w	Eigen/src/Core/DenseCoeffsBase.h	/^    w()$/;"	f	class:Eigen::DenseCoeffsBase
w	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline CoeffReturnType w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase
w	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline NonConstCoeffReturnType w() { return this->derived().coeffs().w(); }$/;"	f	class:Eigen::QuaternionBase
w	doc/snippets/MatrixBase_homogeneous.cpp	/^Vector3d v = Vector3d::Random(), w;$/;"	v
w	doc/snippets/Matrix_resize_int.cpp	/^RowVector3d w;$/;"	v
w	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^    Work w;$/;"	m	struct:Eigen::RunQueue::Elem
wa1	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa1	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa2	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa2	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa3	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa3	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa4	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa4	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wait_until_ready	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^static EIGEN_STRONG_INLINE void wait_until_ready(SyncType* n) {$/;"	f	namespace:Eigen
waiters_	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  MaxSizeVector<Waiter>& waiters_;$/;"	m	class:Eigen::EventCount
waiters_	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  MaxSizeVector<EventCount::Waiter> waiters_;$/;"	m	class:Eigen::NonBlockingThreadPoolTempl
waiters_	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  MaxSizeVector<Waiter*> waiters_;  \/\/ Stack of waiting threads.$/;"	m	class:Eigen::SimpleThreadPoolTempl
weighted_mean	bench/btl/data/smooth.cxx	/^double weighted_mean(const VECTOR & data)$/;"	f
why	unsupported/test/mpreal/mpreal.h	/^    std::string why() { return "inexact conversion from floating point"; }$/;"	f	class:mpfr::conversion_overflow
widget	demos/mandelbrot/mandelbrot.h	/^    MandelbrotWidget *widget;$/;"	m	class:MandelbrotThread
work	unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void work( int stage,Complex * xout, const _Src * xin, size_t fstride,size_t in_stride)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal
worst	bench/BenchTimer.h	/^  inline double worst(int TIMER = CPU_TIMER) const$/;"	f	class:Eigen::BenchTimer
writePacket	Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	Eigen/src/Core/Block.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x) $/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::mapbase_evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index index, const PacketType& x)$/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x) $/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::evaluator_wrapper_base
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::mapbase_evaluator
writePacket	Eigen/src/Core/CoreEvaluators.h	/^  void writePacket(Index row, Index col, const PacketType& x)$/;"	f	struct:Eigen::internal::unary_evaluator
writePacket	Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writePacket	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorChipping.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorConcatenation.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorEvaluator.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorMorphing.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorReverse.h	/^  void writePacket(Index index, const PacketReturnType& x) {$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorShuffling.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writePacket	unsupported/Eigen/CXX11/src/Tensor/TensorStriding.h	/^  void writePacket(Index index, const PacketReturnType& x)$/;"	f	struct:Eigen::TensorEvaluator
writeRegToShmem	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	236;"	d
writeRegToShmem	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	293;"	d
writeResultShmem	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	438;"	d
writeResultShmem	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	461;"	d
writeRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	441;"	d
writeRow	unsupported/Eigen/CXX11/src/Tensor/TensorContractionCuda.h	462;"	d
write_xy_file	bench/btl/data/smooth.cxx	/^void write_xy_file(const string & filename, vector<int> & tab_sizes, vector<double> & tab_mflops){$/;"	f
x	Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	Eigen/src/Core/arch/CUDA/Half.h	/^  unsigned short x;$/;"	m	struct:Eigen::half_impl::__half_raw
x	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline CoeffReturnType x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase
x	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline NonConstCoeffReturnType x() { return this->derived().coeffs().x(); }$/;"	f	class:Eigen::QuaternionBase
x	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	doc/snippets/ColPivHouseholderQR_solve.cpp	/^Matrix3f x;$/;"	v
x	doc/snippets/FullPivHouseholderQR_solve.cpp	/^Matrix3f x;$/;"	v
x	doc/snippets/FullPivLU_solve.cpp	/^Matrix<float,3,2> x = m.fullPivLu().solve(y);$/;"	v
x	doc/snippets/HouseholderQR_solve.cpp	/^Matrix3f x;$/;"	v
x	doc/snippets/Tutorial_solve_matrix_inverse.cpp	/^Vector3f x = A.inverse() * b;$/;"	v
x	doc/snippets/Tutorial_solve_reuse_decomposition.cpp	/^Vector3f x;$/;"	v
x	doc/snippets/Tutorial_solve_singular.cpp	/^Vector3f x;$/;"	v
x	doc/snippets/Tutorial_solve_triangular.cpp	/^Vector3f x = A.triangularView<Upper>().solve(b);$/;"	v
x	test/first_aligned.cpp	/^struct some_non_vectorizable_type { float x; };$/;"	m	struct:some_non_vectorizable_type	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[14];$/;"	m	struct:misra1d_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[154];$/;"	m	struct:Bennett5_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[15];$/;"	m	struct:rat43_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[16];$/;"	m	struct:MGH10_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[24];$/;"	m	struct:lanczos1_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[33];$/;"	m	struct:MGH17_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[35];$/;"	m	struct:eckerle4_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[6];$/;"	m	struct:BoxBOD_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^    static const double x[9];$/;"	m	struct:rat42_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double Bennett5_functor::x[154] = { 7.447168E0, 8.102586E0, 8.452547E0, 8.711278E0, 8.916774E0, 9.087155E0, 9.232590E0, 9.359535E0, 9.472166E0, 9.573384E0, 9.665293E0, 9.749461E0, 9.827092E0, 9.899128E0, 9.966321E0, 10.029280E0, 10.088510E0, 10.144430E0, 10.197380E0, 10.247670E0, 10.295560E0, 10.341250E0, 10.384950E0, 10.426820E0, 10.467000E0, 10.505640E0, 10.542830E0, 10.578690E0, 10.613310E0, 10.646780E0, 10.679150E0, 10.710520E0, 10.740920E0, 10.770440E0, 10.799100E0, 10.826970E0, 10.854080E0, 10.880470E0, 10.906190E0, 10.931260E0, 10.955720E0, 10.979590E0, 11.002910E0, 11.025700E0, 11.047980E0, 11.069770E0, 11.091100E0, 11.111980E0, 11.132440E0, 11.152480E0, 11.172130E0, 11.191410E0, 11.210310E0, 11.228870E0, 11.247090E0, 11.264980E0, 11.282560E0, 11.299840E0, 11.316820E0, 11.333520E0, 11.349940E0, 11.366100E0, 11.382000E0, 11.397660E0, 11.413070E0, 11.428240E0, 11.443200E0, 11.457930E0, 11.472440E0, 11.486750E0, 11.500860E0, 11.514770E0, 11.528490E0, 11.542020E0, 11.555380E0, 11.568550E0,$/;"	m	class:Bennett5_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double BoxBOD_functor::x[6] = { 1., 2., 3., 5., 7., 10. };$/;"	m	class:BoxBOD_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double MGH10_functor::x[16] = { 5.000000E+01, 5.500000E+01, 6.000000E+01, 6.500000E+01, 7.000000E+01, 7.500000E+01, 8.000000E+01, 8.500000E+01, 9.000000E+01, 9.500000E+01, 1.000000E+02, 1.050000E+02, 1.100000E+02, 1.150000E+02, 1.200000E+02, 1.250000E+02 };$/;"	m	class:MGH10_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double MGH17_functor::x[33] = { 0.000000E+00, 1.000000E+01, 2.000000E+01, 3.000000E+01, 4.000000E+01, 5.000000E+01, 6.000000E+01, 7.000000E+01, 8.000000E+01, 9.000000E+01, 1.000000E+02, 1.100000E+02, 1.200000E+02, 1.300000E+02, 1.400000E+02, 1.500000E+02, 1.600000E+02, 1.700000E+02, 1.800000E+02, 1.900000E+02, 2.000000E+02, 2.100000E+02, 2.200000E+02, 2.300000E+02, 2.400000E+02, 2.500000E+02, 2.600000E+02, 2.700000E+02, 2.800000E+02, 2.900000E+02, 3.000000E+02, 3.100000E+02, 3.200000E+02 };$/;"	m	class:MGH17_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double eckerle4_functor::x[35] = { 400.0, 405.0, 410.0, 415.0, 420.0, 425.0, 430.0, 435.0, 436.5, 438.0, 439.5, 441.0, 442.5, 444.0, 445.5, 447.0, 448.5, 450.0, 451.5, 453.0, 454.5, 456.0, 457.5, 459.0, 460.5, 462.0, 463.5, 465.0, 470.0, 475.0, 480.0, 485.0, 490.0, 495.0, 500.0};$/;"	m	class:eckerle4_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double lanczos1_functor::x[24] = { 0.000000000000E+00, 5.000000000000E-02, 1.000000000000E-01, 1.500000000000E-01, 2.000000000000E-01, 2.500000000000E-01, 3.000000000000E-01, 3.500000000000E-01, 4.000000000000E-01, 4.500000000000E-01, 5.000000000000E-01, 5.500000000000E-01, 6.000000000000E-01, 6.500000000000E-01, 7.000000000000E-01, 7.500000000000E-01, 8.000000000000E-01, 8.500000000000E-01, 9.000000000000E-01, 9.500000000000E-01, 1.000000000000E+00, 1.050000000000E+00, 1.100000000000E+00, 1.150000000000E+00 };$/;"	m	class:lanczos1_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double misra1d_functor::x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1d_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double rat42_functor::x[9] = { 9.000E0, 14.000E0, 21.000E0, 28.000E0, 42.000E0, 57.000E0, 63.000E0, 70.000E0, 79.000E0 };$/;"	m	class:rat42_functor	file:
x	unsupported/test/NonLinearOptimization.cpp	/^const double rat43_functor::x[15] = { 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15. };$/;"	m	class:rat43_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[14];$/;"	m	struct:misra1d_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[154];$/;"	m	struct:Bennett5_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[15];$/;"	m	struct:rat43_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[16];$/;"	m	struct:MGH10_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[24];$/;"	m	struct:lanczos1_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[33];$/;"	m	struct:MGH17_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[35];$/;"	m	struct:eckerle4_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[6];$/;"	m	struct:BoxBOD_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^    static const double x[9];$/;"	m	struct:rat42_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double Bennett5_functor::x[154] = { 7.447168E0, 8.102586E0, 8.452547E0, 8.711278E0, 8.916774E0, 9.087155E0, 9.232590E0, 9.359535E0, 9.472166E0, 9.573384E0, 9.665293E0, 9.749461E0, 9.827092E0, 9.899128E0, 9.966321E0, 10.029280E0, 10.088510E0, 10.144430E0, 10.197380E0, 10.247670E0, 10.295560E0, 10.341250E0, 10.384950E0, 10.426820E0, 10.467000E0, 10.505640E0, 10.542830E0, 10.578690E0, 10.613310E0, 10.646780E0, 10.679150E0, 10.710520E0, 10.740920E0, 10.770440E0, 10.799100E0, 10.826970E0, 10.854080E0, 10.880470E0, 10.906190E0, 10.931260E0, 10.955720E0, 10.979590E0, 11.002910E0, 11.025700E0, 11.047980E0, 11.069770E0, 11.091100E0, 11.111980E0, 11.132440E0, 11.152480E0, 11.172130E0, 11.191410E0, 11.210310E0, 11.228870E0, 11.247090E0, 11.264980E0, 11.282560E0, 11.299840E0, 11.316820E0, 11.333520E0, 11.349940E0, 11.366100E0, 11.382000E0, 11.397660E0, 11.413070E0, 11.428240E0, 11.443200E0, 11.457930E0, 11.472440E0, 11.486750E0, 11.500860E0, 11.514770E0, 11.528490E0, 11.542020E0, 11.555380E0, 11.568550E0,$/;"	m	class:Bennett5_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double BoxBOD_functor::x[6] = { 1., 2., 3., 5., 7., 10. };$/;"	m	class:BoxBOD_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double MGH10_functor::x[16] = { 5.000000E+01, 5.500000E+01, 6.000000E+01, 6.500000E+01, 7.000000E+01, 7.500000E+01, 8.000000E+01, 8.500000E+01, 9.000000E+01, 9.500000E+01, 1.000000E+02, 1.050000E+02, 1.100000E+02, 1.150000E+02, 1.200000E+02, 1.250000E+02 };$/;"	m	class:MGH10_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double MGH17_functor::x[33] = { 0.000000E+00, 1.000000E+01, 2.000000E+01, 3.000000E+01, 4.000000E+01, 5.000000E+01, 6.000000E+01, 7.000000E+01, 8.000000E+01, 9.000000E+01, 1.000000E+02, 1.100000E+02, 1.200000E+02, 1.300000E+02, 1.400000E+02, 1.500000E+02, 1.600000E+02, 1.700000E+02, 1.800000E+02, 1.900000E+02, 2.000000E+02, 2.100000E+02, 2.200000E+02, 2.300000E+02, 2.400000E+02, 2.500000E+02, 2.600000E+02, 2.700000E+02, 2.800000E+02, 2.900000E+02, 3.000000E+02, 3.100000E+02, 3.200000E+02 };$/;"	m	class:MGH17_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double eckerle4_functor::x[35] = { 400.0, 405.0, 410.0, 415.0, 420.0, 425.0, 430.0, 435.0, 436.5, 438.0, 439.5, 441.0, 442.5, 444.0, 445.5, 447.0, 448.5, 450.0, 451.5, 453.0, 454.5, 456.0, 457.5, 459.0, 460.5, 462.0, 463.5, 465.0, 470.0, 475.0, 480.0, 485.0, 490.0, 495.0, 500.0};$/;"	m	class:eckerle4_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double lanczos1_functor::x[24] = { 0.000000000000E+00, 5.000000000000E-02, 1.000000000000E-01, 1.500000000000E-01, 2.000000000000E-01, 2.500000000000E-01, 3.000000000000E-01, 3.500000000000E-01, 4.000000000000E-01, 4.500000000000E-01, 5.000000000000E-01, 5.500000000000E-01, 6.000000000000E-01, 6.500000000000E-01, 7.000000000000E-01, 7.500000000000E-01, 8.000000000000E-01, 8.500000000000E-01, 9.000000000000E-01, 9.500000000000E-01, 1.000000000000E+00, 1.050000000000E+00, 1.100000000000E+00, 1.150000000000E+00 };$/;"	m	class:lanczos1_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double misra1d_functor::x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1d_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double rat42_functor::x[9] = { 9.000E0, 14.000E0, 21.000E0, 28.000E0, 42.000E0, 57.000E0, 63.000E0, 70.000E0, 79.000E0 };$/;"	m	class:rat42_functor	file:
x	unsupported/test/levenberg_marquardt.cpp	/^const double rat43_functor::x[15] = { 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15. };$/;"	m	class:rat43_functor	file:
xerbla_	blas/xerbla.cpp	/^EIGEN_WEAK_LINKING int xerbla_(const char * msg, int *info, int)$/;"	f
xlsub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlsub; \/\/ pointers to the beginning of each column in lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xlusup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlusup; \/\/ pointers to the beginning of each column in lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xnorm	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
xnorm	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
xprDims	unsupported/Eigen/CXX11/src/Tensor/TensorReduction.h	/^  const Dims& xprDims() const {return m_xpr_dims;}$/;"	f	struct:Eigen::TensorEvaluator
xradius	demos/mandelbrot/mandelbrot.h	/^    double xradius;$/;"	m	class:MandelbrotWidget
xsup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xsup; \/\/First supernode column ... xsup(s) points to the beginning of the s-th supernode$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xtol	unsupported/Eigen/src/LevenbergMarquardt/LevenbergMarquardt.h	/^    RealScalar xtol() const {return m_xtol; }$/;"	f	class:Eigen::LevenbergMarquardt
xtol	unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar xtol;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
xtol	unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar xtol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
xusub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xusub; \/\/ Pointers to the beginning of each column of U in ucol $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xy	doc/snippets/LLT_solve.cpp	/^Matrix<float,2,1> xy$/;"	v
y	Eigen/src/Core/DenseCoeffsBase.h	/^    y() const$/;"	f	class:Eigen::DenseCoeffsBase
y	Eigen/src/Core/DenseCoeffsBase.h	/^    y()$/;"	f	class:Eigen::DenseCoeffsBase
y	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline CoeffReturnType y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase
y	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline NonConstCoeffReturnType y() { return this->derived().coeffs().y(); }$/;"	f	class:Eigen::QuaternionBase
y	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	doc/snippets/ColPivHouseholderQR_solve.cpp	/^Matrix3f y = Matrix3f::Random();$/;"	v
y	doc/snippets/FullPivHouseholderQR_solve.cpp	/^Matrix3f y = Matrix3f::Random();$/;"	v
y	doc/snippets/FullPivLU_solve.cpp	/^Matrix2f y = Matrix2f::Random();$/;"	v
y	doc/snippets/HouseholderQR_solve.cpp	/^Matrix3f y = Matrix3f::Random();$/;"	v
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[11];$/;"	m	struct:MGH09_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[14];$/;"	m	struct:misra1d_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[154];$/;"	m	struct:Bennett5_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[15];$/;"	m	struct:rat43_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[16];$/;"	m	struct:MGH10_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[24];$/;"	m	struct:lanczos1_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[33];$/;"	m	struct:MGH17_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[35];$/;"	m	struct:eckerle4_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^    static const double y[9];$/;"	m	struct:rat42_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double Bennett5_functor::y[154] = { -34.834702E0 ,-34.393200E0 ,-34.152901E0 ,-33.979099E0 ,-33.845901E0 ,-33.732899E0 ,-33.640301E0 ,-33.559200E0 ,-33.486801E0 ,-33.423100E0 ,-33.365101E0 ,-33.313000E0 ,-33.260899E0 ,-33.217400E0 ,-33.176899E0 ,-33.139198E0 ,-33.101601E0 ,-33.066799E0 ,-33.035000E0 ,-33.003101E0 ,-32.971298E0 ,-32.942299E0 ,-32.916302E0 ,-32.890202E0 ,-32.864101E0 ,-32.841000E0 ,-32.817799E0 ,-32.797501E0 ,-32.774300E0 ,-32.757000E0 ,-32.733799E0 ,-32.716400E0 ,-32.699100E0 ,-32.678799E0 ,-32.661400E0 ,-32.644001E0 ,-32.626701E0 ,-32.612202E0 ,-32.597698E0 ,-32.583199E0 ,-32.568699E0 ,-32.554298E0 ,-32.539799E0 ,-32.525299E0 ,-32.510799E0 ,-32.499199E0 ,-32.487598E0 ,-32.473202E0 ,-32.461601E0 ,-32.435501E0 ,-32.435501E0 ,-32.426800E0 ,-32.412300E0 ,-32.400799E0 ,-32.392101E0 ,-32.380501E0 ,-32.366001E0 ,-32.357300E0 ,-32.348598E0 ,-32.339901E0 ,-32.328400E0 ,-32.319698E0 ,-32.311001E0 ,-32.299400E0 ,-32.290699E0 ,-32.282001E0 ,-32.273300E0 ,-32.264599E0 ,-32.256001E0 ,-32.247299E0$/;"	m	class:Bennett5_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double MGH09_functor::y[11] = { 1.957000E-01, 1.947000E-01, 1.735000E-01, 1.600000E-01, 8.440000E-02, 6.270000E-02, 4.560000E-02, 3.420000E-02, 3.230000E-02, 2.350000E-02, 2.460000E-02 };$/;"	m	class:MGH09_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double MGH10_functor::y[16] = { 3.478000E+04, 2.861000E+04, 2.365000E+04, 1.963000E+04, 1.637000E+04, 1.372000E+04, 1.154000E+04, 9.744000E+03, 8.261000E+03, 7.030000E+03, 6.005000E+03, 5.147000E+03, 4.427000E+03, 3.820000E+03, 3.307000E+03, 2.872000E+03 };$/;"	m	class:MGH10_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double MGH17_functor::y[33] = { 8.440000E-01, 9.080000E-01, 9.320000E-01, 9.360000E-01, 9.250000E-01, 9.080000E-01, 8.810000E-01, 8.500000E-01, 8.180000E-01, 7.840000E-01, 7.510000E-01, 7.180000E-01, 6.850000E-01, 6.580000E-01, 6.280000E-01, 6.030000E-01, 5.800000E-01, 5.580000E-01, 5.380000E-01, 5.220000E-01, 5.060000E-01, 4.900000E-01, 4.780000E-01, 4.670000E-01, 4.570000E-01, 4.480000E-01, 4.380000E-01, 4.310000E-01, 4.240000E-01, 4.200000E-01, 4.140000E-01, 4.110000E-01, 4.060000E-01 };$/;"	m	class:MGH17_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double eckerle4_functor::y[35] = { 0.0001575, 0.0001699, 0.0002350, 0.0003102, 0.0004917, 0.0008710, 0.0017418, 0.0046400, 0.0065895, 0.0097302, 0.0149002, 0.0237310, 0.0401683, 0.0712559, 0.1264458, 0.2073413, 0.2902366, 0.3445623, 0.3698049, 0.3668534, 0.3106727, 0.2078154, 0.1164354, 0.0616764, 0.0337200, 0.0194023, 0.0117831, 0.0074357, 0.0022732, 0.0008800, 0.0004579, 0.0002345, 0.0001586, 0.0001143, 0.0000710 };$/;"	m	class:eckerle4_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double lanczos1_functor::y[24] = { 2.513400000000E+00 ,2.044333373291E+00 ,1.668404436564E+00 ,1.366418021208E+00 ,1.123232487372E+00 ,9.268897180037E-01 ,7.679338563728E-01 ,6.388775523106E-01 ,5.337835317402E-01 ,4.479363617347E-01 ,3.775847884350E-01 ,3.197393199326E-01 ,2.720130773746E-01 ,2.324965529032E-01 ,1.996589546065E-01 ,1.722704126914E-01 ,1.493405660168E-01 ,1.300700206922E-01 ,1.138119324644E-01 ,1.000415587559E-01 ,8.833209084540E-02 ,7.833544019350E-02 ,6.976693743449E-02 ,6.239312536719E-02 };$/;"	m	class:lanczos1_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double misra1d_functor::y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1d_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double rat42_functor::y[9] = { 8.930E0 ,10.800E0 ,18.590E0 ,22.330E0 ,39.350E0 ,56.110E0 ,61.730E0 ,64.620E0 ,67.080E0 };$/;"	m	class:rat42_functor	file:
y	unsupported/test/NonLinearOptimization.cpp	/^const double rat43_functor::y[15] = { 16.08, 33.83, 65.80, 97.20, 191.55, 326.20, 386.87, 520.53, 590.03, 651.92, 724.93, 699.56, 689.96, 637.56, 717.41 };$/;"	m	class:rat43_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[11];$/;"	m	struct:MGH09_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[14];$/;"	m	struct:misra1d_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[154];$/;"	m	struct:Bennett5_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[15];$/;"	m	struct:rat43_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[16];$/;"	m	struct:MGH10_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[24];$/;"	m	struct:lanczos1_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[33];$/;"	m	struct:MGH17_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[35];$/;"	m	struct:eckerle4_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^    static const double y[9];$/;"	m	struct:rat42_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double Bennett5_functor::y[154] = { -34.834702E0 ,-34.393200E0 ,-34.152901E0 ,-33.979099E0 ,-33.845901E0 ,-33.732899E0 ,-33.640301E0 ,-33.559200E0 ,-33.486801E0 ,-33.423100E0 ,-33.365101E0 ,-33.313000E0 ,-33.260899E0 ,-33.217400E0 ,-33.176899E0 ,-33.139198E0 ,-33.101601E0 ,-33.066799E0 ,-33.035000E0 ,-33.003101E0 ,-32.971298E0 ,-32.942299E0 ,-32.916302E0 ,-32.890202E0 ,-32.864101E0 ,-32.841000E0 ,-32.817799E0 ,-32.797501E0 ,-32.774300E0 ,-32.757000E0 ,-32.733799E0 ,-32.716400E0 ,-32.699100E0 ,-32.678799E0 ,-32.661400E0 ,-32.644001E0 ,-32.626701E0 ,-32.612202E0 ,-32.597698E0 ,-32.583199E0 ,-32.568699E0 ,-32.554298E0 ,-32.539799E0 ,-32.525299E0 ,-32.510799E0 ,-32.499199E0 ,-32.487598E0 ,-32.473202E0 ,-32.461601E0 ,-32.435501E0 ,-32.435501E0 ,-32.426800E0 ,-32.412300E0 ,-32.400799E0 ,-32.392101E0 ,-32.380501E0 ,-32.366001E0 ,-32.357300E0 ,-32.348598E0 ,-32.339901E0 ,-32.328400E0 ,-32.319698E0 ,-32.311001E0 ,-32.299400E0 ,-32.290699E0 ,-32.282001E0 ,-32.273300E0 ,-32.264599E0 ,-32.256001E0 ,-32.247299E0$/;"	m	class:Bennett5_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double MGH09_functor::y[11] = { 1.957000E-01, 1.947000E-01, 1.735000E-01, 1.600000E-01, 8.440000E-02, 6.270000E-02, 4.560000E-02, 3.420000E-02, 3.230000E-02, 2.350000E-02, 2.460000E-02 };$/;"	m	class:MGH09_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double MGH10_functor::y[16] = { 3.478000E+04, 2.861000E+04, 2.365000E+04, 1.963000E+04, 1.637000E+04, 1.372000E+04, 1.154000E+04, 9.744000E+03, 8.261000E+03, 7.030000E+03, 6.005000E+03, 5.147000E+03, 4.427000E+03, 3.820000E+03, 3.307000E+03, 2.872000E+03 };$/;"	m	class:MGH10_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double MGH17_functor::y[33] = { 8.440000E-01, 9.080000E-01, 9.320000E-01, 9.360000E-01, 9.250000E-01, 9.080000E-01, 8.810000E-01, 8.500000E-01, 8.180000E-01, 7.840000E-01, 7.510000E-01, 7.180000E-01, 6.850000E-01, 6.580000E-01, 6.280000E-01, 6.030000E-01, 5.800000E-01, 5.580000E-01, 5.380000E-01, 5.220000E-01, 5.060000E-01, 4.900000E-01, 4.780000E-01, 4.670000E-01, 4.570000E-01, 4.480000E-01, 4.380000E-01, 4.310000E-01, 4.240000E-01, 4.200000E-01, 4.140000E-01, 4.110000E-01, 4.060000E-01 };$/;"	m	class:MGH17_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double eckerle4_functor::y[35] = { 0.0001575, 0.0001699, 0.0002350, 0.0003102, 0.0004917, 0.0008710, 0.0017418, 0.0046400, 0.0065895, 0.0097302, 0.0149002, 0.0237310, 0.0401683, 0.0712559, 0.1264458, 0.2073413, 0.2902366, 0.3445623, 0.3698049, 0.3668534, 0.3106727, 0.2078154, 0.1164354, 0.0616764, 0.0337200, 0.0194023, 0.0117831, 0.0074357, 0.0022732, 0.0008800, 0.0004579, 0.0002345, 0.0001586, 0.0001143, 0.0000710 };$/;"	m	class:eckerle4_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double lanczos1_functor::y[24] = { 2.513400000000E+00 ,2.044333373291E+00 ,1.668404436564E+00 ,1.366418021208E+00 ,1.123232487372E+00 ,9.268897180037E-01 ,7.679338563728E-01 ,6.388775523106E-01 ,5.337835317402E-01 ,4.479363617347E-01 ,3.775847884350E-01 ,3.197393199326E-01 ,2.720130773746E-01 ,2.324965529032E-01 ,1.996589546065E-01 ,1.722704126914E-01 ,1.493405660168E-01 ,1.300700206922E-01 ,1.138119324644E-01 ,1.000415587559E-01 ,8.833209084540E-02 ,7.833544019350E-02 ,6.976693743449E-02 ,6.239312536719E-02 };$/;"	m	class:lanczos1_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double misra1d_functor::y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1d_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double rat42_functor::y[9] = { 8.930E0 ,10.800E0 ,18.590E0 ,22.330E0 ,39.350E0 ,56.110E0 ,61.730E0 ,64.620E0 ,67.080E0 };$/;"	m	class:rat42_functor	file:
y	unsupported/test/levenberg_marquardt.cpp	/^const double rat43_functor::y[15] = { 16.08, 33.83, 65.80, 97.20, 191.55, 326.20, 386.87, 520.53, 590.03, 651.92, 724.93, 699.56, 689.96, 637.56, 717.41 };$/;"	m	class:rat43_functor	file:
yes	Eigen/src/Core/util/Meta.h	/^  struct yes {int a[1];};$/;"	s	struct:Eigen::internal::is_convertible_impl
yes	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  struct yes {int a[1];};$/;"	s	struct:Eigen::internal::is_ref_compatible_impl
yes	unsupported/Eigen/CXX11/src/Tensor/TensorMeta.h	/^    typedef char (&yes)[1];$/;"	t	struct:Eigen::internal::is_base_of
z	Eigen/src/Core/DenseCoeffsBase.h	/^    z() const$/;"	f	class:Eigen::DenseCoeffsBase
z	Eigen/src/Core/DenseCoeffsBase.h	/^    z()$/;"	f	class:Eigen::DenseCoeffsBase
z	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline CoeffReturnType z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase
z	Eigen/src/Geometry/Quaternion.h	/^  EIGEN_DEVICE_FUNC inline NonConstCoeffReturnType z() { return this->derived().coeffs().z(); }$/;"	f	class:Eigen::QuaternionBase
z	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	Eigen/src/Geometry/Translation.h	/^  EIGEN_DEVICE_FUNC inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
zCoeffs	Eigen/src/QR/CompleteOrthogonalDecomposition.h	/^  const HCoeffsType& zCoeffs() const { return m_zCoeffs; }$/;"	f	class:Eigen::CompleteOrthogonalDecomposition
zdotc_	blas/f2c/complexdots.c	/^doublecomplex zdotc_(integer *n, doublecomplex *cx, integer *incx, $/;"	f
zdotu_	blas/f2c/complexdots.c	/^doublecomplex zdotu_(integer *n, doublecomplex *cx, integer *incx, $/;"	f
zero	test/svd_common.h	/^EIGEN_DONT_INLINE Scalar zero() { return Scalar(0); }$/;"	f
zeroReduction	test/zerosized.cpp	/^template<typename MatrixType> void zeroReduction(const MatrixType& m) {$/;"	f
zeroSizedMatrix	test/zerosized.cpp	/^template<typename MatrixType> void zeroSizedMatrix()$/;"	f
zeroSizedVector	test/zerosized.cpp	/^template<typename VectorType> void zeroSizedVector()$/;"	f
zero_sized_objects	test/product_extra.cpp	/^void zero_sized_objects(const MatrixType& m)$/;"	f
zeta	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^zeta(const EIGEN_CURRENT_STORAGE_BASE_CLASS<DerivedQ> &q) const$/;"	f
zeta	unsupported/Eigen/CXX11/src/Tensor/TensorBase.h	/^    zeta(const OtherDerived& other) const {$/;"	f	class:Eigen::TensorBase
zeta	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsArrayAPI.h	/^zeta(const Eigen::ArrayBase<DerivedX>& x, const Eigen::ArrayBase<DerivedQ>& q)$/;"	f	namespace:Eigen
zeta	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsHalf.h	/^template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half zeta(const Eigen::half& x, const Eigen::half& q) {$/;"	f	namespace:Eigen::numext
zeta	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^zeta(const Scalar& x, const Scalar& q) {$/;"	f	namespace:Eigen::numext
zeta	unsupported/test/mpreal/mpreal.h	/^inline const mpreal zeta    (const mpreal& x, mp_rnd_t r = mpreal::get_default_rnd()) {   MPREAL_UNARY_MATH_FUNCTION_BODY(zeta   );    }$/;"	f	namespace:mpfr
zeta_impl	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct zeta_impl {$/;"	s	namespace:Eigen::internal
zeta_impl_series	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct zeta_impl_series {$/;"	s	namespace:Eigen::internal
zeta_impl_series	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct zeta_impl_series<double> {$/;"	s	namespace:Eigen::internal
zeta_impl_series	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct zeta_impl_series<float> {$/;"	s	namespace:Eigen::internal
zeta_retval	unsupported/Eigen/src/SpecialFunctions/SpecialFunctionsImpl.h	/^struct zeta_retval {$/;"	s	namespace:Eigen::internal
zhbmv_	blas/f2c/zhbmv.c	/^\/* Subroutine *\/ int zhbmv_(char *uplo, integer *n, integer *k, doublecomplex $/;"	f
zhpmv_	blas/f2c/zhpmv.c	/^\/* Subroutine *\/ int zhpmv_(char *uplo, integer *n, doublecomplex *alpha, $/;"	f
zoom	demos/opengl/camera.cpp	/^void Camera::zoom(float d)$/;"	f	class:Camera
ztbmv_	blas/f2c/ztbmv.c	/^\/* Subroutine *\/ int ztbmv_(char *uplo, char *trans, char *diag, integer *n, $/;"	f
~Action_aat_product	bench/btl/actions/action_aat_product.hh	/^  ~Action_aat_product( void ){$/;"	f	class:Action_aat_product
~Action_ata_product	bench/btl/actions/action_ata_product.hh	/^  ~Action_ata_product( void ){$/;"	f	class:Action_ata_product
~Action_atv_product	bench/btl/actions/action_atv_product.hh	/^  ~Action_atv_product( void )$/;"	f	class:Action_atv_product
~Action_axpby	bench/btl/actions/action_axpby.hh	/^  ~Action_axpby( void ){$/;"	f	class:Action_axpby
~Action_axpy	bench/btl/actions/action_axpy.hh	/^  ~Action_axpy( void ){$/;"	f	class:Action_axpy
~Action_cholesky	bench/btl/actions/action_cholesky.hh	/^  ~Action_cholesky( void ){$/;"	f	class:Action_cholesky
~Action_ger	bench/btl/actions/action_ger.hh	/^  BTL_DONT_INLINE ~Action_ger( void ){$/;"	f	class:Action_ger
~Action_hessenberg	bench/btl/actions/action_hessenberg.hh	/^  ~Action_hessenberg( void ){$/;"	f	class:Action_hessenberg
~Action_lu_decomp	bench/btl/actions/action_lu_decomp.hh	/^  ~Action_lu_decomp( void ){$/;"	f	class:Action_lu_decomp
~Action_matrix_matrix_product	bench/btl/actions/action_matrix_matrix_product.hh	/^  ~Action_matrix_matrix_product( void ){$/;"	f	class:Action_matrix_matrix_product
~Action_matrix_vector_product	bench/btl/actions/action_matrix_vector_product.hh	/^  BTL_DONT_INLINE ~Action_matrix_vector_product( void ){$/;"	f	class:Action_matrix_vector_product
~Action_partial_lu	bench/btl/actions/action_partial_lu.hh	/^  ~Action_partial_lu( void ){$/;"	f	class:Action_partial_lu
~Action_rot	bench/btl/actions/action_rot.hh	/^  BTL_DONT_INLINE ~Action_rot( void ){$/;"	f	class:Action_rot
~Action_symv	bench/btl/actions/action_symv.hh	/^  BTL_DONT_INLINE ~Action_symv( void ){$/;"	f	class:Action_symv
~Action_syr2	bench/btl/actions/action_syr2.hh	/^  BTL_DONT_INLINE ~Action_syr2( void ){$/;"	f	class:Action_syr2
~Action_tridiagonalization	bench/btl/actions/action_hessenberg.hh	/^  ~Action_tridiagonalization( void ){$/;"	f	class:Action_tridiagonalization
~Action_trisolve	bench/btl/actions/action_trisolve.hh	/^  ~Action_trisolve( void ){$/;"	f	class:Action_trisolve
~Action_trisolve_matrix	bench/btl/actions/action_trisolve_matrix.hh	/^  ~Action_trisolve_matrix( void ){$/;"	f	class:Action_trisolve_matrix
~Action_trmm	bench/btl/actions/action_trmm.hh	/^  ~Action_trmm( void ){$/;"	f	class:Action_trmm
~AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  EIGEN_DEVICE_FUNC ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector
~BDCSVD	Eigen/src/SVD/BDCSVD.h	/^  ~BDCSVD() $/;"	f	class:Eigen::BDCSVD
~Barrier	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	/^  ~Barrier() {$/;"	f	class:Eigen::Barrier
~BenchTimer	bench/BenchTimer.h	/^  ~BenchTimer() {}$/;"	f	class:Eigen::BenchTimer
~BenchmarkSuite	bench/tensors/tensor_benchmarks.h	/^  ~BenchmarkSuite() {$/;"	f	class:BenchmarkSuite
~BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB
~BlockSparseMatrix	unsupported/Eigen/src/SparseExtra/BlockSparseMatrix.h	/^    ~BlockSparseMatrix()$/;"	f	class:Eigen::BlockSparseMatrix
~Camera	demos/opengl/camera.cpp	/^Camera::~Camera()$/;"	f	class:Camera
~CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase
~CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition
~CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT
~CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT
~CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT
~CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
~ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient
~Context	unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	/^    ~Context() {$/;"	f	class:Eigen::TensorEvaluator::Context
~CudaStreamDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual ~CudaStreamDevice() {$/;"	f	class:Eigen::CudaStreamDevice
~DGMRES	unsupported/Eigen/src/IterativeSolvers/DGMRES.h	/^  ~DGMRES() {}$/;"	f	class:Eigen::DGMRES
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DynamicSparseMatrix	unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline ~DynamicSparseMatrix() {}$/;"	f	class:Eigen::DynamicSparseMatrix
~EnvThread	unsupported/Eigen/CXX11/src/ThreadPool/ThreadEnvironment.h	/^    ~EnvThread() { thr_.join(); }$/;"	f	class:Eigen::StlThreadEnvironment::EnvThread
~EventCount	unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h	/^  ~EventCount() {$/;"	f	class:Eigen::EventCount
~Foo	test/ctorleak.cpp	/^  ~Foo()$/;"	f	struct:Foo
~GMRES	unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  ~GMRES() {}$/;"	f	class:Eigen::GMRES
~GpuHelper	demos/opengl/gpuhelper.cpp	/^GpuHelper::~GpuHelper()$/;"	f	class:GpuHelper
~Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  EIGEN_DEVICE_FUNC ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~IterScaling	unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    ~IterScaling() { }$/;"	f	class:Eigen::IterScaling
~IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase
~LeastSquaresConjugateGradient	Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h	/^  ~LeastSquaresConjugateGradient() {}$/;"	f	class:Eigen::LeastSquaresConjugateGradient
~Lib_Mean	bench/btl/data/mean.cxx	/^  ~Lib_Mean( void ){$/;"	f	class:Lib_Mean
~MINRES	unsupported/Eigen/src/IterativeSolvers/MINRES.h	/^        ~MINRES(){}$/;"	f	class:Eigen::MINRES
~MandelbrotWidget	demos/mandelbrot/mandelbrot.h	/^    ~MandelbrotWidget()$/;"	f	class:MandelbrotWidget
~Map	Eigen/src/SparseCore/SparseMap.h	/^    inline ~Map() {}$/;"	f	class:Eigen::Map
~MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix
~MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    ~MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
~MatrixMarketIterator	unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    ~MatrixMarketIterator()$/;"	f	class:Eigen::MatrixMarketIterator
~MaxSizeVector	unsupported/Eigen/CXX11/src/util/MaxSizeVector.h	/^  ~MaxSizeVector() {$/;"	f	class:Eigen::MaxSizeVector
~Mixed_Perf_Analyzer	bench/btl/generic_bench/timers/mixed_perf_analyzer.hh	/^  ~Mixed_Perf_Analyzer( void ){$/;"	f	class:Mixed_Perf_Analyzer
~NonBlockingThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h	/^  ~NonBlockingThreadPoolTempl() {$/;"	f	class:Eigen::NonBlockingThreadPoolTempl
~ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  EIGEN_DEVICE_FUNC ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
~PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase
~Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer.hh	/^  ~Portable_Perf_Analyzer(){$/;"	f	class:Portable_Perf_Analyzer
~Portable_Perf_Analyzer	bench/btl/generic_bench/timers/portable_perf_analyzer_old.hh	/^  ~Portable_Perf_Analyzer( void ){$/;"	f	class:Portable_Perf_Analyzer
~RandomSetter	unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    ~RandomSetter()$/;"	f	class:Eigen::RandomSetter
~Ref	Eigen/src/SparseCore/SparseRef.h	/^    ~Ref() {$/;"	f	class:Eigen::Ref
~RenderingWidget	demos/opengl/quaternion_demo.h	/^    ~RenderingWidget() { }$/;"	f	class:RenderingWidget
~RunQueue	unsupported/Eigen/CXX11/src/ThreadPool/RunQueue.h	/^  ~RunQueue() { eigen_assert(Size() == 0); }$/;"	f	class:Eigen::RunQueue
~SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ~SPQR()$/;"	f	class:Eigen::SPQR
~STL_Perf_Analyzer	bench/btl/generic_bench/timers/STL_perf_analyzer.hh	/^  ~STL_Perf_Analyzer( void ){$/;"	f	class:STL_Perf_Analyzer
~ScalarWithExceptions	test/exceptions.cpp	/^    ~ScalarWithExceptions() {$/;"	f	class:ScalarWithExceptions
~SimpleThreadPoolTempl	unsupported/Eigen/CXX11/src/ThreadPool/SimpleThreadPool.h	/^  ~SimpleThreadPoolTempl() {$/;"	f	class:Eigen::SimpleThreadPoolTempl
~SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
~SkylineMatrix	unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline ~SkylineMatrix() {$/;"	f	class:Eigen::SkylineMatrix
~SkylineStorage	unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    ~SkylineStorage() {$/;"	f	class:Eigen::SkylineStorage
~SolverBase	Eigen/src/Core/SolverBase.h	/^    ~SolverBase()$/;"	f	class:Eigen::SolverBase
~SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    ~SparseLU()$/;"	f	class:Eigen::SparseLU
~SparseMapBase	Eigen/src/SparseCore/SparseMap.h	/^    inline ~SparseMapBase() {}$/;"	f	class:Eigen::SparseMapBase
~SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
~SparseSolverBase	Eigen/src/SparseCore/SparseSolverBase.h	/^    ~SparseSolverBase()$/;"	f	class:Eigen::SparseSolverBase
~SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector
~StreamInterface	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceCuda.h	/^  virtual ~StreamInterface() {}$/;"	f	class:Eigen::StreamInterface
~SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU
~SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU
~SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase
~SyclDevice	unsupported/Eigen/CXX11/src/Tensor/TensorDeviceSycl.h	/^  ~SyclDevice() { deallocate_all(); }$/;"	f	struct:Eigen::SyclDevice
~TensorEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorEvalTo.h	/^  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~TensorEvaluator() {$/;"	f	struct:Eigen::TensorEvaluator
~TensorLazyBaseEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  virtual ~TensorLazyBaseEvaluator() { }$/;"	f	class:Eigen::internal::TensorLazyBaseEvaluator
~TensorLazyEvaluator	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  virtual ~TensorLazyEvaluator() {$/;"	f	class:Eigen::internal::TensorLazyEvaluator
~TensorLazyEvaluatorReadOnly	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  virtual ~TensorLazyEvaluatorReadOnly() {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorReadOnly
~TensorLazyEvaluatorWritable	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^  virtual ~TensorLazyEvaluatorWritable() {$/;"	f	class:Eigen::internal::TensorLazyEvaluatorWritable
~TensorRef	unsupported/Eigen/CXX11/src/Tensor/TensorRef.h	/^    ~TensorRef() {$/;"	f	class:Eigen::TensorRef
~TensorStorage	unsupported/Eigen/CXX11/src/Tensor/TensorStorage.h	/^    EIGEN_DEVICE_FUNC  ~TensorStorage() { internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, internal::array_prod(m_dimensions)); }$/;"	f	class:Eigen::TensorStorage
~TestQueue	unsupported/test/cxx11_eventcount.cpp	/^  ~TestQueue() { VERIFY_IS_EQUAL(val_.load(), 0); }$/;"	f	struct:TestQueue
~ThreadPoolInterface	unsupported/Eigen/CXX11/src/ThreadPool/ThreadPoolInterface.h	/^  virtual ~ThreadPoolInterface() {}$/;"	f	class:Eigen::ThreadPoolInterface
~UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
~X86_Perf_Analyzer	bench/btl/generic_bench/timers/x86_perf_analyzer.hh	/^  ~X86_Perf_Analyzer( void ){$/;"	f	class:X86_Perf_Analyzer
~action_t	bench/analyze-blocking-sizes.cpp	/^  virtual ~action_t() {}$/;"	f	struct:action_t
~aligned_allocator	Eigen/src/Core/util/Memory.h	/^  ~aligned_allocator() {}$/;"	f	class:Eigen::aligned_allocator
~aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
~aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
~eigen_assert_exception	test/main.h	/^      ~eigen_assert_exception() { Eigen::no_more_assert = false; }$/;"	f	struct:Eigen::eigen_assert_exception
~eigen_static_assert_exception	test/main.h	/^      ~eigen_static_assert_exception() { Eigen::no_more_assert = false; }$/;"	f	struct:Eigen::eigen_static_assert_exception
~fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftw_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftwf_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~fftw_plan	unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftwl_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space
~mpreal	unsupported/test/mpreal/mpreal.h	/^inline mpreal::~mpreal()$/;"	f	class:mpfr::mpreal
~my_exception	test/exceptions.cpp	/^  ~my_exception() {}$/;"	f	struct:my_exception
~noncopyable	Eigen/src/Core/util/Meta.h	/^  EIGEN_DEVICE_FUNC ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
~scoped_array	Eigen/src/Core/util/Memory.h	/^  ~scoped_array()$/;"	f	class:Eigen::internal::scoped_array
